import random
from typing import Optional

from dataclasses import dataclass
from difflib import Differ
from iohblade.solution import Solution


@dataclass
class TabooElement:
    description: str
    code: str
    fitness: float
    code_feature: list[str]


class TabooTable:
    def __init__(self, size: int, minimisation: bool):
        """
        A Taboo Table manager class, that tracks and keep the taboo table updated.

        ## Args:
        `size: int`: Size of the archive.
        `minimisation: bool`: Optimisation direction for which table is being built for.
        """
        self.table_size = size
        self.minimisation = minimisation
        self.taboo_table: list[TabooElement] = []

    def _find_llm_generated_lines(
        self, current_solution: Solution, new_indvidual: Solution
    ) -> list[str]:
        """
        Returns a list of lines, that were newly added to current generation.
        """
        p_lines = current_solution.code.split("\n")
        n_lines = new_indvidual.code.split("\n")

        def effective_lines(lines):
            result = []
            for line in lines:
                stripped = line.strip()
                if (
                    stripped.startswith("def ")
                    or stripped.startswith("import")
                    or stripped == ""
                    or stripped.startswith("#")
                ):
                    continue

                if "#" in line:
                    line = line.split("#", 1)[0]
                result.append(line.rstrip())
            return result

        prev_content_lines = effective_lines(p_lines)
        new_content_lines = effective_lines(n_lines)

        # Use difflib to find added lines in new_content_lines
        diff = Differ().compare(prev_content_lines, new_content_lines)
        code_features = [line[2:] for line in diff if line.startswith("+ ")]

        return code_features

    def _a_is_better_than_b(self, a: Solution, b: TabooElement):
        if self.minimisation:
            return a.fitness < b.fitness
        else:
            return a.fitness > b.fitness

    def update_taboo_search_table(
        self, current_individual: Solution, next_individual: Solution
    ):
        """
        Maintains a list of elite individuals with unique fitness along with `code_features` that generated them from current_individual.code.
        Will add the next_individual, mapped onto `TabooElement` object, if it's fitness is better than any of the individual in the table or table has
        space, provided fitness != Â±inf.

        ## Args:
        `next_individual: Solution`: A new individual generated by the LLM.
        """
        if abs(next_individual.fitness) == float("inf") or next_individual.fitness in [
            x.fitness for x in self.taboo_table
        ]:
            return

        code_features = self._find_llm_generated_lines(
            current_individual, next_individual
        )
        if len(self.taboo_table) < self.table_size:
            taboo_element = TabooElement(
                next_individual.description,
                next_individual.code,
                next_individual.fitness,
                code_features,
            )
            self.taboo_table.append(taboo_element)
        else:
            if self._a_is_better_than_b(next_individual, self.taboo_table[-1]):
                self.taboo_table = self.taboo_table[:-1]
                taboo_element = TabooElement(
                    next_individual.description,
                    next_individual.code,
                    next_individual.fitness,
                    code_features,
                )
                self.taboo_table.append(taboo_element)

        self.taboo_table = sorted(
            self.taboo_table,
            key=lambda element: element.fitness,
            reverse=not self.minimisation,
        )

    def get_distinct_entry(self, for_individual: Solution) -> Optional[TabooElement]:
        """
        If avaialble, returns a taboo element, that has code not equal to `for_individual.code`.

        ## Args:
        `for_individual: Solution`: A solution instance for which a taboo element with different code is to be returned.

        ## Returns:
        `TabooElement?`: If a taboo element with distinct code entry compared to `for_individual` is present, return that TabooElement, or return None.
        """
        print("---------Get distinct Entry-----------")
        filtered_list = [
            element
            for element in self.taboo_table
            if element.code != for_individual.code
        ]
        print("Filtered list:", [element.code[:5] for element in filtered_list])

        return random.choice(filtered_list) if filtered_list else None

    def get_fitness_series(self):
        return [node.fitness for node in self.taboo_table]
