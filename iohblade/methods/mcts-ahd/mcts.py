from __future__ import annotations

import math
from typing import Optional

from iohblade import Solution, Problem, LLM

class MCTS_Node(Solution):
    def __init__(self, solution: Solution, 
                 depth: int = 0, 
                 parent: Optional[MCTS_Node]=None, 
                 visit: int=0,
                 Q: int = 0):
        """
            MCTS Node is a derivative of `iohblade.Solution`, with extra paramters in `children`, establishing heirarchy in
            the Tree, `rewards`, `depth` and `Q`, for calculating which subtree to explore.
        
            ## Args:
            `Solution: iohblade.Solution`: An instance of iohblade.Solution, generated by the `LLM.sample_solution`.\\
            `depth: int`: The Depth at which this instance of `MCTS_Node` exist in the Monte Carlo Tree.\\
            `parent:MCTS_Node?` An optional variable that points to the parent of current instance of `MCT_Node`; `None` if current instance is root node.\\
            `visits: int` Tracks the number of times current instance has been explored by MCTS Algorithm.\\
            `Q: int`: MCTS Quality value $Q_c$ evaluation of the node. 
        """
        super().__init__()

        # Copy Solution parameters to self.
        self.__dict__.update(solution.__dict__)
        self.parent_ids = solution.parent_ids[-1] if solution.parent_ids else None # Only one parent exist here.

        # MCTS Specific Members:
        self.depth = depth,
        self.parent = parent
        self.visit = visit
        self.Q = Q
        self.children : list[MCTS_Node] = []
        # self.reward = -1 * obj

    def add_child(self, childNode: MCTS_Node):
        """
            Add a child node to the current instance of MCTS_Node.

            ## Args:
            `childNode: MCTS_Node`: MCTS_Node instance to be added as a child.
        """
        childNode.parent = self
        childNode.parent_ids = self.id
        self.children.append(childNode)

    def __repr__(self):
        return f"MCTS_Node(id=...{self.id[-4:]}, children={list(map(lambda x: '...' + x.id[-4:], self.children))} Q={self.Q:.2f}, visits={self.visit})"

    @property
    def is_root(self):
        """
            EZ check for is current node a root.
        """
        return self.parent is None

    @property
    def is_leaf(self):
        return len(self.children) == 0
    
    def is_fully_expanded(self, max_children: int) -> bool:
        """
        Check for completion of progressive Widening (Page 3: https://arxiv.org/pdf/2501.08603).

        ## Args:
        `max_children: int`: User defined upper limit of sub-tree width.

        ## Returns:
        `bool`: Truth value of whether upper limit is reach or not.
        """
        return len(self.children) >= max_children or any(
            child.Q > self.Q for child in self.children
        ) or self.is_root

class MCTS:
    def __init__(self, 
                 llm: LLM,
                 problem: Problem,
                 lambda_0: float = 0.1,
                 alpha: float = 0.5,
                 maximisation:bool = True
    ):
        """
        MCTS method for solving a given `Problem` using LLMs.

        ## Args:
        `llm:iohblade.LLM` Any LLM model from `iohblade.llm.py`.\\
        `problem: iohblade.Problem`: An iohblade problem instance with appropriate prompts, and evaluation function for solving the problem.\\
        `lambda_0: float`: A constant $\lambda_0$ used in UCT calculation.\\
        `alpha: float`: Expansion coefficient for progressive widening the tree.
        `maximisation: bool`: The direction of optimisation, setting it to false will lead to arg max(f), else arg min(f).
        """
        self.llm = llm
        self.problem = problem
        self.maximisation = maximisation
        self.lambda_0 = lambda_0
        self.alpha = alpha
        
        #Prefedined parameters.
        self.max_depth = 10
        self.epsilon = 1e-10
        self.discount_factor = 1
        self.q_min = 0
        self.q_max = -1e4       #-10,000
        self.rank_list = []


        solution = Solution()
        self.root = MCTS_Node(solution)
    
    def backpropogate(self, node: MCTS_Node):
        """
        Backpropagate the subtree fitness from leaf node to root node, for determining next expoloration.

        ## Args:
        `node: MCTS_Node` : A node to iteratively start score back-propagation from.

        ## Returns:
            `None`: Function is an inplace mutation on MCTS_Node objects, and returns/throws nothing.
        """
        if node.Q not in self.rank_list:
            self.rank_list.append(node.Q)
            self.rank_list.sort()
        self.q_min = min(self.q_min, node.Q)
        self.q_max = max(self.q_max, node.Q)
        parent = node.parent
        while parent:
            best_child_Q = max(child.Q for child in parent.children)
            parent.Q = parent.Q * (1 - self.discount_factor) + best_child_Q * self.discount_factor
            parent.visit += 1
            # if not parent.is_root and parent.parent.is_root:              #No Idea why this exist, commented till I figure out.
            #     self.subtree_flatten.append(node)
            parent = parent.parent


    def uct(self, node: MCTS_Node, eval_remain: int):
        """
        Scores the provided node with a score, determining how likely it is to better optima on visiting current 
        node again.

        ## Args:
            `node: MCTS_Node`: A non-root node that needs to be scored.\\
            `eval_remains: int`: Number of evaluation remaining for current optimisation process.

        ## Returns:
            `None`: Inplace mutation function, which retuns or throws nothing.
        """
        exploration_constant = self.lambda_0 * eval_remain
        if node.parent:
            return (node.Q - self.q_min) / (self.q_max - self.q_min) + exploration_constant * (math.log(node.parent.visit + 1)) ** 0.5 / node.visit
        return 0

if __name__ == "__main__":
    a = MCTS_Node(Solution())
    b = MCTS_Node(Solution())
    c = MCTS_Node(Solution())
    a.add_child(b)
    a.add_child(c)

    print(a)
    print(f"\t A is root: {a.is_root}")
    print(b)
    print(f"\t B is root: {b.is_root}")
    print(c)
    print(f"\t C is root: {c.is_root}")
