{"id": "0dec716e-ec2f-44f1-8d82-6ff77516e47b", "fitness": 0.9749396003292835, "name": "landscape", "description": "A non-homogeneous multi-peak landscape built as a weighted mixture of Gaussian basins scattered in the D-dimensional domain. Each basin has its own width (curvature) and depth, producing basins of varying size and depth. The global minimum corresponds to the deepest combination of Gaussian wells, while many shallower, differently shaped local minima create a non-uniform basin structure. This setup yields a minimization problem with a diverse set of local minima and non-uniform basin sizes, challenging metaheuristics to discriminate truly good regions from deceptive ones.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(dim) * 1315423911) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Desired number of Gaussian basins grows with dimension but is capped\n        self.Nc_target = min(12 + dim, 40)\n\n        self.centers = []\n        self.weights = []\n        self.widths = []\n\n        min_sep = 2.0  # try to keep basins reasonably separated to avoid excessive overlap\n        max_tries_per_center = 1000\n\n        # Place centers with a separation constraint, fall back if needed\n        for _ in range(self.Nc_target):\n            placed = False\n            tries = 0\n            while not placed and tries < max_tries_per_center:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n                if all(np.linalg.norm(c - np.array(ex)) >= min_sep for ex in self.centers):\n                    self.centers.append(c)\n                    self.weights.append(-rng.uniform(0.8, 5.0))  # negative depths\n                    self.widths.append(rng.uniform(0.5, 2.2))   # basin widths\n                    placed = True\n                tries += 1\n\n            # If we failed to place with separation, place anyway to guarantee Nc\n            if not placed:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n                self.centers.append(c)\n                self.weights.append(-rng.uniform(0.8, 5.0))\n                self.widths.append(rng.uniform(0.5, 2.2))\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, w, s in zip(self.centers, self.weights, self.widths):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            val += w * np.exp(-dist2 / (2.0 * s * s))\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.3165640922578151, 0.39142236092889926, 0.15274060789904859, 0.34335892897880643, 2.263693629965008, 0.3583286613548258, 0.4764354028167596, 32.54359744333202, 0.6524180056624213, 0.06427703928771614, -0.06640827436148582, 1.8, 0.379327298813461, 0.6742491802461508, 0.3222807136831178, 0.3510886363341723, -0.23773606841082043, 0.14482188935865709, 0.36572474208875744, 0.47057550297326767, 0.6635592923896434, 0.14274704443740943, 0.3143931551651281, 0.4308993289183599, 0.5945816078079202, -0.44705692333835023, -0.33157956407460215, -0.276766144259789, -0.17587663174507218, -0.4390232523091032, -0.3511268676227105, -0.2914404945013607, -0.20761621296955912, 1.0, 1.0, 0.9333333333333333, 1.0, 0.522650935319202, 0.522509004211164, 0.4944112807679467, 0.5237026278865069, 0.722004367110166, 0.5215215215215213, 0.5450576181452702, -0.059059059059059074, 0.38674698795180723], "score_NOT Basins_2D": 0.967308521270752, "score_GlobalLocal_2D": 0.9618079662322998, "ela_features": [0.17680965670504767, 0.8737364618310778, 0.013209245315000562, 0.10072190578999937, 10.13851585510567, 0.285750007488698, 0.18968481659284914, 19.06600747972376, 0.42932501196031164, -3.490947731138815, 15.855540811612148, 5.4, 0.6773390952876517, 0.8509832057376716, 0.5129691150216796, 0.19775449819545515, -0.41501895700323727, 0.7781776209797431, 0.8264339557227125, 0.8573308771618569, 0.8905091432229725, 0.7865828733963305, 0.8392416778900031, 0.8629308855726961, 0.8867713319314307, -0.19512104452153495, -0.15267755367008448, -0.12550096061246524, -0.0963153894453711, -0.18867872665940758, -0.14213986227065603, -0.12120238931949086, -0.10012073007906971, 1.0, 1.0, 0.8333333333333334, 0.8666666666666668, 0.2145791401717541, 0.2145583716998462, 0.21000322430608823, 0.23944294838384456, 0.6224284390374345, 0.28128128128128116, 0.02535343723447766, -1.1001001001001005, 0.4982371794871795], "score_NOT Basins_5D": 0.9986976596992463, "score_GlobalLocal_5D": 0.9221280217170715, "ela_features_10D": [0.0118927667402412, 0.9943487161231476, 0.0005054539503162095, 0.0076887984222829085, 31.57983509349022, 0.03364142120458928, 0.02037710651490261, 34.92084224808862, 0.0625802432879766, -21.719010154473132, 631.565958774551, 5.0, 0.8661882219791888, 0.923279293138005, 0.6248536462259393, 0.11730404809894454, -0.29719378449305567, 0.8567553788076727, 0.8708609921812915, 0.8878636739588828, 0.9117117190101366, 0.8704420928214196, 0.8747689051235333, 0.8887532062650344, 0.910459139086323, -0.18167883713227587, -0.16378830388759602, -0.14222453961360645, -0.11197806510998007, -0.164736275043362, -0.15923217703662867, -0.14145314890968796, -0.11385542151884342, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11018834401773794, 0.11019726486203878, 0.1100466797092241, 0.10354925203943828, 0.6348060464158216, -0.7077077077077074, 1.577954820791986e-05, -3.642642642642643, 0.566773418734988], "score_NOT Basins_10D": 0.9998683461308246, "score_GlobalLocal_10D": 0.9998270869255066}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[14, [-0.5177240701391518, -2.3324851238023956], -7.974918929857496], [19, [2.758591349540173, 3.7409115581162378], -5.551279535998512], [24, [2.77268392481741, -2.7452003636277085], -6.746275087873975], [18, [-3.296375285105755, -2.5359828276992022], -6.891529290162431], [22, [-1.4061283248630423, 2.3965472088776], -4.873601594374105], [3, [0.45787023058374676, 1.3339159699273684], -4.984690909580385]], "nr_of_basins": 6, "f_opt_dim_2": -7.974919458255208, "x_opt_dim_2": [-0.5179792414664848, -2.331959936122838], "f_opt_dim_5": -4.82536133063528, "x_opt_dim_5": [-1.9772935743933384, -3.832618402484988, 0.6489128993917817, -3.841309355299471, 2.708717039049475]}
{"id": "73233f4d-3390-47c5-a6bb-ebb5b4cfbb3a", "fitness": 0.9356858568498865, "name": "landscape", "description": "A non-uniform multi-Gaussian landscape with a deep global well at the origin and several irregular, shallower local wells dispersed across the domain. Centers, depths, and widths vary to produce non-homogeneous basins and a strong global-local contrast, while the global minimum is located at the origin (x=0) with a deep negative value. This setup yields basins of widely varying sizes and depths, making local minima harder to recognize uniformly across the search space.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim):\n        self.dim = dim\n        # deterministic pseudo-random generator state (for reproducibility)\n        self._seed = 123456789\n        # number of wells (K); at least 4, scales with dimensionality\n        self._K = max(4, dim * 2)\n        # centers of wells (K x dim)\n        self.c = np.zeros((self._K, self.dim), dtype=float)\n        # per-well depths (weights) - negative for local minima\n        self.w = np.zeros(self._K, dtype=float)\n        # per-well widths (scales)\n        self.s = np.zeros(self._K, dtype=float)\n\n        # Global deep well at the origin\n        self.c[0] = np.zeros(self.dim)\n        self.w[0] = -20.0\n        self.s[0] = 0.90  # relatively narrow well gives a sharp global minimum\n\n        # Generate irregular, non-homogeneous local wells\n        for i in range(1, self._K):\n            # deterministic centers with a minimum distance from origin\n            ctr = self._sample_center(min_dist=3.0)\n            self.c[i] = ctr\n            # negative depths for local minima (shallower than global)\n            self.w[i] = - (1.0 + self._rand() * 5.0)  # in [-6, -1]\n            # varying widths to create basins of different sizes\n            self.s[i] = 0.25 + self._rand() * 2.0        # in [0.25, 2.25]\n\n    def _rand(self):\n        # simple LCG-like RNG for deterministic output\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=3.0, max_trials=500):\n        # sample a random center within [-5,5]^dim with a minimum distance from origin\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback: place somewhere on a sphere of radius min_dist along axis\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n        # compute squared distances to all centers\n        # broadcasting: (K, dim) - (dim,) -> (K, dim)\n        diff = self.c - x\n        dist2 = np.sum(diff * diff, axis=1)\n        # Gaussian-like wells: w_i * exp(-dist2 / (2 * s_i^2))\n        # Note: s may vary per well\n        exponent = np.exp(- dist2 / (2.0 * (self.s ** 2)))\n        return float(np.sum(self.w * exponent))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.08473789528188243, 0.8531325391048352, 0.09448194399469845, 0.13382017312538974, 1.4319383463035176, 0.11667834711974442, 0.37037644288034344, 1.4209263324496386, 0.5335107626231869, -2.504239727366757, 8.038031939300236, 3.4, 0.5275179200535801, 0.6973744304636467, 0.4358165769082241, 0.34661700591559763, -0.17828065964729195, 0.150751981852914, 0.23852611228572512, 0.33016006421402305, 0.5184159980716652, 0.15692110806661375, 0.23513497363027716, 0.32630518154444477, 0.5129340490808462, -0.4443288355360576, -0.39840410727602027, -0.3504647646638562, -0.2519734568077433, -0.4331825913565133, -0.3929995281922487, -0.34615523889543515, -0.25026394753583214, 1.0, 1.0, 0.9333333333333332, 1.0, 0.5318601440469121, 0.531853315229195, 0.4693424294704428, 0.4396274520683271, 0.6089437592409053, 0.7377377377377374, 0.14394332672578397, -0.5395395395395394, 0.3642570281124498], "score_NOT Basins_2D": 0.98859803378582, "score_GlobalLocal_2D": 0.9690613746643066, "ela_features": [0.015220548362674103, 0.998285261550387, 0.001380001653809504, 0.015887500771293975, 126.30824003311912, 0.05036851880785358, 0.03693165911173015, 7.969484013169402, 0.09641558536035597, -14.852390253620024, 326.8692157216769, 6.4, 0.753770533145136, 0.8524854650573916, 0.5500124191333129, 0.19898953599559127, -0.34735094505192177, 0.8200713287719978, 0.828621548947156, 0.8497821927802416, 0.8882830129716826, 0.7960380672777065, 0.7986086923568898, 0.8186455768467384, 0.869105177082701, -0.15825949264869907, -0.1507420272383698, -0.13212767348114868, -0.09826263053428227, -0.18028360122846884, -0.17801057508093354, -0.16029601443664443, -0.11569063903676673, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2155327740692976, 0.21558807777123784, 0.21431610633183812, 0.19063286013798147, 0.588108019102198, -0.07907907907907907, 8.92933410213421e-05, -2.705705705705706, 0.49839743589743596], "score_NOT Basins_5D": 0.9978991316165775, "score_GlobalLocal_5D": 0.6588712334632874, "ela_features_10D": [0.045999918838440165, 0.9625887101068, 0.0006734955226618014, 0.0222949938162721, 43.99375872593508, 0.08893192298341812, 0.06852952086398993, 64.00315811025686, 0.17118518357614246, -11.668742789869935, 179.71915848298107, 6.2, 0.8989442772662093, 0.9257169353490159, 0.6488525833269139, 0.11507480564078512, -0.3682595820020291, 0.8159138330837171, 0.8236917112800546, 0.8408819358830975, 0.8844712597262016, 0.8205017713475599, 0.8196321716715147, 0.8355598195350564, 0.8822410104298217, -0.2334798289537975, -0.22361415027267859, -0.20181213183477395, -0.14652629332204525, -0.22826693701362305, -0.22937034144005874, -0.20911826961511498, -0.1497511137365876, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11219441993887606, 0.11219194785271473, 0.11188519148191593, 0.11200327866588311, 0.6450005402964589, -0.29529529529529525, 0.0001342540324382288, -2.76976976976977, 0.5590072057646117], "score_NOT Basins_10D": 0.9998694863170385, "score_GlobalLocal_10D": 0.9998158812522888}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[14, [-2.853777753457784, 3.7549496888694485], -3.6330968628118177], [16, [-0.8880189701625426, -3.5492108872848354], -5.195559669007682], [70, [0.03802160121670917, -0.045377114707132696], -22.32543741795942]], "nr_of_basins": 3, "f_opt_dim_2": -22.325437907658497, "x_opt_dim_2": [0.0381864784289679, -0.0454924513639461], "f_opt_dim_5": -20.001042409683365, "x_opt_dim_5": [3.271145175869006e-05, -1.0964327643443884e-05, 2.726656105916284e-06, 5.181905133419874e-05, -5.717316643672229e-05]}
{"id": "1287b5a8-0a74-4130-9cff-c0fc36cfe593", "fitness": 0.5791496593349924, "name": "landscape", "description": "A non-homogeneous multi-well landscape built from negative Gaussian basins aligned along the first axis. Each basin has a distinct depth and width, creating irregular basin sizes. The deepest basin (global minimum) is designed to stand out from shallower local minima, providing a clear global-local contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        \"\"\"\n        dim: number of dimensions of the search space.\n        The landscape consists of K Gaussian basins (K = max(4, min(12, 2*dim))).\n        All basin centers lie along the first axis in [-4, 4], with varying depths and widths.\n        Values: f(x) = -sum_i d_i * exp(-||x - c_i||^2 / (2*s_i^2))\n        Global minimum is at the deepest basin center due to largest d_i.\n        \"\"\"\n        self.dim = int(dim)\n        self.k = max(4, min(12, self.dim * 2))  # number of basins\n        \n        # Initialize centers c_i along the first axis, distributed in [-4, 4]\n        centers = []\n        for i in range(self.k):\n            t = -4.0 + 8.0 * (i + 1) / (self.k + 1)\n            c = np.zeros(self.dim, dtype=float)\n            c[0] = t\n            centers.append(c)\n        self.centers = np.asarray(centers)  # shape (k, dim)\n        \n        # Depths d_i: increasing with i to create a clear global minimum at the last basin\n        self.d = np.array([1.0 + 2.0 * i for i in range(self.k)], dtype=float)  # depth per basin\n        \n        # Widths s_i: vary mildly to create non-homogeneous basin widths\n        self.s = np.array([0.12 + 0.02 * i for i in range(self.k)], dtype=float)\n    \n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x should be a 1D numpy array of length self.dim, with each component in [-5, 5].\n        Returns a scalar value (minimization objective).\n        \"\"\"\n        x = np.asarray(x, dtype=float).flatten()\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected dim={self.dim}, got {x.size}\")\n        \n        val = 0.0\n        for i in range(self.k):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            val += - self.d[i] * np.exp(- dist2 / (2.0 * self.s[i] * self.s[i]))\n        return val", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.989, GlobalLocal 0.287,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.003064321041704643, 0.9973857880203741, 0.0006088392556978297, 0.004988115885603045, 8.188216476574521, -0.0050381626502507436, 0.01118121498982554, 1.5346667939200005, 0.01133064447720764, -15.045863321921956, 257.6481548904002, 5.0, 0.09680691726704796, 0.12974794742888535, 0.05155251443089372, 1.1042619318444413, -0.03611722261011753, 0.3690701268705657, 0.39685911013252195, 0.43833954698406447, 1.0, 0.3195494493068386, 0.3505686110444518, 0.3926367437969432, 1.0, -0.3301542230938931, -0.3156103607641058, -0.29390608150128406, 0.0, -0.34916058253622073, -0.3332566877596822, -0.31167570412298845, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5255836631808435, 0.525569403038086, 0.5167642903390837, 0.35324858324250097, 0.20860176877596254, 0.7777777777777775, 0.0, -Infinity, 0.0859437751004016], "score_NOT Basins_2D": 0.996939460746944, "score_GlobalLocal_2D": 0.033975329250097275, "ela_features": [-0.0028062051254911236, 1.0004230991070944, 9.340403758538812e-05, 0.0032542046267843884, 69.9301160124561, -0.010703590232193827, -0.001729114996324732, 3.432148890996249, -0.02148770262190678, -33.21886385819765, 1122.4190180921337, 1.8, 0.3027661581305766, 0.3342732583404392, 0.19928605281501438, 0.4092188753321951, -0.14603780099042868, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21616334553108524, 0.2161685049137525, 0.21570082556637474, 0.1805782588784725, 0.05807892244721304, -Infinity, 0.0, -Infinity, 0.01362179487179487], "score_NOT Basins_5D": 0.9940577032975852, "score_GlobalLocal_5D": 0.1738036572933197, "ela_features_10D": [-0.0026403032053611054, 1.0001703768090078, 9.244789711820728e-05, 0.001770977255385349, 88.34604083370763, -0.01936255062355925, -0.00288891647495908, 2.948821430341373, -0.05018762122673297, -49.94000079116035, 2493.001386136603, 1.0, 0.43047748780622086, 0.5046006373213769, 0.29474711191301856, 0.2151924702353733, -0.48500032586195435, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.108972113042513, 0.10897535957332598, 0.10891995554901798, 0.09924305717899108, 0.018464871321704362, -Infinity, 0.001798158596623705, -Infinity, 0.0032826261008807047], "score_NOT Basins_10D": 0.9886247320100665, "score_GlobalLocal_10D": 0.28749707341194153}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [10, [-0.7995555555555556, 0.00044444444444512003], -2.9999697658364033], [6, [0.8024110958483602, -0.03247111103131429], -4.897530733343382], [26, [-2.3997378894902908, 0.0009765109361326793], -0.9999645049519195], [52, [2.4000000000002863, 0.00044444444444512003], -6.999978661821884]], "nr_of_basins": 10, "f_opt_dim_2": -5.0, "x_opt_dim_2": [0.7999999997805787, -6.108381592711002e-10], "f_opt_dim_5": -19.671357960413314, "x_opt_dim_5": [3.2394993565647607, 9.479423937185154e-10, 4.0580031334584696e-10, -1.2487913903578151e-09, 3.0307287270337956e-10]}
{"id": "43469e2c-62a9-45c6-bf2a-a53b07c07d0b", "fitness": 0.8126810557441786, "name": "landscape", "description": "A composite multi-well landscape built from uneven Gaussian basins. Each basin has its own center, width (sigma) and depth, producing non-uniform basin sizes. One deepest well creates a clear global minimum, while many shallower wells provide local minima of varying depths, yielding a global-local minima contrast relative to the average landscape level. The function is defined in a dim-dimensional space with per-dimension bounds [-5, 5].", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 10\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # widths (standard deviations) of the wells (controls basin size)\n        self.sigmas = self.rng.uniform(0.25, 1.0, size=self.num_wells)\n\n        # depths of the wells (positive values; function is sum of negative Gaussians)\n        self.depths = self.rng.uniform(0.8, 3.0, size=self.num_wells)\n\n        # make the deepest well explicit to ensure a pronounced global minimum\n        self.depths[0] = 6.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-||x - center[i]||^2 / (2 * sigma[i]^2))\n\n        This yields multiple local minima corresponding to wells with varying depths\n        and widths, producing non-homogeneous basins and a clear global minimum at the\n        deepest well's region.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # Compute squared distances to all centers\n        # diff shape: (num_wells, dim)\n        diff = x - self.centers\n        dist2 = np.sum(diff * diff, axis=1)\n\n        # Exponential terms for each well\n        exps = np.exp(-dist2 / (2.0 * (self.sigmas ** 2)))\n\n        # Sum of negative Gaussians (basins)\n        contributions = -self.depths * exps\n\n        return float(np.sum(contributions))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.995, GlobalLocal 0.291,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.006940634573344218, 0.8873560404367227, 0.03360431329394575, 0.04376565872733162, 2.3306565607866587, 0.005850500085881172, 0.29014433954788255, 1.288629125534102, 0.3595429452157615, -1.8576467657397093, 3.791802178481769, 3.2, 0.42955393640427053, 0.6765941559225819, 0.3895242499528929, 0.3505298064359454, -0.2902213838025077, 0.4010612349755773, 0.5870847845990081, 0.6056109973639936, 0.6742917227169473, 0.4033892793116577, 0.6534672036262628, 0.6543149846117847, 0.6920977044730112, -0.3134706782562302, -0.21611681816247663, -0.206431983690128, -0.17046959292909802, -0.30669810538265063, -0.17816349250787372, -0.17777385352828617, -0.1583026137194039, 1.0, 1.0, 1.0, 1.0, 0.5157311763255793, 0.5157108449532848, 0.4516820687254053, 0.3662080013649542, 0.5517070671896522, 0.6936936936936935, 0.11618543488244384, -0.4074074074074073, 0.3863453815261044], "score_NOT Basins_2D": 0.9951498010195792, "score_GlobalLocal_2D": 0.9127551913261414, "ela_features": [0.004533855854665458, 0.9940132425491838, 0.0031673514057447396, 0.008136205075240339, 5.011048014736074, 0.0028488924701861595, 0.010960244390070994, 185.53485273688102, 0.011743054989506585, -20.770455095435548, 518.0462716265092, 4.8, 0.7241632255372806, 0.8410048529338248, 0.5217521975005697, 0.20483915207364464, -0.2620410018263566, 0.8116608294874353, 0.8276890089680189, 0.8395369034045475, 0.8584027800348117, 0.8335788962008982, 0.856175837925564, 0.8500326859084764, 0.8526454196522589, -0.1656336176092399, -0.15153788605844584, -0.14111890710840305, -0.12452882537537575, -0.1470295659382918, -0.12705819379801117, -0.1325018087238175, -0.1302026714720202, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21678308292395929, 0.21676428553670699, 0.21591983402576775, 0.18604278551850378, 0.49029517387910665, -0.20320320320320312, 0.0, -Infinity, 0.4825320512820513], "score_NOT Basins_5D": 0.9977294297423214, "score_GlobalLocal_5D": 0.684416651725769, "ela_features_10D": [-0.00022436426265803888, 1.0010819509025795, 0.00022238164113602384, 0.002500140475996266, 17.430365844030813, -0.010525751760424385, 0.0005141063762364783, 6.474036438404016, -0.032737934102424274, -41.48275362433109, 1845.2749417258212, 2.6, 0.6476911131548148, 0.7745039483798385, 0.36222902282289043, 0.1887286134805385, -0.08241822060785486, 0.7622423668542458, 0.8009254238623791, 0.827084187826977, 1.0, 0.7589202046566935, 0.7908938206701914, 0.8194700800150052, 1.0, -0.30154216747250395, -0.2524814741405775, -0.2193048807960875, 0.0, -0.3065743048703006, -0.2659142438645021, -0.22957441907446646, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11032876384684502, 0.11032064160373718, 0.1102645240625046, 0.10080332754828106, 0.37072581752980105, -4.2192192192192195, 0.0, -Infinity, 0.17934347477982385], "score_NOT Basins_10D": 0.9950671405531466, "score_GlobalLocal_10D": 0.290968120098114}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [1.3896683654121553, 1.2954014456584253], -3.3222100135829007], [14, [-0.4012758654627413, 0.8926036473351907], -3.027269742601076], [14, [-2.6108177559367665, 2.953272191856201], -1.859090530685336], [13, [2.898645459507664, 2.8997845759627188], -1.210624057924362], [4, [1.9270581473688566, -2.209175213299863], -1.236272827217919], [13, [-2.0062573356878275, -1.5586010489896671], -3.0828486061097533], [12, [3.660482947894766, -1.8574444908603558], -2.7869856054766062], [18, [-1.5326148657447636, -2.8315221779481723], -2.620392684578646], [4, [3.7228398498334476, -0.5795352009581803], -2.856752928522689]], "nr_of_basins": 9, "f_opt_dim_2": -3.391612479407272, "x_opt_dim_2": [1.2331186889553187, 1.2436698192660716], "f_opt_dim_5": -1.9686875921702869, "x_opt_dim_5": [-0.40900811849104873, -1.035932160302121, -0.13864420971244365, -3.2625481425510685, -2.1865350153790164]}
{"id": "9a1b596b-32a8-40fd-847b-96284c9be384", "fitness": 0.9840771376669485, "name": "landscape", "description": "A hierarchical anisotropic Gaussian mixture landscape with non-homogeneous basin sizes. It constructs a global deep basin and multiple main basins, each spawning several irregular sub-basins. Each basin uses per-dimension widths (anisotropy) to create highly varied basin shapes and sizes, resulting in a non-homogeneous basin structure and a strong global-local contrast for robust benchmarking of black-box optimizers.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(dim) * 1315423911) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Containers for centers, weights (negative depths), and per-basin widths\n        self.centers = []\n        self.weights = []\n        self.widths = []  # each element is a vector of length dim (anisotropic widths)\n\n        # Global deep basin to ensure a strong global minimum\n        origin = np.zeros(dim)\n        w_global = -rng.uniform(8.0, 15.0)  # deep global basin\n        s_global = rng.uniform(0.6, 2.0, size=dim)  # per-dimension widths\n        self.centers.append(origin)\n        self.weights.append(float(w_global))\n        self.widths.append(np.asarray(s_global, dtype=float))\n\n        # Main basins (coarse-scale centers)\n        n_main = min(4 + dim // 2, 12)  # scales with dimension but capped to keep size\n        for _ in range(n_main):\n            c_main = rng.uniform(-5.0, 5.0, size=dim)\n            w_main = -rng.uniform(0.8, 5.0)  # negative depth for main basin\n            s_main = rng.uniform(0.4, 2.5, size=dim)  # anisotropic widths per dimension\n\n            self.centers.append(np.asarray(c_main, dtype=float))\n            self.weights.append(float(w_main))\n            self.widths.append(np.asarray(s_main, dtype=float))\n\n            # Sub-basins around the main center (nested, irregular basins)\n            n_sub = rng.integers(0, 4)  # 0-3 sub-basins per main basin\n            for _k in range(n_sub):\n                # Small jitter around the main center\n                jitter_scale = rng.uniform(0.5, 1.5)\n                jitter = rng.normal(loc=0.0, scale=jitter_scale, size=dim)\n                c_sub = c_main + jitter\n                c_sub = np.clip(c_sub, -5.0, 5.0)\n\n                w_sub = -rng.uniform(0.2, 2.5)  # shallower than main basin\n                s_sub = rng.uniform(0.3, 3.0, size=dim)  # highly varied widths\n\n                self.centers.append(np.asarray(c_sub, dtype=float))\n                self.weights.append(float(w_sub))\n                self.widths.append(np.asarray(s_sub, dtype=float))\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, w, s in zip(self.centers, self.weights, self.widths):\n            diff = x - c\n            # Anisotropic Gaussian: dist^2 = sum_j (diff_j^2 / s_j^2)\n            dist2 = float(np.sum((diff * diff) / (s * s)))\n            val += w * np.exp(-0.5 * dist2)\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0dec716e-ec2f-44f1-8d82-6ff77516e47b"], "operator": null, "metadata": {"ela_features_2D": [0.36021688521837064, 0.47661947461690646, 0.1256655955939707, 0.5366240333525887, 4.2916243718889024, 0.37084140963569123, 0.6502765933429193, 1.5714592497161148, 0.750696462634416, -0.5541575884649912, -0.8932478984771031, 2.0, 0.5097234835280665, 0.6988927781514815, 0.42617355937629087, 0.3437490173180783, -0.1692308195934902, 0.15959137128290088, 0.25999651833494897, 0.49976015655211825, 0.598184406731037, 0.15942789291050546, 0.23868554792580313, 0.45189088112512366, 0.588524565890922, -0.4395642535100386, -0.3870387685814619, -0.261645757909903, -0.21016519141106033, -0.4314297187833832, -0.390736541161511, -0.2813252053164771, -0.21118730917816403, 1.0, 1.0, 1.0, 1.0, 0.5185836132504841, 0.5185434511807523, 0.518765590849725, 0.5329129278956843, 0.6188016927946075, 0.5655655655655654, 0.3094379722124637, -0.1271271271271271, 0.3477911646586345], "score_NOT Basins_2D": 0.9994181432412006, "score_GlobalLocal_2D": 0.9979467988014221, "ela_features": [0.016871830069863546, 0.9846131788427425, 0.0040167993723100705, 0.03723628092807023, 11.942537535894093, 0.09112482572019964, 0.13223486308058535, 21.330476877101436, 0.3546150306065134, -5.265571185820493, 40.084494252237135, 5.6, 0.7841213962671059, 0.8577847709542192, 0.5749123918070479, 0.1935555630253451, -0.41863051181434124, 0.6599170384466326, 0.722827571832042, 0.785229627233686, 0.8353462070545019, 0.5997930590079579, 0.6780337820115143, 0.7434996556703727, 0.813591140361055, -0.2990976002814273, -0.24376626570156104, -0.1888896157420316, -0.14481606221379414, -0.35369427040930185, -0.2845347128145204, -0.22668615671889086, -0.1647473812828447, 1.0, 1.0, 0.8333333333333334, 1.0, 0.22236118429204757, 0.2223576264966758, 0.21854233814330323, 0.19371014841624926, 0.6407702694163658, 0.21721721721721715, 0.008774387402165965, -1.5165165165165166, 0.514102564102564], "score_NOT Basins_5D": 0.9995896628242917, "score_GlobalLocal_5D": 0.9077020287513733, "ela_features_10D": [0.009113335872308715, 0.9992577435490271, 0.00020674212143029274, 0.008864143159522855, 1126.0124520937934, 0.014504038669805897, 0.01698898770622732, 8.715489580233466, 0.015215116686561569, -25.766724595027274, 873.5878793876855, 4.8, 0.8727867642396838, 0.922445802756428, 0.6310172642208016, 0.11738957944824077, -0.2969406263340642, 0.8255348389353131, 0.8508330594451323, 0.8640595412288368, 0.8987293295137262, 0.8306866738765419, 0.8504859901915964, 0.8605433550250341, 0.8958647078134865, -0.2212505223192948, -0.18916869225363983, -0.1723954117705769, -0.12842854929886002, -0.2152872022360331, -0.19011381354559465, -0.17732650246862597, -0.13241415236964033, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.109559396403986, 0.10956041409881023, 0.10944408382207065, 0.10204180895795682, 0.6234368148680693, -0.7477477477477477, 1.3221565278821213e-05, -3.8188188188188192, 0.5820656525220176], "score_NOT Basins_10D": 0.99989190386259, "score_GlobalLocal_10D": 0.999914288520813}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [-4.30643320190507, -1.5387268593896017], -7.390645259518198], [18, [-2.2656115949205935, 3.6364376068255346], -7.118824088432139], [63, [-0.3018052511314262, 0.026776474452551564], -9.697089309799017]], "nr_of_basins": 3, "f_opt_dim_2": -9.697089457370751, "x_opt_dim_2": [-0.3019741442021371, 0.02657719767247664], "f_opt_dim_5": -9.261530048301434, "x_opt_dim_5": [-0.09121608407011075, -0.016963840722240605, -0.006617473382126141, -0.0060478207932111476, 0.007040606075388011]}
{"id": "174c0767-80b6-4605-8503-fbaa0f837bbd", "fitness": 0.7816344443660151, "name": "landscape_nonhomogeneous_gaussians", "description": "A non-homogeneous, anisotropic Gaussian multi-well landscape. Each basin is an elliptical Gaussian with its own center, covariance (width/shape), and depth. By using per-well covariance matrices (not simply scalar widths) the basin sizes and shapes vary widely across the search space, breaking basin-size homogeneity and creating a pronounced global-local contrast for robust benchmarking.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_gaussians:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # depths of the wells (positive values; function is sum of negative Gaussians)\n        self.depths = self.rng.uniform(0.8, 3.0, size=self.num_wells)\n\n        # make the deepest well explicit to ensure a pronounced global minimum\n        self.depths[0] = 6.0\n\n        # per-well anisotropic covariances (not just scalar widths) to break basin homogeneity\n        self.covariances = []\n        for i in range(self.num_wells):\n            # Random PD matrix: Cov = A A^T\n            A = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Cov = A @ A.T\n\n            # Normalize to stabilize scale (avoid extremely large/small eigenvalues)\n            eigen_vals = np.linalg.eigvalsh(Cov)\n            max_ev = np.max(eigen_vals) if eigen_vals.size > 0 else 1.0\n            if max_ev <= 0:\n                max_ev = 1.0\n            Cov = Cov / max_ev\n\n            # Width/shape factor per well (introduce diverse anisotropy and scale)\n            w = self.rng.uniform(0.2, 4.0)\n            Cov = Cov * (w ** 2)\n\n            self.covariances.append(Cov)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-0.5 * (x - center[i])^T * inv(Cov_i) * (x - center[i]))\n\n        This yields multiple local minima corresponding to wells with varying depths,\n        widths (anisotropic), and centers, producing non-homogeneous basins and a\n        clear global minimum at the deepest well's region.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            Cov = self.covariances[i]\n\n            # Inverse of Cov (positive definite)\n            inv_cov = np.linalg.inv(Cov)\n\n            # Mahalanobis distance squared\n            dist2 = diff @ inv_cov @ diff\n\n            total += -self.depths[i] * np.exp(-0.5 * dist2)\n\n        return float(total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonhomogeneous_gaussians scored on:NOT Basins 0.995, GlobalLocal 0.392,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["43469e2c-62a9-45c6-bf2a-a53b07c07d0b"], "operator": null, "metadata": {"ela_features_2D": [0.33108687299670087, 0.8890861838072412, 0.12446001488458229, 0.36915596008585877, 3.067693122064575, 0.33458140496539235, 0.5063960808272581, 11.054435928524535, 0.6211860290296933, -1.3765572397822494, 2.1840547386099205, 2.0, 0.45161284290940884, 0.674470075479229, 0.3620218286914753, 0.3538649741779437, -0.24943440407189338, 0.27289930921638905, 0.33748506620590346, 0.49686434942107993, 0.6638566879422909, 0.24732336857718118, 0.3076616789432724, 0.48448548102380223, 0.6711143107227715, -0.38042738649288194, -0.3466244669741756, -0.2632411468454295, -0.17586664986219583, -0.387075528101981, -0.3560235541547871, -0.2651229026053077, -0.1691275915301973, 1.0, 1.0, 0.9333333333333332, 1.0, 0.5084621932526836, 0.5084459985369165, 0.4924464439860161, 0.5270449550954514, 0.6847188782348367, 0.8938938938938936, 0.3532220851780732, -0.1271271271271271, 0.39317269076305217], "score_NOT Basins_2D": 0.9996465290605556, "score_GlobalLocal_2D": 0.9820725321769714, "ela_features": [0.011515045078526454, 1.003530640179044, 0.002012862600701725, 0.01630666210030693, 25.10251583045921, 0.012186998626712308, 0.015596899790600327, 15.570860783199493, 0.02265699735819222, -15.283054410428624, 295.6584034945064, 6.0, 0.5249072264107761, 0.694677459524993, 0.3005240505031283, 0.3029419300068422, -0.19943609681362232, 0.7854624669277441, 0.8119953396605719, 0.8361711113852438, 0.8875198117663958, 0.7795348631507633, 0.801176461623988, 0.8245548199579268, 0.881067645482454, -0.18873178521647307, -0.16539269725461317, -0.1441252605591412, -0.09895229119236515, -0.19488594772851758, -0.17576989163138054, -0.15510328796238795, -0.1051445623709876, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21295383534234916, 0.21293794422181306, 0.21169687833005035, 0.1880680725249349, 0.5342221464497949, 0.1451451451451451, 0.0, -Infinity, 0.3833333333333334], "score_NOT Basins_5D": 0.9971707169897854, "score_GlobalLocal_5D": 0.32428836822509766, "ela_features_10D": [0.0010185485137247153, 1.0016109474472064, 0.00011302830947105215, 0.0033623951331321887, 82.17972676727973, -0.003850186897769037, 0.001437962717879504, 37.03941440687131, -0.013967433622837033, -39.450828150718145, 1657.0252469351276, 3.0, 0.6269108113111375, 0.7778476160219691, 0.33648547009283647, 0.19101550979253026, -0.068197710063217, 0.8243699105339737, 0.851889798801932, 0.8808789095011272, 1.0, 0.8192324747857063, 0.84682200082364, 0.8777643242813721, 1.0, -0.22276181077374754, -0.18785592056630684, -0.15108746352623248, 0.0, -0.22993108722782116, -0.19483618828663954, -0.15547834532123864, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11082234558726345, 0.11082727460547677, 0.11074362942075575, 0.10127850218567239, 0.4469734428077613, -2.8978978978978978, 0.0, -Infinity, 0.2430744595676541], "score_NOT Basins_10D": 0.9951096586883068, "score_GlobalLocal_10D": 0.39151886105537415}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[26, [3.48745107203839, -1.59836916916215], -9.517052481707498], [17, [3.091483136027029, 2.57902761134989], -4.960818025037618], [16, [1.3081250934735051, 1.1953802716161788], -5.435458440277076], [31, [1.2345751198498895, 0.5384941948896521], -4.304774151927049], [10, [-2.6486459502009945, 2.946251861697018], -2.947276422418917]], "nr_of_basins": 5, "f_opt_dim_2": -4.304781763763974, "x_opt_dim_2": [1.2310876773063966, 0.5367820197288801], "f_opt_dim_5": -2.9749960395450294, "x_opt_dim_5": [0.2925298998582709, 1.865853199334137, -0.4087137061321794, -1.555993839885731, 3.5788768170552463]}
{"id": "11f353c0-f779-422a-b516-26df2f4bba5c", "fitness": 0.7555407439358532, "name": "landscape_pnorm_minima", "description": "A non-homogeneous multi-well landscape formed by the minimum of shifted p-norm-like wells with varying depths, widths, and exponents. Each well i has center ci, depth di, width-like weight wi, and an exponent pi that controls the basin shape. The global minimum sits at the origin with a deep negative value, while other wells create irregular local minima of varying sizes and contrasts, yielding non-uniform basins and a strong global-local contrast.", "code": "import numpy as np\n\nclass landscape_pnorm_minima:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._seed = 987654321\n        # number of wells; at least 4, scales with dimensionality\n        self._K = max(4, self.dim * 3)\n\n        # wells parameters\n        self.c = np.zeros((self._K, self.dim), dtype=float)  # centers\n        self.d = np.zeros(self._K, dtype=float)              # base depths (negative = minima)\n        self.w = np.zeros(self._K, dtype=float)              # width/scale per well\n        self.p = np.zeros(self._K, dtype=float)              # exponent per well (shapes the basin)\n\n        # Global deep well at the origin\n        self.c[0] = np.zeros(self.dim)\n        self.d[0] = -60.0    # deep global minimum\n        self.w[0] = 6.0\n        self.p[0] = 2.0       # quadratic-like well\n\n        # Generate irregular, non-homogeneous local wells\n        for i in range(1, self._K):\n            ctr = self._sample_center(min_dist=2.5, max_trials=2000)\n            self.c[i] = ctr\n            self.d[i] = - (0.5 + self._rand() * 4.5)  # local minima in [-5.0, -0.5]\n            self.w[i] = 0.5 + self._rand() * 5.0       # width/strength in [0.5, 5.5]\n            self.p[i] = 1.0 + self._rand() * 2.0         # exponent in [1, 3]\n\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=2.5, max_trials=2000):\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback: place somewhere on a sphere of radius min_dist along axis\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n        # Compute qi = di + wi * (sum_j |x_j - c[i,j]|^p_i)\n        K = self._K\n        vals = np.empty(K, dtype=float)\n        for i in range(K):\n            diff = x - self.c[i]\n            dist_p = np.sum(np.abs(diff) ** self.p[i])\n            vals[i] = self.d[i] + self.w[i] * dist_p\n        return float(np.min(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_pnorm_minima scored on:NOT Basins 0.830, GlobalLocal 0.013,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["73233f4d-3390-47c5-a6bb-ebb5b4cfbb3a"], "operator": null, "metadata": {"ela_features_2D": [0.018975206843548274, 0.5784732821121279, 0.06138072622269662, 0.09265702166906623, 1.5223596708952618, 0.15767143751966822, 0.5937781413914988, 1.0361068689895752, 0.8377671469538468, -0.3534838091405694, -0.024064669875619327, 2.2, 0.5548790801250385, 0.7021975282239581, 0.44957808805847677, 0.3416167326414758, -0.1631215385067425, 0.14479885079402072, 0.22834484759907214, 0.31546377046873136, 0.4977264063715098, 0.14611253107715186, 0.22760969538128176, 0.31750068833787937, 0.49915117333033193, -0.4477093464939356, -0.40397034739544024, -0.3583633602327789, -0.26294645092248825, -0.4391797706983276, -0.39726360757117574, -0.35102954023306665, -0.25760529281105315, 1.0, 1.0, 1.0, 1.0, 0.5182361282091497, 0.5182193058153782, 0.41086264534897027, 0.37962188307929223, 0.6848444053702085, 0.49749749749749733, 0.2904164572545625, -0.3113113113113112, 0.3694779116465864], "score_NOT Basins_2D": 0.9877665173262358, "score_GlobalLocal_2D": 0.9974101185798645, "ela_features": [0.4236992781942133, 0.7199901401942592, 0.06951841202735963, 0.14698875622637872, 2.1269694990961483, 0.4862052977750159, 0.609339518250915, 1.5809671688386502, 0.7148309586110033, -1.1377296583409326, 7.050169737335763, 4.8, 0.7913380766762124, 0.8560770226178557, 0.579847688828109, 0.1946992283224714, -0.3814649030299543, 0.5448237125679933, 0.7157111014313854, 0.7563331327779333, 0.8177747862560272, 0.5013287452097019, 0.7134816147356245, 0.7368806396131748, 0.8059506453040932, -0.4003562056399759, -0.2500506311141068, -0.21432128605525583, -0.16027885361253497, -0.44077276969040324, -0.25325363221062136, -0.2325727723498281, -0.1715189712355233, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21664477832677842, 0.21662890393836626, 0.21575560262080903, 0.27632485247393107, 0.8250521659460176, 0.23323323323323314, 0.0890636453347688, -0.8598598598598596, 0.517948717948718], "score_NOT Basins_5D": 0.9498511962592602, "score_GlobalLocal_5D": 0.7555695176124573, "ela_features_10D": [0.2750597351729979, 0.3560596434467618, 0.011076254485029724, 0.147927421372204, 16.443463174318726, 0.5646388588493141, 0.4173691261692543, 6.484836287145887, 0.7587875650039042, -0.02965855887780593, 0.037356099446877435, 1.4, 0.8522356064450458, 0.9179893609794835, 0.6207373440991498, 0.12137134285603206, -0.5057430346581249, 0.8881752673005341, 0.9090855992614795, 0.9181595394770838, 0.9343223514927154, 0.9031776811124772, 0.9163309313190439, 0.9205779730330015, 0.9334743074582242, -0.14183829961247926, -0.11531363990482162, -0.10380482157788799, -0.08330353198864651, -0.12316225678194889, -0.10642407466701545, -0.10102396235927928, -0.08461794150979358, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11053018502550242, 0.11053161706652262, 0.10970152353813964, 0.13822061133223726, 0.8486089061230546, -0.16716716716716712, 0.10333073856756392, -0.7517517517517515, 0.5709367493995197], "score_NOT Basins_10D": 0.8296771049499512, "score_GlobalLocal_10D": 0.01297000888735056}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [4.258000000000082, 0.8115555555555556], -3.938263502915073], [13, [2.5185719361529966, -2.473343309361979], -3.6090654022150273], [11, [-4.346888888888839, 3.7297777777776737], -3.2916130743158574], [5, [4.3080783529962305, -2.1818209991361703], -1.015118251693106], [49, [0.00044444444444512003, 0.00044444444444512003], -59.99999762962963], [14, [-1.4156710107467647, 2.8426635252063446], -0.6976048952109312]], "nr_of_basins": 6, "f_opt_dim_2": -60.0, "x_opt_dim_2": [2.041926215844396e-08, 1.5783628136630771e-09], "f_opt_dim_5": -60.0, "x_opt_dim_5": [-1.197899669780416e-09, 7.460955199914465e-09, 1.2588486274151904e-08, 2.485978783892572e-09, 1.241723864665334e-08]}
{"id": "da1c0c4f-afde-4536-ad5e-aafea9cf6539", "fitness": 0.8065262707047319, "name": "landscape_contrast_gaussians", "description": "A high-contrast composite Gaussian-well landscape with a dominant global minimum at the origin to create a pronounced global-local minima contrast, while other wells create irregular basins to challenge search strategies.", "code": "import numpy as np\n\nclass landscape_contrast_gaussians:\n    \n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the Gaussian wells\n        # Reserve the origin for the global well to guarantee a strong global minimum\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        self.centers[0] = np.zeros(self.dim)\n\n        # widths (standard deviations) of the wells (controls basin size)\n        self.sigmas = self.rng.uniform(0.25, 1.0, size=self.num_wells)\n\n        # depths of the wells (positive values; function is sum of negative Gaussians)\n        # Global well (index 0) is made significantly deeper to boost global-local contrast\n        self.depths = self.rng.uniform(0.4, 4.0, size=self.num_wells)\n        self.depths[0] = 12.0  # pronounced global minimum at the origin\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-||x - center[i]||^2 / (2 * sigma[i]^2))\n\n        The first well is positioned at the origin with a large depth to create a\n        strong global minimum, while the remaining wells introduce non-homogeneous\n        basins and a clear global-local contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # Compute squared distances to all centers\n        diff = x - self.centers  # shape: (num_wells, dim)\n        dist2 = np.sum(diff * diff, axis=1)\n\n        # Exponential terms for each well\n        exps = np.exp(-dist2 / (2.0 * (self.sigmas ** 2)))\n\n        # Sum of negative Gaussians (basins)\n        contributions = -self.depths * exps\n\n        return float(np.sum(contributions))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_contrast_gaussians scored on:NOT Basins 0.995, GlobalLocal 0.182,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["43469e2c-62a9-45c6-bf2a-a53b07c07d0b"], "operator": null, "metadata": {"ela_features_2D": [0.11689329284324586, 0.9852769356571555, 0.02433281496999156, 0.161178312087451, 10.430402736065504, 0.12278701839032546, 0.28715798880309595, 1.8708567103293177, 0.4064029673001216, -2.2377989116592607, 7.768666189231157, 3.0, 0.38200766053121404, 0.6626826323720642, 0.3337998923020266, 0.3533912092315882, -0.30390275341005907, 0.4212496126281563, 0.44188259836780297, 0.5163807540945069, 0.6865677189150192, 0.5096796243197266, 0.4673206709219014, 0.5336375356469394, 0.6775891087841279, -0.3027309446041867, -0.2919419453804674, -0.25297223593367435, -0.16394425233796964, -0.25164007479773914, -0.2735244976396068, -0.23943286799354419, -0.16548594629092336, 1.0, 1.0, 0.7333333333333332, 1.0, 0.5347001159022718, 0.5346939811264075, 0.48961524412633517, 0.45088752273661764, 0.6291671671832887, 0.7377377377377374, 0.29189537417028266, -0.34734734734734724, 0.39839357429718875], "score_NOT Basins_2D": 0.9977354409638792, "score_GlobalLocal_2D": 0.9648602604866028, "ela_features": [0.004042168379256905, 1.0062259335025352, 0.0004880387704711853, 0.010834762648567866, 41.34334152653063, 0.005063158872610862, 0.019963487431439962, 16.410595883940104, 0.04001290961988992, -16.209192350105866, 334.91714320321023, 5.4, 0.756960537524175, 0.8569014845120284, 0.5419570624248402, 0.1940325022840935, -0.28205943008527956, 0.7094663272242677, 0.7607278394897985, 0.7936680939862671, 0.851151320029242, 0.7101432120687746, 0.7553158654158816, 0.7854259825692697, 0.8398897379152904, -0.25554557944791667, -0.210459680934839, -0.18148599747783806, -0.1309255199370732, -0.2562037184261765, -0.2163006114586393, -0.18968846927609181, -0.1415475688379119, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2176164849442423, 0.21761548026144673, 0.21656529897653756, 0.1871852758468032, 0.4733731158559561, -0.14314314314314314, 7.152637998494247e-06, -Infinity, 0.5057692307692307], "score_NOT Basins_5D": 0.9994836098630913, "score_GlobalLocal_5D": 0.7006160020828247, "ela_features_10D": [-0.0026125579594871605, 0.9990547776135404, 5.1783107639051374e-05, 0.0017335982020881425, 432.541926476715, -0.01923632252241947, -0.0006436562161235892, 4.689027304809771, -0.046522115798877994, -43.907796324334235, 2050.8445507814827, 2.2, 0.7700391477064803, 0.8485966324810249, 0.4913826595133897, 0.15363653994874943, -0.11886378714728998, 0.742021516898579, 0.7620103925938787, 0.7893542841119874, 0.9363115488523299, 0.7325179903466097, 0.7524603358327597, 0.7824050499422047, 0.9351564362272267, -0.3271778698346431, -0.30182918191394525, -0.2671503099692891, -0.0807773566203009, -0.34007718447253266, -0.3147229563066392, -0.27665035407631444, -0.08246333310530755, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1106037038290945, 0.11059960120229402, 0.1105398114278783, 0.10074058667301453, 0.4946064462145164, -3.510510510510511, 0.0, -Infinity, 0.2921537229783827], "score_NOT Basins_10D": 0.9946756693534553, "score_GlobalLocal_10D": 0.1817866414785385}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [-0.15610646913913356, -0.04734912612672262], -10.853066577493284], [8, [-3.4836560682064164, 1.5136907419704928], -2.119162660912658], [5, [1.422577456644439, 1.2348016332768272], -6.065133395806878], [20, [2.873981604055393, 2.8638460605029277], -3.6186450301596222], [15, [-2.6233283119805004, 2.9624175020705232], -2.016040191939736], [23, [-2.062410412839758, -1.461190691115724], -2.0948744499746645], [15, [2.4281877248480073, -2.097979451635751], -5.02303596575145], [10, [3.7635586476290888, -1.6183202151303884], -5.391111729765852]], "nr_of_basins": 8, "f_opt_dim_2": -6.066165390913074, "x_opt_dim_2": [1.4156720798432771, 1.2448111310933792], "f_opt_dim_5": -2.8716952052669313, "x_opt_dim_5": [0.30058927792139634, 1.8660183109171375, -0.42349525797630494, -1.5647150900781928, 3.573847745932758]}
{"id": "45b934b8-671f-4112-993d-52e4e3c4c04d", "fitness": 0.9511576640137113, "name": "landscape_nonuniform_gaussian", "description": "A non-uniform multi-Gaussian landscape with anisotropic (per-dimension) wells to break basin-size homogeneity. The global minimum sits at the origin, while local wells have varying depths and ellipsoidal shapes, creating irregular basin sizes and strong global-local contrast to challenge black-box optimizers.", "code": "import numpy as np\n\nclass landscape_nonuniform_gaussian:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # deterministic pseudo-random generator state (for reproducibility)\n        self._seed = 987654321\n        # number of wells; ensures more than a few local minima in higher dims\n        self._K = max(4, self.dim * 3)\n\n        # centers of wells (K x dim)\n        self.c = np.zeros((self._K, self.dim), dtype=float)\n        # per-well depths (weights) - negative for minima\n        self.w = np.zeros(self._K, dtype=float)\n        # per-well per-dimension widths (anisotropic basins): shape (K, dim)\n        self.s = np.zeros((self._K, self.dim), dtype=float)\n\n        # Global deep well at the origin\n        self.c[0] = np.zeros(self.dim)\n        self.w[0] = -40.0\n        self.s[0] = np.ones(self.dim) * 0.6  # relatively narrow, isotropic global well\n\n        # Generate irregular, non-homogeneous local wells\n        for i in range(1, self._K):\n            # centers away from origin to create irregular basins\n            ctr = self._sample_center(min_dist=2.0)\n            self.c[i] = ctr\n            # depths (negative) for local minima, varying across wells\n            self.w[i] = - (1.0 + self._rand() * 9.0)  # in [-10, -1]\n            # per-well per-dimension widths (anisotropic wells)\n            self.s[i] = self._sample_widths()\n\n    def _rand(self):\n        # simple LCG-like RNG for deterministic output\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=2.0, max_trials=1000):\n        # sample a random center within [-5,5]^dim with a minimum distance from origin\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback: place somewhere on a sphere of radius min_dist along axis\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def _sample_widths(self):\n        # anisotropic widths per dimension, creating non-uniform basin shapes\n        s = np.zeros(self.dim, dtype=float)\n        for j in range(self.dim):\n            # mix of narrow and wide directions to avoid homogeneous basins\n            if self._rand() < 0.35:\n                s_j = 0.25 + self._rand() * 0.75   # ~[0.25, 1.0]\n            else:\n                s_j = 0.8 + self._rand() * 2.2     # ~[0.8, 3.0]\n            s[j] = s_j\n        # occasional extremely wide direction to further break homogeneity\n        if self._rand() < 0.15:\n            idx = int(self._rand() * self.dim)\n            s[idx] *= (1.5 + self._rand() * 2.5)\n        return s\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n        # compute anisotropic squared distances to all centers\n        # dist2_i = sum_j ( (x_j - c[i,j])^2 / s[i,j]^2 )\n        diff = self.c - x  # shape (K, dim)\n        dist2 = np.sum((diff / self.s) ** 2, axis=1)  # shape (K,)\n        # Gaussian-like wells: w_i * exp(-0.5 * dist2_i)\n        exponent = np.exp(-0.5 * dist2)\n        return float(np.sum(self.w * exponent))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonuniform_gaussian scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["73233f4d-3390-47c5-a6bb-ebb5b4cfbb3a"], "operator": null, "metadata": {"ela_features_2D": [0.032292825401072964, 0.807067707149516, 0.05274326902752444, 0.057181593866209954, 1.085555745072344, 0.04522005216688278, 0.33867402129672974, 1.0247842396488172, 0.46281601514509585, -3.7689527820913753, 19.05058616021208, 4.8, 0.5579433619403773, 0.6976612207831916, 0.43691004810669554, 0.34734257298265286, -0.1847969186856721, 0.14330161669667757, 0.21938367586714, 0.32119146507814633, 0.5282450541778827, 0.14905423572202453, 0.2267754970803912, 0.3142036173125607, 0.5137523904921821, -0.4481865203991536, -0.4083855582124797, -0.35512526646850595, -0.24680258120378804, -0.43698454761911, -0.397079827125778, -0.35217292446924436, -0.2496854361928244, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5073850328609423, 0.507289861341326, 0.46810135966243144, 0.3953369686861804, 0.6856139552792252, 0.8338338338338336, 0.11137695486383237, -0.6516516516516514, 0.3783132530120482], "score_NOT Basins_2D": 0.9796351045370102, "score_GlobalLocal_2D": 0.7289597392082214, "ela_features": [0.06775462755285737, 0.9530538002408109, 0.0015166613174345826, 0.0507399952670962, 47.336363089604745, 0.07448047712049226, 0.106863153521319, 26.88202457588262, 0.20452427578136687, -6.459651417110436, 56.36155323644001, 7.0, 0.6859620998136386, 0.8403724618141195, 0.49277855394129205, 0.2085355445978648, -0.4266378024410763, 0.725667951880759, 0.7830889729213679, 0.8258178924314189, 0.8687809428297844, 0.7303935897808133, 0.7727265752164372, 0.8180133939489865, 0.8649704391804314, -0.2412715940538029, -0.1907691404245724, -0.15319243723919126, -0.11540675873938185, -0.23827239389477492, -0.2008613271878162, -0.16084753689486636, -0.11934349286084936, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21898621327378748, 0.21897998365987426, 0.21589456661816855, 0.20984579317012214, 0.6321122050929644, 0.30130130130130117, 0.001481334020489921, -1.6686686686686687, 0.5391025641025641], "score_NOT Basins_5D": 0.999913404120889, "score_GlobalLocal_5D": 0.9986250400543213, "ela_features_10D": [0.012089443485528251, 1.0062492001819696, 0.0007084135916941927, 0.006890291358506368, 22.14124926405172, 0.04474922391903, 0.018327475239654122, 308.54960884897685, 0.0580023738396803, -20.49189212928873, 538.2619923647086, 4.6, 0.8316905068223065, 0.9162037671293494, 0.5897688899875274, 0.12383178572235046, -0.29046397146486386, 0.8495195780015201, 0.8648114869976474, 0.8809058910203428, 0.9114994177727646, 0.8449226546843487, 0.8617243901180511, 0.8772093978270167, 0.9089539408032566, -0.19083215962149674, -0.17144007181087328, -0.15102970941659874, -0.112232660678001, -0.19717994522710136, -0.17581873553834373, -0.15612905616165804, -0.11576674277734629, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11071814680123666, 0.11071866250779676, 0.11058899679574082, 0.10420168729213893, 0.6171109366412885, -0.6236236236236234, 1.1902844365302812e-05, -4.107107107107107, 0.5982385908726982], "score_NOT Basins_10D": 0.9999403693109343, "score_GlobalLocal_10D": 0.9998723268508911}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[29, [3.5259737597495056, -1.926812354249362], -9.989804669160494], [53, [-0.010391680885747613, -0.01806559608785982], -48.52369608897156], [18, [-3.57014976519773, 3.2385655018871713], -6.840855558705476]], "nr_of_basins": 3, "f_opt_dim_2": -48.523793866360315, "x_opt_dim_2": [-0.009434675116891566, -0.017145659761471553], "f_opt_dim_5": -11.905401733109777, "x_opt_dim_5": [2.9075702998682162, -3.4280649815202535, -3.7244525533645207, 0.5629713400743244, -0.529655440813334]}
{"id": "b5c3d2d6-ce70-405d-af84-96bfc12517cb", "fitness": 0.5038839063296715, "name": "landscape_nh_gaussians", "description": "A novel non-homogeneous Gaussian-mixture landscape with a deep global basin at the origin and a highly heterogeneous set of additional wells. By using a mixed distribution for basin widths (very narrow, medium, and wide) and varying depths, the resulting basin sizes are non-homogeneous, creating strong global-local contrast and challenging optmizers to discriminate truly good regions from deceptive ones.", "code": "import numpy as np\n\nclass landscape_nh_gaussians:\n    \"\"\"\n    Non-homogeneous Gaussian mixture landscape.\n    Global minimum is driven by a deep central basin at x=0, with a\n    heterogeneous collection of additional wells of varying width and depth\n    scattered in the D-dimensional domain [-5,5]^D.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(dim) * 987654321) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Desired number of Gaussian basins grows with dimension but is capped\n        self.Nc_target = min(12 + dim, 60)\n\n        self.centers = []\n        self.weights = []\n        self.widths = []\n\n        min_sep = 2.0  # keep some separation between centers to create distinct basins\n\n        # 1) A very deep global basin at the origin (0, ..., 0)\n        self.centers.append(np.zeros(dim))\n        w0 = -rng.uniform(8.0, 14.0)  # deep global minimum\n        s0 = rng.uniform(0.4, 2.2)    # moderate width\n        self.weights.append(w0)\n        self.widths.append(s0)\n\n        # 2) Scatter additional basins with strongly heterogeneous sizes\n        for _ in range(1, self.Nc_target):\n            placed = False\n            tries = 0\n            while not placed and tries < 1000:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n\n                # enforce separation from existing centers\n                if all(np.linalg.norm(c - np.array(ex)) >= min_sep for ex in self.centers):\n                    self.centers.append(c)\n\n                    # Widths drawn from a mixed distribution to create non-homogeneous basins\n                    r = rng.random()\n                    if r < 0.15:\n                        s = rng.uniform(0.15, 0.5)    # very narrow\n                    elif r < 0.65:\n                        s = rng.uniform(0.6, 1.8)     # medium-narrow\n                    else:\n                        s = rng.uniform(2.0, 4.5)     # wide\n                    self.widths.append(s)\n\n                    # Depths: all negative valleys; non-uniform depths\n                    # Ensure additional wells are shallower than the global minimum\n                    w = -rng.uniform(0.4, max(0.9, 0.65 * abs(w0)))\n                    self.weights.append(w)\n                    placed = True\n                tries += 1\n\n            # Fallback if we couldn't place with margin\n            if not placed:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n                self.centers.append(c)\n                self.widths.append(rng.uniform(0.6, 3.5))\n                self.weights.append(-rng.uniform(0.5, 4.0))\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, w, s in zip(self.centers, self.weights, self.widths):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            val += w * np.exp(-dist2 / (2.0 * s * s))\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh_gaussians scored on:NOT Basins 0.050, GlobalLocal 0.993,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0dec716e-ec2f-44f1-8d82-6ff77516e47b"], "operator": null, "metadata": {"ela_features_2D": [0.17328230310937123, 0.5235168159764815, 0.09612467635955821, 0.3511804273880138, 3.685370065484738, 0.20487084426268898, 0.5843026195111495, 1.1183428971151441, 0.8202153537618433, -0.7349539494222664, -0.36927231731939514, 1.4, 0.49146882786903223, 0.6827189385644536, 0.43479991676249624, 0.3513498762994255, -0.18250910832434603, 0.17632048588973856, 0.24625543704810132, 0.3524657018376308, 0.5405513288120398, 0.17022662920109385, 0.24033687468083328, 0.3441896123776282, 0.5214233701165263, -0.4309465691863018, -0.394357333104125, -0.3387907133747699, -0.24038134440278838, -0.4268044052398746, -0.3907413262777422, -0.337309483195515, -0.2461572249919158, 1.0, 1.0, 1.0, 1.0, 0.5141758122407122, 0.5141685651122774, 0.4603142837610651, 0.4744778430436809, 0.6749971043967238, 0.6176176176176174, 0.3068683659195547, -0.19519519519519513, 0.3859437751004016], "score_NOT Basins_2D": 0.9691798202693462, "score_GlobalLocal_2D": 0.9862849712371826, "ela_features": [0.14673561582037584, 0.8987019582330718, 0.007167754130210373, 0.1588526491106957, 77.14551866812523, 0.23573255425007775, 0.7211324030703921, 1.6492536139031213, 0.9048416010326106, -0.936791440849678, 1.6059950109211307, 2.4, 0.8824265326454965, 0.8747976310903584, 0.6371840885117799, 0.17844175921095123, -0.4484585216430112, 0.4607147705135192, 0.5790834406616757, 0.6483620231453722, 0.7539900535702125, 0.4593690022255319, 0.5588594264993176, 0.6323272074493584, 0.7447339672731575, -0.4743252838290539, -0.3702136343361052, -0.3092795736842914, -0.2163750836845125, -0.4778672368110236, -0.3899218419682415, -0.32498297859108893, -0.2256276525162768, 1.0, 1.0, 0.8333333333333334, 0.9666666666666668, 0.21357818343042173, 0.21358302781606353, 0.20707016082772284, 0.2323165541807445, 0.8018695507794462, 0.07307307307307305, 0.15051047271523127, -0.5875875875875873, 0.49967948717948724], "score_NOT Basins_5D": 0.000643312931060791, "score_GlobalLocal_5D": 0.0241762176156044, "ela_features_10D": [0.28738353015614815, 0.9638956176608012, 0.014057521971594966, 0.13211491960819505, 10.069982881534598, 0.5099663333599819, 0.3971582982957057, 3.2346985560634787, 0.7046995122020278, -3.037624701625677, 13.420909630033174, 6.0, 0.9274482757129029, 0.9301293603583372, 0.6702886201778198, 0.10922929448255414, -0.5036653415432601, 0.7882650875506995, 0.8038717557699592, 0.8357881097317044, 0.8803822028534958, 0.7789175782935229, 0.7928224939562429, 0.8285647339765374, 0.8777537527255861, -0.2685349190399361, -0.248743592692538, -0.20826489749275973, -0.15170788756945958, -0.28111570161403227, -0.2634386779053382, -0.21798861732739522, -0.1554430528259453, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10984611477433395, 0.10984674602907388, 0.10913261736810911, 0.1400741636308928, 0.7518430842512233, -0.1471471471471471, 0.022750558045182834, -1.2122122122122125, 0.5530824659727782], "score_NOT Basins_10D": 0.05039167404174805, "score_GlobalLocal_10D": 0.9926274418830872}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[43, [0.33510400273966107, 0.0008553571100769501], -15.064293458396937], [3, [0.8799178695763687, 4.6163117129152695], -3.919883898897866], [23, [2.46036360079706, -2.5685163682283076], -11.57076619058807], [9, [-3.8320817005880228, 0.9967703286231826], -4.877370826253975], [5, [-1.7252882358521102, 4.118142171112135], -6.7044120186252645], [12, [-3.694400600045029, -3.447086090917126], -4.958820589881963], [5, [2.890462177653663, 4.252752225197498], -3.0107118270076074]], "nr_of_basins": 7, "f_opt_dim_2": -15.064304005916362, "x_opt_dim_2": [0.3320956785091327, -0.00038948465810238585], "f_opt_dim_5": -22.532189496126108, "x_opt_dim_5": [0.08570454378701613, -0.022206489087883818, -0.001105139796009555, 0.11812641601273385, -0.020615467242057355]}
{"id": "0c33e68f-4c22-4277-896a-3f076defc785", "fitness": 0.878095394698903, "name": "landscape_nonuniform_aniso", "description": "A nonuniform anisotropic multi-well landscape with per-well diagonal covariances, creating irregular basin sizes and shapes to improve NOT Basins discrimination. The deepest well provides the global minimum, while other wells vary in depth and orientation to pose a non-homogeneous search space.", "code": "import numpy as np\n\nclass landscape_nonuniform_aniso:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # per-well per-dimension standard deviations (anisotropic basins)\n        # Each well i has its own sigma vector across dimensions\n        self.sigmas = self.rng.uniform(0.15, 2.0, size=(self.num_wells, self.dim))\n\n        # introduce additional irregularity: sometimes elongate along a random axis\n        for i in range(self.num_wells):\n            if self.rng.random() < 0.5:\n                axis = self.rng.integers(0, self.dim)\n                self.sigmas[i, axis] *= self.rng.uniform(1.6, 3.2)\n\n        # depths of the wells (positive; function is sum of negative Gaussians)\n        self.depths = self.rng.uniform(0.8, 3.0, size=self.num_wells)\n\n        # ensure a deepest well to enforce a pronounced global minimum\n        self.depths[0] = 6.0\n\n        # Precompute inverse variances for efficient exponent calculation\n        self.inv_covs = 1.0 / (self.sigmas ** 2)  # shape: (num_wells, dim)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i (-depths[i]) * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n        This yields multiple local minima with non-uniform basin sizes and a clear global minimum\n        at the deepest well's region.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # diff shape: (num_wells, dim)\n        diff = x - self.centers\n\n        # exponent for each well: -0.5 * sum_j (diff_j^2 / sigma_ij^2)\n        exponent = -0.5 * np.sum((diff ** 2) * self.inv_covs, axis=1)\n\n        # contributions from all wells\n        contributions = -self.depths * np.exp(exponent)\n\n        return float(np.sum(contributions))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonuniform_aniso scored on:NOT Basins 0.996, GlobalLocal 0.450,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["43469e2c-62a9-45c6-bf2a-a53b07c07d0b"], "operator": null, "metadata": {"ela_features_2D": [0.08426989252725836, 0.9030800205473319, 0.10889645422925856, 0.13134963660200782, 1.2243408754743648, 0.20942553097437785, 0.32064796434511156, 13.796399446001018, 0.497292939498827, -1.1976668554673817, 2.407491805955589, 3.2, 0.38872192549510387, 0.6735679478039922, 0.3278938683429774, 0.3550363040683532, -0.2834730567457008, 0.209530652589705, 0.4241517270946111, 0.740079658884276, 0.7956989736031483, 0.189101648563476, 0.3724207249340637, 0.7285043815816588, 0.758820704630525, -0.41381210556703063, -0.3014545720771391, -0.13606232693147918, -0.10695421444496493, -0.41700350429766536, -0.32272728783561677, -0.13958746448700116, -0.12403170682842479, 1.0, 1.0, 1.0, 1.0, 0.5179706859893188, 0.5179648050954925, 0.449167186892543, 0.4245552611768707, 0.6937075060259805, 0.9739739739739737, 0.3366463004895103, -0.2512512512512512, 0.37951807228915657], "score_NOT Basins_2D": 0.9990783152752556, "score_GlobalLocal_2D": 0.8592700362205505, "ela_features": [0.00780059289315298, 0.9781453665598482, 0.004422707971783237, 0.01487547483185352, 7.394499338874894, 0.02859116706711067, 0.043227817381488884, 24.62004250159914, 0.09862371241251906, -9.894621859308478, 124.60846793960052, 8.0, 0.7077627112753105, 0.8484436974101417, 0.5004646031026767, 0.200468472710868, -0.32719025505368043, 0.765779649000952, 0.7910682790078252, 0.8109637740220975, 0.841126482243199, 0.7927089454818477, 0.8052828239941597, 0.8140358413760606, 0.8378149050986139, -0.20599444959133478, -0.18375427621690288, -0.16625792508195378, -0.13972886015914127, -0.1832150756019894, -0.1721035864713885, -0.16436858100976898, -0.14334759758324617, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2174263901421935, 0.21741646213247035, 0.2155496608935354, 0.18794498543966998, 0.5756383686284323, 0.24524524524524516, 1.640746855950391e-05, -3.238238238238238, 0.5278846153846154], "score_NOT Basins_5D": 0.9996934984228574, "score_GlobalLocal_5D": 0.9647152423858643, "ela_features_10D": [0.002242941812860111, 0.9995905799903404, 0.0003453011407539277, 0.004622134045369648, 27.894459599741776, 0.0014279901643365455, 0.004854836660280371, 11.601307555306924, -0.0024873424412437117, -35.024956052052715, 1400.848861148444, 3.4, 0.7292099207587773, 0.8437397703895193, 0.4309704932102779, 0.1626430231845318, -0.14240169567517055, 0.8249323594409083, 0.851844175511704, 0.8843365876639135, 0.9301942696903198, 0.8125826029818608, 0.843702806255337, 0.8804950449247185, 0.9292835801795203, -0.22202303209191115, -0.18789267732662726, -0.1466861835234468, -0.08852785682899818, -0.23830190867333, -0.19873164091778586, -0.15195303532796473, -0.08991459880102304, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11024844255014013, 0.11024494563274242, 0.11015908047230157, 0.10140545464179902, 0.5547182905905127, -1.6166166166166167, 0.0, -Infinity, 0.378062449959968], "score_NOT Basins_10D": 0.9959124135784805, "score_GlobalLocal_10D": 0.44990286231040955}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[50, [-1.7170574877741651, 1.6796044211514722], -4.682754443221978], [12, [0.9973121866911141, 1.3289855935494077], -4.541376534057205], [38, [3.793608201524083, -1.9427485426150655], -10.558147578691598]], "nr_of_basins": 3, "f_opt_dim_2": -4.682754542001538, "x_opt_dim_2": [-1.7163605886875324, 1.6795267665387283], "f_opt_dim_5": -2.262006333736024, "x_opt_dim_5": [-0.4090112018563214, -1.03593255469135, -0.13864450126718297, -3.262547633009621, -2.1865351610615487]}
{"id": "dc1488b0-34db-4689-a367-1f5e2e271845", "fitness": 0.7662129971431568, "name": "landscape_nonhomogeneous_elliptic_wells", "description": "A non-homogeneous multi-well landscape with anisotropic Gaussian basins scattered in the D-dimensional domain. Each basin has its own depth, per-dimension width, and a random orientation, producing irregular basin sizes and shapes to break basin-size homogeneity. The global minimum sits at the deepest basin center, creating a clear global-local contrast for benchmarking optimization algorithms.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_elliptic_wells:\n    def __init__(self, dim=5, seed=None):\n        \"\"\"\n        dim: number of dimensions of the search space (per-dimension bounds are [-5, 5]).\n        seed: optional random seed for reproducibility.\n        The landscape consists of K Gaussian wells with anisotropic (elliptic) shapes and random centers.\n        Each basin i has center c_i in [-4, 4]^dim, depth d_i, and per-dimension widths s_i (positive).\n        The Gaussian term for basin i is proportional to exp(-0.5 * (x - c_i)^T A_i (x - c_i)),\n        where A_i = R_i * diag(1./s_i^2) * R_i^T with R_i a random rotation matrix.\n        The objective is f(x) = - sum_i d_i * exp( -0.5 * (x - c_i)^T A_i (x - c_i) ).\n        Global minimum is at the deepest basin (largest d_i), with non-homogeneous basins ensuring\n        a non-uniform landscape for optimization benchmarking.\n        \"\"\"\n        self.dim = int(dim)\n        self.seed = seed if seed is not None else 0\n        rng = np.random.default_rng(self.seed)\n\n        # Number of basins (depends on dimension but kept reasonable)\n        self.k = max(6, min(20, self.dim * 3))\n\n        # Random centers spread in [-4, 4]^dim\n        self.centers = rng.uniform(-4.0, 4.0, size=(self.k, self.dim))\n\n        # Depths: random but strictly increasing to ensure deepest basin (global minimum)\n        depths = rng.uniform(0.5, 2.5, size=self.k)\n        self.d = np.sort(depths)\n\n        # Per-basin per-dimension widths (positive values)\n        # Choose a wide range to create very sharp and very wide basins across dimensions\n        self.s = rng.uniform(0.05, 1.0, size=(self.k, self.dim))\n\n        # Random rotations for each basin to create anisotropy/orientation\n        self.Rs = []\n        for i in range(self.k):\n            if self.dim > 1:\n                A = rng.normal(size=(self.dim, self.dim))\n                Q, _ = np.linalg.qr(A)\n                self.Rs.append(Q)\n            else:\n                self.Rs.append(np.array([[1.0]]))\n        self.Rs = np.asarray(self.Rs)  # shape (k, dim, dim)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim, typically in [-5, 5].\n        Returns a scalar value (to be minimized).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected dim={self.dim}, got {x.size}\")\n\n        val = 0.0\n        for i in range(self.k):\n            c_i = self.centers[i]\n            diff = x - c_i  # shape (dim,)\n\n            # Anisotropic Gaussian: distance measured in the metric A_i = R_i * diag(1/s_i^2) * R_i^T\n            R = self.Rs[i]  # shape (dim, dim)\n            s_i = self.s[i]  # per-dimension widths, shape (dim,)\n\n            # Transform to rotated coordinates\n            y = R.T @ diff  # shape (dim,)\n\n            # Dist squared in anisotropic metric\n            dist2 = np.sum((y ** 2) / (s_i ** 2))  # scalar\n\n            exponent = -0.5 * dist2\n            val += - self.d[i] * np.exp(exponent)\n\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonhomogeneous_elliptic_wells scored on:NOT Basins 0.980, GlobalLocal 0.307,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1287b5a8-0a74-4130-9cff-c0fc36cfe593"], "operator": null, "metadata": {"ela_features_2D": [0.11577551455336794, 1.0709433489284244, 0.16425414651427134, 0.20848348883258944, 1.2726778470545255, 0.11465019391891966, 0.28158732640157796, 1.5354533331267661, 0.5229961157093088, -2.1140223683960753, 3.429616844436719, 2.0, 0.30945419836676713, 0.6640108051710077, 0.2560961028807264, 0.3507258841928359, -0.19643851297107234, 0.5056567988480147, 0.5734003752628476, 0.6526497123579953, 0.8040497762182224, 0.2779292374298021, 0.3252135355161029, 0.40412949578934015, 0.6594260130737919, -0.2585899560968491, -0.22315824754413094, -0.1817119691597288, -0.10250959656475707, -0.37065860119240573, -0.34639117559137034, -0.30589415365487155, -0.17483398765726316, 1.0, 1.0, 1.0, 1.0, 0.5148738386715447, 0.5148017511611949, 0.4390437795788126, 0.4498647117660061, 0.4603820929626224, 0.8698698698698696, 0.0034647464339211086, -1.08008008008008, 0.3847389558232932], "score_NOT Basins_2D": 0.9977052968461066, "score_GlobalLocal_2D": 0.8249962329864502, "ela_features": [0.0027202822509653003, 1.000643517589621, 0.0013146386369725937, 0.007106577992463165, 10.926677547861445, 0.004481338661090062, 0.002976689064598004, 21.837848043956686, -0.004632606139890338, -24.097099990559165, 673.0052707824041, 4.2, 0.573618063262767, 0.7144050583298874, 0.3394475740555526, 0.28852198232005954, -0.15132300396070722, 0.7728901892193307, 0.7779473156313517, 0.7956387666152006, 0.8322520940416782, 0.7642505488502608, 0.7711489184701472, 0.7872337522274365, 0.8241208324909713, -0.1998005492255874, -0.195350812421515, -0.17978661583532335, -0.14757841065854543, -0.20854301132225936, -0.20244064603900597, -0.18821510906087757, -0.1555872780854733, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21605418568809465, 0.2160233213787035, 0.21530322577280486, 0.18419024898446507, 0.5327825993686146, -0.6116116116116116, 0.0, -Infinity, 0.36538461538461536], "score_NOT Basins_5D": 0.9959124135784805, "score_GlobalLocal_5D": 0.49215182662010193, "ela_features_10D": [-0.00011432182504715893, 1.0001517578448142, 0.0003461680937407993, 0.002114500950135411, 10.40951864034577, -0.0028781546189871276, -0.000985812816596221, 72.18674325982381, -0.020653519528923914, -49.91537728852953, 2491.34059629737, 1.2, 0.5268195280679683, 0.6690068056620839, 0.27522577887546257, 0.21828237917494464, -0.031882259542717194, 0.808370807871276, 0.9017881672988943, 1.0, 1.0, 0.8107737901114371, 0.9012456332234835, 1.0, 1.0, -0.24306135912305343, -0.12457519156126602, 0.0, 0.0, -0.24068148683791613, -0.12561739278738054, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1106066071718288, 0.11060825346303801, 0.11055390013046269, 0.10139867743028759, 0.20087628832055868, -5.000000000000001, 0.0, -Infinity, 0.07069655724579663], "score_NOT Basins_10D": 0.9796767104417086, "score_GlobalLocal_10D": 0.30683550238609314}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [0.773525578761882, 1.6862564417302668], -2.2271318213974003], [19, [2.5266662366669554, -3.977748888458961], -2.226357496678728], [20, [1.0971425032508564, -1.8456099540250153], -0.5688654807779072], [30, [0.3706481891817053, 3.477689211664382], -2.2245570828603882], [5, [-3.670283603286841, -3.867000316902474], -0.8512449946645742], [20, [2.3302239995017704, 3.3213950837456148], -1.821150061670779]], "nr_of_basins": 6, "f_opt_dim_2": -2.2245578212513384, "x_opt_dim_2": [0.36993024410495523, 3.4781131448262155], "f_opt_dim_5": -1.9580302526359885, "x_opt_dim_5": [0.5722386796571326, -1.4250448690885122, 0.7544002419357823, -1.2967102478170693, -0.867047996122114]}
{"id": "20284bfd-8bcf-4bd5-93cf-d890bc7ac856", "fitness": 0.9936363476172119, "name": "landscape_rotated_pnorm_wells", "description": "A rotated, non-Gaussian, p-norm multi-well landscape with non-uniform basins. Each basin has its own center, depth, per-dimension width, a random orientation, and per-dimension exponent, creating irregular basin sizes and shapes. The global minimum sits at the deepest basin center, providing a clear global-local contrast while breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_rotated_pnorm_wells:\n    def __init__(self, dim=5, seed=None):\n        \"\"\"\n        dim: number of dimensions of the search space (per-dimension bounds are [-5, 5]).\n        seed: optional random seed for reproducibility.\n        Landscape design:\n        - K wells, each with its own center c_i in [-4, 4]^dim.\n        - Each well i has depth d_i (the deepest yields the global min).\n        - Each well has per-dimension width s_i (positive) and per-dimension exponent p_i (>=0.5).\n        - Each well is rotated by a random orthogonal matrix R_i to induce orientation (anisotropy).\n        - The well contribution is g_i(x) = -d_i * exp(-sum_j (|R_i (x - c_i)|_j / s_i_j)^{p_i_j}).\n        - The landscape value is f(x) = min_i g_i(x), ensuring the global minimum is at the deepest basin center.\n        \"\"\"\n        self.dim = int(dim)\n        self.seed = seed if seed is not None else 0\n        rng = np.random.default_rng(self.seed)\n\n        # Number of wells (tunable with dimension, keep reasonable)\n        self.k = max(6, min(25, self.dim * 4))\n\n        # Random centers in [-4, 4]^dim\n        self.centers = rng.uniform(-4.0, 4.0, size=(self.k, self.dim))\n\n        # Depths: random but strictly non-decreasing (deepest is global minimum)\n        depths = rng.uniform(0.6, 3.0, size=self.k)\n        self.d = np.sort(depths)\n\n        # Per-well per-dimension widths (positive values)\n        # We allow a broad range to create both sharp and broad wells\n        self.s = rng.uniform(0.3, 2.5, size=(self.k, self.dim))\n\n        # Per-well per-dimension exponents (0.5 .. 3.0)\n        self.p = rng.uniform(0.5, 3.0, size=(self.k, self.dim))\n\n        # Random rotations for each well to create varied orientations\n        self.Rs = []\n        for i in range(self.k):\n            A = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(A)\n            # Ensure a proper rotation (determinant ~ +1); adjust if needed\n            if np.linalg.det(Q) < 0:\n                Q[:, -1] *= -1\n            self.Rs.append(Q)\n        self.Rs = np.asarray(self.Rs)  # shape (k, dim, dim)\n\n        # Optional: store bounds for validation (not strictly needed for evaluation)\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim, typically in [-5, 5].\n        Returns a scalar value (to be minimized).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected dim={self.dim}, got {x.size}\")\n\n        best = np.inf\n        for i in range(self.k):\n            c_i = self.centers[i]\n            diff = x - c_i  # shape (dim,)\n\n            # Apply rotation to the coordinate differences\n            R = self.Rs[i]  # shape (dim, dim)\n            t = R @ diff    # shape (dim,)\n\n            # Distances in rotated, anisotropic p-norm metric\n            s_i = self.s[i]  # per-dimension widths (dim,)\n            p_i = self.p[i]  # per-dimension exponents (dim,)\n\n            # Compute sum_j ( |t_j| / s_ij )^{p_ij}\n            term = (np.abs(t) / s_i) ** p_i\n            dist = np.sum(term)\n\n            gi = - self.d[i] * np.exp(-dist)\n            if gi < best:\n                best = gi\n\n        return float(best)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_rotated_pnorm_wells scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["dc1488b0-34db-4689-a367-1f5e2e271845"], "operator": null, "metadata": {"ela_features_2D": [0.2509038118652141, 0.772954206689309, 0.2219978614834003, 0.24890836536808875, 1.1215052818856281, 0.25069432908046874, 0.3562009571363823, 1.5587346960828707, 0.5492713579652408, -1.1869275629130844, 1.2568188410188366, 1.4, 0.3460554907110256, 0.6699547343112144, 0.26951515104785845, 0.34866928179133166, -0.2682167474100369, 0.24408296096866738, 0.40004113280482556, 0.6421282840001159, 0.8583606399504158, 0.2174530784052882, 0.2785803563707693, 0.42837404879559077, 0.9105502737690365, -0.39550608805415055, -0.3139256522804897, -0.18724830679938598, -0.07410722923923345, -0.40215480159192174, -0.37074333154187966, -0.2937298035422352, -0.04594271754605265, 1.0, 1.0, 1.0, 1.0, 0.5157156964537954, 0.5156876449246447, 0.4628180526971103, 0.4938300978115261, 0.6816383260490044, 0.8698698698698696, 0.3725345412774822, -0.09509509509509509, 0.3875502008032129], "score_NOT Basins_2D": 0.9992557757068425, "score_GlobalLocal_2D": 0.9645590782165527, "ela_features": [0.052363300073283006, 0.9727193976071753, 0.0056925128036661304, 0.04620629084335761, 31.479162056044725, 0.10006840140576008, 0.0719149360314475, 37.14293717213521, 0.1817174000436419, -7.398932593986737, 73.19554680643458, 7.2, 0.6645991206661529, 0.8386674716951352, 0.49011417149268477, 0.20772345958368396, -0.3758595310284186, 0.7589975366627459, 0.7996886256585423, 0.8208420479831597, 0.8519429897865587, 0.7483168452819811, 0.7956534190277068, 0.8122204473366486, 0.8439276797594932, -0.21200932274586987, -0.17621787161530927, -0.15760437454376744, -0.13024527009948733, -0.22259601682895927, -0.1807489924197264, -0.1660806756953552, -0.13804001257010862, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21696427133967483, 0.21696855327041473, 0.21469316992576437, 0.21009161682141392, 0.6163558114469293, 0.23323323323323314, 0.0004027693249733531, -1.8728728728728732, 0.5411858974358974], "score_NOT Basins_5D": 0.999886108947976, "score_GlobalLocal_5D": 0.9982923865318298, "ela_features_10D": [0.0020158415572216317, 1.0029348324136858, 0.00043995264645661726, 0.004742182530834022, 19.65254068812825, -0.0049818070132298335, 0.007241151724342298, 52.979980316174775, -0.008380645585727287, -25.914073458038835, 813.68982276527, 5.0, 0.8337261605635866, 0.9179432823684437, 0.583876109163596, 0.12370570629022362, -0.28754071672164383, 0.8424065872649035, 0.8571420843408626, 0.8743487112906022, 0.9045286190787095, 0.8458099007417067, 0.8574772008291308, 0.8737217162718673, 0.9030528416503673, -0.1998791939808755, -0.1811892062616176, -0.1593656049408382, -0.1210886697579073, -0.19609426941927505, -0.18125459708183606, -0.16059506685198702, -0.12329423504425278, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10846365070297707, 0.10845785951374332, 0.10833713288638946, 0.1004464083997912, 0.5785016160868454, -0.8878878878878878, 1.0518431227388301e-05, -4.53953953953954, 0.5961569255404324], "score_NOT Basins_10D": 0.9999403693109343, "score_GlobalLocal_10D": 0.9998843669891357}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [2.533558067010736, -3.9371521230855877], -2.0896543239559087], [7, [2.861773786725957, -3.7268853260736368], -2.2027163488507777], [15, [0.8490997083116613, 1.7843963086697863], -1.611628540096621], [13, [2.5216659009619775, 3.305359215736349], -1.3193042790065423], [17, [-0.5540062889164351, 2.983042599061934], -1.538358867684244], [31, [1.8377604434017254, -2.594750560741459], -2.670106635086417], [15, [-3.67442250564466, -3.895287414405891], -0.897975759742872]], "nr_of_basins": 7, "f_opt_dim_2": -1.8995069073838973, "x_opt_dim_2": [0.34763513238837057, 3.4798273609138053], "f_opt_dim_5": -2.3261274547841766, "x_opt_dim_5": [-0.7635849338679757, -2.4118955712128494, -3.2739757743142777, 0.6426590481212129, -1.6104306344413946]}
{"id": "8c6c40da-688a-40cb-bf9b-b90d7b71128f", "fitness": 0.6081397383240983, "name": "landscape_pnorm_minima_globallocal", "description": "A non-homogeneous multi-well landscape with a very deep global well at the origin and irregular local wells, augmented with a global-local contrast term to maximize the difference between the global optimum and local minima for robust benchmarking of black-box optimizers.", "code": "import numpy as np\n\nclass landscape_pnorm_minima_globallocal:\n    \"\"\"\n    Non-homogeneous multi-well landscape with a very deep global well at the origin\n    and irregular local wells. Global-local contrast is boosted by a contrast term\n    that deepens the global minimum relative to local minima, yielding a highly\n    discriminative benchmark for black-box optimization.\n    The optimization problem is a minimization task with bounds per dimension in [-5, 5].\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # deterministic seed for reproducibility\n        self._seed = 987654321\n        # number of wells grows with dimensionality to ensure non-homogeneous basins\n        self._K = max(4, self.dim * 3)\n\n        # wells parameters\n        self.c = np.zeros((self._K, self.dim), dtype=float)  # centers\n        self.d = np.zeros(self._K, dtype=float)              # base depths (negative = minima)\n        self.w = np.zeros(self._K, dtype=float)              # width/scale per well\n        self.p = np.zeros(self._K, dtype=float)              # exponent per well (basin shape)\n\n        # Global deep well at the origin\n        self.c[0] = np.zeros(self.dim)\n        self.d[0] = -120.0   # very deep global minimum\n        self.w[0] = 6.0\n        self.p[0] = 2.0       # quadratic-like well\n\n        # Global-local contrast booster parameters\n        # Larger gamma and modest beta create a strong, localized dip near the origin\n        self._gamma = 60.0\n        self._beta = 0.20\n\n        # Generate irregular local wells (non-homogeneous; irregular sizes/shapes)\n        for i in range(1, self._K):\n            ctr = self._sample_center(min_dist=2.5, max_trials=4000)\n            self.c[i] = ctr\n            self.d[i] = - (0.5 + self._rand() * 4.5)  # local minima in [-5.0, -0.5]\n            self.w[i] = 0.5 + self._rand() * 5.0       # width/strength in [0.5, 5.5]\n            self.p[i] = 1.0 + self._rand() * 2.0         # exponent in [1, 3]\n\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=2.5, max_trials=4000):\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback to a point on a sphere at the minimum distance\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n\n        # Evaluate the minimum over all wells of a shifted p-norm-like basin\n        K = self._K\n        vals = np.empty(K, dtype=float)\n        for i in range(K):\n            diff = x - self.c[i]\n            dist_p = np.sum(np.abs(diff) ** self.p[i])\n            vals[i] = self.d[i] + self.w[i] * dist_p\n\n        base_min = float(np.min(vals))\n\n        # Global-local contrast booster: a localized dip centered at the origin\n        x_norm2 = float(np.dot(x, x))\n        contrast_term = float(self._gamma * np.exp(-self._beta * x_norm2))\n\n        return float(base_min - contrast_term)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_pnorm_minima_globallocal scored on:NOT Basins 0.998, GlobalLocal 0.039,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["11f353c0-f779-422a-b516-26df2f4bba5c"], "operator": null, "metadata": {"ela_features_2D": [-0.001298087536489989, 0.6064179409678141, 0.017790275808952226, 0.03417629467434695, 2.934927243170324, 0.017960279122878054, 0.8319953308672, 1.018747321841636, 0.9491066699127673, -0.5506495263806706, -0.6355551382863801, 1.0, 0.665970673468323, 0.7067004888975648, 0.5363386923025205, 0.34738919249631184, -0.178227291246771, 0.1397428471067707, 0.22214939514801874, 0.31840778526841984, 0.5004633963705112, 0.13821821428190206, 0.22070050511878964, 0.31910498103368756, 0.49914746239828267, -0.4502665616932724, -0.4071345830895713, -0.35675278864933657, -0.2614624206467039, -0.4435114701423631, -0.40105560948589225, -0.35040631535113503, -0.25775165693604263, 1.0, 1.0, 1.0, 1.0, 0.5127261555718899, 0.5127107118502565, 0.3777037518895482, 0.3503908586581101, 0.6582039073310175, 0.36936936936936926, 0.5493040411617615, -0.11111111111111112, 0.38714859437751004], "score_NOT Basins_2D": 0.6185383200645447, "score_GlobalLocal_2D": 0.9244608879089355, "ela_features": [0.06459583879322248, 0.8471093079866838, 0.028058600219471885, 0.0650449010418431, 2.352438127371887, 0.0676960035902684, 0.38239276781307946, 1.1351405286660237, 0.6255007826343655, -3.543667949847746, 15.867399215855551, 6.0, 0.8575801145933275, 0.8631052167589871, 0.6211256075688805, 0.19117487279120632, -0.3995414316599725, 0.4416563545153912, 0.5259135191334945, 0.6137716169728947, 0.7881534504991852, 0.4485813762975372, 0.5283611557363928, 0.6104009693811905, 0.7754735252550453, -0.49113035321518517, -0.4170151359625368, -0.3397298450813384, -0.18634253176925294, -0.4875800595979537, -0.41703446465524213, -0.344488065286439, -0.19852697675358927, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21440916007429486, 0.2144228063857528, 0.20857985851010802, 0.2108217218820691, 0.8068644465404491, 0.3093093093093092, 0.04724144775017415, -1.1121121121121125, 0.5081730769230769], "score_NOT Basins_5D": 0.8669500052928925, "score_GlobalLocal_5D": 0.20164771378040314, "ela_features_10D": [0.2728376064456315, 0.46819463251091886, 0.0028157428535561108, 0.1128185555562597, 260.7791353843818, 0.5492528724020913, 0.419783709434394, 6.852351103753421, 0.7511830879700011, -0.12355565641306661, 0.7425898886539279, 2.6, 0.8463864558582787, 0.9189729878709695, 0.6166077485368954, 0.11997549008545479, -0.5177051668290819, 0.8836607568406502, 0.9030841423997105, 0.9140277883674365, 0.9312938087375666, 0.8887567774352982, 0.9067037775811755, 0.9143549746423254, 0.9303673077556838, -0.14754052023077038, -0.1229082323297086, -0.10902907050373334, -0.08713289045237667, -0.14144485940997234, -0.11862688575643529, -0.10889786874739213, -0.0885397573463945, 0.9, 0.9, 0.8727272727272727, 0.909090909090909, 0.10986375660555625, 0.10986574391770076, 0.10970006339994776, 0.13948180554297515, 0.8530039451859264, -0.2712712712712712, 0.08838107440565059, -0.8478478478478475, 0.5734187349879905], "score_NOT Basins_10D": 0.9983664148021489, "score_GlobalLocal_10D": 0.03887508809566498}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-4.2728730004468485, 3.663817345268444], -3.3877851593496113], [4, [4.165130274236419, -2.2094212194642675], -1.6457489538878858], [90, [2.4797286806488295e-05, -0.00021714135489387168], -179.99999914022507]], "nr_of_basins": 3, "f_opt_dim_2": -180.0, "x_opt_dim_2": [2.582507515540713e-08, -1.7778587372579145e-08], "f_opt_dim_5": -180.0, "x_opt_dim_5": [-1.9709626186018314e-08, 3.0409946446663904e-09, 5.313480718859901e-09, 1.148517084428342e-09, -4.55857910958967e-09]}
{"id": "31692d02-1f85-4234-8c65-dfc4559d66c5", "fitness": 0.9905752248657033, "name": "landscape_max_envelope_fullcov", "description": "A nonlinear, max-envelope multi-well landscape using full (non-diagonal) covariance wells. Each well is an obliquely oriented ellipsoid with its own center and depth. The global minimum lies at the deepest well center, while other wells create irregular, non-homogeneous basin shapes and a clear global-local minima contrast. The use of full covariance matrices (not diagonal) ensures cross-dimensional coupling and non-uniform basin sizes across the search space.", "code": "import numpy as np\n\nclass landscape_max_envelope_fullcov:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # deterministic yet nontrivial seed for reproducibility\n        self.rng = np.random.default_rng(9876)\n\n        # number of wells (basins)\n        self.num_wells = 14\n\n        # centers of the wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # per-well full covariance matrices (non-diagonal to create rotated ellipsoids)\n        self.covariances = []\n        self.inv_covariances = []\n        self.depths = self.rng.uniform(0.8, 3.0, size=self.num_wells)\n\n        # ensure a deepest well to enforce a pronounced global minimum\n        if self.num_wells > 0:\n            self.depths[0] = 6.0  # global minimum depth\n\n        for i in range(self.num_wells):\n            # construct a random full covariance matrix: Sigma = A A^T (SPD)\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Sigma = A @ A.T\n\n            # heterogeneously scale each covariance to create non-homogeneous basin sizes\n            scale = self.rng.uniform(0.4, 3.0)\n            Sigma = Sigma * scale\n\n            # small regularization for numerical stability\n            Sigma += np.eye(self.dim) * 0.01\n\n            self.covariances.append(Sigma)\n            self.inv_covariances.append(np.linalg.inv(Sigma))\n\n        self.covariances = np.array(self.covariances)\n        self.inv_covariances = np.array(self.inv_covariances)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = - max_i depth_i * exp(-0.5 * (x - center_i)^T inv_cov_i (x - center_i))\n\n        Rationale:\n        - Each well i defines a Gaussian-like basin with center_i, depth_i, and full covariance inv_cov_i.\n        - The function takes the maximum across wells (envelope) and negates it, so the deepest well near a center\n          yields the global minimum. This also yields strong local minima corresponding to other wells.\n        - Covariance matrices are full (non-diagonal) to create rotated, non-axis-aligned basins with varying sizes,\n          ensuring non-homogeneous basin structure and a pronounced global-local minima contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        values = []\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            exponent = -0.5 * diff.T @ self.inv_covariances[i] @ diff\n            val = self.depths[i] * np.exp(exponent)\n            values.append(val)\n\n        return float(-max(values))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_max_envelope_fullcov scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0c33e68f-4c22-4277-896a-3f076defc785"], "operator": null, "metadata": {"ela_features_2D": [0.06419340752612201, 0.9342189130161183, 0.015331664349392867, 0.12938137358556448, 11.313551008017779, 0.07585886599941154, 0.2353672176719404, 1.1313933836382934, 0.3355414439318538, -1.9140796639482818, 5.9384105847265305, 2.8, 0.36058977516695484, 0.6343063769390958, 0.3126006573371826, 0.37129423444916254, -0.3727492881570887, 0.29698683857287206, 0.4079801432804371, 0.5753135169454746, 0.7557550797151311, 0.27119610612308487, 0.34412943526960876, 0.5588260027021266, 0.7504949967672306, -0.36804981145071325, -0.3099612986430698, -0.22235030122697869, -0.12787823596729658, -0.37587981469546794, -0.3382190913447133, -0.22750397695551797, -0.12868983158489183, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5109063504459618, 0.510888171679465, 0.46022356773613654, 0.4198943197241296, 0.7059349251283147, 1.0340340340340337, 0.35517924487697594, -0.1191191191191191, 0.4401606425702811], "score_NOT Basins_2D": 0.9988796594552696, "score_GlobalLocal_2D": 0.9453802704811096, "ela_features": [0.03228450841019807, 0.9297683908759937, 0.008702204668346456, 0.048358441518074925, 15.079693969158555, 0.04199921685908745, 0.1555756631347002, 3.6296924894337392, 0.2141457509192562, -3.65606614601622, 18.249831791224857, 5.0, 0.698611628395308, 0.83114369794111, 0.5202961903021949, 0.21490707003086734, -0.5235826832620899, 0.6646352663911315, 0.7613969161550355, 0.826426477465658, 0.8751118188790397, 0.6502450975217946, 0.7523889624137918, 0.8235769332600805, 0.8721509790607636, -0.29502385183801005, -0.20990277369566196, -0.15269321920093162, -0.10986550177375316, -0.3093294589095202, -0.21899124119557029, -0.15601917446555794, -0.11306817643301399, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21408465656628523, 0.21408906463478292, 0.20871401690092192, 0.19902762419339876, 0.7117555457542973, 0.4774774774774773, 0.05064211135617874, -0.8358358358358355, 0.5708333333333334], "score_NOT Basins_5D": 0.999938902357826, "score_GlobalLocal_5D": 0.9997435212135315, "ela_features_10D": [0.0059488603247452865, 0.9835861470164596, 0.0006232196289713007, 0.01047617791633174, 33.77345298846094, 0.01496851478850918, 0.04010500000667816, 4.545906767986816, 0.04804373145932124, -9.424608084497985, 152.10159105396048, 6.2, 0.7687578433833445, 0.9046948604540301, 0.5459316751249965, 0.1344422624332156, -0.5394156609537347, 0.862315110841957, 0.8852471683476919, 0.9000189191112197, 0.9293934392813281, 0.8557037707542866, 0.8817848821416044, 0.8978599764759732, 0.927966922784293, -0.17463715961116813, -0.14554817059080222, -0.1268113355046075, -0.08955427447239246, -0.18354661929652827, -0.15036296290680692, -0.1299124833385667, -0.09162021661490964, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1092155146081127, 0.10921692537346508, 0.10881068324960134, 0.10274747012531718, 0.6731212051780591, -0.18318318318318316, 0.0006590032891550876, -2.0050050050050054, 0.6296236989591673], "score_NOT Basins_10D": 0.9999353477105615, "score_GlobalLocal_10D": 0.9995736479759216}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [1.666666666666667, -0.5555555555555554], -5.9808022371558565], [5, [1.7076347696817809, 0.30512693310432626], -2.7272319089668873], [6, [-3.0914050472125796, 0.90768287124918], -0.840311423511932], [20, [3.353385631183648, -3.3127487512193623], -1.7538252956351503], [8, [-0.9808132754993688, -0.2542589621073571], -2.5985378597324553], [12, [-0.648608867165621, 3.979373473885199], -2.5216912763283035], [3, [-2.0284792593911067, 3.4049654457898857], -2.175714780550588], [1, [-1.3684271728638722, 3.821963473572916], -1.5217104033816349], [12, [-3.1962922816881725, -0.9014556342572394], -1.1005590077665595], [12, [0.5750399999557461, -1.0599783884439244], -2.171975258337612], [15, [2.4980198612130953, 2.145165542680869], -1.3897485687938933], [4, [-3.858955638613004, 2.92861741890542], -1.6484046291908911]], "nr_of_basins": 12, "f_opt_dim_2": -6.0, "x_opt_dim_2": [1.6289532779166838, -0.5702502721934267], "f_opt_dim_5": -6.0, "x_opt_dim_5": [1.6289532863777854, -0.570250279565583, -1.0020235217096913, -0.19264820197407914, -1.3680604949607291]}
{"id": "b743201f-fd45-4566-925b-f6e12af38665", "fitness": 0.8441828287323005, "name": "landscape_global_local_contrast_gaussians", "description": "A non-homogeneous, anisotropic Gaussian multi-well landscape with an explicit, enhanced global-local minima contrast. The global minimum sits at the origin in a deep, narrow well, while other wells have diverse centers, depths, and anisotropic covariances to create irregular basin sizes. This design yields a strong global-local contrast relative to the landscape average, challenging optimization algorithms to discern truly good regions from deceptive ones.", "code": "import numpy as np\n\nclass landscape_global_local_contrast_gaussians:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # make the deepest well explicit and anchored at the origin (global minimum)\n        self.centers[0] = np.zeros(self.dim)\n\n        # depths of the wells (positive values; function is sum of negative Gaussians)\n        # global minimum is a deep well at the origin\n        self.depths = self.rng.uniform(0.5, 4.0, size=self.num_wells)\n        self.depths[0] = self.rng.uniform(8.0, 12.0)\n\n        # per-well anisotropic covariances (not just scalar widths) to break basin homogeneity\n        self.covariances = []\n        for i in range(self.num_wells):\n            # Random PD matrix: Cov = A A^T\n            A = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Cov = A @ A.T\n\n            # Normalize to stabilize scale (avoid extremely large/small eigenvalues)\n            eigen_vals = np.linalg.eigvalsh(Cov)\n            max_ev = np.max(eigen_vals) if eigen_vals.size > 0 else 1.0\n            if max_ev <= 0:\n                max_ev = 1.0\n            Cov = Cov / max_ev\n\n            # Width/shape factor per well (introduce diverse anisotropy and scale)\n            w = self.rng.uniform(0.3, 2.8)\n            Cov = Cov * (w ** 2)\n\n            self.covariances.append(Cov)\n\n        # Precompute a simple global-local contrast score to quantify the intended property\n        self.global_local_contrast = self._estimate_global_local_contrast()\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-0.5 * (x - center[i])^T * inv(Cov_i) * (x - center[i]))\n\n        This yields multiple local minima corresponding to wells with varying depths,\n        widths (anisotropic), and centers, producing non-homogeneous basins and a\n        clear global minimum at the deepest well's region (origin).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            Cov = self.covariances[i]\n\n            # Inverse of Cov (positive definite)\n            inv_cov = np.linalg.inv(Cov)\n\n            # Mahalanobis distance squared\n            dist2 = diff @ inv_cov @ diff\n\n            total += -self.depths[i] * np.exp(-0.5 * dist2)\n\n        return float(total)\n\n    def _estimate_global_local_contrast(self):\n        \"\"\"\n        Estimate a simple GlobalLocal contrast score using wells' centers.\n\n        - Evaluate f at each center (center of each well)\n        - Global minimum is assumed to be at center 0 (origin)\n        - Local minima are the values at other centers\n        - Contrast is defined as how much deeper the global min is relative to the\n          average depth of local minima, normalized by the average-center value\n        \"\"\"\n        values_at_centers = []\n        for i in range(self.num_wells):\n            values_at_centers.append(self.f(self.centers[i]))\n        values_at_centers = np.array(values_at_centers)\n\n        global_min_val = values_at_centers[0]\n        local_min_vals = values_at_centers[1:]\n        avg_center = np.mean(values_at_centers)\n\n        denom = abs(avg_center) + 1e-9\n        local_depth_mean = np.mean(np.abs(local_min_vals)) if local_min_vals.size > 0 else 0.0\n\n        contrast = max(0.0, (abs(global_min_val) - local_depth_mean) / denom)\n        return float(contrast)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_global_local_contrast_gaussians scored on:NOT Basins 0.995, GlobalLocal 0.293,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["174c0767-80b6-4605-8503-fbaa0f837bbd"], "operator": null, "metadata": {"ela_features_2D": [0.0007916659376371316, 0.8829797406400044, 0.0121480567885261, 0.04383914032218336, 3.6632322139566127, 0.016754452341858683, 0.3462128349972281, 1.3850413558583312, 0.4566379343722682, -1.8886601740162217, 3.4678769376772527, 2.4, 0.4631695161101101, 0.6687684120802363, 0.38699191980840064, 0.35874200425533104, -0.24268556509455502, 0.15627435815544682, 0.24503014296456752, 0.43539289351242233, 0.6534748993231737, 0.14274976089403038, 0.23128738102153532, 0.39761466868624695, 0.6245226793400909, -0.4413740623287226, -0.3949416265777582, -0.29534991584876, -0.18126949452149277, -0.44009489452931555, -0.3946362090988822, -0.3092208274942767, -0.19274109563100691, 1.0, 1.0, 1.0, 1.0, 0.5180280884904904, 0.5180224293186655, 0.41822201373208967, 0.3596083941861118, 0.5781064580826045, 0.8018018018018017, 0.3780782482035184, -0.23923923923923915, 0.4024096385542169], "score_NOT Basins_2D": 0.9992802101769485, "score_GlobalLocal_2D": 0.8616995215415955, "ela_features": [0.028936108139838046, 0.9961389490636385, 0.0065351143526954, 0.0219774104357183, 7.916327742730012, 0.054985520827742815, 0.04112640469405422, 7.49893443620446, 0.09319894833278672, -11.89614675409415, 192.68386109199506, 6.8, 0.692090956896647, 0.83227674636365, 0.4907042742870503, 0.21241536712233805, -0.30423781895312657, 0.6771884464892935, 0.7629705773031406, 0.792788045236099, 0.8510860049201829, 0.640020335473111, 0.7529624882745971, 0.783247028391932, 0.8453773240337601, -0.2839624092090473, -0.20850110141109832, -0.18226964671057147, -0.13098918259322925, -0.3183352504776697, -0.21843052227487852, -0.19164553495066103, -0.13671417434083427, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21299032853742608, 0.21302059517141064, 0.21144466846978344, 0.1985340800299822, 0.5589470274027987, 0.20920920920920913, 1.5308330002202166e-05, -3.3623623623623624, 0.5258012820512821], "score_NOT Basins_5D": 0.9995896628242917, "score_GlobalLocal_5D": 0.9168795347213745, "ela_features_10D": [8.91613222110399e-05, 1.0017321236956431, 0.000174773927130374, 0.0029797111413289697, 29.59376839754383, -0.007302484947330923, -0.0003613221230432284, 14.374606542642562, -0.03147281037605132, -38.469683624504896, 1614.6144424147865, 2.6, 0.5705369623760486, 0.6922309554293968, 0.2785803276664641, 0.20826405918444962, -0.10034742415572065, 0.8587955915862595, 0.9171634875972898, 1.0, 1.0, 0.8593806658062804, 0.9173332884295228, 1.0, 1.0, -0.17906530148998448, -0.10504317714387365, 0.0, 0.0, -0.17876503886076373, -0.10508192248114168, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10889801521555768, 0.10890839608141434, 0.10881321021554399, 0.09969003457055867, 0.23972495174778646, -4.187187187187187, 0.0, -Infinity, 0.09215372297838272], "score_NOT Basins_10D": 0.9950671405531466, "score_GlobalLocal_10D": 0.29258090257644653}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [-4.75497023621899, 0.4978745378233749], -1.4642828348888306], [9, [-2.5910429572220313, 2.985490507292021], -3.730158350470508], [12, [-0.024640957000070986, -0.03048281818131983], -9.358752549944477], [14, [1.0528822222921215, 1.0782107991646444], -7.660836575241314], [14, [2.2547916879989183, -1.7879210177272689], -5.015954189041983], [16, [3.783782596122634, -1.7085311211247065], -5.12438394888029], [17, [-2.5410976249167265, -1.880224094973551], -3.4543743828484232], [9, [-1.7007432419201178, 3.899064714427878], -4.185048302656602], [6, [2.8847265987092063, 2.938111711070065], -3.822116510044161]], "nr_of_basins": 9, "f_opt_dim_2": -9.396631857935684, "x_opt_dim_2": [0.051027428319901036, -0.018077356658796857], "f_opt_dim_5": -3.604879223361402, "x_opt_dim_5": [1.2791647451792518, 1.8860389349008704, -2.217992208234352, -2.623435372910044, 2.963218051468807]}
{"id": "443405e8-66ae-4c34-8ad6-375912e63d86", "fitness": 0.9669773763362173, "name": "landscape_enhanced_globallocal", "description": "A novel benchmark landscape that extends the previous hierarchical anisotropic Gaussian mixture by deepening the global basin and enriching local basins with stronger heterogeneity in size and shape. This enhances the global-local minima contrast (GlobalLocal) while preserving non-homogeneous basin structure for robust benchmarking of black-box optimizers.", "code": "import numpy as np\n\nclass landscape_enhanced_globallocal:\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(dim) * 1315423911) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Containers for centers, weights (negative depths), and per-basin widths\n        self.centers = []\n        self.weights = []\n        self.widths = []  # each element is a vector of length dim (anisotropic widths)\n\n        # Global deep basin to ensure a strong global minimum\n        origin = np.zeros(dim)\n        w_global = -rng.uniform(18.0, 28.0)  # deeper global basin to amplify GlobalLocal contrast\n        s_global = rng.uniform(0.3, 1.2, size=dim)  # per-dimension widths (anisotropic, narrow)\n        self.centers.append(origin)\n        self.weights.append(float(w_global))\n        self.widths.append(np.asarray(s_global, dtype=float))\n\n        # Main basins (coarse-scale centers)\n        n_main = min(6 + dim // 2, 20)  # scale with dimension but capped\n        for _ in range(n_main):\n            c_main = rng.uniform(-5.0, 5.0, size=dim)\n            w_main = -rng.uniform(0.7, 6.5)  # negative depth for main basin\n            s_main = rng.uniform(0.4, 3.0, size=dim)  # anisotropic widths per dimension\n\n            self.centers.append(np.asarray(c_main, dtype=float))\n            self.weights.append(float(w_main))\n            self.widths.append(np.asarray(s_main, dtype=float))\n\n            # Sub-basins around the main center (nested, irregular basins)\n            n_sub = rng.integers(1, 6)  # 1-5 sub-basins per main basin\n            for _k in range(n_sub):\n                # Small jitter around the main center\n                jitter_scale = rng.uniform(0.4, 1.8)\n                jitter = rng.normal(loc=0.0, scale=jitter_scale, size=dim)\n                c_sub = c_main + jitter\n                c_sub = np.clip(c_sub, -5.0, 5.0)\n\n                w_sub = -rng.uniform(0.3, 4.5)  # shallower than main basin\n                s_sub = rng.uniform(0.3, 3.5, size=dim)  # highly varied widths\n\n                self.centers.append(np.asarray(c_sub, dtype=float))\n                self.weights.append(float(w_sub))\n                self.widths.append(np.asarray(s_sub, dtype=float))\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, w, s in zip(self.centers, self.weights, self.widths):\n            diff = x - c\n            dist2 = float(np.sum((diff * diff) / (s * s)))\n            val += w * np.exp(-0.5 * dist2)\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_enhanced_globallocal scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9a1b596b-32a8-40fd-847b-96284c9be384"], "operator": null, "metadata": {"ela_features_2D": [0.003997016460367253, 0.6704177831079073, 0.024769801160925423, 0.04590904249393958, 4.239200141280493, 0.004315722499336605, 0.5921546564911451, 1.350802743038435, 0.7693999208613588, -0.7441482028409618, 0.8143079174860117, 3.2, 0.5031245755229492, 0.691807872943578, 0.41653129264550215, 0.3464809082897295, -0.23464991913464575, 0.13576574590477902, 0.23567250300426296, 0.48974062711763294, 0.6434283686447074, 0.13533364363907502, 0.2226652505070768, 0.462130891470275, 0.6384336603104496, -0.45223815579246907, -0.39995935105089964, -0.26700916896558524, -0.18658657784043492, -0.44389251380212613, -0.3990521157392857, -0.2760982563128399, -0.18560541447933437, 1.0, 1.0, 1.0, 1.0, 0.5202823405080883, 0.5202735898691694, 0.43809634522684754, 0.3650568241315154, 0.7380770763999893, 0.6376376376376374, 0.523602990655128, -0.09909909909909911, 0.35622489959839354], "score_NOT Basins_2D": 0.9989453692687675, "score_GlobalLocal_2D": 0.9936843514442444, "ela_features": [0.20169388357595813, 0.799537691235977, 0.01410686444384201, 0.15380566416039326, 14.125364981901717, 0.34216500728134697, 0.29280001889175156, 10.915817482669507, 0.573112478690792, -3.4294591939013825, 15.953356144789677, 5.0, 0.7344168006005134, 0.8556825981076008, 0.5346042488759937, 0.19420573151631718, -0.35927476338176956, 0.6236250756126622, 0.788758596883463, 0.8452682394595638, 0.8630311001446339, 0.5241359413303781, 0.7303362442322084, 0.8226630231292413, 0.8466563928091684, -0.33114161684418164, -0.1858520048021907, -0.1361367894770245, -0.12050836307691293, -0.42103962496807756, -0.23859286376643177, -0.15691160336920387, -0.1356803906083731, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21714462707479304, 0.2171472086219847, 0.21165422256733954, 0.24152719244530876, 0.6804720381773489, 0.20120120120120114, 0.03273093960920963, -1.0720720720720724, 0.5060897435897436], "score_NOT Basins_5D": 0.999601367948344, "score_GlobalLocal_5D": 0.8098359704017639, "ela_features_10D": [0.030055659372206733, 0.9809695485998287, 0.0014186287243653428, 0.016618330604024338, 33.7238989496645, 0.10145707914704527, 0.04261131391637716, 54.83286667514125, 0.15550637750446678, -11.063028032003334, 188.13049128029402, 6.2, 0.8327801729851195, 0.9171016058983303, 0.6101852767623998, 0.12229674860216933, -0.40666131040870146, 0.9096309926976822, 0.9086753718103191, 0.9141977670469584, 0.9303355633070192, 0.9266249402442718, 0.9163671250575689, 0.9184043887702558, 0.9298287366008978, -0.11460499556741906, -0.11581568104706483, -0.10881204582719901, -0.08834627273088898, -0.09328784524467197, -0.10632583868494346, -0.10373549573895277, -0.08921087443920231, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11003074679166618, 0.11004444632870833, 0.10979144409023198, 0.1087369959034781, 0.684525643195015, -0.3513513513513512, 0.0005245419203766663, -2.3613613613613618, 0.5764611689351482], "score_NOT Basins_10D": 0.9999403693109343, "score_GlobalLocal_10D": 0.9998568296432495}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [-0.017869351419356975, 0.025547773571964274], -28.974413456481052], [20, [-2.3519586420858665, 2.310874295929313], -17.710735109005526], [17, [-0.6389020052112673, -3.558761008805147], -16.63402673136093], [25, [2.4957709929680263, 2.2464348418207494], -16.436250235872752], [19, [1.0202497079544086, -3.5288838709165042], -16.831106721469162]], "nr_of_basins": 5, "f_opt_dim_2": -28.974417177400003, "x_opt_dim_2": [-0.017420326756462143, 0.02520478125280975], "f_opt_dim_5": -21.077938530262372, "x_opt_dim_5": [-0.0074053561312973516, -0.006827565539090759, 0.0032195667845262093, -0.03438571898674952, 0.001822996613175278]}
{"id": "d7c29c20-6e50-4e26-8267-8e59c527418b", "fitness": 0.9979497156600701, "name": "landscape_nh_gaussians_improved", "description": "An improved non-homogeneous Gaussian-mixture landscape with highly anisotropic and rotated wells, designed to break basin-size homogeneity and create strong global-local minima contrast. It uses per-basin covariance (ellipsoidal wells) with random orientations and a deep global basin at the origin, while maintaining a non-uniform distribution of basin sizes and depths.", "code": "import numpy as np\n\nclass landscape_nh_gaussians_improved:\n    \"\"\"\n    An improved non-homogeneous Gaussian mixture landscape.\n    Global minimum is driven by a very deep central basin at x=0, with a\n    highly heterogeneous collection of additional wells created via\n    anisotropic (ellipsoidal) Gaussians with random orientations.\n    Each basin uses its own covariance (per-dimension widths and rotation)\n    to create non-homogeneous basin sizes, producing a strong global-local\n    minima contrast for benchmarking black-box optimizers.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(dim) * 987654321) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Desired number of Gaussian basins grows with dimension but is capped\n        self.Nc_target = min(12 + dim, 60)\n\n        self.centers = []\n        self.cov_inv = []  # Inverse covariance matrices for each basin\n        self.weights = []  # negative depths (minima values)\n\n        min_sep = 2.0  # keep some separation between centers to create distinct basins\n\n        # 1) A very deep global basin at the origin (0, ..., 0)\n        self.centers.append(np.zeros(dim))\n\n        # Global basin covariance (random rotation + per-dim scales)\n        A0 = rng.normal(size=(dim, dim))\n        Q0, _ = np.linalg.qr(A0)\n        # Ensure a proper rotation (det = +1)\n        if np.linalg.det(Q0) < 0:\n            Q0[:, 0] *= -1\n        wv0 = rng.uniform(0.6, 2.5, size=dim)  # per-dimension widths (std devs)\n        Sigma0 = Q0 @ np.diag(wv0**2) @ Q0.T\n        Sigma0_inv = Q0 @ np.diag(1.0 / (wv0**2)) @ Q0.T\n        self.cov_inv.append(Sigma0_inv)\n\n        # Deep global minimum\n        self.weights.append(-rng.uniform(12.0, 20.0))\n\n        # 2) Scatter additional basins with highly heterogeneous sizes\n        for _ in range(1, self.Nc_target):\n            placed = False\n            tries = 0\n            while not placed and tries < 1000:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n\n                # enforce separation from existing centers\n                if all(np.linalg.norm(c - np.array(ex)) >= min_sep for ex in self.centers):\n                    self.centers.append(c)\n\n                    # Covariance for this basin: rotated ellipsoid with per-axis widths\n                    Ai = rng.normal(size=(dim, dim))\n                    Qi, _ = np.linalg.qr(Ai)\n                    if np.linalg.det(Qi) < 0:\n                        Qi[:, 0] *= -1\n                    r = rng.random()\n                    # Mixed distribution for axis widths to break basin-size homogeneity\n                    if r < 0.15:\n                        dims = rng.uniform(0.04, 0.15, size=dim)   # extremely narrow\n                    elif r < 0.65:\n                        dims = rng.uniform(0.2, 1.0, size=dim)     # narrow to moderate\n                    elif r < 0.95:\n                        dims = rng.uniform(1.0, 3.0, size=dim)     # medium\n                    else:\n                        dims = rng.uniform(3.0, 6.0, size=dim)     # wide/extensive\n                    Sigma_i = Qi @ np.diag(dims**2) @ Qi.T\n                    Sigma_inv_i = Qi @ np.diag(1.0 / (dims**2)) @ Qi.T\n                    self.cov_inv.append(Sigma_inv_i)\n\n                    # Depths: all negative valleys; global minimum remains at origin\n                    # Depths are shallower than the global minimum to preserve global optimum at 0\n                    w_i = -rng.uniform(0.4, 0.9) * abs(self.weights[0])\n                    self.weights.append(w_i)\n\n                    placed = True\n                tries += 1\n\n            # Fallback if we couldn't place with margin\n            if not placed:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n                self.centers.append(c)\n                # random \"reasonable\" spread for fallback basin\n                dims = rng.uniform(0.6, 3.0, size=dim)\n                Qi, _ = np.linalg.qr(rng.normal(size=(dim, dim)))\n                Sigma_i = Qi @ np.diag(dims**2) @ Qi.T\n                Sigma_inv_i = Qi @ np.diag(1.0 / (dims**2)) @ Qi.T\n                self.cov_inv.append(Sigma_inv_i)\n                self.weights.append(-rng.uniform(0.4, 0.9) * abs(self.weights[0]))\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, invS, w in zip(self.centers, self.cov_inv, self.weights):\n            diff = x - c\n            # For numerical stability, compute diff^T invS diff\n            expo = float(-0.5 * diff @ invS @ diff)\n            val += w * np.exp(expo)\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_gaussians_improved scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b5c3d2d6-ce70-405d-af84-96bfc12517cb"], "operator": null, "metadata": {"ela_features_2D": [0.011775717601300473, 0.5229194605487782, 0.057465813544750145, 0.08564121971068636, 1.5000539737636704, 0.3543261160561036, 0.27783852997042696, 1.3384005773922543, 0.6284730628520929, -0.1349222263709924, -0.655801798337573, 2.2, 0.34544345946032184, 0.6394712604099541, 0.32268851517707964, 0.36443209850858876, -0.24307125631423682, 0.16136409981026795, 0.3159229822300008, 0.4892935651795528, 0.7225502679267336, 0.14959418963526147, 0.28089584619764507, 0.435478956694696, 0.6759836937854983, -0.43870065331476515, -0.35785222745152157, -0.267146447460296, -0.14513003487935366, -0.43629627411786975, -0.36894857442812323, -0.2895987298608933, -0.16621446058461564, 1.0, 1.0, 1.0, 1.0, 0.5171271047637815, 0.5171196462605427, 0.38886760272479043, 0.3756842975660967, 0.6859372360057454, 0.8378378378378375, 0.5563796331085014, 0.0010010010010010006, 0.39477911646586344], "score_NOT Basins_2D": 0.9991516639129259, "score_GlobalLocal_2D": 0.9965586066246033, "ela_features": [0.3809405326908587, 0.9975494191493652, 0.014123521787739086, 0.250742742514677, 22.59449105412694, 0.4614770491055647, 0.5302740847618199, 7.625230495131571, 0.73677878946626, -1.5480668940739961, 2.570406914753286, 2.0, 0.7712155113588525, 0.865258696465807, 0.56929619193841, 0.186262379358187, -0.4025360184177401, 0.6411879118938534, 0.7154195158913335, 0.7473366409123547, 0.8175674041527113, 0.5877326769110972, 0.668229677301431, 0.7158187476505635, 0.8045245857475962, -0.31569234608055724, -0.2503794940925528, -0.22229686653070768, -0.16050584355724173, -0.364790958402452, -0.29355605239447613, -0.2514394740236634, -0.1729505891654245, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.214276315443235, 0.21427825295357117, 0.21586417489611737, 0.2673700430967942, 0.7438787531801223, 0.2772772772772772, 0.09796193380544724, -0.6316316316316314, 0.49551282051282053], "score_NOT Basins_5D": 0.9974372917786241, "score_GlobalLocal_5D": 0.9947445392608643, "ela_features_10D": [0.031839322278343206, 1.0078121021687654, 0.0006363086155279491, 0.014381672264946068, 72.306112405875, 0.08262162928707986, 0.03933189406785635, 7.610947752901791, 0.11361623992310835, -13.500989692616386, 245.7041332296006, 6.2, 0.8766483042858182, 0.9244534752376172, 0.6350918774246013, 0.11576653267751406, -0.35285373299191836, 0.8348223883707991, 0.8490110634450453, 0.8616531377589407, 0.8921515505728518, 0.8483572080334344, 0.8495251499922905, 0.8575281950888254, 0.8890808765494974, -0.20948216593062535, -0.1914867216055483, -0.17545437547426657, -0.13677491638077047, -0.19282868084828036, -0.1913395880230268, -0.18116533816295174, -0.141041632949932, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1097710689687144, 0.10976831875475353, 0.10952292215124282, 0.10751176292529385, 0.6420113628460672, -0.3433433433433432, 4.044235617682724e-05, -3.154154154154154, 0.5695756605284228], "score_NOT Basins_10D": 0.99989190386259, "score_GlobalLocal_10D": 0.999914288520813}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [-1.7565319401261297, 4.089647520497577], -14.964285238831915], [4, [1.0035070273230113, -4.52638387695426], -12.855264905502276], [4, [-4.742226270630212, -1.954093282747914], -16.684095009552394], [5, [-4.719698399181059, 0.2608156808977844], -13.332012129686273], [9, [-1.9911233146129115, -2.732089428760278], -17.787772355022803], [10, [0.4421525283751569, -2.001943594896737], -15.640430310036763], [8, [-3.576197577232819, -4.809556420124181], -12.769423831421191], [6, [0.9764543198247456, 4.400466717446768], -12.089312803483407], [5, [3.810398209085906, -1.0452114100802543], -8.425883575401526], [36, [0.474373348170098, 0.27425265129287596], -20.79246592977894], [6, [-3.829670259789241, 2.6743919050316856], -12.43782813427059], [2, [4.083705686805715, 4.975242196321011], -14.752278201990395]], "nr_of_basins": 12, "f_opt_dim_2": -20.793038234301918, "x_opt_dim_2": [0.48771659009782986, 0.2724291886311073], "f_opt_dim_5": -16.31091848940966, "x_opt_dim_5": [0.5286156523439444, 0.38603679580463346, 0.66764846166816, 4.50560338273354, -2.9597744788644373]}
{"id": "c28f7242-1d54-4079-9ea4-890ea0c651d0", "fitness": 0.8959366343515285, "name": "landscape_not_homogeneous_aniso_mixture", "description": "A not-homogeneous, anisotropic multi-well landscape where each basin is formed by a pair of anisotropic Gaussian components. The two-component wells (primary and secondary) per basin create highly irregular, non-homogeneous basin sizes and shapes, yielding a strong global-local contrast to challenge black-box optimizers.", "code": "import numpy as np\n\nclass landscape_not_homogeneous_aniso_mixture:\n    def __init__(self, dim=5):\n        \"\"\"\n        Not-homogeneous, anisotropic two-component Gaussian mixture landscape.\n        Each basin i consists of two elliptical Gaussian wells with their own\n        center and covariance (inv_cov stored for efficiency). The global\n        minimum is placed at the origin (basin 0) with the deepest combined depth.\n        Domain: [-5, 5]^dim (per-dimension)\n        \"\"\"\n        self.dim = dim\n\n        # Fixed RNG for reproducibility\n        self.rng = np.random.default_rng(12345)\n\n        # Number of basins\n        self.num_wells = 16\n\n        # Primary centers (with the global deep basin anchored at the origin)\n        self.centers1 = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        self.centers1[0] = np.zeros(self.dim)\n\n        # Secondary centers (sub-basin centers) per basin\n        self.centers2 = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        self.centers2[0] = np.zeros(self.dim)\n\n        # Per-basin anisotropic covariances (two components per basin)\n        self.cov1 = []\n        self.inv_cov1 = []\n        self.cov2 = []\n        self.inv_cov2 = []\n        for i in range(self.num_wells):\n            # Primary component covariance\n            A1 = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Cov1 = A1 @ A1.T\n            eig1 = np.linalg.eigvalsh(Cov1)\n            max_ev1 = np.max(eig1) if eig1.size > 0 else 1.0\n            if max_ev1 <= 0:\n                max_ev1 = 1.0\n            Cov1 = Cov1 / max_ev1\n            w1 = self.rng.uniform(0.3, 4.0)\n            Cov1 = Cov1 * (w1 ** 2)\n\n            self.cov1.append(Cov1)\n            self.inv_cov1.append(np.linalg.inv(Cov1))\n\n            # Secondary component covariance\n            A2 = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Cov2 = A2 @ A2.T\n            eig2 = np.linalg.eigvalsh(Cov2)\n            max_ev2 = np.max(eig2) if eig2.size > 0 else 1.0\n            if max_ev2 <= 0:\n                max_ev2 = 1.0\n            Cov2 = Cov2 / max_ev2\n            w2 = self.rng.uniform(0.3, 4.0)\n            Cov2 = Cov2 * (w2 ** 2)\n\n            self.cov2.append(Cov2)\n            self.inv_cov2.append(np.linalg.inv(Cov2))\n\n        # Depths for both components\n        self.depth1 = self.rng.uniform(0.5, 3.0, size=self.num_wells)\n        self.depth2 = self.rng.uniform(0.4, 2.5, size=self.num_wells)\n\n        # Guarantee deepest combined depth at the global well (index 0)\n        max_d1 = np.max(self.depth1)\n        max_d2 = np.max(self.depth2)\n        self.depth1[0] = max_d1 + 0.5\n        self.depth2[0] = max_d2 + 0.5\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} [-depth1[i] * exp(-0.5 * dist1^2)\n                                   - depth2[i] * exp(-0.5 * dist2^2)]\n\n        where dist1^2 = (x - center1[i])^T inv_cov1[i] (x - center1[i]),\n              dist2^2 = (x - center2[i])^T inv_cov2[i] (x - center2[i]).\n        This creates non-homogeneous basins due to differing centers, covariances,\n        and two-component wells per basin.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.num_wells):\n            diff1 = x - self.centers1[i]\n            dist2_1 = diff1 @ self.inv_cov1[i] @ diff1\n            term1 = -self.depth1[i] * np.exp(-0.5 * dist2_1)\n\n            diff2 = x - self.centers2[i]\n            dist2_2 = diff2 @ self.inv_cov2[i] @ diff2\n            term2 = -self.depth2[i] * np.exp(-0.5 * dist2_2)\n\n            total += (term1 + term2)\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_not_homogeneous_aniso_mixture scored on:NOT Basins 0.996, GlobalLocal 0.501,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["174c0767-80b6-4605-8503-fbaa0f837bbd"], "operator": null, "metadata": {"ela_features_2D": [0.1809992124462382, 0.6568963577390856, 0.19957914729549625, 0.24948910565077717, 1.294796645115159, 0.19158772562863843, 0.6719297212854507, 1.131147702233407, 0.8476807391813889, -0.5637003680803585, -0.40372813024457094, 2.0, 0.5243516727856828, 0.6886992953820903, 0.4298735028603704, 0.35124969730536554, -0.22429875048515902, 0.17342451453058721, 0.36514804252333605, 0.43267202594505694, 0.5706530113647053, 0.15964803504062072, 0.3365398149572232, 0.4192456596439872, 0.5509048238167153, -0.43237239494448343, -0.33209175729311163, -0.29676525157269334, -0.2245868840992745, -0.431482527768641, -0.34067488904267573, -0.2981973307649971, -0.2305899494073463, 1.0, 1.0, 1.0, 1.0, 0.5266793228366887, 0.5266478581495224, 0.45446888935428004, 0.4734525148029693, 0.7074291066395817, 0.7177177177177174, 0.4256049689638382, -0.1151151151151151, 0.39116465863453814], "score_NOT Basins_2D": 0.9329837933182716, "score_GlobalLocal_2D": 0.9462316036224365, "ela_features": [0.06049553516884674, 0.940364289711401, 0.00512902571187108, 0.04014609565817432, 8.590989496205577, 0.08396188511398553, 0.11863091136465895, 3.5407599466733912, 0.2159957841524185, -6.798015009264249, 65.24021607960375, 7.0, 0.6955222244643171, 0.8356380062033537, 0.5064601552412178, 0.21097013390392066, -0.4350271212645687, 0.6123760423803801, 0.6926312620853291, 0.7416341662714293, 0.8186752035286273, 0.5851745165285489, 0.6730645029657042, 0.7293314176065643, 0.8110164389109137, -0.3409207771825217, -0.2703332220707222, -0.2272365844454609, -0.15947845846939096, -0.36651007271092784, -0.28884986416614233, -0.23914075827570289, -0.16697313159463073, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21545660032248076, 0.2154083562490215, 0.2128896542690153, 0.20988615570180902, 0.6234729693458906, 0.3533533533533532, 0.00034809335189991806, -2.0130130130130133, 0.5764423076923076], "score_NOT Basins_5D": 0.9998906089385855, "score_GlobalLocal_5D": 0.9999065399169922, "ela_features_10D": [0.0014640870109311477, 0.9980413313112985, 0.0002926174461283759, 0.003698287079755045, 155.33774560078658, -0.0014738017995543195, 0.0019888460005593523, 395.04493033434017, -0.011938613770088846, -33.976840961689156, 1274.7356995108362, 3.2, 0.7440219519277737, 0.8572491023636045, 0.46648365484668713, 0.15399974633673555, -0.14420255618813593, 0.8810026800817725, 0.8935827887337421, 0.9060545675541685, 0.9311408393849965, 0.8781271988148266, 0.892849353527593, 0.9053744526024335, 0.9306384794941632, -0.1509162454782878, -0.13496192784491798, -0.11914434534929072, -0.08732888666991592, -0.15497545460525833, -0.13625645370763095, -0.1203279359219271, -0.08820115037447832, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10941013341062363, 0.1093959465883767, 0.10931548428279145, 0.10000579522592803, 0.5933532695447589, -1.968968968968969, 0.0, -Infinity, 0.4297037630104083], "score_NOT Basins_10D": 0.9959476753138006, "score_GlobalLocal_10D": 0.5006595849990845}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [-1.625483873751555, 2.674364607775545], -11.329514297642309], [3, [0.7540866119105487, -1.4413163904967439], -6.334769380532501], [15, [-3.2781450027897354, 0.661799997489055], -10.068831463693018], [12, [1.7972851084821848, -2.184634206202384], -5.681091205509963], [23, [-1.6466444986941913, -0.6323802330906082], -16.00803906908889], [2, [0.7347311390555636, 0.5424148023057866], -8.103347703887637], [12, [1.0362294722648095, 3.6602790084326142], -8.558613508572549], [14, [2.668557267388146, 0.7265152341222462], -8.678314569440698], [3, [1.015055918565266, -3.850685692631825], -4.03875505411483]], "nr_of_basins": 9, "f_opt_dim_2": -16.008041558573805, "x_opt_dim_2": [-1.6461734366740834, -0.6321779856893187], "f_opt_dim_5": -2.4792307267349116, "x_opt_dim_5": [-2.183460070853336, -1.6630067261624657, 1.5923979153415795, -2.563612825646886, -0.609135496110779]}
{"id": "4730d5e1-d56f-416b-a3ee-ea0bc7e1d302", "fitness": 0.8882370987133376, "name": "landscape_nh_gaussians_nonhom", "description": "A novel non-homogeneous Gaussian-mixture landscape with a deep central basin and highly anisotropic, rotated, and varied-width wells. By assigning per-basin SPD covariance matrices with diverse eigenvalues and orientations, plus varied depths, the landscape destroys basin-size homogeneity and creates strong global-local contrast for robust benchmarking of black-box optimizers.", "code": "import numpy as np\n\nclass landscape_nh_gaussians_nonhom:\n    \"\"\"\n    Non-homogeneous Gaussian mixture landscape with a deep central basin and\n    highly anisotropic, rotated wells. Each basin is defined by a center and a\n    positive definite covariance (represented via its inverse) to create ellipsoidal\n    wells with irregular shapes and varying depths. The global minimum is driven\n    by the deep central basin at the origin; additional wells introduce strong\n    global-local contrast and non-homogeneous basin sizes.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be positive.\")\n        # Deterministic seed derived from dimension for reproducibility\n        seed = (int(self.dim) * 192837465) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Target number of basins grows with dimension but is capped for practicality\n        self.Nc_target = min(12 + self.dim, 60)\n\n        self.centers = []       # basin centers\n        self.CovInvs = []        # inverse covariance matrices (for exponent)\n        self.weights = []        # basin depths (negative values for minimization)\n\n        # 1) Global deep basin at the origin\n        c0 = np.zeros(self.dim)\n        w0 = -rng.uniform(9.0, 15.0)  # deep global minimum\n\n        # Covariance for central basin: diverse but centered at origin\n        # Generate a random SPD Cov0 = Q diag(l) Q^T with varied eigenvalues l\n        l0 = rng.uniform(0.6, 3.5, size=self.dim)\n        if self.dim > 1:\n            # Introduce some occasional axis amplification to increase anisotropy\n            for j in range(self.dim):\n                if rng.random() < 0.3:\n                    l0[j] *= rng.uniform(0.25, 0.60)\n        l0 = np.abs(l0)\n        A = rng.normal(size=(self.dim, self.dim))\n        Q, _ = np.linalg.qr(A)\n        Cov0 = Q @ np.diag(l0) @ Q.T\n        CovInv0 = np.linalg.inv(Cov0)\n\n        self.centers.append(c0)\n        self.CovInvs.append(CovInv0)\n        self.weights.append(w0)\n\n        # 2) Add additional basins with highly varied shapes, orientations, and depths\n        # Ensure centers are reasonably separated\n        attempts = 0\n        while len(self.centers) < self.Nc_target and attempts < self.Nc_target * 60:\n            attempts += 1\n            center = rng.uniform(-5.0, 5.0, size=self.dim)\n\n            # enforce separation from existing centers\n            if any(np.linalg.norm(center - np.array(ex)) < 1.5 for ex in self.centers):\n                continue\n\n            # Generate a random SPD covariance for the basin\n            # Three-type anisotropy patterns to break homogeneity\n            A = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(A)\n\n            anisotropy_type = rng.choice([0, 1, 2], p=[0.25, 0.5, 0.25])\n            if anisotropy_type == 0:\n                # Very narrow along most axes, with a pronounced elongation on one axis\n                l = rng.uniform(0.08, 0.4, size=self.dim)\n                l[0] *= rng.uniform(2.0, 6.0)\n            elif anisotropy_type == 1:\n                # Moderate anisotropy with some axes scaled\n                l = rng.uniform(0.4, 2.5, size=self.dim)\n                idx = rng.choice(self.dim, size=max(1, self.dim // 3), replace=False)\n                l[idx] *= rng.uniform(1.6, 3.2)\n            else:\n                # More isotropic but still varied\n                l = rng.uniform(0.6, 5.0, size=self.dim)\n\n            l = np.abs(l)\n            Cov = Q @ np.diag(l) @ Q.T\n            CovInv = np.linalg.inv(Cov)\n\n            # Depth (negative valley). Keep shallower than the global minimum to maintain a global minimum at origin\n            w = -rng.uniform(0.4, max(0.9, 0.65 * abs(w0)))\n\n            self.centers.append(center)\n            self.CovInvs.append(CovInv)\n            self.weights.append(w)\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n\n        val = 0.0\n        for c, cov_inv, w in zip(self.centers, self.CovInvs, self.weights):\n            diff = x - c\n            term = -0.5 * float(diff @ cov_inv @ diff)\n            val += w * np.exp(term)\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_gaussians_nonhom scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b5c3d2d6-ce70-405d-af84-96bfc12517cb"], "operator": null, "metadata": {"ela_features_2D": [0.08262100887460436, 0.6035453347150886, 0.035793029806973395, 0.17564941830425435, 11.894294838421235, 0.09703478138101766, 0.08719418216632083, 4.097472184628615, 0.23973385045638343, -0.779655304528559, 0.5470741037122038, 1.6, 0.26862188277123983, 0.6415251874465012, 0.25525568101937035, 0.34843171995032474, -0.30280344810906945, 0.18157122776029072, 0.4637949354612475, 0.6730157213255852, 0.936231297429061, 0.15323194931423048, 0.4059169365306385, 0.7475169999754566, 0.95510581542671, -0.4283125905745157, -0.2806499455936034, -0.17116910922694098, -0.03339967163756813, -0.43499591150613287, -0.3053483859742406, -0.12978626981276348, -0.02314323362470021, 1.0, 1.0, 1.0, 1.0, 0.5224681672220195, 0.5224574754734325, 0.4530137810704288, 0.43082209136054334, 0.7346902766208138, 0.7657657657657656, 0.5934736781475786, 0.009009009009008986, 0.39759036144578314], "score_NOT Basins_2D": 0.9991371415089816, "score_GlobalLocal_2D": 0.45810258388519287, "ela_features": [0.08046800673974888, 0.9131674042507425, 0.007234968026690417, 0.06683924214685195, 11.983223259916594, 0.12328428287921205, 0.19007643140621752, 5.4254200055708885, 0.38226596981342376, -4.963553148518389, 32.837387981831455, 6.8, 0.7694236354479383, 0.8585456895976323, 0.5736948530946168, 0.19132277874916512, -0.4009987263902449, 0.5663300455599758, 0.6539108879566107, 0.736835392060987, 0.8371012436240575, 0.5574800705645456, 0.628170112842431, 0.7136033817898257, 0.8202855212620177, -0.3815276098807521, -0.30447532928592913, -0.2315145316566924, -0.14331104117376642, -0.3915229831828563, -0.328968593758501, -0.25335704080021965, -0.158992798152853, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21967414915773928, 0.2196357904232206, 0.21544454871818183, 0.2170319468779831, 0.6383161758095727, 0.3093093093093092, 0.01174607260409832, -1.4044044044044044, 0.514102564102564], "score_NOT Basins_5D": 0.9998576197394868, "score_GlobalLocal_5D": 0.8725185394287109, "ela_features_10D": [0.004039304466841842, 0.9991223127260603, 0.00022613345070128117, 0.004713826170330379, 42.06216922233793, 0.02572680631964519, 0.006310258882732333, 44.33370491085647, 0.05400105741034229, -26.506945314213567, 843.655808235722, 4.2, 0.8587064631381145, 0.9227716603229308, 0.6132929687320104, 0.11765073739025456, -0.23419000748419783, 0.8777050612035259, 0.8777429247730695, 0.8871763990934755, 0.9050628138153785, 0.8692909540900423, 0.8678125427560985, 0.8800850500588033, 0.9008490717467575, -0.15510875497766174, -0.1550612914745257, -0.14309701917433593, -0.12041221505665893, -0.16621350974550309, -0.16809382183287033, -0.1524905068098707, -0.12608924281851044, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10940186555218238, 0.109408300539983, 0.10929035455671579, 0.10142813406601256, 0.5549671642512404, -0.975975975975976, 1.0825950080731578e-05, -4.7557557557557555, 0.5726981585268215], "score_NOT Basins_10D": 0.9999356921689468, "score_GlobalLocal_10D": 0.999871015548706}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [2.097370837122744, -4.4561272705467445], -10.498667538901707], [6, [-4.061631774630436, -3.605796647424545], -8.214106555739802], [11, [-0.06445670989886092, -0.015809812711088937], -14.964415034621204], [12, [4.244805870257608, 4.5163121932024515], -7.976405997137474], [15, [-2.0728400242808354, -2.1795547070356545], -11.455012054984053], [22, [3.348068778886559, -2.1047992284845374], -9.324361713912358], [18, [-3.9147010100295354, 4.8094842242663], -8.915529741665264], [10, [-4.653538677422474, 0.4720296632314932], -6.090694071624253]], "nr_of_basins": 8, "f_opt_dim_2": -14.964584206879566, "x_opt_dim_2": [-0.06600762840358732, -0.0203517299879228], "f_opt_dim_5": -10.816845268826889, "x_opt_dim_5": [0.014551337470733538, -0.0031369082104424958, -0.08274395925630644, 0.06793521036901051, -0.030297861398818134]}
{"id": "7e2060ea-19c4-4329-be99-8f3350dd268f", "fitness": 0.6727057347403994, "name": "landscape_nonuniform_pnorm_rot", "description": "A rotated, anisotropic non-Gaussian multi-well landscape built from per-well rotated p-norm shaped wells with varying depths, scales, and orientations, producing irregular basin sizes and a pronounced global-local minima contrast. The global minimum lies at the center of the deepest well, while other wells create distinct local minima.", "code": "import numpy as np\n\nclass landscape_nonuniform_pnorm_rot:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2025)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the wells spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # per-well random rotation matrices (R_i) to create irregular orientations\n        self.rotations = np.zeros((self.num_wells, self.dim, self.dim))\n        for i in range(self.num_wells):\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(A)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1  # ensure a proper rotation (det > 0)\n            self.rotations[i] = Q\n\n        # per-well per-dimension scales (anisotropy of each well)\n        self.scales = self.rng.uniform(0.4, 3.0, size=(self.num_wells, self.dim))\n\n        # depths of the wells (positive; global minimum is the deepest)\n        self.depths = self.rng.uniform(0.8, 3.5, size=self.num_wells)\n        # ensure a deepest well to enforce a pronounced global minimum\n        self.depths[0] = 8.0\n\n        # per-well p-norm exponents to shape the wells (1.2 to 3.0)\n        self.ps = self.rng.uniform(1.2, 3.0, size=self.num_wells)\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i [-depths[i] * exp(-norm_p_i)]\n        norm_p_i is a per-well rotated and scaled p-norm of (x - center_i):\n          norm_p_i = ( sum_j ( |y_j| / scales[i,j] )^p_i )^(1/p_i)\n          where y = R_i^T * (x - center_i)\n        The global minimum is near the deepest well's center, with other wells\n        creating irregular, non-homogeneous basins and a strong global-local contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # enforce search space bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.num_wells):\n            # rotate and shift\n            y = self.rotations[i] @ (x - self.centers[i])\n\n            # per-dimension scaling\n            scaled = np.abs(y) / self.scales[i]\n\n            # p-norm (per-well exponent)\n            p = self.ps[i]\n            if p == 1:\n                norm_p = np.sum(scaled)\n            else:\n                norm_p = np.sum(scaled ** p) ** (1.0 / p)\n\n            # contribution from this well\n            contrib = -self.depths[i] * np.exp(-norm_p)\n            total += contrib\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nonuniform_pnorm_rot scored on:NOT Basins 1.000, GlobalLocal 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0c33e68f-4c22-4277-896a-3f076defc785"], "operator": null, "metadata": {"ela_features_2D": [0.2789557949716098, 0.7970598021714979, 0.11564948328760613, 0.2734605130228254, 2.3830300137688254, 0.2845881798127567, 0.6387033645665973, 9.158355857384247, 0.7148612254145863, -1.2280316918452399, 2.987182234207715, 3.2, 0.4118935810727968, 0.6837708990953079, 0.32209795718611334, 0.34528189397059805, -0.2229393116915232, 0.1577299652738515, 0.2444799066091675, 0.4682539246916594, 0.7094617572001918, 0.14239922176460856, 0.22721876675103533, 0.36268707758370544, 0.7114289564524524, -0.4404941923514059, -0.39512996080485463, -0.27810651146593096, -0.15195120757299402, -0.4405989758263429, -0.39704603251506165, -0.32747425591085116, -0.14831233353915924, 1.0, 1.0, 0.7333333333333332, 1.0, 0.5200034113749104, 0.5199957134583812, 0.4798077742059446, 0.5070841718471342, 0.7036502065881446, 0.6256256256256254, 0.33404264360455843, -0.20320320320320312, 0.3618473895582329], "score_NOT Basins_2D": 0.9943016921170056, "score_GlobalLocal_2D": 0.9813910722732544, "ela_features": [0.304387874358761, 1.0613369072191883, 0.01645522117415075, 0.1422355440961765, 10.842519431716301, 0.4639976819948329, 0.542578853889613, 2.0334014145251125, 0.7702357996100544, -2.091962672729692, 6.807612493035082, 3.8, 0.83913219350818, 0.8672302024775472, 0.5917398565246289, 0.18670627353082567, -0.39647634561387096, 0.4954879091894882, 0.5912959944929204, 0.670990835400367, 0.7736431746745599, 0.4758112406370314, 0.5714981653031985, 0.6564887448906586, 0.7703756936429235, -0.4437651355103946, -0.3594940721617828, -0.2893977661006458, -0.19910471400457674, -0.4633830406992548, -0.37879230122625573, -0.30366746708750464, -0.20299264695855063, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21722494166481682, 0.2171998502814032, 0.2136072683373845, 0.2574266230919062, 0.7847172669671908, 0.10910910910910906, 0.09022256127319098, -0.7597597597597595, 0.5011217948717949], "score_NOT Basins_5D": 0.013986527919769287, "score_GlobalLocal_5D": 0.04956571012735367, "ela_features_10D": [0.20431735262808742, 1.0012387465538197, 0.008159649148170255, 0.06182985039832526, 8.342594841210504, 0.2824105604489741, 0.3556999357589691, 2.5995240730096443, 0.5389654427119888, -5.183701586935011, 65.63131792493377, 4.6, 0.929618094679151, 0.9283849596269889, 0.6628783277376131, 0.11221614289319641, -0.5411943732766067, 0.7372044702347542, 0.7840085717659149, 0.8146421951437605, 0.8723628690413069, 0.7301996935469081, 0.7810508549370839, 0.8131317819765986, 0.872205261189022, -0.3333040170627656, -0.2739433018404438, -0.2350903823712284, -0.16188273787285415, -0.3431604733572015, -0.27848377411169506, -0.23768007439718164, -0.1625439702790597, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10945407938673464, 0.10946139049192476, 0.10893311140461737, 0.13308965516549626, 0.7621679905843789, -0.28328328328328317, 0.020370356752263133, -1.3643643643643644, 0.5685348278622898], "score_NOT Basins_10D": 0.9998742708121426, "score_GlobalLocal_10D": 0.9971151351928711}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[34, [3.957330399672076, -0.9580277638263371], -11.414206147852852], [17, [0.40866325617615146, 2.835744145012042], -4.510491769464446], [8, [2.6161805508078118, 2.6982278058395504], -4.25700321248952], [24, [-1.6687541490032776, -2.2381241621569177], -5.921701012403257], [17, [-2.345002373899988, 0.6020580077548177], -5.052630534275513]], "nr_of_basins": 5, "f_opt_dim_2": -11.513832447311199, "x_opt_dim_2": [3.9556624413420867, -0.9439220726628186], "f_opt_dim_5": -8.670012275037354, "x_opt_dim_5": [3.9556624413420867, -0.9439220726628186, 2.617184102448798, 2.698042209519917, 3.806472081255656]}
{"id": "836c47f8-afdf-46de-b319-c7d66ac0f7f7", "fitness": 0.6509446137933992, "name": "landscape_nonuniform_aniso_ext", "description": "A more diverse nonuniform anisotropic multi-well landscape with per-well diagonal covariances and varied depths to break basin-size homogeneity. The deepest well is placed at the origin to create a strong global minimum, while other wells have reduced influence and irregular shapes, introducing pronounced global-local contrast for robust benchmarking.", "code": "import numpy as np\n\nclass landscape_nonuniform_aniso_ext:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = int(dim)\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2025)\n\n        # number of wells (basins)\n        self.num_wells = 16\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # depths of the wells (positive; deeper means deeper negative contribution)\n        self.depths = self.rng.uniform(0.6, 3.5, size=self.num_wells)\n\n        # ensure a deepest well to enforce a pronounced global minimum\n        deepest_idx = int(np.argmax(self.depths))\n        self.depths[deepest_idx] = 8.0\n\n        # per-well per-dimension standard deviations (anisotropic basins)\n        # Each well i has its own sigma vector across dimensions\n        raw_sigmas = self.rng.lognormal(mean=0.0, sigma=0.9, size=(self.num_wells, self.dim))\n        self.sigmas = np.clip(raw_sigmas, 0.05, 3.0)\n\n        # introduce additional irregularity: sometimes elongate along a random axis\n        for i in range(self.num_wells):\n            if self.rng.random() < 0.5:\n                axis = self.rng.integers(0, self.dim)\n                self.sigmas[i, axis] *= self.rng.uniform(1.6, 3.2)\n\n        # ensure deepest center at origin to bias the global minimum to the origin\n        self.centers[deepest_idx] = np.zeros(self.dim)\n\n        # depth scaling to reduce influence of non-global wells\n        # This helps guarantee a strong global minimum at the deepest well.\n        self.scaling = np.ones(self.num_wells, dtype=float)\n        for i in range(self.num_wells):\n            if i != deepest_idx:\n                self.scaling[i] = self.rng.uniform(0.01, 0.25)\n        self.effective_depths = self.depths * self.scaling\n        self.effective_depths[deepest_idx] = self.depths[deepest_idx]\n\n        # Precompute inverse variances for efficient exponent calculation\n        self.inv_covs = 1.0 / (self.sigmas ** 2)  # shape: (num_wells, dim)\n\n        # Ripple term to introduce a global non-basin-like pattern and amplify global-local contrast\n        self.ripple_strength = 0.12\n        self.ripple_dir = self.rng.normal(size=self.dim)\n        norm = np.linalg.norm(self.ripple_dir)\n        if norm == 0:\n            self.ripple_dir = np.ones(self.dim)\n            norm = self.dim\n        self.ripple_dir /= norm\n        self.ripple_omega = 2.0 * self.rng.uniform(0.8, 1.2)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i (-effective_depths[i]) * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n        This yields multiple local minima with non-uniform basin sizes and a clear global minimum\n        at the deepest well's region (origin), with a small ripple to break Basin homogeneity.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # diff shape: (num_wells, dim)\n        diff = x - self.centers\n\n        # exponent for each well: -0.5 * sum_j (diff_j^2 * inv_covs_ij)\n        exponent = -0.5 * np.sum((diff ** 2) * self.inv_covs, axis=1)\n\n        # contributions from all wells with scaled depths\n        contributions = -self.effective_depths * np.exp(exponent)\n\n        # base landscape value (sum of contributions)\n        val = float(np.sum(contributions))\n\n        # optional small ripple to break basin-size homogeneity and enhance global-local contrast\n        ripple = self.ripple_strength * np.sin(self.ripple_omega * np.dot(x, self.ripple_dir))\n        return val + ripple", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nonuniform_aniso_ext scored on:NOT Basins 0.004, GlobalLocal 0.008,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0c33e68f-4c22-4277-896a-3f076defc785"], "operator": null, "metadata": {"ela_features_2D": [-0.0033330622290684174, 0.812321570794048, 0.003282628390774226, 0.016400457730539827, 20.538416878825508, -0.004921365673908618, 0.44258402601829766, 2.3923796643969855, 0.4866045328597868, -1.804862597560645, 2.350040538775598, 2.2, 0.5559668427115565, 0.6799384217218524, 0.45617400263351165, 0.36018649680287246, -0.17483520675918873, 0.1897749965647582, 0.29502564670210163, 0.39601473770059414, 0.6115429616621146, 0.16608754985238208, 0.26553851679894425, 0.3579967122577469, 0.5530222222789618, -0.423851526953432, -0.3687872076002461, -0.31595690312948743, -0.2032113422541671, -0.4284673707922371, -0.3773577611278792, -0.3298525973762577, -0.22964896976732221, 1.0, 1.0, 1.0, 1.0, 0.511085989101083, 0.5110595377720022, 0.38867815312323734, 0.3443931772445418, 0.6778827073762026, 0.7497497497497496, 0.11147536434072977, -0.5315315315315313, 0.39236947791164656], "score_NOT Basins_2D": 0.9515991695225239, "score_GlobalLocal_2D": 0.9926363229751587, "ela_features": [0.12662327508743634, 0.918879072384913, 0.003501557355724663, 0.10054590961463847, 57.84481065625412, 0.15558003718851915, 0.20526501210066178, 29.312749831128365, 0.3518649474658174, -1.9914174067973747, 13.439847515644326, 4.8, 0.6501238876840483, 0.8189993241307698, 0.4824718180535924, 0.22522349775977699, -0.5209593765324219, 0.5445952926511446, 0.6191398657549678, 0.6969665858856122, 0.9059906252101133, 0.524597632741713, 0.6066318156649314, 0.6833346244663543, 0.8984394639137248, -0.40055298267907924, -0.3349870631961911, -0.2665324873279765, -0.08268527745350526, -0.4201982591155895, -0.3476927570037792, -0.279889163085471, -0.08976416982227778, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21445521188539077, 0.21447918142183106, 0.20899940920084648, 0.22782070749846328, 0.8570109985779334, 0.1331331331331331, 0.21900180218171644, -0.45145145145145127, 0.5916666666666666], "score_NOT Basins_5D": 0.9996242305496708, "score_GlobalLocal_5D": 0.9495133757591248, "ela_features_10D": [-0.00046471649492247914, 0.4931466788822558, 0.005299616851028683, 0.042766023506976183, 12.880499994083317, -0.0009451929076603971, 0.0002367228627345952, 109.78223143069411, 0.0023742558806425728, -0.0002910580794579495, -1.501587709301698, 2.2, 0.6583156467030628, 0.8816835713415854, 0.48739505120650845, 0.15352286069511384, -0.5653626575646351, 0.9892736403860478, 0.9947712254792693, 0.9960980050747663, 0.9986036684651586, 0.9886423406865982, 0.9946235450190711, 0.9957880011525304, 0.9985067091582781, -0.013604254516864246, -0.006631511001080437, -0.0049487931317839795, -0.0017710640442007096, -0.014442350775423485, -0.006836741669904933, -0.0053558216046177606, -0.0018988286295565705, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10995848690483864, 0.10995949840179439, 0.12603731998265494, 0.100589317861427, 0.8866125004469321, 0.3813813813813812, 0.4182526250874049, -0.05905905905905908, 0.6622898318654923], "score_NOT Basins_10D": 0.0039035677909851074, "score_GlobalLocal_10D": 0.008391016162931919}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.05436796342903119], [7, [3.8285144479821396, 4.611558981525728], -0.4791436922370225], [3, [3.5968888888889214, -5.0], -0.5057016150963964], [12, [3.4869410848073046, -1.2642061238845057], -0.6986229262840454], [8, [3.5332766827880073, 1.63718916387623], -0.5793479435029046], [6, [-3.3440209747735246, 3.2877542791148175], -0.5583680391332398], [6, [-3.4577805356609925, 0.12188382455186778], -1.2006566197593047], [6, [-3.445979221605857, -2.7740544860454874], -0.5707759397410762], [51, [-0.020647529043823575, -0.23232639432773375], -8.45896094687641]], "nr_of_basins": 9, "f_opt_dim_2": -8.45896101526153, "x_opt_dim_2": [-0.020546484665713245, -0.23217537001224417], "f_opt_dim_5": -8.124027730483048, "x_opt_dim_5": [0.08509848985394901, 0.0018853708091257592, 0.0008843933465105305, 0.006889479059828544, -0.008697810627486775]}
{"id": "f7ca6d61-2ba5-435e-8869-172304deb244", "fitness": 0.6365837242143849, "name": "landscape_pnorm_minima_heterogeneous", "description": "A heterogeneous multi-well landscape built as the minimum over shifted p-norm-like wells, enhanced with per-well anisotropic scaling and random rotations to break basin-size homogeneity. The global minimum sits at the origin, while other wells create irregular, differently-sized basins, yielding a strong global-local contrast for robust benchmarking.", "code": "import numpy as np\n\nclass landscape_pnorm_minima_heterogeneous:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._seed = 987654321\n        # number of wells (ensure at least 4, scales with dimension)\n        self._K = max(4, self.dim * 3)\n\n        # wells parameters\n        self.c = np.zeros((self._K, self.dim), dtype=float)  # centers\n        self.d = np.zeros(self._K, dtype=float)              # base depths (negative = minima)\n        self.w = np.zeros(self._K, dtype=float)              # width/scale per well\n        self.p = np.zeros(self._K, dtype=float)              # exponent per well (basin shape)\n\n        # per-well anisotropic scaling (per-dimension) and rotation\n        self.R = np.zeros((self._K, self.dim, self.dim), dtype=float)  # rotation matrices\n        self.s = np.zeros((self._K, self.dim), dtype=float)            # per-dimension scales\n\n        # Global deep well at the origin\n        self.c[0] = np.zeros(self.dim)\n        self.d[0] = -60.0    # deep global minimum\n        self.w[0] = 6.0\n        self.p[0] = 2.0\n        self.R[0] = np.eye(self.dim)\n        self.s[0] = np.ones(self.dim)\n\n        # Generate irregular, non-homogeneous local wells\n        for i in range(1, self._K):\n            ctr = self._sample_center(min_dist=2.5, max_trials=2000)\n            self.c[i] = ctr\n            # local minima in a broader negative range to emphasize heterogeneity\n            self.d[i] = - (0.5 + self._rand() * 14.5)  # ~ [-15.0, -0.5]\n            self.w[i] = 0.3 + self._rand() * 9.7        # width-like scaling in [0.3, 10.0]\n            self.p[i] = 1.0 + self._rand() * 3.0        # exponent in [1, 4]\n\n            # per-dimension anisotropic widths\n            self.s[i] = 0.2 + self._rand() * 4.0        # scales in [0.2, 4.2]\n\n            # random rotation (orthogonal)\n            M = np.zeros((self.dim, self.dim))\n            for r in range(self.dim):\n                M[:, r] = [self._rand() * 2.0 - 1.0 for _ in range(self.dim)]\n            Q, _ = np.linalg.qr(M)\n            # ensure proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] = -Q[:, 0]\n            self.R[i] = Q\n\n    def _rand(self):\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=2.5, max_trials=2000):\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback: place somewhere on a sphere of radius min_dist along axis\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n        K = self._K\n        vals = np.empty(K, dtype=float)\n        for i in range(K):\n            diff = x - self.c[i]\n            # apply rotation and anisotropic scaling\n            rotated = self.R[i] @ diff\n            dist_p = np.sum(np.abs(self.s[i] * rotated) ** self.p[i])\n            vals[i] = self.d[i] + self.w[i] * dist_p\n        return float(np.min(vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_pnorm_minima_heterogeneous scored on:NOT Basins 0.119, GlobalLocal 0.010,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["11f353c0-f779-422a-b516-26df2f4bba5c"], "operator": null, "metadata": {"ela_features_2D": [0.05677759165423098, 0.39411403848005166, 0.02732889120139868, 0.1614458925734648, 15.776706616037904, 0.09018426260908721, 0.7740695290957267, 1.2373511295113448, 0.859999817436677, 0.9113576584556384, 0.7648292026153105, 1.2, 0.48834419477364904, 0.682735694132947, 0.40321623716003974, 0.3534939424220771, -0.2193384253163841, 0.14128288792058544, 0.22324163940222252, 0.3110609144883084, 0.5034750432955738, 0.146920911209387, 0.2234842454241479, 0.3131350955594149, 0.5001230838749464, -0.44939478099207963, -0.4064979742399123, -0.36053458165566926, -0.25982997109327877, -0.4383656830444302, -0.3990039722137576, -0.35292174926852626, -0.25682159567568846, 1.0, 1.0, 1.0, 1.0, 0.5280227371546177, 0.5280187609735622, 0.4413707978357128, 0.4218612857201771, 0.7051533366934664, 0.7297297297297295, 0.5472058110080056, -0.0870870870870871, 0.38152610441767065], "score_NOT Basins_2D": 0.9781983308494091, "score_GlobalLocal_2D": 0.951642632484436, "ela_features": [0.4602698790401859, 0.7695044184071405, 0.06523911164185733, 0.16215688920234997, 2.5055427245078628, 0.49523111894525157, 0.6622949290412528, 1.5073615974446612, 0.7435818782083055, -1.3977827783061614, 6.612438094463227, 3.6, 0.8286942927678744, 0.8641731776813044, 0.5947818061594811, 0.18825427395591135, -0.36711495196934846, 0.5858931742910871, 0.7195345317758745, 0.7238373205916677, 0.7864860628219551, 0.5222312700637823, 0.6931713128537365, 0.7020009902302329, 0.7811617150332132, -0.3642170428848625, -0.24668521324986906, -0.24290207112478557, -0.1877993618876878, -0.4221829126723554, -0.2711441468249484, -0.2633427164668859, -0.19338664721331605, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21639344126760252, 0.21638233367224133, 0.21629397922634444, 0.28070952691309736, 0.8140848654002811, 0.2892892892892892, 0.08783701336468322, -0.8398398398398396, 0.49535256410256406], "score_NOT Basins_5D": 0.9236171841621399, "score_GlobalLocal_5D": 0.8365049362182617, "ela_features_10D": [0.5633484908991628, 0.5522936657685815, 0.018262425933444147, 0.2719773035647145, 17.17222775892275, 0.7147355483847807, 0.7168271514615185, 2.6290868365278994, 0.8987546847992848, 0.0331062376382219, -0.5792009649522479, 1.0, 0.9196320157175035, 0.9280854705833601, 0.6680814105241549, 0.11103321772082311, -0.4415149714485218, 0.69344326318018, 0.7526067031160604, 0.8010765085800813, 0.8774170617836564, 0.6890550827451373, 0.751904279074717, 0.802068161864242, 0.8770121473844865, -0.3887849928542105, -0.3137520406407237, -0.25228103451710665, -0.15546293880205964, -0.39537115034900205, -0.31545743012212873, -0.251674059485379, -0.15638007905874426, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10781150401771462, 0.10781875589092435, 0.1251929876010519, 0.16102059808410357, 0.841802110949246, -0.10310310310310311, 0.11409980936023771, -0.7037037037037035, 0.556365092073659], "score_NOT Basins_10D": 0.11946433782577515, "score_GlobalLocal_10D": 0.010074923746287823}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [4.258167689370257, 0.8111319360854008], -11.578849393325624], [7, [3.0467782867029025, 4.312209395062219], -11.356266993955005], [8, [-4.346059668317323, 3.729868629904692], -9.495197711356957], [72, [0.00044444444444512003, 0.00044444444444512003], -59.99999762962963], [5, [4.366755503800334, -2.213452034199026], -2.065332640144171]], "nr_of_basins": 5, "f_opt_dim_2": -60.0, "x_opt_dim_2": [-1.2500842088173711e-08, -4.016254437341362e-09], "f_opt_dim_5": -60.0, "x_opt_dim_5": [1.8166863003705305e-08, -1.7617776378998826e-09, -8.966291618542818e-09, 1.1182554107606075e-09, 1.1236770805894401e-08]}
{"id": "37a5036d-32fa-4319-bde7-9a2c037e5633", "fitness": 0.9578001996148183, "name": "landscape_max_envelope_fullcov_nonhom", "description": "A non-homogeneous, full-covariance max-envelope landscape with highly varied well depths and scales to break basin-size homogeneity. The deepest well is significantly stronger than the others, and full (non-diagonal) covariances create rotated, irregular ellipsoidal basins, producing pronounced global-local minima contrast and non-uniform basin sizes.", "code": "import numpy as np\n\nclass landscape_max_envelope_fullcov_nonhom:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # deterministic seed for reproducibility with more variability across runs\n        self.rng = np.random.default_rng(20241108)\n\n        # number of wells (basins) to create a rich, non-uniform landscape\n        self.num_wells = 22\n\n        # centers of the wells spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # per-well full covariance matrices (non-diagonal) to create rotated, anisotropic wells\n        self.covariances = []\n        self.inv_covariances = []\n\n        # create highly non-homogeneous depths: one deepest well and others with a broad, heavy-tailed spread\n        # others: lognormal to create diverse depths\n        others = self.rng.lognormal(mean=0.0, sigma=0.9, size=self.num_wells - 1)\n        depths = np.empty(self.num_wells)\n        depths[1:] = others\n        max_other = others.max()\n        depths[0] = max_other * 1.6  # deepest well significantly deeper than others\n\n        # clamp depths to avoid numerical issues yet preserve non-homogeneity\n        depths = np.clip(depths, 0.1, 50.0)\n        self.depths = depths\n\n        for i in range(self.num_wells):\n            # generate a random full covariance matrix Sigma = A A^T (SPD)\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Sigma = A @ A.T\n\n            # heterogeneously scale each covariance to create irregular basin sizes\n            scale = 10 ** self.rng.uniform(-1.0, 1.6)  # ~0.1 to ~40\n            Sigma = Sigma * scale\n\n            # small regularization for numerical stability\n            Sigma += np.eye(self.dim) * 0.01\n\n            self.covariances.append(Sigma)\n            self.inv_covariances.append(np.linalg.inv(Sigma))\n\n        self.covariances = np.array(self.covariances)\n        self.inv_covariances = np.array(self.inv_covariances)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = - max_i depth_i * exp(-0.5 * (x - center_i)^T inv_cov_i (x - center_i))\n\n        Notes:\n        - Each well i defines a Gaussian-like basin with center_i, depth_i, and full covariance inv_cov_i.\n        - The landscape is the negative envelope (minimization problem), so deeper wells yield lower function values.\n        - Full covariance matrices (non-diagonal) create rotated, non-axis-aligned basins with irregular sizes,\n          breaking basin-size homogeneity and increasing global-local contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        values = []\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            exponent = -0.5 * diff.T @ self.inv_covariances[i] @ diff\n            val = self.depths[i] * np.exp(exponent)\n            values.append(val)\n\n        return float(-max(values))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_max_envelope_fullcov_nonhom scored on:NOT Basins 0.997, GlobalLocal 0.939,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["31692d02-1f85-4234-8c65-dfc4559d66c5"], "operator": null, "metadata": {"ela_features_2D": [0.7267618528882923, 0.5733898755522966, 0.5434867985739265, 0.6286079953032584, 1.1580405510302028, 0.7792133740168652, 0.7484724531087437, 5.716943925648079, 0.8662338392754965, -0.34180957162052134, -0.9647207909278075, 2.6, 0.4888873136572814, 0.6822244035197034, 0.3853533635741305, 0.35073947490582136, -0.14889881934237523, 0.21268845865333197, 0.2956956621447125, 0.3863069788058852, 0.5368374375656164, 0.18337373305907181, 0.26850789427140026, 0.3489250776781424, 0.5134224655153748, -0.4118786315170885, -0.368444455078908, -0.32104249357610415, -0.24229306457575756, -0.4196968966134186, -0.3759401083855235, -0.33461057996247195, -0.25007941658636024, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5201867498502534, 0.5201755916020314, 0.620074861494706, 0.6236320456166556, 0.7016774659762833, 0.4254254254254253, 0.4574884862299452, -0.031031031031031053, 0.3714859437751004], "score_NOT Basins_2D": 0.8270650207996368, "score_GlobalLocal_2D": 0.9888492822647095, "ela_features": [0.41595128448612717, 0.9365171385931959, 0.018340279451099877, 0.19540201048153485, 14.218022544268191, 0.4942731919501549, 0.4283276572698561, 122.13215049023157, 0.5717246307922957, -1.6375951269731719, 8.100571864220482, 3.8, 0.6587736345237684, 0.8385041605594739, 0.4885084716460163, 0.2057977669660203, -0.36669233248461985, 0.9203368239729338, 0.8625603385686726, 0.8586762524842205, 0.8782211541573401, 0.899804267586769, 0.8249791805368026, 0.8384718040683176, 0.8688449159860163, -0.07004622239946674, -0.1208531129884733, -0.12427624944485387, -0.10709087827403611, -0.08849504793365756, -0.1545986183840951, -0.14271509320890624, -0.11588165234989292, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.22065166082724064, 0.22063795523773622, 0.22004943723303097, 0.2742623767595352, 0.7949587492200715, 0.1531531531531531, 0.08438318082489506, -0.7917917917917915, 0.5363782051282051], "score_NOT Basins_5D": 0.999842097677174, "score_GlobalLocal_5D": 0.995140552520752, "ela_features_10D": [0.20109570109207567, 0.7113502406935368, 0.03666411942479655, 0.19386878599277377, 6.145684598478622, 0.32105114397402773, 0.2705210682885497, 15.765971224650182, 0.45136030327851706, -1.066729804952195, 0.31807339058247514, 1.0, 0.8060331681388746, 0.9089177503528546, 0.5926700465805561, 0.12929390350146183, -0.5475926220413425, 0.8319690284702472, 0.8746105445527854, 0.9116635192929003, 0.9399662489603109, 0.8309623907815682, 0.8739024771584771, 0.910993296060837, 0.9391151659960894, -0.21310255250933804, -0.15902522665577443, -0.11203273733393923, -0.0761378081222341, -0.21492183580348184, -0.16033439874642577, -0.11317317838712038, -0.0774158792828246, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10924408605300492, 0.10923854522994494, 0.11439675241660237, 0.13225596750099972, 0.8005116677778634, 0.14914914914914912, 0.1278865971772876, -0.5235235235235234, 0.6042433947157726], "score_NOT Basins_10D": 0.9968102970160544, "score_GlobalLocal_10D": 0.9390939474105835}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [-3.5036002966927655, 0.6166004565548167], -2.4637678268423193], [29, [0.6827452601603375, 0.612199132632896], -3.0816444880795735], [6, [-3.7060220991388344, 3.3185997332016965], -1.0555234303541938], [54, [3.3473247032769304, -2.621769122417576], -4.930886595366552]], "nr_of_basins": 4, "f_opt_dim_2": -4.930887150276492, "x_opt_dim_2": [3.343968220235909, -2.625451292493894], "f_opt_dim_5": -2.510425437582167, "x_opt_dim_5": [-3.708336487919035, 3.319714358249694, 3.582190560526725, -1.3968310136115825, 2.430957147513198]}
{"id": "f7a242e0-6f41-4bc1-9cd0-56e9d6899393", "fitness": 0.9264723915354504, "name": "landscape_max_envelope_fullcov_glocal_boost", "description": "A nonlinear, max-envelope multi-well landscape with full covariance wells and an enhanced global-local minima contrast. The global minimum sits at the origin as a deep, narrow well, while other wells are shallower and irregular due to full covariance rotations, creating non-homogeneous basin sizes. The combination strengthens the global-local minima contrast relative to the landscape average, aiding robust benchmarking of solvers.", "code": "import numpy as np\n\nclass landscape_max_envelope_fullcov_glocal_boost:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # deterministic yet nontrivial seed for reproducibility\n        self.rng = np.random.default_rng(9876)\n\n        # number of wells (basins)\n        self.num_wells = 14\n\n        # centers of the wells\n        # global minimum at origin\n        self.centers = np.zeros((self.num_wells, self.dim))\n        if self.num_wells > 1:\n            self.centers[1:] = self.rng.uniform(-4.0, 4.0, size=(self.num_wells - 1, self.dim))\n\n        # per-well depths (prominent global minimum at origin)\n        # global minimum much deeper than others to boost GlobalLocal contrast\n        self.depths = self.rng.uniform(0.2, 1.2, size=self.num_wells)\n        self.depths[0] = 8.0  # deep global minimum at origin\n\n        # per-well full covariance matrices (non-diagonal to create rotated ellipsoids)\n        self.covariances = []\n        self.inv_covariances = []\n        for i in range(self.num_wells):\n            # construct a random full covariance matrix: Sigma = A A^T (SPD)\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Sigma = A @ A.T\n\n            # heterogeneously scale each covariance to create non-homogeneous basin sizes\n            if i == 0:\n                # global well: narrow and sharp\n                scale = self.rng.uniform(0.08, 0.25)\n            else:\n                scale = self.rng.uniform(0.4, 2.0)\n            Sigma = Sigma * scale\n\n            # small regularization for numerical stability\n            Sigma += np.eye(self.dim) * 0.01\n\n            self.covariances.append(Sigma)\n            self.inv_covariances.append(np.linalg.inv(Sigma))\n\n        self.covariances = np.array(self.covariances)\n        self.inv_covariances = np.array(self.inv_covariances)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = - max_i depth_i * exp(-0.5 * (x - center_i)^T inv_cov_i (x - center_i))\n\n        Rationale:\n        - Each well i defines a Gaussian-like basin with center_i, depth_i, and full covariance inv_cov_i.\n        - The function takes the maximum across wells (envelope) and negates it, so the deepest well near a center\n          yields the global minimum. This also yields strong local minima corresponding to other wells.\n        - Covariance matrices are full (non-diagonal) to create rotated, non-axis-aligned basins with varying sizes,\n          ensuring non-homogeneous basin structure and a pronounced global-local minima contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        values = []\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            exponent = -0.5 * diff.T @ self.inv_covariances[i] @ diff\n            val = self.depths[i] * np.exp(exponent)\n            values.append(val)\n\n        return float(-max(values))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_max_envelope_fullcov_glocal_boost scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["31692d02-1f85-4234-8c65-dfc4559d66c5"], "operator": null, "metadata": {"ela_features_2D": [0.04679526272513723, 0.9440125285124562, 0.021917469533003775, 0.06713372540702581, 3.2164657068723876, 0.04518718766519765, 0.2435534705422336, 1.5208401222375136, 0.3038939002652893, -4.915631792552206, 51.98881046005257, 3.2, 0.3326921211519158, 0.6348912071495564, 0.3101319371158325, 0.3670515279961013, -0.3122875203420351, 0.4097319188786742, 0.5423263993719697, 0.6371806237367348, 0.7301540902920215, 0.46191976209135815, 0.6381850694762164, 0.6786273932785314, 0.7196991771640577, -0.3088031256033706, -0.2394226813130814, -0.18980919115309774, -0.14117040905770137, -0.27645331856779426, -0.18584133366852423, -0.1651536930548013, -0.14404132901102948, 1.0, 1.0, 0.6666666666666666, 1.0, 0.516811518908803, 0.5168059847485242, 0.49359775205581585, 0.40890387728038996, 0.6828097574241068, 0.5895895895895894, 0.2536322916212731, -0.33133133133133125, 0.4188755020080322], "score_NOT Basins_2D": 0.9976981568615884, "score_GlobalLocal_2D": 0.5659098029136658, "ela_features": [0.10100603342168143, 0.909760037219646, 0.004744318563495641, 0.0829814252774224, 20.653306131949655, 0.14757563137615606, 0.1829608294402491, 2.4638174620232514, 0.3045311356234034, -4.4368606783906275, 42.7425072909714, 4.4, 0.6985020130026041, 0.8391295984432459, 0.5128776737886878, 0.20737514167260276, -0.4864658199357872, 0.6954734754355505, 0.7358492661320037, 0.7901835379540448, 0.8542107079934956, 0.6985052135194371, 0.7338524627121682, 0.7882298471659454, 0.8506027194524497, -0.2678397960841433, -0.2323251025169589, -0.18453836355908051, -0.12822583502712578, -0.2664817291305489, -0.23522492216720448, -0.18716808223739256, -0.13204455198561468, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21582106412768698, 0.21581629306423616, 0.21193220104950444, 0.2218869904008245, 0.672529323523533, 0.2572572572572572, 0.01638566023324712, -1.068068068068068, 0.5440705128205128], "score_NOT Basins_5D": 0.9998602793493774, "score_GlobalLocal_5D": 0.9957684278488159, "ela_features_10D": [0.0235845063194841, 1.0008646259182774, 0.0007904855815585373, 0.019331899912818157, 230.05238339472447, 0.041019460706961296, 0.051691275605524535, 12.254209076058007, 0.08971615587438508, -9.865374934521636, 151.22642090848353, 6.0, 0.7983173515563287, 0.908986883233972, 0.5722565049038046, 0.13034995848443712, -0.4895320468219816, 0.8298667446888348, 0.874167719129334, 0.8953390488927842, 0.9265748403659424, 0.8280487693176084, 0.8720110154337497, 0.8940156400071873, 0.9254755401652328, -0.21575061383094268, -0.15957150985677332, -0.13272371538795186, -0.09311214880432468, -0.21856476187357546, -0.1626860680067284, -0.13471717018854218, -0.09472709872667809, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10953071513129378, 0.10953343786711742, 0.10920335779361427, 0.10735747524800895, 0.6585060302774235, -0.19519519519519518, 0.0001583825472272129, -2.2892892892892895, 0.6112890312249799], "score_NOT Basins_10D": 0.9999408857838716, "score_GlobalLocal_10D": 0.9996567964553833}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [0.38997053476821486, -0.26734777913801233], -1.0159084950176667], [8, [-2.0968239432935234, 3.351910181450061], -0.5858250104212386], [14, [-1.002091796976168, -0.19242849836927467], -0.8277551024095325], [5, [-3.087630579833531, 0.9092569163872806], -0.5280485180262802], [3, [-0.6858756944744254, 3.9904731608142288], -0.3366363389282516], [24, [2.4986562815972246, 2.145142673109484], -0.9829491383664519], [13, [-3.1979754178274633, -0.9073295714217647], -0.7426854865274688], [4, [-3.746317770444513, 2.9249376236352753], -0.8235523776105638], [1, [-1.3170022859277193, 4.224878191011883], -0.8384173922524373], [6, [1.6504427383057165, -0.5541902392534148], -0.7384658682110183], [4, [3.3504364819284196, -3.3108790744503094], -0.4680658162764484], [15, [3.0888093473799327, -3.458348069606443], -0.5646409256376462]], "nr_of_basins": 12, "f_opt_dim_2": -2.6089248910283307, "x_opt_dim_2": [0.34355008761860845, -0.3361482902926115], "f_opt_dim_5": -1.0256140409942878, "x_opt_dim_5": [0.5682698938008196, -1.0693037015707394, -3.7649262652012494, 2.9316837700571097, -2.096918641675593]}
{"id": "317442e5-e3fa-47ca-b1c4-b8e5e15bcee5", "fitness": 0.6539954351222453, "name": "landscape_min_of_aniso_wells_rot", "description": "A min-of-anisotropic-rotated-ellipsoidal wells landscape. Each well is defined by a center, a random rotation, and per-dimension anisotropic scaling. The objective at any x is the minimum value over all wells, creating non-homogeneous basin shapes. The deepest well sits at the origin to enforce a pronounced global minimum and global-local contrast, while other wells produce irregular local minima. A small ripple term adds non-basin-like variation to further challenge optimizers.", "code": "import numpy as np\n\nclass landscape_min_of_aniso_wells_rot:\n    def __init__(self, dim=5, num_wells=20, seed=2025):\n        # problem dimension\n        self.dim = int(dim)\n        self.num_wells = int(num_wells)\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(seed)\n\n        # Centers of wells: spread across [-4, 4]\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # Depths of wells (positive; deeper means deeper negative contribution)\n        self.depths = self.rng.uniform(0.6, 3.5, size=self.num_wells)\n\n        # Ensure a deepest well to enforce a pronounced global minimum\n        deepest_idx = int(np.argmax(self.depths))\n        self.depths[deepest_idx] = 8.0\n\n        # Ensure the deepest center is at the origin\n        self.centers[deepest_idx] = np.zeros(self.dim)\n\n        # Per-well random rotation matrices (orthogonal)\n        self.Rs = []\n        for i in range(self.num_wells):\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(A)\n            self.Rs.append(Q)\n        self.Rs = np.stack(self.Rs, axis=0)  # shape: (num_wells, dim, dim)\n\n        # Per-well anisotropic scales in the rotated frame (positive values)\n        raw_lambdas = self.rng.lognormal(mean=0.0, sigma=0.8, size=(self.num_wells, self.dim))\n        self.lambdas = np.clip(raw_lambdas, 0.15, 4.0)  # shape: (num_wells, dim)\n\n        # Ripple term to break basin_size homogeneity and enhance global-local contrast\n        self.ripple_strength = 0.08\n        self.ripple_dir = self.rng.normal(size=self.dim)\n        norm = np.linalg.norm(self.ripple_dir)\n        if norm == 0:\n            self.ripple_dir = np.ones(self.dim)\n            norm = self.dim\n        self.ripple_dir /= norm\n        self.ripple_omega = 2.0 * self.rng.uniform(0.8, 1.2)\n\n    def f(self, x):\n        \"\"\"\n        Landscape value at x.\n        f_i(x) = -depths[i] * exp(-0.5 * ( (R_i @ (x - center_i))^T diag(lambdas_i) (R_i @ (x - center_i)) ))\n        f(x) = min_i f_i(x) + ripple(x)\n        This yields irregular, non-homogeneous basins with a strong global minimum at the origin.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        contributions = []\n        for i in range(self.num_wells):\n            c = self.centers[i]\n            delta = x - c\n            y = self.Rs[i] @ delta  # transform into eigenbasis of well i\n            # exponent uses per-dimension lambdas in the rotated frame\n            exponent = -0.5 * np.sum((y ** 2) * self.lambdas[i])\n            val_i = -self.depths[i] * np.exp(exponent)\n            contributions.append(val_i)\n\n        # Global minimum across wells (min over f_i)\n        val = float(min(contributions))\n\n        # Ripple term to break Basin-size homogeneity\n        ripple = self.ripple_strength * np.sin(self.ripple_omega * np.dot(x, self.ripple_dir))\n        return val + ripple", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_min_of_aniso_wells_rot scored on:NOT Basins 0.005, GlobalLocal 0.010,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["836c47f8-afdf-46de-b319-c7d66ac0f7f7"], "operator": null, "metadata": {"ela_features_2D": [0.05436870847312099, 0.8508827946838503, 0.04375493696828438, 0.1348165736828262, 3.322265828031432, 0.053526149844129976, 0.3658780756292985, 1.6742266884365058, 0.5242859483900922, -1.6780552346842288, 4.110353272438742, 2.8, 0.45498546057171074, 0.6724940090976952, 0.3935733974860962, 0.3577866665137654, -0.2505676544909251, 0.18938359458177478, 0.280035456980518, 0.4173038347994066, 0.7102165583971554, 0.17770440445417585, 0.2617563005583837, 0.3919448414338297, 0.6938618280733593, -0.4242139895084741, -0.37678317634637404, -0.3049389118854718, -0.15163653289596363, -0.42237658935101596, -0.37921338703570207, -0.31231883514105263, -0.1572023554885294, 1.0, 1.0, 1.0, 1.0, 0.5283638704424437, 0.5283593917578051, 0.45734223943597285, 0.42029679400297504, 0.7438687387354587, 0.7817817817817816, 0.43245170539254413, -0.11111111111111108, 0.4104417670682731], "score_NOT Basins_2D": 0.9997096210718155, "score_GlobalLocal_2D": 0.9624779224395752, "ela_features": [0.009058142563171723, 0.9628561023725336, 0.0032318424578098707, 0.01644990685775848, 6.173860052892769, 0.006662590877398955, 0.06547035120211113, 2.482025868635222, 0.10505312091806115, -9.427879685035547, 151.65895495640905, 6.0, 0.6368052741305038, 0.8174267514043987, 0.48370118423477493, 0.2246858379163376, -0.49373611464217326, 0.7260860529504767, 0.7468426650640968, 0.7800876036050903, 0.9141951834105772, 0.7175132737928929, 0.7453438312922331, 0.7779822613072277, 0.9091586146278752, -0.24092293138716148, -0.22267099252959116, -0.19342937529844612, -0.07547276279804653, -0.24973766616109136, -0.225149050765574, -0.19628770808210363, -0.08031570297555683, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2154053527372734, 0.21539513705399305, 0.21358545494753134, 0.1866852293711441, 0.8553953283606915, 0.12512512512512508, 0.05765972845543199, -0.991991991991992, 0.6081730769230769], "score_NOT Basins_5D": 0.9992723747855052, "score_GlobalLocal_5D": 0.9482121467590332, "ela_features_10D": [0.0009375606261552649, 0.5593755639613477, 0.0027271567536056285, 0.05191299025089906, 105.94139198420888, 0.001585545662388932, 0.00195766812457574, 31.887895114468012, 0.004125729940757239, 0.008997860356066074, -1.4715899205018188, 2.4, 0.6507790696796183, 0.8833180530758584, 0.4870624980025132, 0.15126685932019443, -0.5552918781680606, 0.9809746971374411, 0.9990007956498186, 0.9976644692335901, 0.9972609054788102, 0.9824872172889663, 0.9990079649736877, 0.9981716399082033, 0.9971714471549007, -0.024128530361687696, -0.0012666137183352077, -0.0029617885811266563, -0.0034735845852299275, -0.022266943166740428, -0.001260134204365837, -0.0023240515362332737, -0.003595916361820306, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10888445404790711, 0.10888814803337903, 0.12273150067302499, 0.09976255160608032, 0.8872147458145039, 0.3333333333333332, 0.39810068888379513, -0.12312312312312312, 0.6640512409927943], "score_NOT Basins_10D": 0.004574835300445557, "score_GlobalLocal_10D": 0.00972571037709713}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [2.393861712794941, 2.1245505326915133], -3.4304970772962786], [10, [3.644844180405164, 3.377486916965138], -2.7423261271824626], [15, [3.83300476516156, -3.4153592506171893], -2.8737871745565853], [2, [3.869544324805239, -0.8988210735508462], -1.9918950954806343], [11, [0.044663891275982325, 0.006073859661923551], -8.002738687601823], [5, [-1.811020764541631, 0.1844624110245812], -3.4189953944880718], [15, [-1.6744826169129516, -2.3269953558541094], -3.4514394456201156], [9, [-3.203407601448197, -0.018868711837332214], -2.2414967499786758], [8, [0.5597591811201921, 2.843720349231118], -3.2971050256744587], [5, [1.4097049460576305, -1.7264369738360843], -2.153196919964914], [2, [2.8889252864799313, -1.0657410274177734], -2.4490589965404985], [13, [-1.1686594936614083, 3.2936270074281997], -1.9764338545804987]], "nr_of_basins": 12, "f_opt_dim_2": -8.002747651258217, "x_opt_dim_2": [0.04538795865221304, 0.00515413104140331], "f_opt_dim_5": -8.002091471908448, "x_opt_dim_5": [-0.003474571292892219, -0.007114741029976457, 0.003989298481139365, 0.027438918571948395, 0.011144295070417698]}
{"id": "0f6f56e0-9a9b-457f-9d38-bb0bbda462eb", "fitness": 0.658548936926915, "name": "landscape_nh_gaussians_improved_v2", "description": "An expanded non-homogeneous Gaussian-mixture landscape with extreme basin-size heterogeneity and rotated anisotropic wells; global minimum at origin; uses log-space per-well covariances to create irregular basin shapes and highly varied basin sizes to break basin-size homogeneity and maximize global-local contrast.", "code": "import numpy as np\n\nclass landscape_nh_gaussians_improved_v2:\n    \"\"\"\n    An expanded non-homogeneous Gaussian-mixture landscape with extreme basin-size heterogeneity.\n    Global minimum sits at the origin in a very deep central basin. Additional wells use\n    anisotropic, rotated Gaussians with per-basin covariances drawn from a wide (log-uniform)\n    distribution to break basin-size homogeneity and create strong global-local minima contrast.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed from dimension for reproducibility\n        seed = (int(dim) * 123457) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Target number of basins grows with dimension, but cap to avoid excessive size\n        self.Nc_target = min(16 + dim, 120)\n\n        self.centers = []\n        self.cov_inv = []  # inverse covariance matrices for each basin\n        self.weights = []  # negative depths (minima values)\n\n        # Global deep basin at origin\n        self.centers.append(np.zeros(dim))\n\n        # Global basin covariance (rotation + per-axis widths)\n        A0 = rng.normal(size=(dim, dim))\n        Q0, _ = np.linalg.qr(A0)\n        if np.linalg.det(Q0) < 0:\n            Q0[:, 0] *= -1\n        wv0 = rng.uniform(0.4, 1.8, size=dim)  # per-dimension widths for global basin\n        Sigma0_inv = Q0 @ np.diag(1.0 / (wv0**2)) @ Q0.T\n        self.cov_inv.append(Sigma0_inv)\n\n        # Deep global minimum\n        self.weights.append(-rng.uniform(18.0, 40.0))\n\n        # 2) Additional wells with extreme heterogeneity\n        min_sep_from_origin = 2.5  # avoid clustering too close to origin\n        for idx in range(1, self.Nc_target):\n            placed = False\n            tries = 0\n            while not placed and tries < 1500:\n                c = rng.uniform(-5.0, 5.0, size=dim)\n\n                # enforce separation from origin\n                if np.linalg.norm(c) < min_sep_from_origin:\n                    tries += 1\n                    continue\n\n                # enforce separation from existing centers\n                if any(np.linalg.norm(c - cp) < 0.5 for cp in self.centers):\n                    tries += 1\n                    continue\n\n                self.centers.append(c)\n\n                # Random rotation for the basin\n                A = rng.normal(size=(dim, dim))\n                Q, _ = np.linalg.qr(A)\n                if np.linalg.det(Q) < 0:\n                    Q[:, 0] *= -1\n\n                # Highly variable axis scales (log-uniform across axes)\n                # log-space range roughly [-6, 2] -> dims in [e^-6, e^2] ~ [0.0025, 7.39]\n                dims_log = rng.uniform(-6.0, 2.0, size=dim)\n                dims = np.exp(dims_log)\n\n                Sigma_inv_i = Q @ np.diag(1.0 / (dims**2)) @ Q.T\n                self.cov_inv.append(Sigma_inv_i)\n\n                # Depths: negative valleys; keep global minimum at origin\n                # Scale relative to the global depth to preserve hierarchy\n                w_i = -rng.uniform(0.25, 1.0) * abs(self.weights[0])\n                self.weights.append(w_i)\n\n                placed = True\n            if not placed:\n                # Fallback basin if placement failed\n                c = rng.uniform(-5.0, 5.0, size=dim)\n                self.centers.append(c)\n\n                A = rng.normal(size=(dim, dim))\n                Q, _ = np.linalg.qr(A)\n                if np.linalg.det(Q) < 0:\n                    Q[:, 0] *= -1\n                dims_log = rng.uniform(-6.0, 2.0, size=dim)\n                dims = np.exp(dims_log)\n                Sigma_inv_i = Q @ np.diag(1.0 / (dims**2)) @ Q.T\n                self.cov_inv.append(Sigma_inv_i)\n\n                w_i = -rng.uniform(0.25, 1.0) * abs(self.weights[0])\n                self.weights.append(w_i)\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n        val = 0.0\n        for c, invS, w in zip(self.centers, self.cov_inv, self.weights):\n            diff = x - c\n            expo = float(-0.5 * diff @ invS @ diff)\n            val += w * np.exp(expo)\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_gaussians_improved_v2 scored on:NOT Basins 0.761, GlobalLocal 0.841,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d7c29c20-6e50-4e26-8267-8e59c527418b"], "operator": null, "metadata": {"ela_features_2D": [0.10840319167623247, 0.802851126982959, 0.10422427034216333, 0.12256544931850188, 1.1854468365586506, 0.13288229626359938, 0.16649291707825722, 2.7727913787587206, 0.3158136044270546, -2.432881575345543, 7.70791954411388, 3.2, 0.31059486270183, 0.6092433941916722, 0.2827280721057722, 0.3817464700335699, -0.3313132648042523, 0.3896417646059209, 0.5006402602127826, 0.5730856998821232, 0.7944171144750705, 0.22946948117240282, 0.4694558927946126, 0.5491291212669381, 0.7796699350551494, -0.31936892577414505, -0.2612970133627206, -0.2233853562725911, -0.10757538117187035, -0.39587995483320965, -0.2726835934651264, -0.23170148999566292, -0.1132322643013433, 1.0, 1.0, 0.7333333333333332, 1.0, 0.522054661333505, 0.5220438579990175, 0.47401129545777876, 0.43976289381134903, 0.5561620335234595, 1.0820820820820818, 0.3953438623652138, -0.3153153153153152, 0.42771084337349397], "score_NOT Basins_2D": 0.9994405250763521, "score_GlobalLocal_2D": 0.9163618087768555, "ela_features": [0.016501080093484544, 1.0090367354069512, 0.004110727264065581, 0.027828506573926583, 9.706221221394923, 0.025572596325746554, 0.12943917842638822, 2.386116576642919, 0.27111882155863914, -6.994046836820762, 62.3744257933608, 6.4, 0.8457336288207848, 0.8652843265439276, 0.6185926610468476, 0.18778318547754463, -0.36828150723578545, 0.5927126818034054, 0.6203354345016932, 0.6708830362478272, 0.7604357655049163, 0.5812814428831073, 0.5984799996525262, 0.6542863164398487, 0.7522272691317149, -0.3582220722811318, -0.33393025544319277, -0.28947306178370064, -0.21070840610850042, -0.37007996991649483, -0.3548887033585803, -0.3055691711498127, -0.2190030901037648, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21873264389740038, 0.21875025744890966, 0.2160282243210748, 0.19219637431964065, 0.6153779992631956, 0.2692692692692692, 0.00025557589168251837, -2.3173173173173174, 0.5168269230769231], "score_NOT Basins_5D": 0.1488361954689026, "score_GlobalLocal_5D": 0.2850354313850403, "ela_features_10D": [-0.003110752345364709, 0.99826914249093, 0.00016344969203314002, 0.001467668353023623, 12.108507645225435, -0.02052437247797987, 0.006829558769915889, 3.4859704612241145, -0.018373665747092694, -38.05326724117033, 1648.0250834635558, 3.6, 0.9710008609874141, 0.9290485494616065, 0.6815359095982754, 0.11024433852075062, -0.2313634945203757, 0.6676920680087951, 0.7229793637985111, 0.7712339956080323, 0.8503812804700617, 0.6680117401560015, 0.723664778123361, 0.7718863414897974, 0.8503434413873757, -0.4214816581863358, -0.35135823543000655, -0.2901544361048001, -0.18976839278454616, -0.42224521624847605, -0.351462572334, -0.2901308949998723, -0.19034445771801875, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10926973592769681, 0.1092664236399393, 0.10919042291186207, 0.09944745195494473, 0.5182969595648101, -1.6366366366366367, 0.0, -Infinity, 0.5587670136108887], "score_NOT Basins_10D": 0.76080322265625, "score_GlobalLocal_10D": 0.8408164381980896}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [4.72139992821255, -3.610288817101379], -23.891014006254323], [9, [-2.0236794948446786, -3.474017867033754], -72.46488552992629], [11, [-4.158278581596383, 2.8230615411085838], -13.046650754755136], [2, [1.9297479789762804, -1.9678989762518786], -16.187294179994176], [1, [0.5813282695640553, -3.004116198506782], -22.497923377667963], [2, [-4.752907309043297, -4.571348283035466], -29.53997505332957], [7, [-4.813886700378203, -3.8066202885539298], -36.04392714128186], [3, [3.747778384805723, -2.7857892938431563], -27.490150977784214], [6, [0.7178396270915409, -3.1437264903163733], -33.98461394931761], [1, [0.1948204883213884, -2.447914751292032], -12.763045376548298], [4, [-0.243175402401353, -3.275492929108595], -33.99981903487119], [7, [0.009246732663603922, 0.009631435284422186], -37.418260878508256], [5, [2.936369183639455, -0.06820116925623838], -11.258442543746257], [4, [3.468988984115758, 3.8816544003115006], -20.647609535603273], [18, [-1.8186364535956392, -1.2203285880474366], -23.391526660297902], [1, [4.679179951983812, 2.4769355986105333], -1.9331076458071914], [11, [1.5486050396666966, 0.16885271604958035], -20.844778807452993], [3, [3.8169101089094393, -1.537795149696532], -23.91054237364214], [3, [4.840046974603072, 4.046885156641358], -23.90844627751245]], "nr_of_basins": 19, "f_opt_dim_2": -37.41930265457239, "x_opt_dim_2": [0.014382729401417292, 0.01091318767291779], "f_opt_dim_5": -22.939590769024047, "x_opt_dim_5": [-4.4947782172289816e-05, 0.000180306001797025, 3.751125223449879e-05, 0.00010570187227907415, -4.649356166302752e-06]}
{"id": "59806853-252d-41a0-9a6d-4202f6b1c993", "fitness": 0.5961517956263075, "name": "landscape_not_homogeneous_aniso_ext_v2", "description": "A more diverse nonuniform anisotropic multi-well landscape with per-well diagonal covariances and varied depths to break basin-size homogeneity. The deepest well is anchored at the origin to create a pronounced global minimum, while other wells have irregular centers, depths and diagonal covariances to ensure highly non-homogeneous basin sizes and strong global-local contrast. A ripple term further disrupts basin uniformity, challenging robust optimization benchmarks.", "code": "import numpy as np\n\nclass landscape_not_homogeneous_aniso_ext_v2:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = int(dim)\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2026)\n\n        # number of wells (basins)\n        self.num_wells = 24\n\n        # centers of the Gaussian wells, designed to be non-uniformly distributed\n        self.centers = np.zeros((self.num_wells, self.dim))\n        for i in range(self.num_wells):\n            cluster = self.rng.integers(0, 3)\n            if cluster == 0:\n                # compact cluster near origin\n                self.centers[i] = self.rng.normal(loc=0.0, scale=0.9, size=self.dim)\n            elif cluster == 1:\n                # cluster near corners with some jitter\n                corner = self.rng.choice([-4.0, 4.0], size=self.dim)\n                self.centers[i] = corner + self.rng.normal(scale=0.7, size=self.dim)\n            else:\n                # broader, far-from-origin cluster with directional bias\n                self.centers[i] = self.rng.normal(loc=0.0, scale=2.0, size=self.dim)\n                self.centers[i] += self.rng.choice([-4.0, 4.0], size=self.dim) * self.rng.uniform(0.4, 0.9)\n\n        # clip centers to search space bounds\n        self.centers = np.clip(self.centers, -5.0, 5.0)\n\n        # depths of the wells (positive; deeper means stronger negative contribution)\n        self.depths = self.rng.uniform(0.6, 3.8, size=self.num_wells)\n\n        # deepest well should be anchored at the origin; ensure origin is the deepest\n        deepest_idx = int(np.argmax(self.depths))\n        self.centers[deepest_idx] = np.zeros(self.dim)\n\n        # per-well per-dimension standard deviations (diagonal covariances)\n        raw_sigmas = self.rng.lognormal(mean=0.0, sigma=0.9, size=(self.num_wells, self.dim))\n        self.sigmas = np.clip(raw_sigmas, 0.05, 4.0)\n\n        # introduce irregular elongation on random axes for more heterogeneity\n        for i in range(self.num_wells):\n            if self.rng.random() < 0.6:\n                axis = self.rng.integers(0, self.dim)\n                self.sigmas[i, axis] *= self.rng.uniform(1.6, 3.0)\n\n        # inverse variances for efficient exponent calculation\n        self.inv_covs = 1.0 / (self.sigmas ** 2)  # shape: (num_wells, dim)\n\n        # depth scaling to reduce influence of non-global wells\n        # ensure the global minimum at the origin is the deepest overall\n        self.scaling = self.rng.uniform(0.02, 0.42, size=self.num_wells)\n        self.scaling[deepest_idx] = 1.0\n        self.effective_depths = self.depths * self.scaling\n\n        # ripple term to break basin-size homogeneity and amplify global-local contrast\n        self.ripple_strength = self.rng.uniform(0.12, 0.22)\n        self.ripple_dir = self.rng.normal(size=self.dim)\n        norm = np.linalg.norm(self.ripple_dir)\n        if norm == 0:\n            self.ripple_dir = np.ones(self.dim)\n            norm = self.dim\n        self.ripple_dir /= norm\n        self.ripple_omega = 2.0 * self.rng.uniform(0.8, 1.2)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i (-effective_depths[i]) * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n        plus a small ripple term to break basin-size homogeneity.\n\n        The global minimum is anchored at the origin (deepest well center at origin).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # diff shape: (num_wells, dim)\n        diff = x - self.centers  # broadcasting\n\n        # exponent for each well: -0.5 * sum_j (diff_j^2 / sigma_ij^2)\n        exponent = -0.5 * np.sum((diff ** 2) * self.inv_covs, axis=1)\n\n        # contributions from all wells with scaled depths\n        contributions = -self.effective_depths * np.exp(exponent)\n\n        # base landscape value (sum of contributions)\n        val = float(np.sum(contributions))\n\n        # optional small ripple to break basin-size homogeneity\n        ripple = self.ripple_strength * np.sin(self.ripple_omega * np.dot(x, self.ripple_dir))\n        return val + ripple", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_not_homogeneous_aniso_ext_v2 scored on:NOT Basins 0.004, GlobalLocal 0.009,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["836c47f8-afdf-46de-b319-c7d66ac0f7f7"], "operator": null, "metadata": {"ela_features_2D": [0.006436446797993956, 0.7805217798349815, 0.024554745930581528, 0.059666966118856066, 22.35193252661953, 0.01909971780238744, 0.43878302421946636, 2.069406697143609, 0.46028825945845353, -1.8194009055493052, 3.233259994817781, 2.0, 0.5140660045654538, 0.6772253715709784, 0.4356933604601621, 0.35696433776342384, -0.24151805303979446, 0.3206133217420208, 0.4902519715057682, 0.6077841734546553, 0.6152853048693, 0.2834186421906709, 0.43261360683606487, 0.5470095658056222, 0.5751412723965768, -0.35559678800576483, -0.2668155787461727, -0.20529718981525852, -0.20136698935035655, -0.36862181427315516, -0.2918789928218878, -0.23303184778348518, -0.21855510497062852, 1.0, 1.0, 1.0, 1.0, 0.5197944619217044, 0.5197408210417654, 0.4306482548280647, 0.37302387263665526, 0.7307434220172111, 0.9019019019019016, 0.32993561304418967, -0.22722722722722716, 0.3622489959839358], "score_NOT Basins_2D": 0.9596826136112213, "score_GlobalLocal_2D": 0.7688921093940735, "ela_features": [0.017565972926846675, 0.7752640225418654, 0.009695052566106383, 0.049292917867690536, 5.596979964745186, 0.018290924217501604, 0.2268350147306748, 2.375150991861689, 0.39116905622161624, -1.7213622835981226, 5.979825634024913, 5.0, 0.6602765221745992, 0.8206217447379345, 0.5060623100250609, 0.2215570464745463, -0.569956269634017, 0.509500315444293, 0.5910647638655913, 0.7009703077781821, 0.8411275322623641, 0.4940456735109054, 0.5784793745121314, 0.6853357605892432, 0.8319278143936435, -0.43142064821610393, -0.35967986305829064, -0.26300953467162935, -0.1397355722477947, -0.4472556674301442, -0.37262585721079394, -0.278153083523416, -0.1485690372821921, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21630531895317895, 0.21631556892611728, 0.20862847928713807, 0.19349232319252055, 0.8557633352801114, 0.30130130130130117, 0.2579815090127616, -0.35935935935935925, 0.6041666666666667], "score_NOT Basins_5D": 0.997353230137378, "score_GlobalLocal_5D": 0.8377126455307007, "ela_features_10D": [0.0005304021118421431, 0.5093022018179599, 0.0015365883543325323, 0.04678297116932454, 70.42183406472648, -0.0009628306798743936, 0.0011751930041204784, 35.541601419386225, -0.0035154884231029413, 0.0013618554209973877, -1.5076129662542734, 2.2, 0.6291799758041892, 0.8808974956039585, 0.4853937688835844, 0.15177516379036965, -0.5648719081302186, 0.9962540773186482, 0.9990703156136134, 1.0039814433794345, 0.9986882042757553, 0.9988602498246042, 0.9993529798106426, 1.004009935762864, 0.9986763555867377, -0.004750865627924173, -0.001180159912786438, 0.005048981789895724, -0.0016638437460281263, -0.0014509240531512368, -0.000827801316611021, 0.005097091897427797, -0.0016843395999033284, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11093650510396098, 0.1109331657426336, 0.13137784056066823, 0.10156086190679706, 0.8908943249936081, 0.3813813813813812, 0.4376005102038835, -0.05105105105105105, 0.6654923939151322], "score_NOT Basins_10D": 0.003937661647796631, "score_GlobalLocal_10D": 0.009332513436675072}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [2.3295518174846803, 3.412030116274966], -2.4655251966749616], [14, [-1.5968333540423973, -1.79941561136777], -2.3271406485649293], [3, [4.964021228041856, 3.502541667594951], -1.1770102923214645], [8, [-4.409847866816375, -2.3692699477558112], -1.9710726770802713], [14, [1.7317956921108009, -2.1054253487586228], -2.497525323472729], [44, [0.6732592570207647, 0.027285787366307924], -6.728806203449946], [6, [-3.520024672978734, 3.4655806878933157], -1.487120167297963]], "nr_of_basins": 7, "f_opt_dim_2": -6.728806306844615, "x_opt_dim_2": [0.6731954358424317, 0.027374463130744507], "f_opt_dim_5": -4.573069160561575, "x_opt_dim_5": [0.0019587601854896652, -0.01085460517821828, -6.783953734514745e-05, -0.0033792393843678505, -0.0546145089236411]}
{"id": "9350fc9a-21b5-4bc1-b5b3-93c8cee2b57e", "fitness": 0.6725933004636317, "name": "landscape_min_quadratic_envelope", "description": "A non-homogeneous, anisotropic multi-well landscape formed by the minimum over several fully-coupled quadratic wells. Each well is an obliquely oriented ellipsoid (via a full SPD matrix) centered at different locations, with the global minimum at the origin. The non-diagonal covariances ensure irregular basin sizes and shapes, creating a strong global-local minima contrast while avoiding basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_min_quadratic_envelope:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # deterministic seed for reproducibility\n        self.rng = np.random.default_rng(2025)\n\n        # number of wells (basins)\n        self.num_wells = 12\n\n        # centers of the wells; first well at the origin (global minimum)\n        rest_centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells - 1, self.dim))\n        self.centers = np.vstack([np.zeros((1, self.dim)), rest_centers])\n\n        # per-well depths; ensure a global minimum at the origin with depth 0\n        self.depths = self.rng.uniform(0.2, 3.5, size=self.num_wells)\n        self.depths[0] = 0.0\n\n        # per-well full SPD matrices (not diagonal) to create rotated, anisotropic wells\n        self.covariances = []\n        self.inv_covariances = []\n        for i in range(self.num_wells):\n            # random full SPD via A A^T\n            A = self.rng.normal(size=(self.dim, self.dim))\n            Sigma = A @ A.T\n\n            # heterogeneously scale to create non-homogeneous basin sizes\n            scale = self.rng.uniform(0.3, 4.0)\n            Sigma *= scale\n\n            # small regularization for numerical stability\n            Sigma += np.eye(self.dim) * 0.01\n\n            self.covariances.append(Sigma)\n            self.inv_covariances.append(np.linalg.inv(Sigma))\n\n        self.covariances = np.array(self.covariances)\n        self.inv_covariances = np.array(self.inv_covariances)\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation:\n        f(x) = min_i [ depth_i + (x - center_i)^T Cov_i (x - center_i) ]\n        - Each well i is a quadratic (ellipsoidal) basin with center_i and SPD Cov_i.\n        - The global minimum sits at the origin with value 0 (depth_0 = 0, x = 0).\n        - The minimum across wells yields irregular, non-homogeneous basins with strong global-local contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        values = []\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            val = self.depths[i] + diff.T @ self.covariances[i] @ diff\n            values.append(val)\n\n        return float(min(values))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_min_quadratic_envelope scored on:NOT Basins 0.999, GlobalLocal 0.015,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["31692d02-1f85-4234-8c65-dfc4559d66c5"], "operator": null, "metadata": {"ela_features_2D": [0.2225639225370168, 0.2884857040166967, 0.16269712542121778, 0.2811765609456578, 1.7482718976811338, 0.31686534493757285, 0.7279572023929664, 1.2763370853604585, 0.8193299070197011, 0.8805323089013232, 0.15095888896785645, 1.8, 0.3800318636695873, 0.6459352732597641, 0.344937535250744, 0.3643604966046092, -0.2387268446809457, 0.21235535971300043, 0.3652997399500937, 0.5185430876563084, 0.6100646607325042, 0.17298214292573372, 0.3133711025792213, 0.5138314290452216, 0.5873777673355486, -0.4118507462750765, -0.3318830245369848, -0.2517560948998324, -0.2038961074513581, -0.4245306844338138, -0.3524865829833399, -0.24958757403371007, -0.2118180371598152, 1.0, 1.0, 1.0, 1.0, 0.5274809864024255, 0.5274732729711167, 0.46956903665615685, 0.4918619794438861, 0.7236651049057324, 0.9579579579579576, 0.49154330174128846, -0.07107107107107105, 0.40080321285140563], "score_NOT Basins_2D": 0.9902415229007602, "score_GlobalLocal_2D": 0.9056344032287598, "ela_features": [0.07194166388959715, 0.25653951202148545, 0.01590889052815376, 0.08825735726430531, 13.198064174480843, 0.2031700088905776, 0.3548411154643456, 2.3072168955740073, 0.5685679170008092, 1.442365534351203, 3.0809901745279147, 2.4, 0.6735557854011963, 0.8391988164444995, 0.4916545993237076, 0.20849523094836067, -0.396445331743364, 0.8173689087596767, 0.810765430580544, 0.8273686714421222, 0.8713643090130649, 0.8155045212327341, 0.8075480679858732, 0.8271860622574312, 0.8691271116468187, -0.16062332603835777, -0.16642561672084305, -0.1518248630231459, -0.11313256122795752, -0.1630602459006345, -0.17007130960674455, -0.15271721885824635, -0.11565775055401428, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2188497473231922, 0.21884158876450824, 0.21060480177072613, 0.2157789374428171, 0.8259778505318758, 0.20520520520520513, 0.18754603498390326, -0.4794794794794794, 0.5375], "score_NOT Basins_5D": 0.9997544568614103, "score_GlobalLocal_5D": 0.12545202672481537, "ela_features_10D": [0.27198275889320334, 0.14187985830828706, 0.020040656908168482, 0.15815794411671086, 8.365970264715182, 0.4743959679657852, 0.42193450880898914, 1.9214248271369954, 0.6635991976478713, 0.876863216073678, 1.012076784234106, 2.0, 0.8327025455819352, 0.9175163840372026, 0.6050313594692353, 0.12275618817077469, -0.45747300504263544, 0.8667385670867971, 0.87634104744576, 0.8818591457938997, 0.9168200604957601, 0.8656366556004658, 0.8751717703983133, 0.8785066333648791, 0.9151070931709011, -0.16898954095111418, -0.15681115038333965, -0.14981286736909533, -0.10547931256666736, -0.17079873452368882, -0.1586724588725076, -0.15443092983720202, -0.10790687936527817, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11083323891938375, 0.11083405647891753, 0.11038787236797945, 0.139919976493087, 0.8519571635991336, -0.1271271271271271, 0.10591231927338436, -0.7437437437437435, 0.5864691753402722], "score_NOT Basins_10D": 0.9991820877767168, "score_GlobalLocal_10D": 0.015295305289328098}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [-2.664338634847292, -2.7718040486788316], 3.2574798871337873], [17, [-0.00041989745385667015, 0.0006790062319803815], 2.460187007641585e-07], [4, [3.752492304449726, -0.5888076061695733], 2.710757424455971], [8, [-2.261621362823571, 0.6101361491889675], 1.921385146201216], [18, [1.4053855429864717, -1.708151812905788], 1.8033132531068856], [9, [-3.4950233470303007, -0.06690928633158315], 2.780685785459129], [14, [2.6088568566065833, 2.706321901103939], 0.5625232890184754], [9, [-1.4749070007459317, 3.3361514460447994], 1.159723499377021], [4, [-1.674582154010574, -2.3147611830342765], 1.117904578700915], [6, [3.8058814219568533, -3.3811056139162248], 1.837798098383357]], "nr_of_basins": 10, "f_opt_dim_2": 0.0, "x_opt_dim_2": [3.035242044506685e-163, 4.9847445472744485e-163], "f_opt_dim_5": 2.2168183189209145, "x_opt_dim_5": [-0.343177792225251, -1.5905406741725105, 2.4842297259478547, -0.04974349261711301, 0.5038305419241956]}
{"id": "03e2561f-fe11-4f04-8f62-396dfe8fe8a4", "fitness": 0.8729366852646004, "name": "landscape_global_local_contrast_not_homogeneous_gaussians", "description": "A highly irregular, non-homogeneous multi-well Gaussian landscape. Each well is an anisotropic Gaussian with its own random orientation and a broad, heterogeneously spread spectrum of widths and depths. This creates wide variation in basin sizes (not basin-homogeneous) and a pronounced global-local minima contrast, while keeping a deep global minimum at the origin. The landscape is defined as a sum of negative Gaussian wells, evaluated in a [-5,5]^dim search space for robust benchmarking of black-box optimizers.", "code": "import numpy as np\n\nclass landscape_global_local_contrast_not_homogeneous_gaussians:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins) - increased to break basin-size homogeneity\n        self.num_wells = 20\n\n        # Centers of the wells: include a deep global minimum at the origin\n        # and several clusters to create irregular basin shapes/sizes.\n        def pad_to_dim(vec, dim):\n            v = np.array(vec, dtype=float)\n            if v.size < dim:\n                v = np.concatenate([v, np.zeros(dim - v.size)])\n            return v[:dim]\n\n        # Define a few cluster bases (pad to dim)\n        cluster_bases = [\n            [0.0, 0.0, 0.0, 0.0, 0.0],          # global deep well at origin\n            [4.0, -3.0, 0.0, 0.0, 0.0],\n            [-3.0, 4.0, 3.0, 0.0, 0.0],\n            [2.0, -4.0, -3.0, 3.0, 0.0],\n            [0.0, 3.0, -4.0, 0.0, 2.0],\n        ]\n        centers = np.zeros((self.num_wells, self.dim))\n        centers[0] = np.zeros(self.dim)  # origin for global deep well\n\n        # Create remaining centers by perturbing cluster bases with variable spread\n        for i in range(1, self.num_wells):\n            base = pad_to_dim(cluster_bases[self.rng.integers(0, len(cluster_bases))], self.dim)\n            # per-well spread, enabling strong heterogeneity in basin sizes\n            spread = self.rng.uniform(0.2, 4.0, size=self.dim)\n            centers[i] = base + self.rng.normal(0.0, spread)\n\n        self.centers = centers\n\n        # Depths of wells (positive values; global minimum is the deepest at origin)\n        depths = self.rng.uniform(0.5, 6.0, size=self.num_wells)\n        depths[0] = self.rng.uniform(14.0, 28.0)  # global minimum at origin\n        self.depths = depths\n\n        # Per-well covariances (SPD) to break basin homogeneity\n        # Generate a random rotation and a broad spectrum of eigenvalues for each well\n        self.covariances = []\n        self.inv_covs = []\n        for i in range(self.num_wells):\n            # Random rotation matrix via QR decomposition\n            M = self.rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n\n            # Eigenvalues drawn log-uniformly to create wide variation in basin shapes/sizes\n            eigs = 10.0 ** self.rng.uniform(-2.0, 2.0, size=self.dim)\n\n            Cov = Q @ np.diag(eigs) @ Q.T\n\n            # Per-well width/scale factor (also log-uniform in effect)\n            w = self.rng.uniform(0.3, 4.0)\n            Cov = Cov * (w ** 2)\n\n            # Numerical stability / PD guarantee\n            Cov = (Cov + Cov.T) / 2.0\n            Cov[np.arange(self.dim), np.arange(self.dim)] += 1e-8\n\n            self.covariances.append(Cov)\n            self.inv_covs.append(np.linalg.inv(Cov))\n\n        self.inv_covs = [np.array(inv) for inv in self.inv_covs]\n\n        # Precompute a simple global-local contrast score to quantify the intended NOT-Basin property\n        self.global_local_contrast = self._estimate_global_local_contrast()\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-0.5 * (x - center[i])^T * inv(Cov_i) * (x - center[i]))\n\n        This yields multiple local minima corresponding to wells with varying depths,\n        widths (anisotropic), and centers, producing non-homogeneous basins\n        and a pronounced global minimum at the origin.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            inv_cov = self.inv_covs[i]\n            dist2 = diff @ inv_cov @ diff\n            total += -self.depths[i] * np.exp(-0.5 * dist2)\n\n        return float(total)\n\n    def _estimate_global_local_contrast(self):\n        \"\"\"\n        Estimate a simple GlobalLocal contrast score using wells' centers.\n\n        - Evaluate f at each center (center of each well)\n        - Global minimum is assumed to be at origin (center 0)\n        - Local minima are values at other centers\n        - Contrast is defined as how much deeper the global min is relative to\n          the average absolute depth of local center values, normalized by the average center value\n        \"\"\"\n        values_at_centers = np.array([self.f(self.centers[i]) for i in range(self.num_wells)])\n\n        global_min_val = values_at_centers[0]\n        local_min_vals = values_at_centers[1:]\n        avg_center = np.mean(values_at_centers)\n\n        denom = abs(avg_center) + 1e-9\n        local_depth_mean = np.mean(np.abs(local_min_vals)) if local_min_vals.size > 0 else 0.0\n\n        contrast = max(0.0, (abs(global_min_val) - local_depth_mean) / denom)\n        return float(contrast)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_global_local_contrast_not_homogeneous_gaussians scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b743201f-fd45-4566-925b-f6e12af38665"], "operator": null, "metadata": {"ela_features_2D": [-0.002161143008801303, 0.5865896364360748, 0.013922836935476652, 0.03567417501710125, 5.874731494687177, 0.21730461074866003, 0.45056528686918007, 7.045813390399711, 0.7108493518827697, -0.3730149166139597, -1.2767414210391836, 2.0, 0.4727179357885243, 0.6806503250124006, 0.3969184334087156, 0.3573623601607148, -0.16895395193936802, 0.19531561766947825, 0.3654449181702136, 0.6147974728848592, 0.7045982961284231, 0.18356668245172483, 0.2823966281272567, 0.5306087337585896, 0.6261069956696472, -0.42074448513016083, -0.33177863418749454, -0.2014007415304216, -0.154459236178853, -0.4187700270367759, -0.36805447552819215, -0.2407507848609371, -0.19177730779729835, 1.0, 1.0, 1.0, 1.0, 0.5199128430455595, 0.5197338312745123, 0.35931990601052777, 0.35447006462899433, 0.6878511966814719, 0.6056056056056054, 0.3378043680572703, -0.07507507507507502, 0.37269076305220883], "score_NOT Basins_2D": 0.9972193725407124, "score_GlobalLocal_2D": 0.9946850538253784, "ela_features": [0.013267003319609217, 0.7324059435777833, 0.005413600226491284, 0.07249773950021111, 15.831890078983452, 0.26633526606829383, 0.38971430471858115, 3.5592427172277725, 0.7212402827950753, -0.8273619706455679, 0.11206150363380277, 1.0, 0.8195333725290748, 0.8584855508577378, 0.5965625605326633, 0.1946745691148604, -0.45062596498889673, 0.6263004545266525, 0.6880866247241975, 0.7438290540637883, 0.8324352888148117, 0.59428567927958, 0.6597319920327787, 0.7188502629936853, 0.8153525022337575, -0.32876513050028, -0.2744049587243349, -0.22536438113223395, -0.1474152811928772, -0.3589312408517393, -0.30102292863095415, -0.2487210094949713, -0.16335248522084334, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21418741079695636, 0.21419005787297904, 0.1972890883709284, 0.19061329301224586, 0.7836847296341715, 0.26126126126126115, 0.18085377139312656, -0.4074074074074073, 0.5057692307692309], "score_NOT Basins_5D": 0.9793400503695011, "score_GlobalLocal_5D": 0.26679158210754395, "ela_features_10D": [0.01792278136310286, 0.9728070464154523, 0.0022462061055526163, 0.020120703299354326, 13.293099598955692, 0.037912779096673274, 0.04670294954374814, 13.94727790138619, 0.08631511276523789, -6.9353423514028325, 63.498370213902604, 5.6, 0.7981867118831103, 0.9105272107927055, 0.5704105928997264, 0.12914184556212352, -0.508745195406417, 0.892251423608234, 0.8972843555020174, 0.908192596763431, 0.9325532454205382, 0.8940188086317914, 0.8969414210369158, 0.9072782961046604, 0.9320229469424911, -0.1366595008373963, -0.13027791832087793, -0.11644338618122259, -0.08554516858311563, -0.1347884638105306, -0.13107390791221957, -0.11792923930260057, -0.08645654635692872, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1104620689899281, 0.11046185523669065, 0.1098214533436721, 0.10501091283043391, 0.6544146874689353, -0.019019019019019034, 0.000584756540637436, -2.0010010010010015, 0.6028022417934348], "score_NOT Basins_10D": 0.9999403693109343, "score_GlobalLocal_10D": 0.9996436834335327}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [-5.0, 2.7777777777777786], -36.41847724219181], [8, [3.258925846437613, 3.032660906043055], -15.889599252901444], [4, [0.2962032097554601, 3.8012390088381016], -15.341038369757577], [18, [2.114362772077532, -1.0093817707682937], -40.59345253784017], [16, [2.769190095422452, -1.3018675765276564], -41.60557580819569], [7, [0.875204354274117, -0.40586680279887294], -40.71700991154447], [2, [3.8505086379391833, 4.407335424113666], -13.620367436957842], [36, [-3.9314440330885545, 1.6076024773847204], -37.3914813293818], [1, [-4.475006732251394, -4.820997391857171], -10.093012795779948]], "nr_of_basins": 9, "f_opt_dim_2": -41.825102388454766, "x_opt_dim_2": [2.725856960621132, -1.2730087445061264], "f_opt_dim_5": -24.298609032202947, "x_opt_dim_5": [-0.21573662867929375, 1.4872564938515906, -1.1305264286181598, -2.8115957228934483, -0.849188225308989]}
{"id": "2387f19b-cbb6-49b9-968d-49019ee970c7", "fitness": 0.8934333885990782, "name": "landscape_enhanced_global_local_contrast_gaussians_improved", "description": "Enhanced non-homogeneous, anisotropic Gaussian multi-well landscape with an explicit, strengthened global-local minima contrast. The global minimum sits at the origin in a deep, narrow well, while other wells have varied centers, depths, and highly anisotropic covariances to create irregular basin sizes. The benchmark emphasizes a stronger distinction between the global optimum and local minima, improving the GlobalLocal contrast while preserving a consistent search space [-5,5]^d.", "code": "import numpy as np\n\nclass landscape_enhanced_global_local_contrast_gaussians_improved:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2025)\n\n        # number of wells (basins) - scale with dimension, ensure enough variety\n        self.num_wells = min(20, max(6, self.dim * 2 + 2))\n\n        # centers of the Gaussian wells, already anchoring global minimum at the origin\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        self.centers[0] = np.zeros(self.dim)  # global minimum at origin\n\n        # depths of the wells (positive values; function is sum of negative Gaussians)\n        # global minimum is a deep, narrow well at the origin\n        self.depths = self.rng.uniform(0.5, 2.5, size=self.num_wells)\n        self.depths[0] = self.rng.uniform(12.0, 20.0)  # deep global minimum\n\n        # per-well anisotropic covariances (SPD) to break basin homogeneity\n        self.covariances = []\n        for i in range(self.num_wells):\n            # Random PD matrix: Cov = A A^T\n            A = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Cov = A @ A.T\n\n            # Normalize scale to avoid extreme eigenvalues\n            eigen_vals = np.linalg.eigvalsh(Cov)\n            max_ev = np.max(eigen_vals) if eigen_vals.size > 0 else 1.0\n            if max_ev <= 0:\n                max_ev = 1.0\n            Cov = Cov / max_ev\n\n            # Width/shape factor per well (diverse anisotropy and scale)\n            w = self.rng.uniform(0.3, 3.0)\n            Cov = Cov * (w ** 2)\n\n            self.covariances.append(Cov)\n\n        # Precompute a more robust global-local contrast score\n        self.global_local_contrast = self._estimate_global_local_contrast()\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_{i=1..num_wells} (-depth[i]) * exp(-0.5 * (x - center[i])^T * inv(Cov_i) * (x - center[i]))\n\n        This yields non-homogeneous, irregular basins with a deep global minimum at the origin\n        while other wells provide diverse local minima, enhancing global-local contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            Cov = self.covariances[i]\n\n            # Inverse of Cov (positive definite)\n            inv_cov = np.linalg.inv(Cov)\n\n            # Mahalanobis distance squared\n            dist2 = diff @ inv_cov @ diff\n\n            total += -self.depths[i] * np.exp(-0.5 * dist2)\n\n        return float(total)\n\n    def _estimate_global_local_contrast(self):\n        \"\"\"\n        Compute a robust GlobalLocal contrast score.\n\n        - Evaluate the landscape at each well center\n        - Global minimum is considered at the origin (center 0)\n        - Local minima are the values at other centers\n        - Two components are combined:\n          1) an original-like ratio comparing the global min depth to the mean magnitude of local centers\n          2) a secondary ratio based on the spread (std) of center values\n        The final contrast is the maximum of the two components to emphasize deep, easily recognizable global minima.\n        \"\"\"\n        values_at_centers = np.array([self.f(self.centers[i]) for i in range(self.num_wells)])\n\n        global_min_val = values_at_centers[0]\n        local_min_vals = values_at_centers[1:]\n\n        avg_center = np.mean(values_at_centers)\n        denom = abs(avg_center) + 1e-9\n\n        local_depth_mean = np.mean(np.abs(local_min_vals)) if local_min_vals.size > 0 else 0.0\n        contrast1 = max(0.0, (abs(global_min_val) - local_depth_mean) / denom)\n\n        std_all = np.std(values_at_centers) + 1e-9\n        contrast2 = max(0.0, (abs(global_min_val) - np.mean(np.abs(values_at_centers))) / std_all)\n\n        return float(max(contrast1, contrast2))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_enhanced_global_local_contrast_gaussians_improved scored on:NOT Basins 0.996, GlobalLocal 0.385,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b743201f-fd45-4566-925b-f6e12af38665"], "operator": null, "metadata": {"ela_features_2D": [-0.002134637453288901, 0.7965568152413465, 0.02005963609108972, 0.029636375520479957, 1.5189221964368316, 0.028547152683299947, 0.5446962034420169, 1.3926117990013063, 0.7166600833962928, -1.3941343448236139, 1.011111271999305, 1.4, 0.6399604618684234, 0.7142456131665769, 0.5350271256994565, 0.33551386211277545, -0.18044718766929851, 0.14408695923227383, 0.22751517697227458, 0.3441695580269082, 0.5336551895769384, 0.13721075061794694, 0.21936325416187735, 0.32578056002214145, 0.5088610751007663, -0.44762169622751624, -0.4039929348180397, -0.34298643314310145, -0.24388502868191003, -0.44265460853623495, -0.4005076756339282, -0.3459147645535826, -0.2519748683677604, 1.0, 1.0, 1.0, 1.0, 0.5203018875199398, 0.5202813525548196, 0.3813776328101865, 0.35575537384211825, 0.6580534936747341, 0.6496496496496494, 0.24087198889025535, -0.2432432432432432, 0.37068273092369475], "score_NOT Basins_2D": 0.9955137665383518, "score_GlobalLocal_2D": 0.9899857044219971, "ela_features": [0.056447674088041896, 1.010530446534424, 0.004772585824738357, 0.037150581632683685, 13.126425410163497, 0.08331235636493714, 0.08886585091706407, 6.756018483649879, 0.19973291878024085, -7.864300005201879, 85.46230066691932, 6.8, 0.7248492203115904, 0.8425883802766894, 0.5305669270374481, 0.20579429437575372, -0.36229094865907785, 0.6123248756240459, 0.7338896601446553, 0.7845707853972166, 0.8631897189492406, 0.6028251219681989, 0.7331579292467822, 0.778080505465056, 0.8590027454143009, -0.3409667905453756, -0.23404902866426402, -0.18947559053709861, -0.12032702788704604, -0.35107092229585135, -0.23587623656512, -0.19616543319424945, -0.12462979964035534, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21729830289343396, 0.21730461058788747, 0.21479348066581022, 0.20768562076781602, 0.5937927614506433, 0.24924924924924916, 6.006245492201585e-05, -2.3533533533533535, 0.542948717948718], "score_NOT Basins_5D": 0.9998711308289785, "score_GlobalLocal_5D": 0.9944300055503845, "ela_features_10D": [-0.001459720282536292, 0.9989595031107124, 0.000164838840327812, 0.0022272246691977036, 21.006370862757585, -0.012999404227367384, -0.001579772429099413, 4.682801866685118, -0.035765279268865725, -40.48756723492876, 1749.0493850807622, 2.8, 0.646921115477493, 0.7550659813975906, 0.3516750168379433, 0.18639000953838963, -0.13816058972423712, 0.8537366585129454, 0.8875796532439889, 0.9448407380442276, 1.0, 0.8507741774419999, 0.8859165483872566, 0.9438235933326201, 1.0, -0.18550969624271532, -0.14258586092713768, -0.06995622241997608, 0.0, -0.1897680625919696, -0.14508074209572394, -0.07142754885594874, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10999058683737559, 0.10998615148741982, 0.10991578665995787, 0.10017560446129048, 0.3515306767572996, -4.051051051051052, 0.0, -Infinity, 0.16317053642914334], "score_NOT Basins_10D": 0.9955696896649897, "score_GlobalLocal_10D": 0.38523003458976746}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [3.673260079660033, -3.2633936889770196], -2.5304945030582906], [92, [0.0783052079907766, 0.030067175939883832], -14.687049815054888]], "nr_of_basins": 2, "f_opt_dim_2": -14.687049829150276, "x_opt_dim_2": [0.0783222462414541, 0.030013889438747526], "f_opt_dim_5": -1.6208006202160468, "x_opt_dim_5": [-0.011395300697114391, -1.698386452509141, -0.13256609722880855, 3.5772303736278612, 3.37933954203529]}
{"id": "47147051-2725-4421-b4d7-fd410bd5c65d", "fitness": 0.9956421996854866, "name": "landscape_max_envelope_fullcov_hetero", "description": "A nonlinear, max-envelope multi-well landscape with strongly heterogeneous, obliquely oriented ellipsoidal wells. Each well is centered at a distinct location, with a random full covariance (including cross-dimensional coupling) and diverse depths to create irregular, non-homogeneous basin sizes. The deepest well is placed at the origin to ensure a pronounced global minimum, while other wells introduce highly non-uniform basins and a strong global-local minima contrast, challenging optimizers to distinguish true optima in a non-homogeneous landscape.", "code": "import numpy as np\n\nclass landscape_max_envelope_fullcov_hetero:\n    def __init__(self, dim=5):\n        self.dim = dim\n        # deterministic seed for reproducibility\n        self.rng = np.random.default_rng(123456)\n\n        # number of wells (basins)\n        self.num_wells = 20\n\n        # centers of the wells\n        centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        # ensure global minimum center is at the origin\n        centers[0] = np.zeros(self.dim)\n\n        # ensure other wells are reasonably spread and not all too close to origin\n        for i in range(1, self.num_wells):\n            if np.linalg.norm(centers[i]) < 1.0:\n                direction = self.rng.normal(size=self.dim)\n                direction /= np.linalg.norm(direction)\n                centers[i] += direction * self.rng.uniform(1.0, 3.0)\n\n        self.centers = centers\n\n        # depths per well; deepest well is the global minimum\n        depths = self.rng.uniform(0.6, 3.5, size=self.num_wells)\n        depths[0] = 6.0  # global minimum depth\n        self.depths = depths\n\n        # per-well full covariance matrices (SPD) to create rotated, anisotropic wells\n        covariances = []\n        inv_covariances = []\n        for i in range(self.num_wells):\n            # random orthogonal basis\n            Z = self.rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(Z)\n\n            # Eigenvalues spread to create varied basin shapes\n            eigs = self.rng.uniform(0.2, 6.0, size=self.dim)\n            D = np.diag(eigs)\n\n            # Construct a full covariance Sigma = Q D Q^T\n            Sigma = Q @ D @ Q.T\n\n            # per-well scale to induce non-homogeneous basin sizes\n            scale = self.rng.uniform(0.5, 3.5)\n            Sigma = Sigma * scale\n\n            # numerical stability\n            Sigma += np.eye(self.dim) * 0.01\n\n            covariances.append(Sigma)\n            inv_covariances.append(np.linalg.inv(Sigma))\n\n        self.covariances = np.array(covariances)\n        self.inv_covariances = np.array(inv_covariances)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = - max_i depths[i] * exp(-0.5 * (x - center_i)^T inv_cov_i (x - center_i))\n\n        This creates a max-envelope over full-covariance (obliquely oriented) wells with\n        heterogeneous centers, depths, and shapes, producing irregular basin sizes\n        and a strong global-local minima contrast.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        values = []\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            exponent = -0.5 * diff.T @ self.inv_covariances[i] @ diff\n            val = self.depths[i] * np.exp(exponent)\n            values.append(val)\n\n        return float(-max(values))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_max_envelope_fullcov_hetero scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["31692d02-1f85-4234-8c65-dfc4559d66c5"], "operator": null, "metadata": {"ela_features_2D": [0.08445766665552683, 0.6924047737069257, 0.07820956767390652, 0.1515875444872104, 1.9647489343569813, 0.10377528939807376, 0.5844868368922194, 1.1588416424819277, 0.6827601854298219, -0.9252749879733994, 2.1839186641385737, 2.4, 0.5004543319767673, 0.6790313387626303, 0.40512166758674173, 0.354270325194982, -0.2303653446353255, 0.1683190027473899, 0.24493687245906542, 0.36389882456490097, 0.5880287745154954, 0.17151364257968904, 0.24564804804046206, 0.35759186941089793, 0.5753594938532341, -0.43520357164317164, -0.3951098525212345, -0.3328546019314946, -0.21557654745862145, -0.4264115271736431, -0.3882570814606688, -0.3306279935019654, -0.21855972906731558, 1.0, 1.0, 1.0, 1.0, 0.5307641819400906, 0.5307569308150362, 0.46443162903990054, 0.4328717281386026, 0.739181532634928, 0.6216216216216214, 0.5149384123732672, -0.1071071071071071, 0.38072289156626504], "score_NOT Basins_2D": 0.9983265027403831, "score_GlobalLocal_2D": 0.9856936931610107, "ela_features": [0.0315969321731947, 0.8205546584407651, 0.011823694479649817, 0.05419585306237823, 6.120090657910016, 0.11591793859506953, 0.23933909895380684, 3.265500476253763, 0.3950412566737473, -2.042698165638206, 6.5200210547403135, 3.2, 0.7590763038998298, 0.8502336672600709, 0.5639409579687588, 0.2002805817718703, -0.5225033983087598, 0.6705657461661094, 0.748661896217617, 0.7800556325621361, 0.8638204990577917, 0.6565011469269434, 0.7453994128147589, 0.7751421518558341, 0.859981603468845, -0.2898455985405758, -0.22112960058039993, -0.19350916517409772, -0.1198113702179188, -0.30390926066865537, -0.22523686509105917, -0.1989246612995344, -0.12386699661349052, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21318739000083942, 0.21316160938229062, 0.20590890625870822, 0.20088475955311255, 0.7848726707984891, 0.33733733733733723, 0.11459666187634968, -0.6116116116116114, 0.53125], "score_NOT Basins_5D": 0.9998385458311532, "score_GlobalLocal_5D": 0.9901600480079651, "ela_features_10D": [0.1237514951345609, 0.9537455446790485, 0.0026537939181910655, 0.05278720628337352, 51.14528949704391, 0.23962752406727636, 0.22790578112717924, 4.299103981547082, 0.4132808450495199, -4.438001410702138, 30.63932877723629, 5.2, 0.8791239018690031, 0.9234818971360681, 0.6212786661887889, 0.11740202554138852, -0.536898161165497, 0.8100206787861832, 0.8312569750855173, 0.852418857357749, 0.888323724360913, 0.8034536790908288, 0.8265775144943952, 0.849669537702747, 0.8869190903325176, -0.24096654081043592, -0.2140302391140604, -0.18718875063897897, -0.14164783326724678, -0.24997249310726813, -0.22056374372849136, -0.19119566818482156, -0.14382050712540456, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10887549513883507, 0.10887886471103962, 0.10826887971198138, 0.12431063776172999, 0.7437479760218297, -0.14314314314314308, 0.011869912164211826, -1.3763763763763763, 0.5759807846277022], "score_NOT Basins_10D": 0.9999004503188189, "score_GlobalLocal_10D": 0.9999339580535889}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[7, [2.384006430872396, 3.7550001860262707], -3.366192888581277], [16, [-3.82164081105633, -1.9897560855275558], -2.9233415349450973], [19, [-1.208456457938441, 2.71288409161727], -3.386652918805684], [41, [0.0004673165581418929, 0.0006930624044421733], -5.999999181153868], [8, [3.841039727236102, 2.531787149262831], -3.185656189291795], [3, [-3.5618481178977253, 3.6594096657555126], -2.2980410619379197], [6, [3.250322670433659, -0.3395522825978791], -2.7794262728188794]], "nr_of_basins": 7, "f_opt_dim_2": -6.0, "x_opt_dim_2": [1.341283817835347e-08, 4.0320479024378e-09], "f_opt_dim_5": -6.0, "x_opt_dim_5": [-8.911426689901814e-09, 3.749380468770198e-09, -1.294799450460706e-08, 7.3412681981648416e-09, 2.180872170860701e-09]}
{"id": "5250fbdc-1b92-4f5b-8e21-79893a80ff20", "fitness": 0.9944488611975734, "name": "landscape_nh_gaussians_nonhom_improved", "description": "A novel non-homogeneous Gaussian-mixture landscape with a deep central basin and highly irregular, anisotropic wells. Each basin can be a single Gaussian component or a two-component mixture (to break symmetry and create irregular basin shapes). Covariances are drawn from a wide, log-uniform spectrum and random orientations, producing highly diverse basin sizes and shapes across dimensions. The global minimum sits at the origin, while the additional basins provide strong global-local contrast and substantial non-homogeneity in basin volumes, challenging black-box optimizers.", "code": "import numpy as np\n\nclass landscape_nh_gaussians_nonhom_improved:\n    \"\"\"\n    Highly non-homogeneous Gaussian-mixture landscape with a deep central basin.\n    Each basin can be a single Gaussian or a two-component mixture to introduce\n    irregular basin shapes and sizes. Bases use diverse SPD covariances with\n    random orientations to destroy basin-size homogeneity and create strong\n    global-local minima contrast.\n    The global minimum sits at the origin, with additional wells scattered in the\n    domain [-5, 5]^dim.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be positive.\")\n        # Deterministic seed for reproducibility\n        seed = (int(self.dim) * 987654321) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed=seed)\n\n        # Target number of basins grows with dimension, but capped for practicality\n        self.Nc_target = min(12 + self.dim, 80)\n\n        self.basins = []  # Each basin: {'comps': [{'center', 'cov_inv', 'weight'}, ...]}\n\n        # 1) Global deep basin at the origin\n        c0 = np.zeros(self.dim)\n        # Highly varied, log-uniform eigenvalues to induce extreme anisotropy\n        l0 = 10.0 ** rng.uniform(-1.0, 1.6, size=self.dim)\n        A = rng.normal(size=(self.dim, self.dim))\n        Q, _ = np.linalg.qr(A)\n        Cov0 = Q @ np.diag(l0) @ Q.T\n        CovInv0 = np.linalg.inv(Cov0)\n\n        w0 = -rng.uniform(12.0, 22.0)  # deep global minimum\n        self.basins.append({'comps': [{'center': c0, 'cov_inv': CovInv0, 'weight': w0}]})\n\n        # 2) Add additional basins with highly varied shapes, orientations, and depths\n        # Ensure centers are reasonably separated\n        attempts = 0\n        existing_centers = [c0]\n        while len(self.basins) < self.Nc_target and attempts < self.Nc_target * 60:\n            attempts += 1\n            center = rng.uniform(-5.0, 5.0, size=self.dim)\n\n            # Enforce separation from existing centers\n            if any(np.linalg.norm(center - ex) < 1.5 for ex in existing_centers):\n                continue\n\n            # Decide whether this basin is a single-component or a two-component well\n            two_component = rng.random() < 0.4  # ~40% chance of two-component basin\n\n            if two_component:\n                # Second component center offset within a reasonable radius\n                offset_scale = rng.uniform(0.5, 2.0)\n                offset_dir = rng.normal(size=self.dim)\n                if np.linalg.norm(offset_dir) == 0:\n                    offset_dir = rng.normal(size=self.dim)\n                offset = (offset_scale * offset_dir) / np.linalg.norm(offset_dir)\n                center2 = center + offset\n\n                # Component 1\n                l1 = 10.0 ** rng.uniform(-1.0, 1.6, size=self.dim)\n                A1 = rng.normal(size=(self.dim, self.dim))\n                Q1, _ = np.linalg.qr(A1)\n                Cov1 = Q1 @ np.diag(l1) @ Q1.T\n                CovInv1 = np.linalg.inv(Cov1)\n\n                # Component 2\n                l2 = 10.0 ** rng.uniform(-1.0, 1.6, size=self.dim)\n                A2 = rng.normal(size=(self.dim, self.dim))\n                Q2, _ = np.linalg.qr(A2)\n                Cov2 = Q2 @ np.diag(l2) @ Q2.T\n                CovInv2 = np.linalg.inv(Cov2)\n\n                # Weights for the two components (sum to a basin depth)\n                w_base = -rng.uniform(0.8, 8.0)\n                w1 = w_base * rng.uniform(0.4, 0.9)\n                w2 = w_base - w1\n\n                comps = [\n                    {'center': center, 'cov_inv': CovInv1, 'weight': w1},\n                    {'center': center2, 'cov_inv': CovInv2, 'weight': w2},\n                ]\n            else:\n                # Single-component basin\n                l = 10.0 ** rng.uniform(-1.0, 1.6, size=self.dim)\n                A = rng.normal(size=(self.dim, self.dim))\n                Q, _ = np.linalg.qr(A)\n                Cov = Q @ np.diag(l) @ Q.T\n                CovInv = np.linalg.inv(Cov)\n\n                w = -rng.uniform(0.8, 8.0)\n                comps = [{'center': center, 'cov_inv': CovInv, 'weight': w}]\n\n            self.basins.append({'comps': comps})\n\n            # Track centers for separation checks\n            for comp in comps:\n                existing_centers.append(comp['center'])\n\n        self.Nc = len(self.basins)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n\n        val = 0.0\n        for basin in self.basins:\n            for comp in basin['comps']:\n                diff = x - comp['center']\n                term = -0.5 * float(diff @ comp['cov_inv'] @ diff)\n                val += comp['weight'] * np.exp(term)\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_gaussians_nonhom_improved scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4730d5e1-d56f-416b-a3ee-ea0bc7e1d302"], "operator": null, "metadata": {"ela_features_2D": [0.14808148020589304, 0.5198957182076492, 0.1768513530900627, 0.2672573613891699, 1.5575901422220082, 0.20402317488216043, 0.7825100780855271, 1.2995849477580654, 0.8578601905286704, -0.14225268386462547, -0.8248592023280189, 1.2, 0.5394878566583308, 0.6879064135918138, 0.41139445234715044, 0.3568006514854975, -0.193657620506125, 0.16920733902235366, 0.2774686371799852, 0.3778083480082214, 0.5457629056036047, 0.15596693755444907, 0.25113761236633797, 0.3515730981868644, 0.5312053511084971, -0.43464021811886705, -0.3779976906484006, -0.32549847669885307, -0.2376297248916946, -0.4336787210714272, -0.3847432098468543, -0.3331412930788531, -0.24084339559156173, 1.0, 1.0, 1.0, 1.0, 0.5119918549517426, 0.5119839594190596, 0.4484921575691736, 0.46391405744764425, 0.7227540765858742, 0.5175175175175173, 0.6752432625311757, -0.031031031031031046, 0.368273092369478], "score_NOT Basins_2D": 0.9712989367544651, "score_GlobalLocal_2D": 0.9960150122642517, "ela_features": [0.03675187947070337, 0.9457219324150463, 0.0025289917564756273, 0.038516309374967805, 107.9146806194905, 0.05440788228132136, 0.10212877860110998, 8.043306003065089, 0.20038204486792138, -5.954631277556753, 53.94392159221203, 6.6, 0.6825425006386376, 0.833239598504988, 0.5187578861949182, 0.2118423408000063, -0.45185587563258567, 0.7184358655421594, 0.7986493171443716, 0.8488047512960681, 0.896691589697641, 0.7131177831479377, 0.7911384070857007, 0.8429284776587428, 0.8915042622874818, -0.24773286765541647, -0.1771577204132224, -0.13302909108433655, -0.09089574048047552, -0.25378734990842566, -0.18477641649422302, -0.1389587461348989, -0.09598661597698388, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21328679172736723, 0.21329763167832655, 0.2105386555847207, 0.20223269560267537, 0.680562014616991, 0.21721721721721715, 0.02908045426465239, -1.204204204204204, 0.5658653846153847], "score_NOT Basins_5D": 0.999900546434219, "score_GlobalLocal_5D": 0.9996697902679443, "ela_features_10D": [-0.0018978218411206615, 0.9938127239430763, 0.0002220230068284503, 0.003543696639115375, 16.132071148463076, 0.0030339470833055547, 0.023912811190968285, 10.600993392730725, 0.027368743262411076, -15.491051877280913, 324.9558044028722, 5.8, 0.8461318053789929, 0.9155713147406711, 0.6132533531335718, 0.12373079709412269, -0.42535774673837495, 0.8248614903241661, 0.8728144855803256, 0.8962891257358325, 0.9281141913437161, 0.8256029634648081, 0.8717676916682425, 0.8950785199124581, 0.9268915908197919, -0.22209287466044678, -0.16128180327066413, -0.13151374635234497, -0.09115690812707392, -0.22169678731627748, -0.16300293840705815, -0.13337151054875887, -0.0929320195775158, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10848753512572903, 0.1084990868357029, 0.108268442326715, 0.09908141627743194, 0.6169126255945395, -0.35535535535535523, 1.2962020831343106e-05, -3.5305305305305312, 0.5916733386709367], "score_NOT Basins_10D": 0.9999403693109343, "score_GlobalLocal_10D": 0.9998685121536255}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[13, [-4.252821324625029, -0.37548162586754685], -19.98044284789596], [46, [-1.3167219106109416, 1.3027133574572354], -28.67310253721808], [5, [-4.634579469483114, 4.163901123823947], -15.216206702381415], [36, [0.5075360119619596, -1.9280082350085046], -24.84907480262385]], "nr_of_basins": 4, "f_opt_dim_2": -28.673102905521468, "x_opt_dim_2": [-1.316720599329891, 1.3031462601800636], "f_opt_dim_5": -18.344931860735237, "x_opt_dim_5": [0.012062861775345013, -0.006239932020136811, 0.021252999340808452, -0.011652604672353255, 0.0037099340361007294]}
{"id": "ffc7162e-5451-420e-bfb7-94a4fcdf04bd", "fitness": 0.5746426712721586, "name": "landscape_nonuniform_aniso_ext_glocal", "description": "A novel landscape with nonuniform anisotropic wells and a global-local contrast booster. The global minimum is placed at the origin with a deep well, while other wells have smaller, irregular depths and anisotropic covariances. A per-well positive bump centered at non-global wells increases their local minima, enhancing the global-local minima contrast relative to the landscape average, thus challenging optimizers to distinguish truly good regions from deceptive ones.", "code": "import numpy as np\n\nclass landscape_nonuniform_aniso_ext_glocal:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = int(dim)\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2029)\n\n        # number of wells (basins)\n        self.num_wells = 18\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # depths of the wells (positive; deeper means deeper negative contribution)\n        depths = self.rng.uniform(0.5, 3.5, size=self.num_wells)\n\n        # ensure a deepest well to enforce a pronounced global minimum\n        deepest_idx = int(np.argmax(depths))\n        depths[deepest_idx] = 15.0  # very deep global minimum\n        self.deepest_idx = deepest_idx\n\n        # ensure deepest center at origin to bias the global minimum to the origin\n        self.centers[self.deepest_idx] = np.zeros(self.dim)\n\n        # per-well per-dimension standard deviations (anisotropic basins)\n        # Each well i has its own sigma vector across dimensions\n        raw_sigmas = self.rng.lognormal(mean=0.0, sigma=0.9, size=(self.num_wells, self.dim))\n        self.sigmas = np.clip(raw_sigmas, 0.05, 3.0)\n\n        # introduce additional irregularity: sometimes elongate along a random axis\n        for i in range(self.num_wells):\n            if self.rng.random() < 0.5:\n                axis = self.rng.integers(0, self.dim)\n                self.sigmas[i, axis] *= self.rng.uniform(1.6, 3.2)\n\n        # depth scaling to reduce influence of non-global wells\n        # Deep global minimum remains at full depth; others are scaled down\n        self.scaling = np.ones(self.num_wells, dtype=float)\n        for i in range(self.num_wells):\n            if i != self.deepest_idx:\n                self.scaling[i] = self.rng.uniform(0.01, 0.25)\n        self.effective_depths = depths * self.scaling\n        self.effective_depths[self.deepest_idx] = depths[self.deepest_idx]\n\n        # Precompute inverse variances for efficient exponent calculation\n        # inv_covs shape: (num_wells, dim)\n        self.inv_covs = 1.0 / (self.sigmas ** 2)\n\n        # Ripple term to introduce a global non-basin-like pattern and amplify global-local contrast\n        self.ripple_strength = 0.12\n        self.ripple_dir = self.rng.normal(size=self.dim)\n        norm = np.linalg.norm(self.ripple_dir)\n        if norm == 0:\n            self.ripple_dir = np.ones(self.dim)\n            norm = self.dim\n        self.ripple_dir /= norm\n        self.ripple_omega = 2.0 * self.rng.uniform(0.8, 1.2)\n\n        # Global-local contrast booster: a per-well Gaussian bump centered at non-global wells\n        max_depth = float(np.max(self.effective_depths))\n        if max_depth <= 0:\n            max_depth = 1.0\n        # bump_weights scale with (effective_depth / max_depth), exclude global well\n        self.bump_weights = 0.6 * (self.effective_depths / max_depth)\n        self.bump_weights[self.deepest_idx] = 0.0  # no bump at the global minimum center\n\n        # bump_scales reuse per-well sigmas for width in the bump term\n        self.bump_scales = self.sigmas.copy()\n\n        # Note: bump term uses MD distance with per-well sigma to create localized plateaus around non-global wells\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Base multi-well landscape:\n        f_base(x) = sum_i (-effective_depths[i]) * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n\n        Global-local contrast booster (positive bump around non-global wells):\n        g(x) = sum_{i != deepest} w_i * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n\n        Ripple term adds a small high-frequency modulation to break basin-homogeneity.\n\n        The function is designed for minimization: lower values are better.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # diff for all wells: shape (num_wells, dim)\n        diff = x - self.centers\n\n        # exponent for each well: -0.5 * sum_j (diff_j^2 / sigma_j^2)\n        exponent = -0.5 * np.sum((diff ** 2) * self.inv_covs, axis=1)\n\n        # contributions from all wells with scaled depths\n        contributions = -self.effective_depths * np.exp(exponent)\n\n        # base landscape value (sum of contributions)\n        val = float(np.sum(contributions))\n\n        # Global-local contrast booster: per-well Gaussian bumps centered at non-global wells\n        g = 0.0\n        for i in range(self.num_wells):\n            if i == self.deepest_idx:\n                continue\n            d = x - self.centers[i]\n            # Use per-well sigma to compute a Mahalanobis-like distance\n            mdist2 = np.sum((d ** 2) * (1.0 / (self.sigmas[i] ** 2)))\n            g += self.bump_weights[i] * np.exp(-0.5 * mdist2)\n\n        # ripple to break basin-size homogeneity\n        ripple = self.ripple_strength * np.sin(self.ripple_omega * np.dot(x, self.ripple_dir))\n\n        return val + g + ripple", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nonuniform_aniso_ext_glocal scored on:NOT Basins 0.005, GlobalLocal 0.010,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["836c47f8-afdf-46de-b319-c7d66ac0f7f7"], "operator": null, "metadata": {"ela_features_2D": [-0.0007309750702793715, 0.9207608149712158, 0.008762721909302136, 0.030291791477268494, 3.5698141840211255, -0.0023044459461793567, 0.19628404100110333, 2.1081726100167937, 0.21145489444972299, -3.432886770176296, 12.016056286754326, 3.2, 0.4683650545538409, 0.6604225715990555, 0.3791470402216047, 0.36330228605591863, -0.2109090144442424, 0.24159007790794101, 0.41052978726306055, 0.5695368341022304, 0.6360441880099611, 0.22666999331513785, 0.36818571571061187, 0.5051065293555689, 0.5906945329654171, -0.3966879645049569, -0.3083221614181171, -0.22516036165173442, -0.19037327645303762, -0.3969218377918672, -0.32429075041471644, -0.2540268125289213, -0.21011137713582279, 1.0, 1.0, 1.0, 1.0, 0.5188569945149946, 0.5188110241716515, 0.4466116569798067, 0.3579630877004891, 0.7044449429407994, 1.0780780780780777, 0.054477039707380236, -0.9079079079079075, 0.4072289156626506], "score_NOT Basins_2D": 0.8299259841442108, "score_GlobalLocal_2D": 0.6083768606185913, "ela_features": [-0.0024492097830619564, 0.9682889091599811, 0.0007308625959262067, 0.00732780332403334, 50.923318528807435, -0.009728570657367186, 0.14926262388223713, 3.4480219364865503, 0.2886424714379441, -7.233978172035016, 66.86964648536821, 6.4, 0.6841732977076169, 0.8252576971969848, 0.5289927688898239, 0.21647886971124136, -0.37329174669458287, 0.5263244014000834, 0.6153839638004487, 0.675961394213456, 0.8533227936589141, 0.508953084750013, 0.5976757510826372, 0.6637209366522726, 0.8435192790935758, -0.41670029855264634, -0.3383525938904702, -0.28506145726364257, -0.12903255282184276, -0.43426858567880017, -0.35580142958324357, -0.2973926354780273, -0.13838295749319915, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21651564950067215, 0.21651424285399817, 0.21380920697499556, 0.18097725705843432, 0.8504239325076746, 0.26126126126126115, 0.0317747024746371, -1.2322322322322325, 0.6105769230769231], "score_NOT Basins_5D": 0.9976510684937239, "score_GlobalLocal_5D": 0.9976015686988831, "ela_features_10D": [0.000619515659887937, 0.5535146142645697, 0.004348298436042988, 0.048700432496989174, 70.89667299686728, 4.762148850439019e-05, 0.0019723435208683694, 37.2237262043616, 0.0046629987996226864, 0.003627699602046111, -1.5004831933158462, 2.4, 0.6550578637418046, 0.8820390914178056, 0.49982925464899264, 0.1517193906785907, -0.5518660227792884, 0.9894571432790272, 0.9962157063442127, 0.9966139289261335, 1.001395148709869, 0.9923718591643791, 0.9972362372001499, 0.9963693918962078, 1.0008991663538382, -0.01336903158904268, -0.0047987152374001415, -0.004294588274764611, 0.0017690531399967568, -0.009693272167695888, -0.003513716068077155, -0.0046180108080402515, 0.0011425463627299237, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10918438726636773, 0.10918373918789696, 0.12538997720727743, 0.10008421967046024, 0.8903333110100518, 0.3893893893893893, 0.4536981968327264, -0.06306306306306307, 0.6702962369895916], "score_NOT Basins_10D": 0.004574835300445557, "score_GlobalLocal_10D": 0.00972571037709713}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [3.010666666666556, -5.0], -0.8371607693096162], [4, [3.2046666666665344, 5.0], -0.3654500855902679], [12, [0.0715124453623905, -2.046155780815451], -1.041169815090873], [4, [0.2644444444444453, -5.0], -0.5123450475858349], [11, [3.0413781954344854, -3.0741659877824388], -1.2533384922841], [2, [1.3824837913160997, 3.294169619753808], -0.8722972686769839], [5, [-3.6000651364787517, 1.6455382698842422], -0.4312119091432121], [11, [-0.394382687849792, 3.3946145386472883], -0.8864371540059546], [7, [-3.6353076756968576, -3.4852820261769786], -0.47576921621112167], [9, [3.061744837259367, 3.0357973993789233], -0.8967493077553723], [26, [0.15614074524525767, 0.030259206754031542], -15.997493370356269], [2, [-3.5653171460275446, -1.6651606330924154], -0.49294050703242176], [4, [-3.5999567315481484, 4.517684111489435], -0.2858611171901373]], "nr_of_basins": 13, "f_opt_dim_2": -16.055920846653315, "x_opt_dim_2": [0.14186011689772737, 0.0007958615048148527], "f_opt_dim_5": -15.053921866265998, "x_opt_dim_5": [-0.016893128914522174, 4.758516485712944e-05, 0.12166291320267747, 0.004352228299935824, 0.001741816158914837]}
{"id": "0a045b35-0fc8-437b-a0ee-0891d6d32c7e", "fitness": 0.6600436878701051, "name": "landscape_nonuniform_aniso_ext_improved", "description": "A highly diverse nonuniform anisotropic multi-well landscape with a very deep global minimum at the origin to amplify global-local minima contrast. Each well uses a diagonal covariance, diverse depths and irregular centers, with additional ripple to break basin homogeneity and enhance global-local contrast.", "code": "import numpy as np\n\nclass landscape_nonuniform_aniso_ext_improved:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = int(dim)\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(2027)\n\n        # number of wells (basins)\n        self.num_wells = 24\n\n        # centers of the Gaussian wells, spread across [-4, 4] in each dimension\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n\n        # depths of the wells (positive; deeper means deeper negative contribution)\n        self.depths = self.rng.uniform(0.6, 2.5, size=self.num_wells)\n\n        # ensure a deepest well to enforce a pronounced global minimum\n        deepest_idx = int(np.argmax(self.depths))\n        # ensure global minimum at origin by placing deepest well center at zero\n        self.centers[deepest_idx] = np.zeros(self.dim)\n        self.depths[deepest_idx] = 50.0  # very deep global well for strong global-local contrast\n\n        # per-well per-dimension standard deviations (anisotropic basins)\n        # Each well i has its own sigma vector across dimensions\n        raw_sigmas = self.rng.lognormal(mean=0.0, sigma=0.9, size=(self.num_wells, self.dim))\n        self.sigmas = np.clip(raw_sigmas, 0.05, 2.5)\n\n        # introduce irregularity: sometimes elongate along a random axis\n        for i in range(self.num_wells):\n            if self.rng.random() < 0.4:\n                axis = self.rng.integers(0, self.dim)\n                self.sigmas[i, axis] *= self.rng.uniform(1.5, 3.0)\n\n        # depth scaling for non-global wells to keep a pronounced global minimum\n        self.scaling = np.ones(self.num_wells, dtype=float)\n        for i in range(self.num_wells):\n            if i != deepest_idx:\n                self.scaling[i] = self.rng.uniform(0.01, 0.25)\n\n        self.effective_depths = self.depths * self.scaling\n        self.effective_depths[deepest_idx] = self.depths[deepest_idx]\n\n        # Precompute inverse variances for efficient exponent calculation\n        self.inv_covs = 1.0 / (self.sigmas ** 2)  # shape: (num_wells, dim)\n\n        # Ripple term to introduce a global non-basin-like pattern and amplify global-local contrast\n        self.ripple_strength = 0.25\n        self.ripple_dir = self.rng.normal(size=self.dim)\n        norm = np.linalg.norm(self.ripple_dir)\n        if norm == 0:\n            self.ripple_dir = np.ones(self.dim)\n            norm = self.dim\n        self.ripple_dir /= norm\n        self.ripple_omega = 2.0 * self.rng.uniform(0.8, 1.2)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i (-effective_depths[i]) * exp(-0.5 * sum_j ( (x_j - center[i,j])^2 / sigma[i,j]^2 ))\n        This yields multiple local minima with non-uniform basin sizes and a clear global minimum\n        at the deepest well's region (origin), with a small ripple to break Basin homogeneity.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        # diff shape: (num_wells, dim)\n        diff = x - self.centers\n\n        # exponent for each well: -0.5 * sum_j (diff_j^2 * inv_covs_ij)\n        exponent = -0.5 * np.sum((diff ** 2) * self.inv_covs, axis=1)\n\n        # contributions from all wells with scaled depths\n        contributions = -self.effective_depths * np.exp(exponent)\n\n        # base landscape value (sum of contributions)\n        val = float(np.sum(contributions))\n\n        # optional small ripple to break basin-size homogeneity and enhance global-local contrast\n        ripple = self.ripple_strength * np.sin(self.ripple_omega * np.dot(x, self.ripple_dir))\n        return val + ripple", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nonuniform_aniso_ext_improved scored on:NOT Basins 0.004, GlobalLocal 0.008,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["836c47f8-afdf-46de-b319-c7d66ac0f7f7"], "operator": null, "metadata": {"ela_features_2D": [-0.0032593852171028726, 0.796658807209997, 0.005444774352990872, 0.02199439873592417, 4.00077348222382, -0.003852987937839991, 0.48654137480042187, 3.981014263163175, 0.5088429675489295, -1.4343197153828204, 0.8181641235496606, 2.4, 0.5840023627800106, 0.7030122552688411, 0.47999423251463097, 0.3434227386534213, -0.17554684546778138, 0.24078926828502722, 0.3117088278172936, 0.42880040931846286, 0.6439952877592463, 0.23329309877465007, 0.28055471527678527, 0.38043524017572483, 0.5738981174865966, -0.39754447696741524, -0.36040561438987917, -0.29909132216843415, -0.18641209818363103, -0.3945332634536202, -0.370206246683606, -0.31880769817338067, -0.21926227065005904, 1.0, 1.0, 1.0, 1.0, 0.5208633841089834, 0.5208557831884707, 0.3649017277849874, 0.3499419914335285, 0.6299284121436941, 0.7457457457457456, 0.0492637317031102, -0.6076076076076073, 0.3590361445783133], "score_NOT Basins_2D": 0.9628844745457172, "score_GlobalLocal_2D": 0.993013322353363, "ela_features": [-0.003442344195575764, 0.9830874434921135, 0.00042579505415854464, 0.0027931924735345747, 12.643253957383578, -0.010922930374645246, 0.07867268259723399, 1.767527112203305, 0.1773903939632015, -12.691984890303866, 217.27709051644428, 6.2, 0.6733193394758398, 0.8158496809346494, 0.5058290556247722, 0.22826602132246193, -0.3024139642622065, 0.47591215453701646, 0.577458694126317, 0.6926366059759189, 0.905155581016507, 0.4621714403057918, 0.5639976198453904, 0.6799673022906954, 0.8949082410641049, -0.4611207467819137, -0.37177418364088033, -0.2704328265991262, -0.08344891039348298, -0.47600366150409307, -0.38588522439949313, -0.2832346019538886, -0.09301081959461563, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21705263092112603, 0.2170799011202602, 0.21577847329700256, 0.1812556097466048, 0.8590095896842194, 0.017017017017016994, 0.01969236961630031, -1.3963963963963966, 0.6155448717948718], "score_NOT Basins_5D": 0.9970157397910953, "score_GlobalLocal_5D": 0.9950540065765381, "ela_features_10D": [-0.0017508893867523411, 0.4884412862521046, 0.0031887537081309223, 0.03316879855655684, 11.443568633912367, -0.0023231321162304084, -0.0022240682243767074, 150.93322255234938, -0.006087157897998741, 0.005766537069113746, -1.5071195615032529, 2.2, 0.6516336136893811, 0.881576965688101, 0.4755392525065318, 0.15387753009615784, -0.5551296325148285, 0.993995413783259, 0.9959244254843685, 0.9966374610598642, 0.9980230813374922, 0.9921952188217167, 0.9945448437590387, 0.9957880663922302, 0.9976139727149768, -0.0076139136687963125, -0.005168928050547273, -0.004264746905047722, -0.0025073714930024414, -0.009925062114531124, -0.006937861316991612, -0.00535683666462754, -0.0030344300443594817, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.109413131742467, 0.10941635285373838, 0.13071650306265625, 0.09970162148817446, 0.8905011634982888, 0.39339339339339324, 0.4176021116512956, -0.05105105105105105, 0.6628502802241794], "score_NOT Basins_10D": 0.0039035677909851074, "score_GlobalLocal_10D": 0.008391016162931919}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [5.0, -3.568888888888924], -0.7183926644097582], [3, [5.000147818466883, 1.0706688005595733], -0.0808070803972693], [10, [-4.596713444010479, 1.2229259885721318], -1.0562114174573964], [71, [0.0040364301162375315, 0.06876282209139135], -50.747948606737296], [10, [-4.778495668277661, -1.2985780726099454], -0.6689398524673167]], "nr_of_basins": 5, "f_opt_dim_2": -50.747949672239656, "x_opt_dim_2": [0.004142884910778606, 0.0680335372102448], "f_opt_dim_5": -50.07024242367145, "x_opt_dim_5": [0.008079588946858151, -0.0024628147070340067, -0.013858012841596127, -0.009753608453578644, 0.005123574917861784]}
{"id": "656e2d7b-e94d-47f4-84ba-4f8c982d91ff", "fitness": 0.6217506430208838, "name": "landscape_min_ellipsoids_not_homogeneous", "description": "A non-homogeneous, multi-component ellipsoidal-well landscape with a deep global basin at the origin. The landscape is constructed as the minimum over a heterogeneous collection of ellipsoidal sub-wells (components), with varying centers, SPD covariances and depths. By giving each well a random number of components and a broad spread of volumes (via determinant of A and depths), basin sizes become highly non-uniform, producing strong global-local contrast and breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_min_ellipsoids_not_homogeneous:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # deterministic pseudo-random generator state (for reproducibility)\n        self._seed = 20210407\n\n        # a collection of ellipsoidal sub-wells (components)\n        self.components = []\n\n        # Global deep well at origin, represented by multiple components\n        origin = np.zeros(self.dim)\n\n        # 1) Origin component with deep global minimum\n        A0 = self._sample_A(base_aniso=True)\n        self.components.append({'c': origin.copy(), 'A': A0, 'w': -60.0})\n\n        # 2) Additional components near origin to break basin homogeneity\n        for _ in range(2):\n            c = self._sample_center(min_dist=0.8)\n            A = self._sample_A()\n            w = - (1.0 + self._rand() * 14.0)  # [-15, -1]\n            self.components.append({'c': c, 'A': A, 'w': w})\n\n        # 3) Additional scattered wells with variable number of components\n        self._K = max(3, self.dim * 2)\n        for _ in range(1, self._K):\n            # Each \"base well\" may have 1 or 2 components\n            n_comp = 1 if self._rand() < 0.6 else 2\n            for _ in range(n_comp):\n                ctr = self._sample_center(min_dist=1.0)\n                A = self._sample_A()\n                w = - (1.0 + self._rand() * 9.0)  # [-10, -1]\n                self.components.append({'c': ctr, 'A': A, 'w': w})\n\n    def _rand(self):\n        # simple LCG-like RNG for deterministic output\n        self._seed = (1664525 * self._seed + 1013904223) & 0xFFFFFFFF\n        return self._seed / 0xFFFFFFFF\n\n    def _sample_center(self, min_dist=1.5, max_trials=2000):\n        # sample a random center within [-5,5]^dim with a minimum distance from origin\n        for _ in range(max_trials):\n            v = np.array([ (self._rand() * 2.0 - 1.0) * 5.0 for _ in range(self.dim) ])\n            if np.linalg.norm(v) >= min_dist:\n                return v\n        # fallback: place somewhere on a sphere of radius min_dist along axis\n        v = np.zeros(self.dim, dtype=float)\n        v[0] = min_dist\n        return v\n\n    def _sample_A(self, base_aniso=False):\n        # Create a random SPD matrix via an orthogonal basis and random eigenvalues\n        Q = self._random_orthogonal(self.dim)\n        lam = np.zeros(self.dim, dtype=float)\n        for j in range(self.dim):\n            lam[j] = 0.2 + self._rand() * (10.0 - 0.2)\n        D = np.diag(lam)\n        A = Q @ D @ Q.T\n        if base_aniso:\n            # mild global anisotropy for the global well\n            factor = 0.7 + self._rand() * 0.6\n            A = A * factor\n        return A\n\n    def _random_orthogonal(self, n):\n        # Generate a random orthogonal matrix via QR decomposition\n        M = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                M[i, j] = (self._rand() * 2.0 - 1.0)\n        Q, R = np.linalg.qr(M)\n        # Ensure determinant is positive (proper rotation)\n        if np.linalg.det(Q) < 0:\n            Q[:, 0] = -Q[:, 0]\n        return Q\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a vector of length {self.dim}\")\n\n        # The overall objective is the minimum value across all sub-wells:\n        # f_i(x) = (x - c_i)^T A_i (x - c_i) + w_i\n        # f(x) = min_i f_i(x)\n        vals = np.empty(len(self.components), dtype=float)\n        for idx, comp in enumerate(self.components):\n            diff = x - comp['c']\n            vals[idx] = float(diff @ (comp['A'] @ diff) + comp['w'])\n        return float(np.min(vals))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_min_ellipsoids_not_homogeneous scored on:NOT Basins 0.968, GlobalLocal 0.005,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2da52183-7962-4e43-984d-6de61e213a6a"], "operator": null, "metadata": {"ela_features_2D": [0.2579691320800571, 0.4301913798997029, 0.06745349240949768, 0.31411272305207527, 4.729774202982682, 0.26370764110446865, 0.8574621715103674, 1.1754213712579529, 0.9566010969735373, 0.9055502477380879, 0.9715672481816728, 1.6, 0.5783608956899547, 0.7081657395797772, 0.4796075451443428, 0.33761812813674774, -0.17024907871937658, 0.15509925671657127, 0.23096955264626842, 0.31915273824789026, 0.4965003279258367, 0.15636679536032774, 0.2356186329500199, 0.3209648107482236, 0.49720683221142625, -0.4420143887447153, -0.4023232926682135, -0.3561896263257706, -0.26340804104388393, -0.4334989871808486, -0.3927724018116865, -0.3489161899900442, -0.25835922997113747, 1.0, 1.0, 1.0, 1.0, 0.5188895190109553, 0.5188548521027148, 0.48064868804706967, 0.505203298442533, 0.6881670404646892, 0.37337337337337323, 0.2903096672699462, -0.28328328328328317, 0.3690763052208835], "score_NOT Basins_2D": 0.710015058517456, "score_GlobalLocal_2D": 0.9384737014770508, "ela_features": [0.03726889201397261, 0.3914489958614963, 0.0060695080582911145, 0.09095961813879587, 73.07703292768034, 0.15539342579859367, 0.36761957624937264, 3.2791801559545966, 0.6035581376094481, 0.894747821428042, 1.365807126676501, 1.8, 0.764635192755437, 0.8543680193760019, 0.5712342747592494, 0.19543376195015116, -0.43009162404852785, 0.48877172703737415, 0.623326280930422, 0.7218046728431287, 0.8403464005404377, 0.47222856013372133, 0.6050348501419818, 0.708518290763848, 0.8323629524517397, -0.4496137100821441, -0.3312780545164932, -0.24466710581166332, -0.14041200193344353, -0.46655502708924673, -0.34915060413980437, -0.2576663441811885, -0.14819012655789454, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21457376102740028, 0.21454949799923345, 0.20428808038824203, 0.20095073855104148, 0.8273128615624274, 0.1451451451451451, 0.20744085783811772, -0.4674674674674673, 0.528846153846154], "score_NOT Basins_5D": 0.9991056677536108, "score_GlobalLocal_5D": 0.11001908779144287, "ela_features_10D": [0.05454527592759954, 0.3580386246950965, 0.00686753803602851, 0.06540201072402645, 28.1638485032924, 0.26449435337606536, 0.3460668534348435, 2.395756432084619, 0.5938450906229098, 0.42451878000806753, 0.24278770361798951, 1.6, 0.8396463840088593, 0.9181162337133507, 0.6056204966359263, 0.12204319534440915, -0.5336687764418253, 0.8503987801971669, 0.858372151610966, 0.8776126447331236, 0.904562350983845, 0.8465075133985696, 0.8568059870775369, 0.875027927189176, 0.9020627717498326, -0.1897376227627272, -0.179624450956351, -0.15522199328387423, -0.12104201441463625, -0.19520584273362548, -0.18210582452076168, -0.15893226993493598, -0.12455077139438062, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10991774780995026, 0.10991528436894707, 0.10719815712796203, 0.11244222374337498, 0.8565608600999699, -0.10710710710710707, 0.13358786671214923, -0.6516516516516514, 0.5917534027221778], "score_NOT Basins_10D": 0.9683633334934711, "score_GlobalLocal_10D": 0.004527009092271328}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[7, [4.692585162924323, 3.820430552595189], -9.852573324071182], [10, [1.7172511475079553, 2.946791545940838], -11.330598293366888], [16, [3.7189946756627843, -0.9830425109469387], -10.767963048018947], [14, [-0.1259904413653796, -3.494899099588996], -8.580004844363632], [53, [3.52053553930038e-05, -0.00041127751627346564], -59.99999916945626]], "nr_of_basins": 5, "f_opt_dim_2": -60.0, "x_opt_dim_2": [1.5850526153398526e-08, 1.503651881652427e-08], "f_opt_dim_5": -60.0, "x_opt_dim_5": [2.5005017008809447e-08, -6.24499567469706e-09, -5.77840306920378e-10, -1.553186472055074e-08, -1.2277402819916124e-08]}
{"id": "4f74d164-d514-4393-a010-a5caa9b38d9a", "fitness": 0.5113897959236056, "name": "landscape_nh_wells_exp_tail", "description": "A novel non-homogeneous landscape built from anisotropic, non-Gaussian wells using per-well SPD distance measures and negative exponential tails. This creates irregular basin shapes (non-homogeneous basins) and a pronounced global-local minima contrast, with a deep global basin centered at the origin.", "code": "import numpy as np\n\nclass landscape_nh_wells_exp_tail:\n    \"\"\"\n    Non-homogeneous landscape with anisotropic, non-Gaussian wells.\n\n    Each basin i is defined by:\n      center c_i (in R^dim),\n      a positive-definite covariance Cov_i (represented via its inverse CovInv_i for distance),\n      depth parameters: w_i (baseline valley level) and alpha_i (depth strength),\n      shape parameters: p_i (exponent) and s_i (scale).\n\n    The basin value at x is:\n      g_i(x) = w_i - alpha_i * exp(- (d_i(x) / s_i) ** p_i),\n    where d_i(x)^2 = (x - c_i)^T CovInv_i (x - c_i).\n\n    The objective is minimum over i: f(x) = min_i g_i(x).\n\n    Design notes:\n    - The deepest basin is at the origin (c_0 = 0) with a large negative value at x = 0:\n      f(0) = w_0 - alpha_0, chosen to be much smaller than any w_i - alpha_i for i > 0.\n    - As |x| -> infinity, each g_i(x) -> w_i, so the global asymptotic floor is min_i w_i,\n      which is greater than f(0), ensuring a global minimum at the origin.\n    - Basins are irregular due to random centers, diverse SPD covariances, and varying p_i, s_i.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be positive.\")\n\n        # Deterministic seed for reproducibility\n        seed = (self.dim * 424242) & 0xFFFFFFFF\n        rng = np.random.default_rng(seed)\n\n        # Target number of basins (non-homogeneous growth with dimension)\n        self.Nc_target = min(12 + self.dim, 60)\n\n        # Basin parameters (lists aligned by basin index)\n        self.centers = []\n        self.CovInvs = []\n        self.weights = []  # w_i\n        self.alpha = []    # alpha_i (depth strength)\n        self.ps = []         # p_i (exponent)\n        self.ss = []         # s_i (scale)\n\n        # 1) Deep central basin at the origin\n        c0 = np.zeros(self.dim)\n        w0 = -20.0    # baseline trough level at the baseline\n        a0 = 10.0     # depth strength for central basin\n        p0 = 2.0      # exponent (Euclidean-like near center)\n        s0 = rng.uniform(0.8, 2.0)  # scale controlling tail sharpness\n\n        # SPD covariance for central basin (anisotropic, rotated)\n        A = rng.normal(size=(self.dim, self.dim))\n        Q, _ = np.linalg.qr(A)\n        l = rng.uniform(0.5, 3.0, size=self.dim)\n        Cov0 = Q @ np.diag(l) @ Q.T\n        CovInv0 = np.linalg.inv(Cov0)\n\n        self.centers.append(c0)\n        self.CovInvs.append(CovInv0)\n        self.weights.append(w0)\n        self.alpha.append(a0)\n        self.ps.append(p0)\n        self.ss.append(s0)\n\n        # 2) Additional irregular wells with varied shapes, depths, and orientations\n        attempts = 0\n        while len(self.centers) < self.Nc_target and attempts < self.Nc_target * 60:\n            attempts += 1\n            center = rng.uniform(-5.0, 5.0, size=self.dim)\n\n            # enforce reasonable separation between centers\n            if any(np.linalg.norm(center - np.array(ex)) < 1.0 for ex in self.centers):\n                continue\n\n            # Generate a random SPD covariance for the basin\n            A = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(A)\n            l = rng.uniform(0.3, 4.0, size=self.dim)\n            Cov = Q @ np.diag(l) @ Q.T\n            CovInv = np.linalg.inv(Cov)\n\n            w = -rng.uniform(1.0, 6.0)    # base level around -1 to -6\n            a = rng.uniform(0.5, 4.0)     # depth strength\n            p = rng.uniform(1.2, 2.8)     # exponent (affects shape)\n            s = rng.uniform(0.6, 3.0)     # scale for tail\n\n            self.centers.append(center)\n            self.CovInvs.append(CovInv)\n            self.weights.append(w)\n            self.alpha.append(a)\n            self.ps.append(p)\n            self.ss.append(s)\n\n        self.Nc = len(self.centers)\n\n    def f(self, x):\n        x = np.asarray(x).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must have length equal to landscape dimension.\")\n\n        val = None\n        for i in range(self.Nc):\n            center = self.centers[i]\n            diff = x - center\n            cov_inv = self.CovInvs[i]\n\n            # Mahalanobis-like distance\n            d2 = float(diff @ cov_inv @ diff)\n            d = max(np.sqrt(d2), 1e-12)\n\n            w = self.weights[i]\n            a = self.alpha[i]\n            p = self.ps[i]\n            s = self.ss[i]\n\n            # Negative exponential tail around each basin\n            term = w - a * np.exp(- (d / s) ** p)\n\n            if val is None or term < val:\n                val = term\n\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_wells_exp_tail scored on:NOT Basins 0.987, GlobalLocal 0.017,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4730d5e1-d56f-416b-a3ee-ea0bc7e1d302"], "operator": null, "metadata": {"ela_features_2D": [-0.0033216274163314187, 0.8076923287484716, 0.010543621533286847, 0.01625754641596708, 2.436323698174022, 0.00023055248223620152, 0.6356226092671091, 1.0277254258518638, 0.797500275280989, -1.5442028701146264, 1.4600241916488845, 2.2, 0.7078656298074153, 0.709949171623383, 0.5475049339226069, 0.3482671030209622, -0.1619178689088592, 0.14224470190128047, 0.21793057387625853, 0.3085348848322382, 0.5022460802259257, 0.1409652818223046, 0.2128356685123464, 0.304089756430637, 0.4965552619260052, -0.4489433980836333, -0.4093279959203663, -0.361909118309284, -0.26052212018459137, -0.44222803958831697, -0.4052185430971081, -0.35824829134049935, -0.259169053907798, 1.0, 1.0, 1.0, 1.0, 0.5211486232839064, 0.5211413550648125, 0.3804115207167148, 0.3483693457553055, 0.6091485925363233, 0.5415415415415413, 0.1666736907800901, -0.3193193193193193, 0.35341365461847396], "score_NOT Basins_2D": 0.9973043161444366, "score_GlobalLocal_2D": 0.9846177101135254, "ela_features": [-0.0036623107034969406, 0.9962389535845049, 0.0003235988108850893, 0.0023247670970855698, 51.849608268647636, -0.01147934604489933, 0.05794381074314077, 1.2150933638872836, 0.1431490727466013, -14.698456287802617, 265.8799388952008, 6.2, 0.9042488431857386, 0.8734055076443088, 0.648861821735982, 0.1821196096020595, -0.24890474510594923, 0.44108571397443097, 0.5230780989113016, 0.6009823233422205, 0.7261653785156538, 0.43567730826789874, 0.5238029476074256, 0.6013505804699936, 0.7262400724823028, -0.49158527500986704, -0.4194698954921175, -0.35094968789429115, -0.24084563680156287, -0.49877964316046414, -0.42088983504536015, -0.3523467644629271, -0.24195952913043123, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2176253704598045, 0.21761857989832994, 0.21644955336107316, 0.18146787458302815, 0.5225244997019965, -0.19119119119119113, 1.2778697208266918e-05, -4.463463463463464, 0.5033653846153847], "score_NOT Basins_5D": 0.033978819847106934, "score_GlobalLocal_5D": 0.04878094792366028, "ela_features_10D": [-0.0032419084173198167, 0.9992816452615806, 0.00012282721876023247, 0.0011172767290552501, 21.838058366959274, -0.02117094206849033, -0.0019069882659841664, 2.1947100076426, -0.050005428490189095, -46.621378822018805, 2235.998474646934, 2.0, 0.6857976756816602, 0.7970834152360136, 0.41701985726181057, 0.17326818127178753, -0.08023768291321723, 0.6381326055625312, 0.7052721300162939, 0.7575490298443954, 1.0, 0.6405897073537559, 0.7071923423079765, 0.759909988596404, 1.0, -0.4589330216597249, -0.37378383282935745, -0.3074843820233579, 0.0, -0.45706212456073364, -0.37236242924570967, -0.30532107281955867, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10975103671622961, 0.10975598443346765, 0.10969502298195577, 0.09982492645735845, 0.3661916097401668, -4.1391391391391394, 0.0, -Infinity, 0.17029623698959168], "score_NOT Basins_10D": 0.987074101343751, "score_GlobalLocal_10D": 0.016582880169153214}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [5.767603473134236e-05, -0.00026801131380738055], -29.99999988786594]], "nr_of_basins": 1, "f_opt_dim_2": -30.0, "x_opt_dim_2": [-7.845369221922533e-09, 2.1055274286202394e-08], "f_opt_dim_5": -30.0, "x_opt_dim_5": [1.3485843463173453e-08, -5.077883373753197e-09, 1.520359896084511e-08, -1.0564335246892395e-08, -1.0854477993570118e-08]}
{"id": "19167976-163f-4a38-b36d-b30b256edea9", "fitness": 0.9866517762930016, "name": "landscape_global_local_contrast_gaussians_enhanced_notbasins", "description": "A non-homogeneous, anisotropic Gaussian multi-well landscape with enhanced global-local minima contrast implemented via a min-over-wells formulation. Each well is an anisotropic, rotated Gaussian with distinct centers and covariance structures, including a deepest global well at the origin. The use of a per-well full covariance and a min-aggregation creates highly irregular basin shapes and sizes (not basins-homogeneous) while maintaining a clear global minimum at the origin to challenge black-box optimizers with non-uniform basin geometry and pronounced global-local contrast.", "code": "import numpy as np\n\nclass landscape_global_local_contrast_gaussians_enhanced_notbasins:\n    def __init__(self, dim=5):\n        # problem dimension\n        self.dim = dim\n\n        # fixed RNG for reproducibility\n        self.rng = np.random.default_rng(1234)\n\n        # number of wells (basins)\n        self.num_wells = 18\n\n        # centers of Gaussian wells, with the global minimum anchored at the origin\n        self.centers = self.rng.uniform(-4.0, 4.0, size=(self.num_wells, self.dim))\n        self.centers[0] = np.zeros(self.dim)\n\n        # depths of the wells (positive values; we take min over wells)\n        self.depths = self.rng.uniform(0.5, 5.0, size=self.num_wells)\n        # make the global minimum deeper than the rest\n        self.depths[0] = self.rng.uniform(9.0, 16.0)\n\n        # per-well full covariances (SPD) to create anisotropy and irregular basin shapes\n        self.covariances = []\n        for i in range(self.num_wells):\n            # Random rotation (orthogonal matrix)\n            M = self.rng.normal(0.0, 1.0, size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)  # orthonormal basis\n\n            # Eigenvalues drawn to span a wide range (log-uniform-like)\n            log_min, log_max = np.log(0.2), np.log(6.0)\n            eig_vals = np.exp(self.rng.uniform(log_min, log_max, size=self.dim))\n\n            Cov = Q @ np.diag(eig_vals) @ Q.T\n\n            # Stabilize numerics\n            Cov += 1e-6 * np.eye(self.dim)\n\n            self.covariances.append(Cov)\n\n        # Optional lightweight perturbations to further break symmetry/homogeneity\n        for i in range(self.num_wells // 4):\n            j = (i + 1) % self.num_wells\n            perturb = 0.05 * (np.eye(self.dim) + 0.5 * (np.ones((self.dim, self.dim)) - np.eye(self.dim)))\n            self.covariances[i] = self.covariances[i] + perturb\n            self.covariances[i] = (self.covariances[i] + self.covariances[j]) / 2.0\n\n        # Precompute a simple global-local contrast score (optional diagnostic)\n        self.global_local_contrast = self._estimate_global_local_contrast()\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = min_i [ -depth[i] * exp(-0.5 * (x - center[i])^T * inv(Cov_i) * (x - center[i]) ) ]\n\n        This yields irregular, non-homogeneous basins (via per-well anisotropic covariances\n        and varied centers) with a deep global minimum at the origin.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        min_val = float('inf')\n        for i in range(self.num_wells):\n            diff = x - self.centers[i]\n            Cov = self.covariances[i]\n\n            # Inverse of Cov (positive definite)\n            inv_cov = np.linalg.inv(Cov)\n\n            # Mahalanobis distance squared\n            dist2 = diff @ inv_cov @ diff\n\n            val = -self.depths[i] * np.exp(-0.5 * dist2)\n\n            if val < min_val:\n                min_val = val\n\n        return float(min_val)\n\n    def _estimate_global_local_contrast(self):\n        \"\"\"\n        Basic estimate of GlobalLocal contrast using values at well centers.\n\n        - Evaluate f at each center\n        - Global minimum is assumed to be at origin (center 0)\n        - Local minima are the values at other centers\n        - Contrast = (abs(global_min) - mean_abs_local) / (mean_center_value + eps)\n        \"\"\"\n        values_at_centers = np.array([self.f(self.centers[i]) for i in range(self.num_wells)])\n\n        global_min_val = values_at_centers[0]\n        local_min_vals = values_at_centers[1:]\n        avg_center = np.mean(values_at_centers)\n\n        denom = abs(avg_center) + 1e-9\n        local_depth_mean = np.mean(np.abs(local_min_vals)) if local_min_vals.size > 0 else 0.0\n\n        contrast = max(0.0, (abs(global_min_val) - local_depth_mean) / denom)\n        return float(contrast)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_global_local_contrast_gaussians_enhanced_notbasins scored on:NOT Basins 1.000, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b743201f-fd45-4566-925b-f6e12af38665"], "operator": null, "metadata": {"ela_features_2D": [0.05632032562183535, 0.9284131240485884, 0.10539806246884917, 0.11515454376199497, 1.093366374721184, 0.061993855911827, 0.3933454565340484, 1.196140580950923, 0.5111694378769227, -2.3448993759754426, 6.146178295566674, 3.2, 0.45710815319982484, 0.6714751434308699, 0.3959531870344724, 0.35690479338776504, -0.18932363237514044, 0.12497642903367297, 0.2130912244931066, 0.3268086224263666, 0.6117964921314866, 0.11963466128787606, 0.20971621083350717, 0.3149467729091413, 0.6089054247302738, -0.4575704098037428, -0.4114925608575879, -0.3520286542790211, -0.2029998792578509, -0.4518157277772315, -0.40558142062881064, -0.3515666094968573, -0.20071206216297882, 1.0, 1.0, 1.0, 1.0, 0.5257419244346351, 0.5256908838877916, 0.4448825230797352, 0.41042644359751057, 0.696604714559818, 0.7177177177177174, 0.22722139610417585, -0.2952952952952953, 0.39879518072289155], "score_NOT Basins_2D": 0.9786093086004257, "score_GlobalLocal_2D": 0.9445794820785522, "ela_features": [0.010871178348053356, 0.9879793095092999, 0.0009298333830861935, 0.017331758782567395, 23.612331495902694, 0.017199235276491188, 0.04417628230901187, 32.45623168652703, 0.093322771374078, -11.614814369205703, 199.52086804113245, 6.2, 0.7018154159140816, 0.8415540962400103, 0.48653446327621686, 0.2077865346510357, -0.39070774196303665, 0.7429645196335912, 0.8026357166154618, 0.8290809207252282, 0.8670419247731587, 0.7447096851727361, 0.8023750149105613, 0.8255191948073926, 0.8613506941033163, -0.2261477023396906, -0.17364768678168443, -0.15038069993793005, -0.11698119805154934, -0.2258569104066077, -0.17484080858889844, -0.15436452693305316, -0.12266411996709588, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21395268260741634, 0.21395697017049864, 0.21233507134204924, 0.1883359162152164, 0.6238069968515314, 0.07707707707707703, 0.0002003587789998965, -2.2452452452452456, 0.5434294871794872], "score_NOT Basins_5D": 0.99986523782718, "score_GlobalLocal_5D": 0.9970293045043945, "ela_features_10D": [-0.0010204695293159149, 0.9994448967080901, 0.0002034169657431196, 0.0023076791418819164, 20.19635866052318, -0.008378430158895079, -0.00017544202070169935, 13.819448499054406, -0.03127480750287206, -36.467250258104244, 1458.7231264731975, 4.0, 0.8823812280673611, 0.9181544167947033, 0.6138085073680347, 0.12091974246926593, -0.1980146424259516, 0.8026245717965752, 0.8123905318484337, 0.8402712852758212, 0.8768119182183188, 0.7956076361161509, 0.804733804443163, 0.8342933009830183, 0.8739758641951585, -0.25033901841676115, -0.237953022989199, -0.20259084933643812, -0.15624490481203024, -0.25993283264995454, -0.2483262001101949, -0.2107343611921307, -0.16026870764621254, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10940932745885834, 0.10940971195607704, 0.1093307473972952, 0.10032510188751757, 0.5524312668951096, -1.7447447447447448, 0.0, -Infinity, 0.5691753402722177], "score_NOT Basins_10D": 0.9999076718086144, "score_GlobalLocal_10D": 0.9999196529388428}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [-3.5191190965603547, 1.4699864677282328], -2.1672877752448483], [13, [-2.7722066578214077, 3.937734036284648], -1.8747534365187768], [2, [1.5641788014883709, 1.0668663774351785], -4.731884240769837], [16, [2.771570651139377e-06, 0.00043305791424047124], -15.631516672159712], [6, [-1.4480688665464458, -3.055421279338569], -0.8909735695394121], [12, [3.386121251605857, -1.906550874139702], -4.730507958729547], [19, [2.909323871585609, 2.9103902859117268], -4.41091164412861], [8, [1.880036661732351, -2.1771481460271134], -4.281476018242913], [4, [2.8677391407581148, -0.5975181910041812], -3.7995422749755696], [3, [-2.0657949772775632, -1.4518168357555001], -2.606948186396193], [1, [-2.666099548635585, 2.758398878031836], -2.474813543655286], [11, [-3.9768720791364465, -1.9768874308093352], -2.914413793800206]], "nr_of_basins": 12, "f_opt_dim_2": -15.631517223020493, "x_opt_dim_2": [-2.0664233430650098e-09, 1.203561598065667e-08], "f_opt_dim_5": -13.354326160703302, "x_opt_dim_5": [-2.487288194184305e-10, -4.649525436478151e-09, -8.77503440174175e-10, -2.2259735466151478e-09, -1.9095540126170263e-09]}
