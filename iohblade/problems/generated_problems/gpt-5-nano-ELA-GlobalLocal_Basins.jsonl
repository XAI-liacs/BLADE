{"id": "5f1e38a3-6b6b-48c7-a7d2-54691e3c1bf6", "fitness": 0.5351751446723938, "name": "landscape", "description": "A multi-basin minimization landscape with one deeper global basin and several symmetric local basins. Local basins are created by placing negative Gaussian wells at axis-aligned centers; a larger negative well at the origin creates a controllable global-local minima contrast. All basins share the same width (sigma) to ensure basin size homogeneity, while the global basin depth is tuned via a higher amplitude. This design provides a challenging yet tunable benchmark for metaheuristics in continuous spaces, with clear global-local contrast and uniform basin sizes.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Basin configuration\n        self.s = 2.0                 # center distance from origin along each axis\n        self.sigma = 0.9              # shared Gaussian width (controls basin size)\n        self.A_global = 1.8           # amplitude of the global (deepest) basin\n        self.A_local = 1.0            # amplitude of the local basins (symmetric)\n        \n        # Build centers and weights\n        self.centers = []  # list of center points c_i\n        self.weights = []  # corresponding amplitudes a_i (positive values; depth via negative Gaussian)\n        self._build_centers()\n    \n    def _build_centers(self):\n        # Global (deepest) basin at origin\n        self.centers.append(np.zeros(self.dim))\n        self.weights.append(self.A_global)\n        \n        # Local basins located along each axis: +s and -s\n        for d in range(self.dim):\n            c_plus = np.zeros(self.dim)\n            c_plus[d] = self.s\n            self.centers.append(c_plus)\n            self.weights.append(self.A_local)\n            \n            c_minus = np.zeros(self.dim)\n            c_minus[d] = -self.s\n            self.centers.append(c_minus)\n            self.weights.append(self.A_local)\n        \n        # Convert to numpy arrays for faster operations\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.weights = np.asarray(self.weights, dtype=float)\n    \n        # Precompute constants\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n    \n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is defined as a sum of negative Gaussians centered at:\n          - origin (global basin, deeper)\n          - each axis center at +/- s (local basins)\n        f(x) = sum_i -a_i * exp(-||x - c_i||^2 / (2*sigma^2))\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        \n        total = 0.0\n        for a, c in zip(self.weights, self.centers):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            total += -a * np.exp(-dist2 / self._two_sigma2)\n        return float(total)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.108, Basins 0.922,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.003227642695089239, 0.8605417123408777, 0.010106296227243742, 0.018736813166406602, 2.2510653940968113, -0.004588765290346908, 0.5315685302356961, 1.0104856156842803, 0.7051025300964898, -1.728684988801443, 2.082090238592978, 2.4, 0.7224878306536697, 0.7204165786240029, 0.5826397262498603, 0.33883991134188296, -0.16575789715261618, 0.1489637056601793, 0.2234657588223575, 0.3205169851278967, 0.4914285985018335, 0.15423528160323316, 0.22262626101118865, 0.3220085171893953, 0.49386880408185957, -0.44504499625044536, -0.4060881500705061, -0.3553373546130905, -0.2659567719059618, -0.43422365926470113, -0.39910698828600033, -0.3480831973299698, -0.2598505743932781, 1.0, 1.0, 1.0, 1.0, 0.519020693294873, 0.5189915552186568, 0.3921677152258267, 0.34972128112522827, 0.4890699597552425, 0.5935935935935934, 0.030742867686242282, -0.7117117117117114, 0.3534136546184739], "score_GlobalLocal_2D": 0.9855847954750061, "score_Basins_2D": 0.13697826862335205, "ela_features": [-0.0033714900601061527, 0.9899276707298205, 0.0007326409014350771, 0.003441997068614243, 6.130679184981425, -0.011278886796938049, 0.0741190388599899, 1.1526817681160344, 0.1773939160850582, -12.843157229756134, 218.22346000075905, 6.4, 0.8983579273366953, 0.8723606456047571, 0.6342144948187314, 0.1826941204478553, -0.2843744659345567, 0.44773633908815036, 0.5270920032722476, 0.6053559592900148, 0.7187360406667643, 0.44895971786894784, 0.5312438714494613, 0.6088398475839346, 0.7219357325087723, -0.4858149583917104, -0.4160069430763967, -0.3471595026191596, -0.24742213807703967, -0.48746312628486554, -0.4146725729293161, -0.3460251763031702, -0.24598020301921375, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21621265455433844, 0.2162156887189231, 0.21443472864549779, 0.18040184060062692, 0.48204947748019567, 0.09309309309309308, 1.116329886889341e-05, -Infinity, 0.5070512820512821], "score_GlobalLocal_5D": 0.1012667641043663, "score_Basins_5D": 0.9574368596076965, "ela_features_10D": [-0.003169017224467119, 0.9977030468662713, 0.00011666999613289479, 0.0014694242994778978, 620.1631321735525, -0.021017585489826286, -0.00015039788055766224, 3.077664236284618, -0.0410838306350624, -44.5311119457896, 2086.6645785405553, 2.8, 0.928512043092893, 0.9117054233611599, 0.6275998820469912, 0.121596583511079, -0.17666505347066197, 0.6290786484676906, 0.6848831473302137, 0.7334484002779844, 0.8082454727335152, 0.6317203224474804, 0.6898924027488128, 0.7381069700804315, 0.8130685942396161, -0.47046810371757325, -0.3996864157310533, -0.33808751841092777, -0.24321673895991172, -0.46839513927539167, -0.3944078965360286, -0.3330865881916915, -0.2377471800554471, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10997520852763905, 0.1099686191547922, 0.10991666064634413, 0.10008699206086118, 0.5992246926388846, -2.6736736736736737, 0.0, -Infinity, 0.4728582866293034], "score_GlobalLocal_10D": 0.10788518190383911, "score_Basins_10D": 0.9218991994857788}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [3.2863989307685415e-13, 0.00044444444444512003], -2.1386317956724326]], "nr_of_basins": 1, "f_opt_dim_2": -2.1386319544901204, "x_opt_dim_2": [1.7638643115097005e-09, -4.274080667277577e-09], "f_opt_dim_5": -2.6465798862253007, "x_opt_dim_5": [4.6421065574026034e-09, -4.824499146778533e-09, 1.7877580111032952e-09, -2.85614967359051e-09, 3.1834988823727486e-09]}
{"id": "e2d31e27-1b9c-454d-b45a-7d3285ad5f1e", "fitness": 0.6001031994819641, "name": "landscape", "description": "A multi-well quadratic benchmark landscape where the global minimum sits at the origin and all axis-aligned axis wells provide identical local minima. The function is the minimum over a set of quadratics, guaranteeing a unique global optimum while maintaining symmetric, homogeneous basin sizes for the local minima. The global-local contrast is controlled by the depth differences between the global and local wells.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Number of wells: one at origin (global min) and one on each coordinate axis\n        self.K = self.dim + 1\n\n        # Centers: origin plus axis-aligned centers at radius 'radius' along each axis\n        self.centers = []\n        self.centers.append(np.zeros(self.dim))  # global minimum at origin\n\n        radius = 2.0  # distance from origin to each axis well, kept within [-5,5]\n        for i in range(self.dim):\n            c = np.zeros(self.dim)\n            c[i] = radius\n            self.centers.append(c)\n\n        # Depths (costs) for each well: global well depth 0, local wells depth 1\n        self.a = np.zeros(self.K, dtype=float)\n        self.a[0] = 0.0\n        self.a[1:] = 1.0\n\n        # GlobalLocal: contrast between deepest and shallowest wells relative to average depth\n        self.GlobalLocal = (np.max(self.a) - np.min(self.a)) / (np.mean(self.a) + 1e-12)\n\n        # Basins: due to symmetric placement (origin + axis wells with equal local depths),\n        # the non-global basins are homogeneous in size. We encode this as 1.0 ratio.\n        self.Basins = 1.0\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i [ a_i + || x - c_i ||^2 ]\n        Global minimum is at x = c_0 (the origin) with value 0.\n        Local minima are at x = c_i for i > 0 with value a_i = 1.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        \n        # Compute all a_i + ||x - c_i||^2 and take the minimum\n        vals = np.empty(self.K, dtype=float)\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            vals[i] = self.a[i] + np.dot(diff, diff)\n        return float(np.min(vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.17411772337931006, 0.4607327809974711, 0.18852119648777316, 0.21181759911409775, 1.1412928933450786, 0.1951858577944649, 0.9517702369880287, 1.012318081019512, 0.9933114964415903, 0.758083899153037, -0.015809577963100896, 1.4, 0.6904295436347044, 0.7162581863480311, 0.5501447957767039, 0.338718060244006, -0.18113310106315417, 0.14601316114870597, 0.2687034008665746, 0.3504978617870744, 0.5008210094787982, 0.15318794445893372, 0.25790313882682636, 0.34726163972860624, 0.4983921946393126, -0.44686261363673746, -0.3826690501766533, -0.3398730858505795, -0.2612073752429785, -0.43502225640499664, -0.3812363710384248, -0.3353403386205539, -0.2576958117143119, 1.0, 1.0, 1.0, 1.0, 0.5172922371393648, 0.5172789516017423, 0.4620700267502048, 0.47670716172920996, 0.6930554161857873, 0.37337337337337323, 0.39442917097259206, -0.2152152152152152, 0.3783132530120482], "score_GlobalLocal_2D": 0.879727303981781, "score_Basins_2D": 0.7208685874938965, "ela_features": [0.0398577903125932, 0.515659598475136, 0.04391594267340491, 0.07096813794368799, 1.6736895364468705, 0.049907868375376904, 0.9655666939142746, 1.0326268214069394, 0.9908491733686532, 0.3963022439180449, -0.15844382108380461, 1.0, 0.913090587884932, 0.8752085545537207, 0.6493383890284044, 0.18137329821613513, -0.46457754554314395, 0.42782770830897066, 0.5179026772634477, 0.5947974890323051, 0.7171411266234997, 0.42949247497791954, 0.5174895765760292, 0.5949977194660006, 0.7193892403432052, -0.503243799368527, -0.424018918523115, -0.35638726499179363, -0.24878264821909113, -0.5041663126638501, -0.4263966880123814, -0.3578993464904038, -0.24797566863255538, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21783745550468941, 0.21785118865426772, 0.203043737617045, 0.20235953168203266, 0.8217607414903985, 0.1371371371371371, 0.26325697850843666, -0.3633633633633632, 0.5064102564102564], "score_GlobalLocal_5D": 0.0001974102051462978, "score_Basins_5D": 0.9998524188995361, "ela_features_10D": [0.006510011025007989, 0.48114261863329516, 0.003101569614663487, 0.031361236400108385, 66.77082817402167, 0.01552864135474381, 0.9884865122603108, 1.023186865819356, 0.9946131619486941, 0.24909485071121376, -0.10501294019226677, 1.6, 1.0115778486822353, 0.9388995301083947, 0.7205659522230292, 0.10326084559790612, -0.5974824321204981, 0.6259575677867231, 0.6862713812327979, 0.7352201457329901, 0.8097498794921096, 0.6285220731529553, 0.6908785289412865, 0.7402443976540936, 0.8145416323565303, -0.47442598803451064, -0.39792481787676104, -0.33583941970849757, -0.24130810239335648, -0.47249415929624805, -0.3931783997308744, -0.3303876419604751, -0.23588795341937, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11071843008021154, 0.11071371561384658, 0.10765831469652391, 0.10303012331328538, 0.8586986918541968, -0.1271271271271271, 0.13036704712879751, -0.6316316316316314, 0.5831865492393915], "score_GlobalLocal_10D": 0.00019993186288047582, "score_Basins_10D": 0.9997735619544983}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[33, [0.00044444444444512003, 2.0000000000003304], 1.000000197530864], [36, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [31, [2.0000000000003304, 0.00044444444444512003], 1.000000197530864]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.8093430360216034e-163, 3.509470229236667e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.151109603491714e-163, -1.4190769554214708e-162, -1.0031200999033706e-162, -1.8972787246941015e-164, 9.938378871486332e-163]}
{"id": "f556a0fc-4fca-482b-a035-1dd273988d3b", "fitness": 0.5131421685218811, "name": "landscape", "description": "A multi-well Gaussian landscape with one deepest global well and several identical local wells arranged on a regular grid. The wells are spaced to produce roughly uniform basin sizes, while the global well is deeper to create a clear global-local minima contrast. This yields a challenging but interpretable benchmark for black-box optimization within [-5,5] per dimension.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Gaussian width (basis of all wells)\n        self.sigma = 1.0\n        # Total number of wells (global + locals)\n        if self.dim <= 1:\n            # 1D: use a 5-point grid for wells\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.N_wells = min(5, len(grid))\n            # Centers are 1D (dimension matches self.dim)\n            self.centers = [np.array([g], dtype=float) for g in grid[:self.N_wells]]\n        else:\n            # 2D+ case: use a regular 4x4 grid in the first two dimensions\n            grid = [-4.0, -1.0, 2.0, 5.0]  # spacing ~3, all within [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # If dim > 2, ensure centers have length dim (pad with zeros)\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes (depths) for each well\n        # Global deepest well is the first one; others are identical to enforce BasinSizeHomogeneity\n        self.A = [6.0] + [2.0] * (self.N_wells - 1)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = 0.0\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            val += - self.A[i] * np.exp(- dist2 / two_sigma2)\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.964, Basins 0.133,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.19708680202520967, 0.6860997297827938, 0.1579586226030635, 0.16888836998456072, 1.0710575105315843, 0.3658934092336705, 0.2908594042846134, 1.1283673366465536, 0.6233498730326861, -3.2844120389148985, 13.114257351773137, 3.6, 0.2426742207980775, 0.5870152717578907, 0.22434050571805947, 0.37714413602674945, -0.24428509391096656, 0.13985960750560616, 0.2224986199363978, 0.7501626339769528, 1.0174505804367002, 0.14516009950192066, 0.225234121662736, 0.5929683575757025, 1.0522597976288437, -0.4501804097588266, -0.40693085045920485, -0.13079729265324364, 0.009130748899745966, -0.43952453402484426, -0.3983554349187868, -0.2094010002460136, 0.026852241849764, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5154571008084712, 0.515408876811686, 0.4705808031121766, 0.4755763895280241, 0.7600155226178524, 0.7617617617617616, 0.480874286296308, -0.08308308308308308, 0.40843373493975904], "score_GlobalLocal_2D": 0.9786465764045715, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.002400834715699762, 0.9822957167148685, 0.000554041638870193, 0.0069265354003955875, 17.83262581973117, -0.008246207689221218, 0.11604157259151981, 65.3411733251475, 0.2284228994942213, -8.68949045916261, 102.03349882462275, 6.8, 0.8117488779420855, 0.8603394979312062, 0.5784777054793613, 0.19247334508382874, -0.32899682813468073, 0.6894680067794314, 0.6951467016666836, 0.7256162965888457, 0.7902401412800136, 0.6898220467842149, 0.680245402137097, 0.7089577869783893, 0.778439330759777, -0.27325011359656404, -0.26825514294572594, -0.2414443952111296, -0.18457911187201814, -0.2745834457058828, -0.2830735447503178, -0.25765650230352416, -0.19614431068163157, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2159740657532705, 0.2159560670765664, 0.21391944388486378, 0.18056291652549133, 0.5729284556865427, 0.18518518518518512, 1.1813381681024504e-05, -3.6306306306306313, 0.5110576923076924], "score_GlobalLocal_5D": 0.6214264035224915, "score_Basins_5D": 0.38014766573905945, "ela_features_10D": [-0.0021494397423254875, 0.998388119468275, 0.00012060934201459778, 0.003031589557924111, 58.31082905916185, -0.018196895803713486, 0.008980459281017294, 30.24936337719057, 0.007369147343949245, -30.90619345416648, 1046.2430906199525, 3.2, 0.9801224633037666, 0.9295446967068177, 0.6796403864527847, 0.11117919801011156, -0.21187200837683923, 0.6774886618391857, 0.7246071055109626, 0.7637330089564724, 0.8298431682001736, 0.6709479943309227, 0.7201952297918593, 0.7625972652100736, 0.8306160038679649, -0.40902391538871197, -0.3492665856272259, -0.299644474212296, -0.2158005244344582, -0.4184366039526159, -0.3558111196947475, -0.30188942364123594, -0.21539423441391312, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10941111020456344, 0.10940950709479284, 0.10929776444353032, 0.09977120904350173, 0.5579796095845951, -2.061061061061061, 0.0, -Infinity, 0.5600480384307446], "score_GlobalLocal_10D": 0.9637989401817322, "score_Basins_10D": 0.13349300622940063}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [4.962888888888771, 4.962888888888771], -2.0471561960207123], [4, [4.962888888888771, -0.9995555555555558], -2.068397389770059], [4, [-0.9995555555555558, 4.962888888888771], -2.0683973897700594], [6, [4.962888888888771, 1.999777777777864], -2.068397512972315], [6, [1.999777777777864, 4.962888888888771], -2.068397512972315], [6, [1.999777777777864, -0.9995555555555558], -2.0898591062765024], [6, [-0.9995555555555558, 1.999777777777864], -2.0898591062765024], [9, [1.999777777777864, 1.999777777777864], -2.0898592300803482], [4, [-1.0030703191010164, -1.0006763767342979], -2.0903502209056564], [6, [4.962888888888771, -3.9628888888888807], -2.0471561960207123], [6, [-3.9628888888888807, 4.962888888888771], -2.0471561960207127], [9, [1.999777777777864, -3.9628888888888807], -2.0683975739315215], [9, [-3.9628888888888807, 1.999777777777864], -2.068397573931522], [6, [-1.1068018696876383, -3.9640016783161043], -2.1197794427698953], [6, [-3.9644259948272036, -1.1066063061027829], -2.119779626448207], [9, [-3.9880799999745062, -3.9888888568888974], -6.045459783410072]], "nr_of_basins": 16, "f_opt_dim_2": -6.045460742996053, "x_opt_dim_2": [-3.9884562697295474, -3.9884562734588034], "f_opt_dim_5": -2.0898593136888506, "x_opt_dim_5": [1.9999998856866432, -0.9999998895580786, 8.754763505114222e-09, -2.165473099688376e-09, 2.0757424987911174e-09]}
{"id": "806708df-1ba9-4d6e-97f4-8439aa948562", "fitness": 0.5519084334373474, "name": "landscape", "description": "A multi-basin quadratic landscape formed as the minimum of several parabolic wells (centred on a regular grid). The origin is a deeper global minimum, while all other wells provide shallow local minima. The basins are arranged to yield roughly uniform basin sizes, and the landscape exposes quantitative metrics for GlobalLocal contrast and Basin size homogeneity.", "code": "import numpy as np\nimport itertools\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Parameters for the multi-basin construction\n        self.alpha = 1.0      # common quadratic coefficient\n        self.a = 1.5            # half-range for centers along each axis\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n\n        # Build centers on a small grid: coordinates in {-a, 0, a} for each dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local basins: set a deep global minimum at the origin (0,...,0)\n        self.beta = np.full(self.K, -9.5, dtype=float)\n        # Find index of the origin center\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the centers.\")\n        self.beta[origin_index] = -12.0  # deepest well at the origin\n        self.origin_index = origin_index\n\n        # Precompute a few landscape characteristics\n        # 1) Global and local minima strength (GlobalLocal contrast)\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = np.mean(f_center_values)\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # 2) Basin size homogeneity\n        # Sample a deterministic grid of points in the domain and assign each to the\n        # basin (i.e., the center k that minimizes alpha*||x - c_k||^2 + beta_k)\n        coords = [-self.domain_hi, 0.0, self.domain_hi]\n        grid_points = np.array(list(itertools.product(coords, repeat=self.dim)))\n        counts = np.zeros(self.K, dtype=int)\n        for x in grid_points:\n            x = np.asarray(x, dtype=float)\n            d2 = np.sum((self.centers - x) ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n        nonzero = counts[counts > 0]\n        self.basin_homogeneity = 1.0 if nonzero.size <= 1 else (np.max(nonzero) / np.min(nonzero))\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) for x in R^dim as the minimum over all wells:\n          f(x) = min_k ||x - c_k||^2 * alpha + beta_k\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        d2 = np.sum((self.centers - x) ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0019021540475833599, 0.31035294396225016, 0.009768905525037135, 0.02743528837151647, 5.507035099401793, -0.0024389872866842355, 0.9641039754224611, 1.0189219488287184, 0.9644986486761529, 0.6772640980878923, -0.19052435194034184, 1.0, 0.6973514365348901, 0.7241527469807946, 0.5568595035016299, 0.3332824735993443, -0.21806639041094517, 0.1620117526003335, 0.2270362850791922, 0.3172966157555318, 0.4897612257090861, 0.1645116783281937, 0.22708307119192575, 0.3217177796065598, 0.4909431225070273, -0.4382038461847488, -0.40419865508830516, -0.35700120836075966, -0.26681488817326765, -0.42812361002913335, -0.3960628514522494, -0.34756631134441685, -0.2608539924025173, 1.0, 1.0, 1.0, 1.0, 0.5170006738904297, 0.5169904104460299, 0.41138844282552267, 0.35358332955274496, 0.7045660853564812, 0.4934934934934933, 0.4218614012026404, -0.09509509509509509, 0.38433734939759034], "score_GlobalLocal_2D": 0.9450161457061768, "score_Basins_2D": 0.36629560589790344, "ela_features": [-0.0007763924965489055, 0.34576786789502917, 0.0040090510734925415, 0.029792224351213044, 18.93285829905919, 0.0031958992416332155, 0.9481362913399849, 1.0366754446811979, 0.9484193703343278, 0.49016563081410897, -0.06742707501347409, 1.0, 0.8787733665174446, 0.8697440288893314, 0.6163522009842437, 0.1860198884604241, -0.4976336994538958, 0.4777564970122124, 0.5530000806178357, 0.6171615164276222, 0.7306537028452633, 0.4823151173823687, 0.5558871892602052, 0.6223857057350545, 0.7345745781616113, -0.4594219539328175, -0.3932299652946708, -0.3367872842569338, -0.23694701961177494, -0.4580778925956356, -0.3929801221183983, -0.3341413343143049, -0.2348680638758709, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21520325994308703, 0.21520842297253134, 0.19774895974605805, 0.18150726903455247, 0.8317668346845151, 0.25325325325325315, 0.30029478478158955, -0.2872872872872872, 0.5392628205128205], "score_GlobalLocal_5D": 0.0004705054161604494, "score_Basins_5D": 0.9998124241828918, "ela_features_10D": [-0.0006531826113092221, 0.36910549875574367, 0.0015082053884958018, 0.016791428327603213, 14.3147126619042, 0.005045699858729246, 0.9481215383686136, 1.0424492164923789, 0.9484927211206653, 0.3715751629131242, 0.0490821672551605, 1.4, 1.0077455684109289, 0.9377215296836265, 0.6981353212055557, 0.10645287624689041, -0.6074284601276971, 0.6450259442930777, 0.6984481488685509, 0.7428248155108881, 0.8147960888914063, 0.6454895080637909, 0.7018538058709822, 0.7470354979805953, 0.8192054874833892, -0.45022659175723156, -0.3824690838203153, -0.3261845965576675, -0.23490067304814657, -0.4508666531371934, -0.3791823634433297, -0.32172044337690037, -0.22993408445890423, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10997648978191779, 0.10997496715482229, 0.10699245737162358, 0.10039618280936154, 0.8610232273411107, -0.08308308308308307, 0.13451154432876192, -0.6396396396396394, 0.6044835868694955], "score_GlobalLocal_10D": 0.00023008426069281995, "score_Basins_10D": 0.999625563621521}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[24, [0.00044444444444512003, 0.00044444444444512003], -11.999999604938271], [16, [-1.4997894663066353, -1.4997894663066353], -9.499999911351129], [20, [-1.4998808524022824, 1.489593443211053], -9.499891689379648], [22, [1.4998829417916182, -1.4966731145726204], -9.499988918130729], [18, [1.4986653078070928, 1.5009779404455346], -9.499997262229234]], "nr_of_basins": 5, "f_opt_dim_2": -12.0, "x_opt_dim_2": [-2.566755170077227e-09, 1.3754842973978955e-08], "f_opt_dim_5": -12.0, "x_opt_dim_5": [5.408707054287561e-09, 1.7639434454887887e-08, -6.705437575275315e-09, 1.8327051472106174e-08, 2.3781018376982556e-09]}
{"id": "59e097eb-1e98-4edf-a76b-9c21aef339d0", "fitness": 0.5369756817817688, "name": "landscape_min_gaussians_homogeneous", "description": "A homogeneous multi-basin Gaussian landscape formulated as the minimum over Gaussian wells on a symmetric grid, with a deeper global well to induce global-local contrast while preserving roughly equal basin sizes via identical widths and symmetric placement.", "code": "import numpy as np\n\nclass landscape_min_gaussians_homogeneous:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Shared Gaussian width for all wells\n        self.sigma = 1.0\n\n        if self.dim <= 1:\n            # 1D: use a symmetric grid of wells\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.N_wells = min(5, len(grid))\n            self.centers = [np.array([g], dtype=float) for g in grid[:self.N_wells]]\n        else:\n            # 2D+ case: place wells on a regular 4x4 grid in the first two dims\n            grid = [-4.0, -1.0, 2.0, 5.0]  # spacing ~3, within [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # If dim > 2, pad centers to match self.dim\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes: a deeper global well (global) plus identical local wells\n        self.A = [6.0] + [2.0] * (self.N_wells - 1)\n\n        # The landscape is constructed as a min over Gaussian wells:\n        # f(x) = min_i { -A[i] * exp(-||x - center_i||^2 / (2*sigma^2)) }\n        # This fosters clearly defined, approximately homogeneous basins of attraction\n        # while maintaining a global-local minima contrast through the deeper global well.\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = float('inf')\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            candidate = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if candidate < val:\n                val = candidate\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_min_gaussians_homogeneous scored on:GlobalLocal 0.746, Basins 0.498,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f556a0fc-4fca-482b-a035-1dd273988d3b"], "operator": null, "metadata": {"ela_features_2D": [0.16803744674807583, 0.6755752902861236, 0.1376275471759503, 0.14535306416962665, 1.0559228209542926, 0.2812877224154501, 0.2712516604415839, 1.1587097626244742, 0.5088532841336992, -2.543963009230356, 9.20579375338115, 3.8, 0.22869257989610267, 0.5799336037141494, 0.23740284696327438, 0.3771484279555523, -0.321882977844287, 0.16915011793281792, 0.24973416513203608, 0.8855725465755631, 1.03142351349963, 0.16951708396859522, 0.24349208521162674, 0.8411100370887477, 1.0612977076530639, -0.4347997831321321, -0.39262805601203377, -0.059883929754911545, 0.01644529581197789, -0.42677149609004994, -0.38876229089452546, -0.08167920491379381, 0.03148695071142049, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5154506825319352, 0.5154367478934601, 0.48118840323904666, 0.47771838088028334, 0.7749150115560919, 0.7297297297297295, 0.7459275952118551, 0.06106106106106102, 0.4248995983935743], "score_GlobalLocal_2D": 0.938332200050354, "score_Basins_2D": 0.0012942879693582654, "ela_features": [-0.0021165541372245135, 0.9857315458969051, 0.0008314210466476062, 0.007291494699225645, 19.397102591482398, -0.009254906982403676, 0.10319280845265691, 28.787224574433584, 0.1940969021987185, -9.813224402395083, 126.35032557315844, 7.0, 0.8168078861438234, 0.8650167292408903, 0.5918191967524981, 0.1884374592909876, -0.343681601356143, 0.6604963423147832, 0.6730377674915499, 0.7063155619376096, 0.7862714164278037, 0.6388588800410667, 0.6474722420334602, 0.6828108318261534, 0.772470805723825, -0.29868513018975096, -0.28764936212130976, -0.258373509067619, -0.18803110535321035, -0.31948612476280325, -0.3118606725141988, -0.2805994730315973, -0.20128362766852112, 1.0, 1.0, 0.8333333333333334, 1.0, 0.213299865237357, 0.21329126126994927, 0.21141620096032548, 0.1793799856238093, 0.5793723623796267, 0.1651651651651651, 1.232918665734401e-05, -3.622622622622623, 0.5044871794871795], "score_GlobalLocal_5D": 0.1906857192516327, "score_Basins_5D": 0.8470000624656677, "ela_features_10D": [-0.0026780528139415337, 0.9982860373029652, 2.301982538969108e-05, 0.0019982322662418146, 128.02780273259776, -0.019694998691850474, 0.004072322646522686, 4.7998145303931, -0.019095790509034427, -37.28988282091409, 1530.8077216528525, 3.6, 0.9636422319128002, 0.929485192227402, 0.6771844662966663, 0.11018243078307115, -0.18052534343615467, 0.6774020257608473, 0.721773927757873, 0.7639029830629427, 0.832366235486903, 0.6688024035200081, 0.7186101971709548, 0.7620438168029388, 0.8332818548473305, -0.40912568847998454, -0.35285184329917857, -0.29942311074710737, -0.21259658528323438, -0.42112471929363104, -0.35779163334835473, -0.3025654752482577, -0.21198483923714084, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10963396608250438, 0.10963225719987946, 0.10955406943048787, 0.09984744086972545, 0.5663808561803892, -2.2572572572572573, 0.0, -Infinity, 0.5572457966373099], "score_GlobalLocal_10D": 0.7464452385902405, "score_Basins_10D": 0.4980968236923218}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [5.0, 5.0], -2.0], [4, [5.0, -0.9995555555555558], -1.9999998024691457], [4, [-0.9995555555555558, 5.0], -1.9999998024691457], [4, [-0.9995555555555558, -0.9995555555555558], -1.9999996049383106], [6, [5.0, 1.999777777777864], -1.9999999506172845], [6, [1.999777777777864, 5.0], -1.9999999506172845], [6, [1.999777777777864, -0.9995555555555558], -1.999999753086435], [6, [-0.9995555555555558, 1.999777777777864], -1.999999753086435], [9, [1.999777777777864, 1.999777777777864], -1.9999999012345704], [6, [5.0, -4.00000000000011], -2.0], [6, [-4.00000000000011, 5.0], -2.0], [6, [-0.9995555555555558, -4.00000000000011], -1.9999998024691457], [6, [-4.00000000000011, -0.9995555555555558], -1.9999998024691457], [9, [1.999777777777864, -4.00000000000011], -1.9999999506172845], [9, [-4.00000000000011, 1.999777777777864], -1.9999999506172845], [9, [-4.00000000000011, -4.00000000000011], -6.0]], "nr_of_basins": 16, "f_opt_dim_2": -6.0, "x_opt_dim_2": [-3.9999999995744364, -3.999999998422388], "f_opt_dim_5": -2.0, "x_opt_dim_5": [1.9999999966865654, -0.9999999933946054, 4.342184720438782e-10, -3.30937489068483e-09, -3.5331806060114828e-09]}
{"id": "3fb4f864-876c-4d8f-82fa-317f2f82e53a", "fitness": 0.5007156133651733, "name": "landscape_parabolic_minima", "description": "A new multi-basin benchmark defined as the minimum over a set of parabolic wells (quadratic basins) arranged on a small grid in the first two dimensions. The global minimum sits at the origin with a deeper depth, while several symmetric local minima appear at grid centers. All wells share the same curvature, yielding homogeneous basin sizes, and non-differentiability arises from the min-over-wells construction.", "code": "import numpy as np\nfrom itertools import product\n\nclass landscape_parabolic_minima:\n    \"\"\"\n    A novel benchmark landscape for minimization.\n\n    Construction:\n    - The objective is the minimum over a set of parabolic wells:\n        f_i(x) = 0.5 * kappa * ||x - c_i||^2 - A_i\n      where all wells share the same curvature (kappa) and depth offsets A_i.\n    - A global deep well sits at the origin (c_0 = 0) with depth A_global.\n    - Local wells are centered on a small grid in the first k dimensions (k = min(dim, 2))\n      with centers at positions in {-s, 0, +s} along those axes, and zeros elsewhere.\n    - In all wells, the global minimum is at the origin; local wells provide symmetric\n     , homogeneous basins of attraction.\n    - The function is defined as the minimum over all wells, providing non-differentiable\n      ridges at basin boundaries and a tunable GlobalLocal contrast.\n    - All centers lie within [-5, 5] per dimension for the domain specification.\n\n    Parameters:\n    - dim: dimensionality of the input space.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Number of axes used to place wells (deterministic and small to keep wells manageable)\n        self.k = min(self.dim, 2)\n\n        # Grid parameters for well centers (within domain [-5, 5])\n        self.s = 2.0           # distance along each axis to local well centers\n        self.kappa = 1.0        # curvature of each parabolic well (same for all wells)\n\n        # Depths (negative values). Global well deeper than locals to create GlobalLocal contrast.\n        self.A_global = 3.0\n        self.A_local = 1.5\n\n        # Build centers and corresponding amplitudes\n        self.centers = []\n        self.amplitudes = []\n        self._build_centers()\n\n        # Convert to numpy arrays for performance\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.amplitudes = np.asarray(self.amplitudes, dtype=float)\n\n        # Precompute constant\n        self._half_kappa = 0.5 * self.kappa\n\n    def _build_centers(self):\n        # Global/global well at origin\n        self.centers.append(np.zeros(self.dim))\n        self.amplitudes.append(self.A_global)\n\n        # Local wells placed on a small grid in the first k dimensions\n        coords = [-self.s, 0.0, self.s]\n        for t in product(coords, repeat=self.k):\n            # Skip the origin (already added as global well)\n            if all(abs(val) < 1e-12 for val in t):\n                continue\n\n            c = np.zeros(self.dim)\n            for i, val in enumerate(t):\n                c[i] = val\n            self.centers.append(c)\n            self.amplitudes.append(self.A_local)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value to be minimized.\n        Landscape is defined as:\n          f(x) = min_i [ 0.5 * kappa * ||x - c_i||^2 - A_i ]\n        where (c_i, A_i) are the centers and depths of the wells.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_val = float(\"inf\")\n        for c, a in zip(self.centers, self.amplitudes):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            val = self._half_kappa * dist2 - a\n            if val < min_val:\n                min_val = val\n        return float(min_val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_parabolic_minima scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f1e38a3-6b6b-48c7-a7d2-54691e3c1bf6"], "operator": null, "metadata": {"ela_features_2D": [-0.002042333784203265, 0.3451487234705019, 0.00808987770556929, 0.026943959765747323, 5.247796868192627, -0.0019740275068937272, 0.9189891555248128, 1.0187646960571715, 0.921852214226873, 0.7004252041928515, -0.07233012952695166, 1.4, 0.6335244669723706, 0.7086335876105843, 0.5257604997634158, 0.3412707872179412, -0.23752865761457484, 0.14924822184246198, 0.2355315884427251, 0.32239205620699585, 0.5253869168799543, 0.1483190897190843, 0.2344577995438606, 0.3234482815435509, 0.5203364166658557, -0.4450622757813839, -0.39992396960958465, -0.35448245257800887, -0.24828840702276228, -0.4368962296377644, -0.39270757606913503, -0.34705175248195064, -0.2460539681808877, 1.0, 1.0, 1.0, 1.0, 0.5162450206195357, 0.5161354780686056, 0.419809529160977, 0.35297755302245826, 0.7209109369451785, 0.5455455455455454, 0.5325658048358501, -0.07907907907907909, 0.39518072289156625], "score_GlobalLocal_2D": 0.9875122904777527, "score_Basins_2D": 0.01660703308880329, "ela_features": [-0.0006011335743763224, 0.39715243605968953, 0.003444169264077406, 0.026368851986440713, 30.842031462656507, 0.005488795155481951, 0.9932784873435484, 2.9614529888788748, 0.9936628752021862, 0.33054306360023444, -0.28008987911612476, 1.0, 0.8873599346095411, 0.8704864618526045, 0.6125730309892408, 0.18592919945356323, -0.4637678815497857, 0.48131997076745314, 0.5549909780270401, 0.6324532688648885, 0.7413871064087642, 0.46135952593212914, 0.5483944231460033, 0.6216031894059396, 0.73749203478197, -0.45632438038041123, -0.3915121175371452, -0.3233604104236657, -0.22752185612573736, -0.47650740287939647, -0.3995144035190097, -0.33474817518883715, -0.23222712614787153, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21784016303616474, 0.21782478791886933, 0.20183880908733537, 0.18274551314143367, 0.8320598051882986, 0.1611611611611611, 0.25635897808897445, -0.3713713713713712, 0.5166666666666667], "score_GlobalLocal_5D": 0.0002057963574770838, "score_Basins_5D": 0.9998811483383179, "ela_features_10D": [0.00025550206089040015, 0.44803006512728505, 0.00037137912778499057, 0.02427536312888277, 104.9294330687923, 0.006194706092537872, 0.9973592237483342, 2.970028958530238, 0.9975090535276323, 0.22393591359832515, -0.08106634118021257, 1.2, 1.013602110194315, 0.9375808631707633, 0.7118930091237463, 0.10587800426725942, -0.6049981281345203, 0.6426191476384912, 0.6947534535057718, 0.7447570066733864, 0.8184732042857966, 0.6408008345378856, 0.6962310941177737, 0.7471862164252284, 0.821420390208047, -0.4532742791982091, -0.38715059745289515, -0.3237298101804081, -0.23023398059033418, -0.4568715490090254, -0.38636703105739234, -0.3215551648924342, -0.22713580340339695, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11045895595720231, 0.11045889612067661, 0.10740942569192542, 0.10078417262768535, 0.8627821159973144, -0.12312312312312308, 0.1286214383768512, -0.6476476476476474, 0.5903122497998399], "score_GlobalLocal_10D": 0.00023754897119943053, "score_Basins_10D": 0.9998500347137451}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [0.00044444444444512003, 0.00044444444444512003], -2.999999802469136], [6, [0.00044444444444512003, -1.9997777777778631], -1.4999998765432099], [6, [-1.9997777777778631, 0.00044444444444512003], -1.4999998765432099], [16, [-1.9997777777778631, -1.9997777777778631], -1.499999950617284], [6, [0.00044742712681760153, 1.999870959751011], -1.4999998915787902], [6, [1.9998833140699743, 0.00044761130994803604], -1.4999998930142544], [16, [1.9999377421687548, -1.9997722304772083], -1.4999999721225035], [16, [-1.9997722796422377, 1.9999426712868238], -1.4999999724284288], [16, [1.9999536908182092, 1.999937200303736], -1.4999999969558289]], "nr_of_basins": 9, "f_opt_dim_2": -3.0, "x_opt_dim_2": [1.5440471053149315e-08, 1.1676507657866648e-08], "f_opt_dim_5": -3.0, "x_opt_dim_5": [1.1331164129600832e-08, 5.052909920150988e-09, -2.6495936602216413e-09, 5.454858993471025e-10, -1.3100289546858069e-08]}
{"id": "70b13637-56c4-4f6d-b087-7edcc41b879a", "fitness": 0.5179827213287354, "name": "landscape_improved", "description": "A high-contrast multi-well Gaussian landscape with a deeply deeper global well on a grid. The depth ratio between the global and local wells is boosted to enhance GlobalLocal, making the global optimum easily distinguishable while preserving homogeneous basin sizes. Suitable for any dimensionality within [-5,5] per dimension.", "code": "import numpy as np\n\nclass landscape_improved:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Gaussian width (same for all wells)\n        self.sigma = 1.0\n\n        if self.dim <= 1:\n            # 1D: use a 5-point grid\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.centers = [np.array([g], dtype=float) for g in grid[:5]]\n            self.N_wells = len(self.centers)\n        else:\n            # 2D+ case: regular 4x4 grid in the first two dimensions\n            grid = [-4.0, -1.0, 2.0, 5.0]  # roughly evenly spaced within [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # Pad centers for dim > 2\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes (depths) for each well\n        # Global deepest well is first; others are shallower\n        # GlobalLocal contrast is boosted by a large gap between global and local wells\n        self.A = [12.0] + [4.0] * (self.N_wells - 1)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = 0.0\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            val += - self.A[i] * np.exp(- dist2 / two_sigma2)\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_improved scored on:GlobalLocal 0.959, Basins 0.143,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f556a0fc-4fca-482b-a035-1dd273988d3b"], "operator": null, "metadata": {"ela_features_2D": [0.20842639125552215, 0.6884779943809568, 0.16140818063365084, 0.1675830747095183, 1.0394928795672898, 0.36869694616492704, 0.29116051749742344, 1.0580990716879548, 0.6273291726446081, -3.347326005472394, 13.641030465111971, 3.8, 0.24234385180134446, 0.5899565850296972, 0.28183149438998567, 0.3743129219974338, -0.24108315063659652, 0.14115637956185564, 0.2189932687704304, 0.7453067679872933, 1.0047572060045655, 0.14596149585192048, 0.21829065880492088, 0.5142295259087679, 1.0206388945092941, -0.4495951944682167, -0.4088491046931302, -0.1333188901714172, 0.00249123690467814, -0.4394848243523491, -0.40226539512755294, -0.2499888754411539, 0.010590782256831587, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5152884527032665, 0.515212591183244, 0.46490558020359574, 0.4794774421597962, 0.7564107615951525, 0.7057057057057055, 0.5127760009551802, -0.06706706706706708, 0.40361445783132527], "score_GlobalLocal_2D": 0.9858990907669067, "score_Basins_2D": 0.0018604384968057275, "ela_features": [-0.00040338181312011835, 0.9763459424752619, 0.0007461238094517192, 0.012526671663913825, 23.21434724421725, -0.007042459330004735, 0.12829107112766452, 466.359651107179, 0.25013712203248245, -7.3871203277673985, 65.9564461917395, 7.4, 0.8150625554166012, 0.8631236210993706, 0.5869439942073743, 0.1899870470766317, -0.3336420183612187, 0.6415994811399675, 0.6867794060311931, 0.7199704843267861, 0.7913381966628886, 0.6218512787501304, 0.6685240268000676, 0.6989890308706059, 0.7791269189345421, -0.3153419473181812, -0.2755967249615154, -0.24639374656867555, -0.18359816322435427, -0.3345753931907732, -0.2933136541076483, -0.26636296513838653, -0.1954490479483996, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21550961987126493, 0.21550770065667954, 0.21257706434996804, 0.18162218677277592, 0.5712054112633418, 0.3173173173173172, 1.7898335190437425e-05, -3.526526526526527, 0.5137820512820512], "score_GlobalLocal_5D": 0.965082585811615, "score_Basins_5D": 0.05304644629359245, "ela_features_10D": [-0.002152609723813237, 0.9975397498449915, 3.0554691170108694e-05, 0.002868635791792703, 282.2949247829471, -0.018334514718900952, 0.00813596246160373, 4.709119606675837, 0.004529047873588809, -33.85261383154155, 1319.4789664544974, 4.0, 0.9766464632117883, 0.9291970173779933, 0.6849923456254261, 0.1117446544037615, -0.18740022269976125, 0.6803033588638006, 0.7236877407528626, 0.7602794799644592, 0.8265143449514204, 0.6713172861205086, 0.7188160379555079, 0.7592079837865594, 0.8277218915202432, -0.40541110196304053, -0.35039554593610733, -0.3039932864897194, -0.21999970800795365, -0.41778393405285097, -0.3574109782548196, -0.306069138611161, -0.21898138295359368, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10992815508259754, 0.10992988730063884, 0.10983239590888157, 0.10000709910288819, 0.5571607865634882, -1.6926926926926928, 0.0, -Infinity, 0.5585268214571657], "score_GlobalLocal_10D": 0.9588812589645386, "score_Basins_10D": 0.14312641322612762}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [4.962888888888771, 4.962888888888771], -4.094312392041425], [4, [4.962888888888771, -0.9995555555555558], -4.136794779540118], [4, [-0.9995555555555558, 4.962888888888771], -4.136794779540119], [6, [4.962888888888771, 1.999777777777864], -4.13679502594463], [6, [1.999777777777864, 4.962888888888771], -4.13679502594463], [6, [1.999777777777864, -0.9995555555555558], -4.179718212553005], [6, [-0.9995555555555558, 1.999777777777864], -4.179718212553005], [9, [1.999777777777864, 1.999777777777864], -4.1797184601606965], [4, [-1.0030703191010164, -1.0006763767342979], -4.180700441811313], [6, [4.962888888888771, -3.9628888888888807], -4.094312392041425], [6, [-3.9628888888888807, 4.962888888888771], -4.0943123920414255], [9, [1.999777777777864, -3.9628888888888807], -4.136795147863043], [9, [-3.9628888888888807, 1.999777777777864], -4.136795147863044], [6, [-1.1068018696876383, -3.9640016783161043], -4.2395588855397905], [6, [-3.9644259948272036, -1.1066063061027829], -4.239559252896414], [9, [-3.9880799999745062, -3.9888888568888974], -12.090919566820144]], "nr_of_basins": 16, "f_opt_dim_2": -4.18070852613248, "x_opt_dim_2": [-1.0008852684015221, -1.0008852683946747], "f_opt_dim_5": -4.179718627377701, "x_opt_dim_5": [1.9999998773849519, -0.9999998944790582, -7.084433413421984e-09, -6.09727770121918e-09, -1.7670277471407044e-09]}
{"id": "1541bb5b-6ee8-49e4-a572-d159a1132122", "fitness": 0.5318999290466309, "name": "landscape", "description": "A min-over-quadratic-wells benchmark arranged on a circle in the first two dimensions (plus a global well at the origin). The global minimum sits at the origin with a deeper depth, while several local quadratic wells are placed equidistantly on a circle to yield a symmetric, homogeneous basin structure. For 1D, wells are placed along a line. This provides a completely different construction from the Gaussian-basin solver while maintaining GlobalLocal contrast and Basin size homogeneity.", "code": "import numpy as np\nimport math\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Global minimum and local minima depths (negative values are minima)\n        self.A_global = 2.2   # depth of the global well at origin\n        self.A_local = 1.0    # depth of each local well\n        self.r = 2.2            # radius for placing local wells (in plane of first two dims)\n\n        # Centers and corresponding \"depths\" for the parabolic wells\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # Fallback 1D: place wells along the line at -r and +r\n            c_left = np.array([-self.r])\n            c_right = np.array([ self.r])\n            centers.append(c_left)\n            centers.append(c_right)\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a circle in the first two dimensions\n            n_local = max(3, min(self.dim, 12))  # ensure a reasonable number of wells\n            for i in range(n_local):\n                theta = 2.0 * math.pi * i / float(n_local)\n                c = np.zeros(self.dim)\n                c[0] = self.r * math.cos(theta)\n                c[1] = self.r * math.sin(theta)\n                centers.append(c)\n                depths.append(-self.A_local)\n\n        # Convert to numpy arrays for efficient evaluation\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n        # Precompute nothing else (we use a simple min over quadratics)\n    \n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i { depth_i + || x - center_i ||^2 }\n        - Global minimum sits at origin with value -A_global\n        - All local wells have equal shape/width; centers are arranged on a circle\n          to ensure basin size homogeneity under symmetric perturbations.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_vals = []\n        for c, d in zip(self.centers, self.depths):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            min_vals.append(d + dist2)\n        return float(min(min_vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f1e38a3-6b6b-48c7-a7d2-54691e3c1bf6"], "operator": null, "metadata": {"ela_features_2D": [0.006750685168721659, 0.2316385819075196, 0.02084138451612131, 0.06603388390099116, 4.8428560866257895, 0.009284936477216598, 0.8312363818769664, 1.029016088231653, 0.9668422016876717, 0.9588405744321635, 0.5209183922922868, 1.0, 0.6469348110942585, 0.7110448120764119, 0.5037260062327544, 0.34123812081422067, -0.209471861203497, 0.13778204097804278, 0.24928683892160844, 0.3981061856502853, 0.538571150739459, 0.14053283908011607, 0.23854564935122774, 0.3867777144321887, 0.5340543151111, -0.451300777940219, -0.39293175669683833, -0.31504556635114633, -0.24151849018244098, -0.4414549796508439, -0.39111269887623257, -0.3149855333011442, -0.2393174218156066, 1.0, 1.0, 1.0, 1.0, 0.5106715744001318, 0.5106618072993708, 0.41252520746545096, 0.3679127214105512, 0.7005289247340523, 0.4534534534534533, 0.551318472938208, -0.09909909909909906, 0.37228915662650597], "score_GlobalLocal_2D": 0.934058666229248, "score_Basins_2D": 0.2572627067565918, "ela_features": [0.0018466434632649076, 0.367266936164503, 0.007048130196808405, 0.03176875791685916, 20.834841684531142, 0.011160605060280094, 0.9904532127860186, 2.116119289926078, 0.9938591013595133, 0.3921473472831208, -0.13874738591570468, 1.4, 0.8963964333025238, 0.8708866382151562, 0.632751033787974, 0.18554811091681328, -0.47436790419474095, 0.468146858944751, 0.5494380608070779, 0.6231194007674483, 0.731898103694945, 0.45488721137630594, 0.5434269794927157, 0.6176257257848387, 0.7313259983350142, -0.4677459661094548, -0.39625267518659923, -0.33145296549799347, -0.2357853816111625, -0.48176708504486127, -0.4035106120527317, -0.3379359657083638, -0.23744663793746082, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21816286786596767, 0.2181628796343369, 0.20364336654196133, 0.1854798256452056, 0.8231075490294923, 0.1411411411411411, 0.24334862769755095, -0.3953953953953953, 0.5173076923076924], "score_GlobalLocal_5D": 0.00020287105871830136, "score_Basins_5D": 0.9998524188995361, "ela_features_10D": [-0.0005835875759616415, 0.44297582989101947, 0.0012208955299748798, 0.016112594707734372, 28.28609659310257, 0.003292058130096387, 0.9973971241042717, 2.2587676752769013, 0.9988450544059496, 0.20311823405055907, -0.11671628957459897, 1.4, 1.0205671852598723, 0.9383018714596909, 0.7112727259446219, 0.10506768226931854, -0.6076033006854082, 0.6321483046380333, 0.6919082109406877, 0.7402876170534982, 0.8144430189543896, 0.6309668691738066, 0.6933599994859214, 0.7427563766231747, 0.818237395345889, -0.4665622715752834, -0.3907669061224001, -0.32940502909294683, -0.2353506204193488, -0.4693848015316993, -0.3900270724250193, -0.3271977287234075, -0.23119131027911793, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10976479824685836, 0.10976698983084465, 0.10677537004879686, 0.10040737762080638, 0.8530108863717931, -0.11911911911911906, 0.13085239530393297, -0.6516516516516514, 0.5882305844675739], "score_GlobalLocal_10D": 0.00015364222053904086, "score_Basins_10D": 0.9998694658279419}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [0.00044444444444512003, 0.00044444444444512003], -2.199999604938272], [27, [-1.0995555555555558, 1.905777777777864], -0.9999995301005355], [32, [-1.0995555555555558, -1.905777777777863], -0.9999995301005355], [29, [2.2000000000003084, 0.00044444444444512003], -0.9999998024691358]], "nr_of_basins": 4, "f_opt_dim_2": -2.2, "x_opt_dim_2": [6.481725521993301e-09, 2.3044279009627866e-10], "f_opt_dim_5": -2.2, "x_opt_dim_5": [-3.2811076495453167e-09, 4.628493370022331e-09, 1.082875703704068e-09, 5.63296923369143e-09, 7.2927252739680145e-09]}
{"id": "9b0029de-8ccc-44f0-90bf-ecf540ce31f6", "fitness": 0.5255573391914368, "name": "landscape_parabolic_grid_uniform", "description": "A multi-basin parabolic landscape with wells on a 3-ary grid, global optimum at the origin. Basins homogeneity is improved by robust Monte Carlo estimation of basin volumes to quantify and encourage uniform basin sizes.", "code": "import numpy as np\nimport itertools\n\nclass landscape_parabolic_grid_uniform:\n    def __init__(self, dim):\n        self.dim = dim\n\n        # Global settings for the multi-basin construction\n        self.alpha = 1.0        # common quadratic coefficient\n        self.a = 1.5              # half-range for centers along each axis\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n\n        # Build centers on a small grid: coordinates in {-a, 0, a} for each dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local basins: set a deep global minimum at the origin (0,...,0)\n        self.beta = np.full(self.K, -9.5, dtype=float)\n        # Find index of the origin center\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the centers.\")\n        self.beta[origin_index] = -12.0  # deepest well at the origin\n        self.origin_index = origin_index\n\n        # Precompute global-local minima contrast\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = np.mean(f_center_values)\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # Basins homogeneity: estimate basin sizes via Monte Carlo sampling\n        # A larger sample improves robustness of the homogeneity metric\n        self._estimate_basins(n_samples=20000, seed=12345)\n\n    def _estimate_basins(self, n_samples=20000, seed=12345):\n        rng = np.random.RandomState(seed)\n        counts = np.zeros(self.K, dtype=int)\n\n        domain_span = self.domain_hi - self.domain_lo\n        for _ in range(n_samples):\n            x = rng.rand(self.dim) * domain_span + self.domain_lo\n            d2 = np.sum((self.centers - x) ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n\n        # Consider only basins that actually attract samples (nonzero)\n        nonzero_mask = counts > 0\n        nonzero = counts[nonzero_mask]\n\n        if nonzero.size <= 1:\n            self.basin_homogeneity = 1.0\n        else:\n            self.basin_homogeneity = float(np.max(nonzero) / np.min(nonzero))\n\n        # Store for potential external introspection\n        self._basin_counts = counts\n        self._basin_n_samples = n_samples\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) for x in R^dim as the minimum over all wells:\n          f(x) = min_k (alpha * ||x - c_k||^2 + beta_k)\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        d2 = np.sum((self.centers - x) ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_parabolic_grid_uniform scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["806708df-1ba9-4d6e-97f4-8439aa948562"], "operator": null, "metadata": {"ela_features_2D": [-0.001686496220036915, 0.30354912045510296, 0.014696659337022544, 0.025866169397509926, 2.3250216699235873, 0.0003934210634754853, 0.9607766589401265, 1.0122017331313695, 0.9620542523453033, 0.6322254217049396, -0.16081577134106126, 1.8, 0.7040254438705786, 0.713667758798062, 0.5610851151762819, 0.34328078484532665, -0.22630670012575763, 0.14078928282760808, 0.2139108478452596, 0.3293140464477307, 0.5019048632371182, 0.14436800688078483, 0.2166233608596418, 0.3259113557029456, 0.4993479842004346, -0.44966460002186315, -0.4113960012863484, -0.3510002158491087, -0.2606757683787655, -0.4400721331025036, -0.40291186874032653, -0.3466997469484051, -0.2574988815496056, 1.0, 1.0, 1.0, 1.0, 0.5179363262428813, 0.5179312196394117, 0.4189510476983146, 0.35289572905819055, 0.7119776806992222, 0.4814814814814813, 0.5007564528365082, -0.08708708708708707, 0.3927710843373494], "score_GlobalLocal_2D": 0.9487587809562683, "score_Basins_2D": 0.2042464017868042, "ela_features": [-0.001453727430175311, 0.35432825794169914, 0.002463276844219471, 0.024386079391874056, 127.5334871074939, 0.0034032774871669337, 0.9478471852598048, 1.0243741842666612, 0.9479494001619099, 0.4942225423165586, -0.04228305651473807, 1.4, 0.87883649471369, 0.8696106349598333, 0.6146099472257148, 0.1864892695161622, -0.5027945894817953, 0.47611563126792983, 0.5475009435553202, 0.615053694830558, 0.7293819992301338, 0.47749555369781493, 0.5484442934635175, 0.6187233666826304, 0.7334233062615234, -0.460872773176504, -0.39807306979569657, -0.3386477207477468, -0.23806998704589305, -0.46221722630556633, -0.39945507556340115, -0.3372893040867351, -0.23582239519644332, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21559755123202068, 0.21560037439072627, 0.2002774357190468, 0.1805934388853831, 0.8352939511356647, 0.20920920920920913, 0.2671493861280435, -0.2872872872872872, 0.528525641025641], "score_GlobalLocal_5D": 0.0004078864003531635, "score_Basins_5D": 0.9998615980148315, "ela_features_10D": [-0.002016059413757354, 0.3704583284310899, 0.00038709116183631925, 0.01371022722806663, 199.35051254038248, 0.006227796822751608, 0.9482679298415976, 1.0429432591634409, 0.9486020141852786, 0.3426833636267427, 0.01781178673656907, 1.6, 1.0157327662467437, 0.9390937288133117, 0.7044434155804062, 0.10579135063875048, -0.6115626407446283, 0.6369195449177647, 0.690791596712734, 0.7391564862544957, 0.8127086663497904, 0.6404992680234798, 0.6946854051775541, 0.74331268188418, 0.8171821803228154, -0.46045862861777653, -0.39213844421233335, -0.33080241055565907, -0.23752317453596722, -0.45709348123337873, -0.38819808282635043, -0.3263710360336785, -0.23244700836914373, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11026718441416541, 0.11026173259102309, 0.10716445280172734, 0.10053472357302518, 0.8649709479894518, -0.0910910910910911, 0.1345655664206459, -0.6236236236236234, 0.599919935948759], "score_GlobalLocal_10D": 0.00028726624441333115, "score_Basins_10D": 0.9997820258140564}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[24, [0.00044444444444512003, 0.00044444444444512003], -11.999999604938271], [16, [-1.4997894663066353, -1.4997894663066353], -9.499999911351129], [22, [1.4988066457551177, -1.501213903959779], -9.499997102342823], [22, [-1.4965086931078329, 1.4988928611846255], -9.499986585019828], [16, [1.5000370188909513, 1.4956152959829256], -9.499980773000285]], "nr_of_basins": 5, "f_opt_dim_2": -12.0, "x_opt_dim_2": [1.5804427400449646e-08, 5.542585625257298e-09], "f_opt_dim_5": -12.0, "x_opt_dim_5": [-1.0421969763833016e-08, -4.798256758038032e-09, -2.3209096940817478e-08, -4.2331149222377197e-10, 3.767058169630515e-09]}
{"id": "4b77f187-8a8d-4a06-a87b-01e858554749", "fitness": 0.5700785517692566, "name": "GridParabolicGridLandscape", "description": "A multi-basin parabolic landscape laid out on a regular grid in the first few dimensions, with a deep global minimum at the origin and shallow local wells at grid centers. We push the global-local minima contrast by making the origin substantially deeper than the others, while keeping basin sizes homogeneous through identical quadratic widths. The benchmark exposes a clear global-local contrast and uniform basin sizes to robustly evaluate search behavior in continuous spaces.", "code": "import numpy as np\nimport itertools\n\nclass GridParabolicGridLandscape:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Domain and basic parameters\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n        self.alpha = 1.0  # common quadratic coefficient\n        self.a = 2.0        # centers along each axis: -a, 0, +a\n\n        # Build centers on a regular grid: coordinates in {-a, 0, a} per dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local wells: set depths beta_k\n        # Global minimum at origin is made significantly deeper than local wells\n        self.beta = np.full(self.K, -1.0, dtype=float)\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the grid centers.\")\n        self.beta[origin_index] = -50.0  # deep global minimum\n        self.origin_index = origin_index\n\n        # Precompute landscape characteristics for benchmarking metrics\n        # 1) Global vs local minima strength (GlobalLocal contrast)\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = np.mean(f_center_values)\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # 2) Basin size homogeneity\n        # Use a deterministic grid of points in domain to assign each to a basin\n        coords = [-self.domain_hi, 0.0, self.domain_hi]\n        grid_points = np.array(list(itertools.product(coords, repeat=self.dim)))\n        counts = np.zeros(self.K, dtype=int)\n        for x in grid_points:\n            x = np.asarray(x, dtype=float)\n            d2 = np.sum((self.centers - x) ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n        nonzero = counts[counts > 0]\n        self.basin_homogeneity = 1.0 if nonzero.size <= 1 else (np.max(nonzero) / np.min(nonzero))\n\n        # Store lightweight diagnostics for potential inspection\n        self.f_center_values = f_center_values\n        self.global_min_value = global_min\n        self.local_best_value = local_best_value\n        self.avg_center_value = avg_center\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) for x in R^dim as the minimum over all wells:\n          f(x) = min_k (||x - c_k||^2 * alpha) + beta_k\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        d2 = np.sum((self.centers - x) ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 1, "feedback": "The optimization landscape GridParabolicGridLandscape scored on:GlobalLocal 0.000, Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["806708df-1ba9-4d6e-97f4-8439aa948562"], "operator": null, "metadata": {"ela_features_2D": [-0.0009829442159931645, 0.33407616822475983, 0.012747431356260507, 0.03703774275673913, 3.3924739309832694, -0.0007724326558223415, 1.0, 1.0018421505851012, 1.0, 0.45658524152668356, -0.42500324584208415, 1.6, 0.716877773151751, 0.7252739722295702, 0.567467745183885, 0.33442619337116336, -0.20703049634093268, 0.1344421604431007, 0.21085598733338418, 0.30900861961929926, 0.49459138140124353, 0.14016626185715048, 0.2096645632930077, 0.3072391449779963, 0.49375644127943225, -0.4529232996292806, -0.41293753665353633, -0.36157515986536953, -0.26446453896393746, -0.4422337184889832, -0.4064852414815235, -0.3562918564325722, -0.2603552859798491, 1.0, 1.0, 1.0, 1.0, 0.5143194658452102, 0.5142388620897553, 0.39803166088330283, 0.35520977600443937, 0.7158978201862306, 0.4094094094094093, 0.5343327904609302, -0.11911911911911907, 0.3746987951807229], "score_GlobalLocal_2D": 0.8949530720710754, "score_Basins_2D": 0.5266521573066711, "ela_features": [-0.0009941483512020844, 0.47830172261177195, 0.004177618583205886, 0.0267384508140819, 8.62842823153769, -0.0008149970790784833, 0.9892050827259723, 1.0160674968988221, 0.995775555472431, 0.040701932504567044, -0.5974718349974297, 1.0, 0.9149432299560318, 0.8755811090991491, 0.6477800087012482, 0.18128271616755728, -0.4824547346004384, 0.4291796592831716, 0.5143226803456403, 0.593641329435554, 0.7166718795119054, 0.4332607771382982, 0.518153858105521, 0.5963909557269483, 0.7202098662447594, -0.5021452241496636, -0.4272456131216386, -0.357468872731807, -0.24924068983497136, -0.5012315956490563, -0.4261518515803395, -0.3569550006996688, -0.24744830512233595, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2165714149292146, 0.21657481980213666, 0.19790308963355496, 0.1826030233104591, 0.8270710781181452, 0.17717717717717713, 0.29865942475646745, -0.30730730730730726, 0.524198717948718], "score_GlobalLocal_5D": 0.00013999831571709365, "score_Basins_5D": 0.999874472618103, "ela_features_10D": [-0.0009637339827784253, 0.627794367210338, 0.000639917325832773, 0.014938251120683773, 107.44957085091308, -0.0012247589748260346, 0.8675085164396925, 1.069978922172679, 0.9322680762758997, -0.9106632585566343, 1.8772428563054333, 1.2, 1.016509523907114, 0.9400385223174622, 0.7116548001677464, 0.10341268293492896, -0.6779662606040052, 0.6049532899434291, 0.6718701291926112, 0.7242923937433254, 0.8107383883726902, 0.6086542069298718, 0.6757350691744023, 0.7282404653114389, 0.8145041785849202, -0.5009507694453392, -0.4160948150096466, -0.3496193114334153, -0.23999883124859403, -0.4974647303573728, -0.41219326527555494, -0.3454504913560448, -0.2357950407923875, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11031395435874987, 0.11032009010837192, 0.10811878173818121, 0.10078044089555024, 0.8463919775111128, -0.09909909909909906, 0.10053607841042504, -0.7637637637637635, 0.6032826261008808], "score_GlobalLocal_10D": 0.00039223654312081635, "score_Basins_10D": 0.9984593391418457}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], -49.999999604938274]], "nr_of_basins": 1, "f_opt_dim_2": -50.0, "x_opt_dim_2": [-4.4750357447654416e-08, 1.5553732392537563e-08], "f_opt_dim_5": -50.0, "x_opt_dim_5": [2.038373922997502e-08, 1.1318925455917307e-08, 1.508438967034505e-08, 3.7809292964142935e-09, -7.728534945218237e-09]}
{"id": "e3d739e4-d5d2-4b17-af83-d640a3d4daf8", "fitness": 0.5656084418296814, "name": "landscape", "description": "A toroidal multi-basin quadratic landscape with a grid of parabolic wells designed for homogeneous basin sizes. The global minimum sits at the origin (deep well), while local wells on a symmetric grid share the same shape. A lightweight, iterative beta-balancing routine adjusts local well depths to promote basin size homogeneity (Basins) while preserving global-local contrast. Distances use wrap-around (torus) metrics to enforce symmetry and more uniform basin volumes.", "code": "import numpy as np\nimport itertools\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Domain and basic landscape parameters\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n        self.L = self.domain_hi - self.domain_lo  # wrap-around length (torus)\n        self.alpha = 1.0      # common quadratic coefficient\n        self.a = 1.5            # half-range for centers along each axis\n\n        # Build centers on a small grid: coordinates in {-a, 0, a} for each dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Identify origin center (global minimum at origin)\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the centers.\")\n        self.origin_index = origin_index\n\n        # Initialize depths (betas). Origin is the global minimum; locals are shallower.\n        self.beta = np.full(self.K, -2.0, dtype=float)\n        self.beta[self.origin_index] = -12.0  # deeper global well at the origin\n\n        # Improve basin size homogeneity by balancing basin sizes\n        self._balance_basins()\n\n        # Evaluate GlobalLocal contrast (based on center values) after balancing\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = np.mean(f_center_values)\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # Basin homogeneity score after balancing\n        self.basin_homogeneity = self._compute_basin_homogeneity()\n\n    def _wrap_distance2(self, x):\n        \"\"\"\n        Toroidal (wrap-around) squared distance from x to all centers.\n        Uses per-dimension wrap: delta_i = min(|x_i - c_i|, L - |x_i - c_i|)\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        # dx: difference between centers and x, shape (K, dim)\n        dx = self.centers - x\n        dx = np.abs(dx)\n        # wrap-around per dimension\n        dx = np.minimum(dx, self.L - dx)\n        return np.sum(dx**2, axis=1)\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) = min_k [ alpha * ||x - c_k||_torus^2 + beta_k ]\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        d2 = self._wrap_distance2(x)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)\n\n    def _assignment_counts(self, beta):\n        \"\"\"\n        Compute basin assignment counts for a given beta vector by sampling domain uniformly.\n        Returns counts over centers.\n        \"\"\"\n        self.beta = beta\n        rng = np.random.default_rng(123456)\n        samples = rng.uniform(self.domain_lo, self.domain_hi, size=(2000, self.dim))\n        counts = np.zeros(self.K, dtype=int)\n        for x in samples:\n            d2 = self._wrap_distance2(x)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n        return counts\n\n    def _balance_basins(self):\n        \"\"\"\n        Simple iterative beta-balancing to promote basin size homogeneity.\n        Keeps the origin (global minimum) fixed and adjusts locals to\n        approach equal basin sizes, using toroidal distances for basin definition.\n        \"\"\"\n        beta = self.beta.copy()\n        origin = self.origin_index\n\n        # Initial counts\n        counts = self._assignment_counts(beta)\n\n        # Iterative balancing with diminishing steps\n        steps = [0.8, 0.4, 0.2, 0.1, 0.05]\n        for step in steps:\n            avg = float(np.mean(counts))\n            for i in range(self.K):\n                if i == origin:\n                    continue\n                if counts[i] > avg:\n                    beta[i] += step  # make this basin less attractive\n                elif counts[i] < avg:\n                    beta[i] -= step  # make this basin more attractive\n            counts = self._assignment_counts(beta)\n\n        self.beta = beta\n\n    def _compute_basin_homogeneity(self):\n        \"\"\"\n        Compute a basin homogeneity score using a fresh set of samples.\n        Score is max(counts) / min(nonzero counts). 1.0 is perfect homogeneity.\n        \"\"\"\n        rng = np.random.default_rng(42)\n        samples = rng.uniform(self.domain_lo, self.domain_hi, size=(4000, self.dim))\n        counts = np.zeros(self.K, dtype=int)\n        for x in samples:\n            d2 = self._wrap_distance2(x)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n        nonzero = counts[counts > 0]\n        if nonzero.size <= 1:\n            return 1.0\n        return float(np.max(nonzero)) / float(np.min(nonzero)) if np.min(nonzero) > 0 else np.inf", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["806708df-1ba9-4d6e-97f4-8439aa948562"], "operator": null, "metadata": {"ela_features_2D": [-0.0029813920954691042, 0.42634252310133885, 0.009717985329605447, 0.019107154127771052, 8.057209546838248, -0.0017889517263849574, 0.971993310238988, 1.0074397589185853, 0.9903686859762276, -0.049007726004697695, -0.6800786075495661, 1.8, 0.7133806763387875, 0.71769384808691, 0.5561180699368151, 0.33935688142682063, -0.2068936349169015, 0.14302243328142103, 0.2175537481301833, 0.31323676123768246, 0.4910623282352657, 0.15233469158473775, 0.22254517929653295, 0.3144667606890095, 0.491350268793661, -0.4485320569700633, -0.40952704659265277, -0.35944543775808635, -0.266375292980371, -0.43607575586345426, -0.399952225660743, -0.35265820718266905, -0.2616655747281664, 1.0, 1.0, 1.0, 1.0, 0.5128688023801049, 0.5128632225602228, 0.39488105904967935, 0.3467010292563576, 0.7238343363504401, 0.36936936936936926, 0.6767273211096798, -0.02302302302302302, 0.3646586345381526], "score_GlobalLocal_2D": 0.9245988726615906, "score_Basins_2D": 0.4690925180912018, "ela_features": [0.00013431630680003082, 0.43075844858074513, 0.004374591513084171, 0.027885803497647788, 16.560700802222918, 0.005251674761902803, 0.9781800625819397, 1.0404193475213472, 0.9783999427442065, 0.4129289135104789, -0.05693841020509902, 1.2, 0.9092334082723657, 0.8727024668686166, 0.6301890459436776, 0.18627827830404523, -0.48961847916089785, 0.44502863296939077, 0.5321426602457301, 0.6017225188886586, 0.7193341816725842, 0.4488699471398131, 0.536797566040924, 0.6072024210169589, 0.7242937579424898, -0.48810106691478994, -0.41148537082339975, -0.3502889108217335, -0.24684839998226873, -0.48705934002564516, -0.4093563026738282, -0.34713647734022457, -0.2436565820791178, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21567871079874196, 0.21567608933988178, 0.2022288207409292, 0.1825108351112011, 0.8347419639471779, 0.1611611611611611, 0.2811179465029476, -0.35535535535535523, 0.5275641025641027], "score_GlobalLocal_5D": 0.00022376449487637728, "score_Basins_5D": 0.9998795986175537, "ela_features_10D": [-0.00010935678500105795, 0.3946794510240636, 0.00171193004775178, 0.01854861777369747, 35.86460512499068, 0.007314552605842195, 0.9507780279215323, 1.0368524079064192, 0.9512023111752439, 0.34420633953070245, 0.03962780159035386, 1.2, 1.0055669319320117, 0.9383032755928115, 0.6994031754576477, 0.10545392297760996, -0.6148069771199911, 0.6354896664573041, 0.6894181265788379, 0.7386081555672563, 0.815203997507213, 0.6382951583574576, 0.6927482486203428, 0.742136053411115, 0.8193065190104939, -0.4623450114335981, -0.3939424868395904, -0.3315498214954025, -0.2343956034508607, -0.4601154674270941, -0.3908475767727828, -0.3280228678477658, -0.22985622337467232, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10927460011898268, 0.10926715939866086, 0.10611767486724263, 0.0997818448783673, 0.858075771648623, -0.07507507507507508, 0.14408889899262955, -0.6236236236236234, 0.6046437149719776], "score_GlobalLocal_10D": 0.00023008426069281995, "score_Basins_10D": 0.999625563621521}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 22.65], [4, [1.666666666666667, -5.0], 10.427777777777779], [4, [-5.0, 1.666666666666667], 10.427777777777779], [3, [-5.001696600394623, -1.3926842425475439], 10.499643347488133], [88, [0.00044444444444512003, 0.00044444444444512003], -11.999999604938271]], "nr_of_basins": 5, "f_opt_dim_2": -12.0, "x_opt_dim_2": [1.0524986009805236e-08, 1.801533538633202e-08], "f_opt_dim_5": -12.0, "x_opt_dim_5": [-4.652523500444493e-09, 4.853568866551159e-09, -1.8125590829124488e-08, -2.008830202202172e-08, -3.1966968927118086e-09]}
{"id": "ceb00acf-57d4-4451-8164-04c4cd689782", "fitness": 0.5192751288414001, "name": "landscape_elliptical_ring_minima", "description": "A novel multi-basin benchmark using a ring of anisotropic quadratic wells (elliptical parabolas) around the origin. The objective is the minimum over a set of wells: each well is a quadratic form with a shared positive-definite curvature matrix, creating homogeneous basin sizes but with a clear global-local contrast since the origin well is deeper. Wells are placed on a ring in the first two dimensions (or along a line in 1D), and additional dimensions contribute via the shared curvature, yielding a distinct landscape from grid-based minima.", "code": "import numpy as np\n\nclass landscape_elliptical_ring_minima:\n    \"\"\"\n    A novel benchmark landscape for minimization.\n\n    Construction:\n    - The objective is the minimum over a set of elliptical parabolic wells:\n        f_i(x) = 0.5 * (x - c_i)^T Q (x - c_i) - A_i\n      where Q is a shared positive-definite curvature matrix (elliptical wells),\n      and (c_i, A_i) are the center and depth offset of well i.\n    - A global deep well sits at the origin (c_0 = 0) with depth A_global.\n    - Local wells are arranged on a ring in the first two dimensions (dimensions 0 and 1),\n      with centers on radius r. For dim=1, wells lie along the 1D axis at +/- r.\n    - All wells share the same curvature Q to produce homogeneous basin sizes.\n    - The landscape is non-differentiable at basin boundaries due to the min over wells.\n    - All centers lie within [-5, 5] per dimension for the domain specification.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Ring configuration (uses first two dimensions if available)\n        self.use_ring_in_two_dims = self.dim >= 2\n\n        # Ring parameters\n        self.r = 2.0  # ring radius for local wells\n        self.n_ring = 12  # number of local wells on the ring\n\n        # Curvature (elliptical wells): Q is diagonal with anisotropy\n        # First axis more curved than second; others have unit curvature\n        self.Q = np.diag(np.concatenate(([2.0, 1.0], np.ones(self.dim - 2, dtype=float))))\n\n        # Depths (negative values). Global well is deeper than local wells.\n        self.A_global = 4.0\n        self.A_local = 2.0\n\n        # Build centers and corresponding depths\n        self.centers = []\n        self.amplitudes = []\n        self._build_centers()\n\n        # Convert to numpy arrays for performance\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.amplitudes = np.asarray(self.amplitudes, dtype=float)\n\n        # Precompute a helper for computing Q @ diff efficiently\n        self._Q = self.Q\n\n    def _build_centers(self):\n        # Global well at origin\n        self.centers.append(np.zeros(self.dim))\n        self.amplitudes.append(self.A_global)\n\n        # Local wells placed on a ring in the first two dimensions\n        if self.use_ring_in_two_dims:\n            for i in range(self.n_ring):\n                theta = 2.0 * np.pi * i / float(self.n_ring)\n                c = np.zeros(self.dim)\n                c[0] = self.r * np.cos(theta)\n                c[1] = self.r * np.sin(theta)\n                self.centers.append(c)\n                self.amplitudes.append(self.A_local)\n        else:\n            # Fallback for 1D: place wells at +/- r along the single axis\n            for i, sign in enumerate([-1.0, 1.0]):\n                c = np.zeros(self.dim)\n                c[0] = sign * self.r\n                self.centers.append(c)\n                self.amplitudes.append(self.A_local)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value to be minimized.\n\n        Landscape is defined as:\n          f(x) = min_i [ 0.5 * (x - c_i)^T Q (x - c_i) - A_i ]\n        where (c_i, A_i) are the centers and depths of the wells.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_val = float(\"inf\")\n        for c, a in zip(self.centers, self.amplitudes):\n            diff = x - c\n            # val = 0.5 * diff^T Q diff - A_i\n            val = 0.5 * float(np.dot(diff, self._Q @ diff)) - float(a)\n            if val < min_val:\n                min_val = val\n        return float(min_val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_elliptical_ring_minima scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3fb4f864-876c-4d8f-82fa-317f2f82e53a"], "operator": null, "metadata": {"ela_features_2D": [-0.00037407394047184184, 0.2846857749117643, 0.012045379496949931, 0.03936738464905851, 3.865542345789693, 0.00041016808828540083, 0.9757405469002679, 1.5532796808844593, 0.9850884596718898, 0.8977716387338696, 0.22467041516243755, 1.0, 0.6775538484555602, 0.7137325117884744, 0.5503227676890936, 0.34005364620588147, -0.20252170986530899, 0.13621610332269873, 0.22271748149700712, 0.3319594506766044, 0.4964004902121248, 0.1338306196467577, 0.2220422389213612, 0.3256915483101265, 0.4968725137949336, -0.45212653773288725, -0.40684945167330466, -0.34967024951592707, -0.2635975244984597, -0.44541311204336076, -0.40006469432359026, -0.3467636326041138, -0.2587371171536909, 1.0, 1.0, 1.0, 1.0, 0.513246104180515, 0.513159681553424, 0.4124801325113655, 0.35729903703909904, 0.6855994392567604, 0.5015015015015013, 0.318677441775686, -0.20720720720720714, 0.3803212851405623], "score_GlobalLocal_2D": 0.9806415438652039, "score_Basins_2D": 0.13496556878089905, "ela_features": [-0.0022207723655648603, 0.404973539738983, 0.004116503750113157, 0.019270708184231888, 5.384661662280133, 0.003050311120229221, 0.9930967843564561, 1.731259527729182, 0.9960079161330082, 0.3115058011822638, -0.19956879282611634, 1.2, 0.9202503418037272, 0.8747058139669699, 0.6485098694574155, 0.1833494813409143, -0.4812519014374061, 0.422567668176812, 0.5178096835338074, 0.5977268486319501, 0.719978696905162, 0.42098351095904524, 0.5145365384605819, 0.5950935354345168, 0.721154629917723, -0.507925334148398, -0.42414898123554945, -0.35385213425185086, -0.24631497464300858, -0.5118955786099446, -0.4291907586405667, -0.35797359869576545, -0.24652287323008681, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21675548094443414, 0.21673407130437342, 0.20168808065798066, 0.1812692335138734, 0.824170584198382, 0.1411411411411411, 0.24201496936635397, -0.36736736736736725, 0.5118589743589743], "score_GlobalLocal_5D": 0.0001701374421827495, "score_Basins_5D": 0.9998505115509033, "ela_features_10D": [-0.0006334672395184038, 0.4381801065909361, 0.0013525390631974614, 0.01846005666065082, 21.546842599619332, 0.007866063845656112, 0.9969054412082446, 1.72813086606115, 0.9982397611779035, 0.24032473124520318, -0.03155214813151934, 1.4, 1.0187960013496058, 0.9399405053984087, 0.7140652779163508, 0.10315802248222598, -0.6082424110438021, 0.6219133331978526, 0.6780715905994803, 0.7295019702015011, 0.8097369787274753, 0.6260448628224177, 0.6815855894160658, 0.7330851412381143, 0.8139266282851892, -0.479505482765612, -0.40828343788211907, -0.3430571769794291, -0.24129976859838234, -0.4755524448867858, -0.4049220991630804, -0.3394308965648659, -0.23662608258708726, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10950877917535266, 0.10950854675259543, 0.10657763383070215, 0.10022597405476967, 0.8527394369372894, -0.1271271271271271, 0.1254510649130478, -0.6556556556556554, 0.5903923138510809], "score_GlobalLocal_10D": 0.00015364222053904086, "score_Basins_10D": 0.9998694658279419}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [0.00044444444444512003, 0.00044444444444512003], -3.9999997037037036], [10, [1.0150052107101264, -1.5446449559360311], -1.9822143670384285], [9, [1.0090538793756179, 1.650398682843236], -1.9965844925321459], [17, [-1.7321151670566133, -0.9896289328099607], -1.9999462163405262], [9, [1.7314460275213808, -1.0003600368621999], -1.999999569427823], [6, [-1.994602103044193, -0.0016298102694524363], -1.9999695345676973], [15, [-1.7316308352825265, 0.9954520389745755], -1.9999894816485344], [11, [2.0002655989791918, 0.00040213129249165765], -1.999999848602394], [11, [1.732462091049316, 0.9993687053307819], -1.999999631579419]], "nr_of_basins": 9, "f_opt_dim_2": -4.0, "x_opt_dim_2": [-1.360248005686129e-08, -6.086474422636346e-09], "f_opt_dim_5": -4.0, "x_opt_dim_5": [3.954870631688241e-09, -5.168586463662039e-09, 1.4244320746816548e-08, 2.9287024592290836e-09, -8.629580025245338e-09]}
{"id": "7c804012-31ef-4c59-b64e-e47b73804fd5", "fitness": 0.5194658637046814, "name": "landscape_min_gaussians_homogeneous_improved", "description": "An improved homogeneous multi-basin Gaussian landscape using a minimum-over-Gaussian-wells on a symmetric grid, with a deeper global well at the origin to amplify GlobalLocal contrast. Basin widths are identical, wells cover the search space, and a normalized GlobalLocal score quantifies peak recognizability.", "code": "import numpy as np\n\nclass landscape_min_gaussians_homogeneous_improved:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Shared Gaussian width (basin size)\n        self.sigma = 1.0\n\n        # Strengths: deeper global well vs identical local wells\n        # GlobalLocal contrast is improved by enlarging the gap between global and local wells.\n        # We fix explicit values to guarantee a robust, improved contrast across dimensions.\n        self.local_strength = 2.0\n        self.global_strength = 7.0  # deeper global well; chosen to yield strong GlobalLocal contrast\n\n        # Build wells\n        if self.dim <= 1:\n            # 1D: symmetric grid of wells including origin\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.centers = [np.array([g], dtype=float) for g in grid]\n        else:\n            # 2D+ : symmetric 4x4 grid in the first two dimensions that includes origin\n            grid1d = [-4.0, -2.0, 0.0, 2.0]  # includes origin\n            centers_tmp = []\n            for a in grid1d:\n                for b in grid1d:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.centers = centers_tmp\n\n        self.N_wells = len(self.centers)\n\n        # Amplitudes: one global well + identical local wells\n        self.A = [self.global_strength] + [self.local_strength] * (self.N_wells - 1)\n\n        # Pre-compute a normalized GlobalLocal score\n        self._global_local_score = self._compute_global_local_score()\n\n    def _compute_global_local_score(self):\n        # Normalize contrast between global and local wells to [0,1]\n        if self.N_wells <= 1:\n            return 0.0\n        A0 = self.A[0]\n        Aloc = self.A[1] if self.N_wells > 1 else A0\n        if A0 == 0:\n            return 0.0\n        # Normalized contrast: (A0 - Aloc) / A0\n        score = (A0 - Aloc) / float(A0)\n        return max(0.0, min(1.0, score))\n\n    def global_local_score(self):\n        return float(self._global_local_score)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = float('inf')\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            candidate = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if candidate < val:\n                val = candidate\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_min_gaussians_homogeneous_improved scored on:GlobalLocal 0.331, Basins 0.753,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["59e097eb-1e98-4edf-a76b-9c21aef339d0"], "operator": null, "metadata": {"ela_features_2D": [0.46048493802088625, 0.5545590155461317, 0.25782801411116946, 0.26830867021930377, 1.0407876528525815, 0.6110467362902533, 0.4706514011846304, 2.1379541580208032, 0.7699627790841093, -2.1652271859991568, 7.349476692868992, 4.8, 0.29744501345244945, 0.6297071711378205, 0.2640596470655379, 0.3622524739157242, -0.19245368525156745, 0.14621701043812177, 0.2356042917296938, 0.6257377764080223, 0.790195695683317, 0.15272520058924893, 0.22839861336196493, 0.5262766517811766, 0.8043820561731094, -0.44644122211658743, -0.39970480144687903, -0.19569764564809433, -0.10970719678717829, -0.43474281702135437, -0.3959229250328199, -0.24297522060010998, -0.10036704634650226, 1.0, 1.0, 0.6666666666666666, 0.9333333333333332, 0.5244475923985813, 0.5244428091118646, 0.507490452355322, 0.5618197675653807, 0.7088432541060803, 0.7417417417417416, 0.5048597930064593, -0.1511511511511511, 0.4188755020080322], "score_GlobalLocal_2D": 0.9870452284812927, "score_Basins_2D": 0.007830831222236156, "ela_features": [0.009458617499940281, 0.977249193414792, 0.0004996826189222732, 0.016865913985797152, 176.25042739032983, 0.006764768124463227, 0.09036009867793804, 21.161535983929248, 0.19645632109245625, -11.829320784283194, 194.83705117539844, 7.2, 0.8648516285765144, 0.8683928455978265, 0.6129300426637408, 0.18714461652612258, -0.28257150983115137, 0.5425822214735556, 0.590838068235984, 0.6620987026163613, 0.761972735315279, 0.523975296246316, 0.5691409826879009, 0.64298484943254, 0.7532831685914342, -0.40230453267615074, -0.3598636196963363, -0.29719080068123305, -0.20934842652102265, -0.4206563239744036, -0.38074109736629647, -0.31549090084077097, -0.21801652513557918, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21214352048319643, 0.21212551924241735, 0.21075910690264266, 0.18776708911363277, 0.5477073218428533, 0.07307307307307302, 1.1716703224209044e-05, -3.9509509509509515, 0.5064102564102564], "score_GlobalLocal_5D": 0.1487116515636444, "score_Basins_5D": 0.88946533203125, "ela_features_10D": [-0.0026866660522557595, 0.9977058288056287, 5.677168603344779e-05, 0.0018984026264595173, 43.95479936759612, -0.019452723018716877, 0.0025069652606025004, 7.5021667179232905, -0.024849450709302244, -40.73449908845159, 1790.4163653859632, 2.8, 0.9802867473590229, 0.9302779351392498, 0.6883300663411702, 0.11007784608932199, -0.1832827278750743, 0.6585707983672864, 0.7085827039534238, 0.755279683507918, 0.823946628240886, 0.6543118882092115, 0.707658205279923, 0.7554738489434892, 0.8260076771094476, -0.43302337331156, -0.36959498868646734, -0.31037084812508037, -0.2232827851657439, -0.43955349935599586, -0.3717217819695577, -0.31092292549877315, -0.22123703103379216, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10923202424831377, 0.10922769491341626, 0.10916204978350852, 0.09939404034487183, 0.56905010084029, -2.3293293293293296, 0.0, -Infinity, 0.5527622097678142], "score_GlobalLocal_10D": 0.33067771792411804, "score_Basins_10D": 0.7530643343925476}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], -1.9999996049383106], [3, [-1.999785964057643, -1.9999442418178546], -1.9999999510796411], [4, [0.00044444444444512003, -4.00000000000011], -1.9999998024691457], [4, [0.00044444444444512003, -1.9997777777778631], -1.999999753086435], [4, [-4.00000000000011, 0.00044444444444512003], -1.9999998024691457], [4, [-1.9997777777778631, 0.00044444444444512003], -1.999999753086435], [2, [-4.00000000000011, -2.0006666666666666], -1.999999555555605], [9, [-4.00000000000011, -4.00000000000011], -7.0], [2, [-2.0001989433894716, -3.9997139550352316], -1.9999998785998097], [8, [1.999777777777864, -1.9997777777778631], -1.9999999012345704], [8, [1.999777777777864, 0.00044444444444512003], -1.999999753086435], [8, [0.00044444444444512003, 1.999777777777864], -1.999999753086435], [8, [-1.9997777777778631, 1.999777777777864], -1.9999999012345704], [8, [1.9999388586091222, -3.9999938763680114], -1.9999999962242314], [8, [-3.9999931888222213, 1.9999569449138996], -1.9999999980998675], [16, [1.9999198551748365, 1.9999423606621807], -1.9999999902545138]], "nr_of_basins": 16, "f_opt_dim_2": -2.0, "x_opt_dim_2": [-2.0000000040024246, -1.9999999954866299], "f_opt_dim_5": -2.0, "x_opt_dim_5": [-1.9999999950838252, 2.0000000022340076, 5.070231631015704e-09, -2.5784765492431046e-09, -4.896721341289645e-10]}
{"id": "6a7baa4c-d3f1-447d-8203-44a46b0d81a2", "fitness": 0.510958731174469, "name": "landscape_ring_minima", "description": "A ring-based multi-basin landscape using a min-over Gaussian wells. It places a deeply global well at the origin and a ring of identical local wells in the first two dimensions (or two wells in 1D), with equal widths to ensure homogeneous basin sizes. The global-local contrast is explicit and can be quantified via a normalized GlobalLocal score.", "code": "import numpy as np\n\nclass landscape_ring_minima:\n    def __init__(self, dim=5, n_wells=16, s=2.0, sigma=0.9, A_global=2.0, A_local=1.0):\n        \"\"\"\n        Multi-basin landscape with a global well at the origin and a ring of local wells.\n        - dim: number of dimensions\n        - n_wells: number of local wells placed on the ring (only for dim >= 2)\n        - s: ring radius (distance from origin to local wells in the first two dimensions)\n        - sigma: Gaussian width of wells (controls basin size; same for all wells)\n        - A_global: depth (magnitude) of the global well (at origin)\n        - A_local: depth of each local well (at ring centers)\n        The landscape is defined as f(x) = min_i [-A_i * exp(-||x - c_i||^2 / (2*sigma^2))]\n        where c_i are centers (origin for global, ring centers for locals).\n        \"\"\"\n        self.dim = int(dim)\n        self.n_wells = int(n_wells) if self.dim >= 2 else 2\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n\n        self.centers = []\n        self._build_centers()\n\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n    def _build_centers(self):\n        # Global center at origin\n        origin = np.zeros(self.dim, dtype=float)\n        self.centers.append(origin)\n\n        if self.dim >= 2:\n            # Local wells placed on a ring in the first two dimensions\n            for k in range(self.n_wells):\n                theta = 2.0 * np.pi * k / float(self.n_wells)\n                c = np.zeros(self.dim, dtype=float)\n                c[0] = self.s * np.cos(theta)\n                c[1] = self.s * np.sin(theta)\n                self.centers.append(c)\n        else:\n            # Fallback for 1D: two local wells at +/- s on the single axis\n            c_plus = np.array([ self.s ], dtype=float)\n            c_minus = np.array([-self.s], dtype=float)\n            self.centers.append(c_plus)\n            self.centers.append(c_minus)\n\n        # Ensure centers are numpy arrays\n        self.centers = [np.asarray(c, dtype=float) for c in self.centers]\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        - x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is defined as a min-over-Gaussian-wells:\n          f(x) = min_i (-A_i * exp(-||x - c_i||^2 / (2*sigma^2)))\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_vals = []\n        for c in self.centers:\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            # Determine amplitude based on center type\n            if np.allclose(c, np.zeros(self.dim)):\n                a = self.A_global\n            else:\n                a = self.A_local\n            val = -a * np.exp(-dist2 / self._two_sigma2)\n            min_vals.append(val)\n        return float(min(min_vals))\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a scale-invariant GlobalLocal score.\n        - min_global: value at the origin (global optimum)\n        - min_local: minimum value among all local wells (excluding origin)\n        - mean_center_value: mean value across all basin centers\n        GlobalLocal score = (min_local - min_global) / max(|mean_center_value|, 1e-9)\n        A positive score indicates a pronounced global-local contrast relative to the basin baseline.\n        \"\"\"\n        origin = np.zeros(self.dim, dtype=float)\n        min_global = self.f(origin)\n\n        # local minima values (excluding origin)\n        min_local = None\n        for c in self.centers:\n            if np.allclose(c, origin):\n                continue\n            val = self.f(c)\n            if min_local is None or val < min_local:\n                min_local = val\n        if min_local is None:\n            min_local = min_global  # safeguard\n\n        # mean value across all centers\n        all_vals = [self.f(c) for c in self.centers]\n        mean_center_value = float(np.mean(all_vals))\n\n        diff = float(min_local) - float(min_global)\n        denom = max(abs(mean_center_value), 1e-9)\n        gl_score = diff / denom\n        return gl_score\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_ring_minima scored on:GlobalLocal 0.078, Basins 0.922,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["683d47d6-8785-4c4d-b750-007fcfaa57f3"], "operator": null, "metadata": {"ela_features_2D": [-0.0037364417717373755, 0.8365172199563553, 0.0046503877245976846, 0.00961817876305271, 4.197151559544053, -0.005003170284891878, 0.6667318532529365, 1.0232074651133871, 0.8281587357992459, -1.2909372252209423, 1.0254310205341919, 3.2, 0.6115703607653943, 0.6975866326730474, 0.4904191097298812, 0.3472037970150498, -0.16771482249406877, 0.12223658708591705, 0.24647502561458015, 0.37842004498979376, 0.4784965154582442, 0.12128740436494012, 0.22877642802752787, 0.3755857152295128, 0.4777101660498161, -0.4592930428610071, -0.3942692170322127, -0.3252371610189637, -0.2728726413195199, -0.4510728659352651, -0.3958486343482485, -0.32049035221871447, -0.26808293339348693, 1.0, 1.0, 1.0, 1.0, 0.514200557772148, 0.5141797020870629, 0.40078509160593556, 0.3444944819531547, 0.550265126741976, 0.7737737737737735, 0.2901331900007995, -0.3673673673673673, 0.39357429718875503], "score_GlobalLocal_2D": 0.9940438866615295, "score_Basins_2D": 0.004310382064431906, "ela_features": [-0.0034345846082600496, 0.9930283231193329, 0.00018389459132032803, 0.0032145075640274273, 55.835093934718884, -0.011359507605008012, 0.053869812473180304, 1.5580071412675551, 0.12635904484009047, -13.311134617744335, 208.02835345218696, 6.4, 0.9063812896623595, 0.8730462353466155, 0.6548729285312177, 0.18295057067508153, -0.24613893012204305, 0.45723525381889923, 0.5449875401721116, 0.614499800385994, 0.7300954291782548, 0.4497167208872135, 0.5373244871233132, 0.6100699592058618, 0.7289030688615858, -0.4774603461876589, -0.40026780969033326, -0.33911779378144613, -0.23743069307122217, -0.4866677171152478, -0.40918975594909196, -0.3448516972826937, -0.23975666055824335, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2154956589726215, 0.2155032064819009, 0.21414397758991566, 0.1800904294225957, 0.45257145925946085, -0.031031031031031064, 8.593249658174045e-06, -Infinity, 0.5166666666666666], "score_GlobalLocal_5D": 0.11055707186460495, "score_Basins_5D": 0.9571801424026489, "ela_features_10D": [-0.0033028964858541343, 0.9992824091220067, 7.91335327659341e-05, 0.0013020478762192755, 39.625160979384226, -0.02097592963245467, -0.0006922058513847418, 5.074195862515287, -0.04776057603565929, -42.621784522540246, 1914.6273330374527, 2.8, 0.9104740872225389, 0.9052799072855684, 0.6228970218391165, 0.12469992455098784, -0.1365641802258904, 0.6213858189347661, 0.6819698796384357, 0.733309309717374, 0.8097438797616286, 0.6247946681787199, 0.6837323497707846, 0.7362368715013787, 0.8133671040502468, -0.4801340255030624, -0.40330453279730694, -0.33819923545420827, -0.24126972630524998, -0.4770164107496062, -0.402085243645473, -0.33533429642368545, -0.23727405540715746, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11008843729700488, 0.11008465423574898, 0.110024972996043, 0.10010569290479783, 0.5892119074143807, -3.03003003003003, 0.0, -Infinity, 0.4398718975180144], "score_GlobalLocal_10D": 0.07810461521148682, "score_Basins_10D": 0.9215565919876099}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], -1.9999995122695307], [2, [0.7368973870563378, -1.7734493376502607], -0.9960987121327382], [2, [-1.773458241763931, 0.7369011206540351], -0.9960996564707032], [3, [0.7368706930302421, 1.7733777696676651], -0.9960912339441588], [7, [1.8089531899263942, -0.7451730842753561], -0.9988194105860014], [16, [-1.8131323932750771, -0.7473483747957543], -0.999059903664106], [16, [-0.7450183855068101, -1.8122584265997193], -0.9989669808856059], [14, [-0.7544946827330477, 1.8302745326643066], -0.9997383594109284], [12, [1.8300816310251862, 0.7544199116331145], -0.9997331668070257], [8, [-1.4210928617691685, -1.4029832545948164], -0.999892941179985], [4, [-1.4007468286082851, 1.4132786727418283], -0.9998875205627585], [4, [1.4131966977303356, -1.400462866911977], -0.9998826515529257], [8, [1.42229771813617, 1.4043704552516034], -0.9998998566614649]], "nr_of_basins": 13, "f_opt_dim_2": -2.0, "x_opt_dim_2": [-4.429305510917912e-09, -4.236954766017728e-09], "f_opt_dim_5": -2.0, "x_opt_dim_5": [-2.1165577055743624e-10, 5.636892810887898e-09, 1.0866201830881859e-09, 5.964199311796652e-09, -1.7798906461522171e-09]}
{"id": "3f837acd-f37f-4cbf-a83e-2752f8bb7375", "fitness": 0.625896692276001, "name": "landscape_glocal_enhanced", "description": "A multi-basin minimization landscape with tunable global-local contrast and an enhanced GlobalLocal score. The global basin at the origin is deeper than axis-aligned local wells, and additional symmetric corner wells (when dim is > 1) are included to promote uniform basin distribution. The GlobalLocal score is computed by comparing the global-to-local depth difference against the dispersion (standard deviation) of all center evaluations, providing a scale-invariant measure of peak prominence.", "code": "import numpy as np\n\nclass landscape_glocal_enhanced:\n    def __init__(self, dim=5, s=2.0, sigma=0.9, A_global=2.2, A_local=1.0, include_corner=True):\n        \"\"\"\n        Enhanced multi-basin landscape with a tunable global-local contrast.\n        - dim: number of dimensions\n        - s: center distance from origin along axes (for local wells)\n        - sigma: shared Gaussian width (controls basin size)\n        - A_global: amplitude (depth) of the global (deepest) basin at origin\n        - A_local: amplitude of the local wells\n        - include_corner: whether to include symmetric corner wells at coordinates +/- s\n        \"\"\"\n        self.dim = int(dim)\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.include_corner = bool(include_corner)\n\n        # Build centers and weights\n        self.centers = []\n        self.weights = []\n        self._build_centers()\n\n        # Precompute constants for efficient evaluation\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n    def _build_centers(self):\n        # Global (deepest) basin at origin\n        self.centers.append(np.zeros(self.dim))\n        self.weights.append(self.A_global)\n\n        # Local basins located along each axis: +s and -s\n        for d in range(self.dim):\n            c_plus = np.zeros(self.dim)\n            c_plus[d] = self.s\n            self.centers.append(c_plus)\n            self.weights.append(self.A_local)\n\n            c_minus = np.zeros(self.dim)\n            c_minus[d] = -self.s\n            self.centers.append(c_minus)\n            self.weights.append(self.A_local)\n\n        # Optional symmetric corner wells (2^dim corners)\n        if self.include_corner and self.dim > 1:\n            # Generate all corner signs in {-, +}^dim except the origin\n            for mask in range(1, 1 << self.dim):\n                c = np.zeros(self.dim)\n                for d in range(self.dim):\n                    bit = (mask >> d) & 1\n                    c[d] = self.s if bit == 1 else -self.s\n                self.centers.append(c)\n                self.weights.append(self.A_local)\n\n        # Convert to numpy arrays for faster operations\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.weights = np.asarray(self.weights, dtype=float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is defined as a sum of negative Gaussians centered at:\n          - origin (global basin, deeper)\n          - each axis center at +/- s (local basins)\n          - optional corner wells at +/- s along all dimensions\n        f(x) = sum_i -a_i * exp(-||x - c_i||^2 / (2*sigma^2))\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        total = 0.0\n        for a, c in zip(self.weights, self.centers):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            total += -a * np.exp(-dist2 / (self._two_sigma2))\n        return float(total)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Improved, scale-invariant GlobalLocal score.\n        - min_global: value at the origin (global minimum)\n        - min_local: smallest value among all local wells (excluding origin)\n        - mean_center_value: mean value across all basin centers (including origin)\n        - std_center_value: standard deviation of center values\n        GlobalLocal score = (min_local - min_global) / (std_center_value + epsilon)\n        A positive score indicates a pronounced global-local contrast relative to the dispersion of basin energies.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        min_global = self.f(origin)\n\n        # compute local minima values (excluding origin)\n        min_local = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, origin):\n                continue\n            val = self.f(c)\n            if min_local is None or val < min_local:\n                min_local = val\n        if min_local is None:\n            min_local = min_global  # safeguard\n\n        # mean and std value across all centers (including origin)\n        all_vals = [self.f(c) for c in self.centers]\n        mean_center_value = float(np.mean(all_vals))\n        std_center_value = float(np.std(all_vals, ddof=0))\n\n        diff = float(min_local) - float(min_global)\n        eps = 1e-9\n        gl_score = diff / (std_center_value + eps)\n        return gl_score\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_glocal_enhanced scored on:GlobalLocal 1.000, Basins 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["683d47d6-8785-4c4d-b750-007fcfaa57f3"], "operator": null, "metadata": {"ela_features_2D": [0.003592149611768014, 0.8631107962322402, 0.03721331316197335, 0.05864904832921604, 1.6968814852073226, 0.004511689602205493, 0.6486412889950437, 1.0128896227660156, 0.8384557781870313, -1.2831281559681709, 0.7927507598076121, 2.4, 0.7177880962806065, 0.725868541196722, 0.5662873385689047, 0.3332511208094693, -0.1750748873366893, 0.12838491513213718, 0.21656048074721929, 0.3138009524985622, 0.503215592214352, 0.12635166207368417, 0.21324797841058496, 0.31191969552840015, 0.5019556173073431, -0.4562537175604272, -0.4100994872689099, -0.3591979454816026, -0.2600461372781402, -0.44895471238607565, -0.4043047574296935, -0.3535974915729757, -0.25593420934523714, 1.0, 1.0, 1.0, 1.0, 0.5158392991217198, 0.5158273648065751, 0.39101807254846416, 0.36191704375128186, 0.56114813109227, 0.5335335335335334, 0.27463382558240385, -0.26726726726726724, 0.3634538152610442], "score_GlobalLocal_2D": 0.9940953254699707, "score_Basins_2D": 0.00862065702676773, "ela_features": [-0.0027166539957316437, 0.9790791942638094, 0.0008385854208859603, 0.005756807394415741, 113.459496096641, -0.00926752789675378, 0.16816779626658346, 1.1629988210568096, 0.29895604927667413, -7.588273002782711, 87.23290232745612, 6.0, 0.8131324945053604, 0.8592584207538172, 0.5501643112206126, 0.19892627402518334, -0.4802851099078224, 0.6149061058404725, 0.6495669592233698, 0.6883765643209362, 0.7656880905910424, 0.6103672937767316, 0.6468766916875479, 0.6847423238504309, 0.76638396037695, -0.3387555583275074, -0.30826356626683793, -0.2741203923445602, -0.20611460035079315, -0.3446159523482172, -0.31232147262127885, -0.27881319008742106, -0.2066155069097456, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21383981772535857, 0.21385628360259928, 0.21160490169351265, 0.17973344554164614, 0.6656156037701236, 0.25325325325325315, 0.0013280922042057182, -1.6406406406406409, 0.5592948717948719], "score_GlobalLocal_5D": 0.9997418522834778, "score_Basins_5D": 0.753109872341156, "ela_features_10D": [-0.0021124447044889917, 0.9947783032710757, 0.00011053489354275665, 0.00279827856085984, 54.640053140291045, -0.0163573191388398, 0.030321318294093548, 1.5260822671182337, 0.01897173354089665, -22.250667646636252, 650.1135852057804, 5.0, 0.9112373633243148, 0.9262627978875461, 0.5927482276062594, 0.12103492758774945, -0.42264509971377173, 0.7430307153953308, 0.7777504748348985, 0.802185162246853, 0.8505960135161568, 0.743616623063039, 0.7788687381730935, 0.8040206352708458, 0.8530680303317348, -0.32590624130358326, -0.2818718821215832, -0.2508819474645669, -0.189483615825093, -0.32598335354903635, -0.2811596140151643, -0.24917943379207846, -0.1868167108801551, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11007858312037382, 0.11007397346046985, 0.10994329022625773, 0.10026643199273047, 0.6736700824947247, -0.5955955955955954, 2.294046527231462e-05, -3.398398398398399, 0.6281825460368294], "score_GlobalLocal_10D": 0.9995589852333069, "score_Basins_10D": 0.00025345440371893346}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.009262664176681782, 0.009090140874073666], -2.5602858608221224]], "nr_of_basins": 1, "f_opt_dim_2": -2.560286384235788, "x_opt_dim_2": [0.008676675851636985, 0.008676673753144662], "f_opt_dim_5": -3.046714689910143, "x_opt_dim_5": [3.939394997566434e-06, 3.932533341187913e-06, 3.9319348898846025e-06, 3.945233099809314e-06, 3.933172712838001e-06]}
{"id": "ee212694-de7e-4ff8-98f6-62297621c67b", "fitness": 0.5327569246292114, "name": "landscape_sum_gaussians", "description": "A differentiable, sum-of-Gaussians multi-well landscape. Wells are placed on a square lattice in the first two dimensions with torus wrap-around to promote homogeneous basin volumes. The origin hosts a deeper global well, while all other wells have identical width and depth, producing a clear GlobalLocal contrast but with uniform basin sizes across wells. The function is differentiable and suitable for minimization benchmarks in any dimension within [-5, 5].", "code": "import numpy as np\n\nclass landscape_sum_gaussians:\n    def __init__(self, dim=5, sigma=1.0, A_global=2.2, A_local=1.0, grid_x=4, grid_y=4, wrap_toroidal=True):\n        \"\"\"\n        A differentiable multi-well landscape constructed as a sum of Gaussian wells.\n        - dim: problem dimensionality\n        - sigma: width of Gaussian wells\n        - A_global: absolute depth (positive) for the global well at the origin\n        - A_local: absolute depth for local wells\n        - grid_x, grid_y: number of wells along x and y in the first two dimensions (grid on a plane)\n        - wrap_toroidal: if True, distances in the first two dimensions wrap around (torus)\n        \"\"\"\n        self.dim = int(dim)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.wrap = bool(wrap_toroidal)\n        self.grid_x = int(grid_x)\n        self.grid_y = int(grid_y)\n\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # Fallback 1D: place wells along the line\n            s = 2.0\n            centers.append(np.array([-s]))\n            centers.append(np.array([ s]))\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a rectangular grid in the first two dimensions\n            gx = max(1, min(self.grid_x, 12))\n            gy = max(1, min(self.grid_y, 12))\n            xs = np.linspace(-4.0, 4.0, gx)\n            ys = np.linspace(-4.0, 4.0, gy)\n            for i in range(gx):\n                for j in range(gy):\n                    c = np.zeros(self.dim)\n                    c[0] = float(xs[i])\n                    c[1] = float(ys[j])\n                    centers.append(c)\n                    depths.append(-self.A_local)\n\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the landscape at a 1D numpy array x of length self.dim.\n        f(x) = sum_i depth_i * exp(-||x - center_i||^2 / (2*sigma^2))\n        Global minimum is at the origin with value more negative than local wells.\n        Distances use torus wrap-around for the first two dimensions when enabled.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        val = 0.0\n        two_sigma_sq = 2.0 * (self.sigma ** 2)\n        domain_length = 10.0  # domain [-5, 5] => wrap-around length\n\n        for c, w in zip(self.centers, self.depths):\n            if self.dim >= 2 and self.wrap:\n                dx = abs(x[0] - c[0])\n                dy = abs(x[1] - c[1])\n                dx = min(dx, domain_length - dx)\n                dy = min(dy, domain_length - dy)\n                dist2 = float(dx*dx + dy*dy)\n                if self.dim > 2:\n                    rest = x[2:] - c[2:]\n                    dist2 += float(np.dot(rest, rest))\n            else:\n                diff = x - c\n                dist2 = float(np.dot(diff, diff))\n\n            val += w * np.exp(-dist2 / two_sigma_sq)\n\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_sum_gaussians scored on:GlobalLocal 0.504, Basins 0.678,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1541bb5b-6ee8-49e4-a572-d159a1132122"], "operator": null, "metadata": {"ela_features_2D": [-0.0029277014961810455, 0.7901468100185586, 0.00548061800656932, 0.017031859383691117, 4.444776947247829, -0.004466883173837521, 0.019119567399496627, 1.0849473323611931, 0.1715624895218117, -2.1264706155795237, 5.588855743335183, 3.2, 0.22379675462430929, 0.5901484862658619, 0.2705043919287112, 0.3686154406950049, -0.27786704736220774, 0.1377393064780769, 0.21647493777538043, 0.4327010711089974, 0.9629837988527227, 0.13780851627663634, 0.21396560536735096, 0.3315418691057621, 1.0125985545367333, -0.45105241531510193, -0.40986487470484817, -0.2967403859213664, -0.019365179450291637, -0.44265206063936446, -0.40355541850699855, -0.34314752662973824, 0.006448596162908405, 1.0, 1.0, 1.0, 1.0, 0.5179792650704492, 0.5179642455641453, 0.4418601204982111, 0.3526365774031429, 0.7283573403386228, 0.6736736736736735, 0.5476942749334054, -0.02702702702702704, 0.38152610441767065], "score_GlobalLocal_2D": 0.8368679881095886, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.0018170754647556463, 0.9795835997573972, 0.0011974451205661815, 0.010481745101880368, 18.22131879587961, -0.006986485546613297, 0.13980406334102152, 76.82791322214823, 0.2623019520079368, -6.68594183999126, 51.3117912948979, 7.8, 0.8014025108631515, 0.8641644738421604, 0.5800501428069581, 0.18766985589249155, -0.33708156752499885, 0.6229406693097888, 0.6677212009476319, 0.6994652697795083, 0.7757457681752896, 0.592257156833309, 0.6380681866472436, 0.6755142430177863, 0.7622314541784538, -0.3316298179727381, -0.29224704756704983, -0.2643282756348219, -0.19723740698484446, -0.36036433477890883, -0.3198785710161063, -0.28678667707933697, -0.21014480197815658, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21804184288447437, 0.21805664238700131, 0.2139151344839081, 0.18249694179444204, 0.5723075037153112, 0.40540540540540526, 1.435580425370378e-05, -3.4024024024024024, 0.5020833333333334], "score_GlobalLocal_5D": 0.7919247150421143, "score_Basins_5D": 0.3850720524787903, "ela_features_10D": [-0.002586829558975401, 0.999210570841661, 5.037125928248462e-05, 0.0024021490700987876, 66.79897128150574, -0.0193992409786508, 0.007060751464915094, 9.707809111561572, -0.01146123307435416, -34.1552070564622, 1345.591393220257, 4.6, 0.9735051886000534, 0.9302115377796927, 0.6796375027756365, 0.11007204720237165, -0.22015245674788578, 0.6656454096504681, 0.7179371702718119, 0.7597367929742359, 0.8267480833387164, 0.6569892176701573, 0.7125188644747829, 0.7575712949062415, 0.8276075379431946, -0.4240027270680464, -0.3576905531000555, -0.3046837709077147, -0.21970514419521026, -0.4360542202830578, -0.3654619293692697, -0.30818892645519513, -0.21915507780664165, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10893506407994069, 0.10893529980515973, 0.10883760002624947, 0.0990737255655245, 0.5573652659628436, -1.8248248248248249, 0.0, -Infinity, 0.5510008006405125], "score_GlobalLocal_10D": 0.5035477876663208, "score_Basins_10D": 0.6777884364128113}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [4.706888888888799, 4.706888888888799], -1.4789085836243951], [5, [4.705400397731301, -1.333554295198623], -1.2856177921430012], [5, [-1.333554295198623, 4.705400397731301], -1.2856177921430012], [5, [4.705400397731301, 1.333554295198623], -1.285617792143001], [5, [1.333554295198623, 4.705400397731301], -1.285617792143001], [6, [-4.705400397731301, -1.333554295198623], -1.2856177921430012], [6, [1.333554295198623, -4.705400397731301], -1.285617792143001], [6, [-4.705400397731301, 1.333554295198623], -1.285617792143001], [6, [-1.3333203556308204, -4.70600009407991], -1.2856177957147858], [9, [4.706888888888799, -4.706888888888799], -1.4789085836243954], [9, [-4.706888888888799, 4.706888888888799], -1.4789085836243954], [9, [-4.706888888888799, -4.706888888888799], -1.4789085836243954], [20, [0.00043086065144475776, 0.0004036175137974397], -2.8771567239915306]], "nr_of_basins": 13, "f_opt_dim_2": -2.877157014239657, "x_opt_dim_2": [3.9987134938806415e-09, 6.687364857316872e-09], "f_opt_dim_5": -2.877157014239657, "x_opt_dim_5": [2.0317626472287494e-09, 4.077759159194463e-10, -2.38292009031496e-10, -5.215609700448578e-09, 4.197262829656514e-09]}
{"id": "19640fc0-ffd5-414c-b5d5-c8194dea4555", "fitness": 0.5223271250724792, "name": "landscape_glocal_enhanced", "description": "A multi-basin minimization landscape with tunable GlobalLocal contrast and an explicit, normalized GlobalLocal score. The global basin at the origin is deeper than axis-aligned local wells, and an adjustable contrast parameter magnifies the global basin depth. The GlobalLocal score is computed as a scale-invariant, normalized measure of how much the local wells stand out relative to the global minimum, using the standard deviation across center evaluations for normalization.", "code": "import numpy as np\n\nclass landscape_glocal_enhanced:\n    def __init__(self, dim=5, s=2.0, sigma=0.9, A_global=1.8, A_local=1.0, contrast=0.5):\n        \"\"\"\n        landscape_glocal_enhanced\n        - dim: number of dimensions\n        - s: center distance along each axis for local wells\n        - sigma: shared Gaussian width (controls basin size)\n        - A_global: base amplitude of the global well (will be amplified by 'contrast')\n        - A_local: amplitude of the local wells\n        - contrast: fractional increase applied to the global well depth (0 -> no change, >0 -> stronger global descent)\n        \"\"\"\n        self.dim = int(dim)\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.contrast = float(contrast)\n\n        # Build centers and corresponding weights\n        self.centers = []\n        self.weights = []\n        self._build_centers()\n\n        # Precompute constants for efficient evaluation\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n    def _build_centers(self):\n        # Global (deepest) basin at origin\n        self.centers.append(np.zeros(self.dim))\n        self.weights.append(self.A_global)\n\n        # Local basins located along each axis: +s and -s\n        for d in range(self.dim):\n            c_plus = np.zeros(self.dim)\n            c_plus[d] = self.s\n            self.centers.append(c_plus)\n            self.weights.append(self.A_local)\n\n            c_minus = np.zeros(self.dim)\n            c_minus[d] = -self.s\n            self.centers.append(c_minus)\n            self.weights.append(self.A_local)\n\n        # Convert to numpy arrays for faster operations\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.weights = np.asarray(self.weights, dtype=float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is defined as a sum of negative Gaussians centered at:\n          - origin (global basin, deeper)\n          - each axis center at +/- s (local basins)\n        f(x) = sum_i -a_eff_i * exp(-||x - c_i||^2 / (2*sigma^2))\n        where a_eff_i for i==0 is scaled by (1 + contrast)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        total = 0.0\n        for i, a in enumerate(self.weights):\n            # Apply contrast to the global basin (first center)\n            a_eff = a * (1.0 + self.contrast) if i == 0 else a\n            c = self.centers[i]\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            total += -a_eff * np.exp(-dist2 / (self._two_sigma2))\n        return float(total)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a robust, normalized GlobalLocal score.\n        - val_global: function value at the origin (global minimum candidate)\n        - val_local_min: minimum value among local wells (excluding origin)\n        - vals: function values at all basin centers (origin + local wells)\n        GlobalLocal score is the local-prominence relative to the global minimum,\n        normalized by the dispersion (standard deviation) of center values.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        val_global = self.f(origin)\n\n        # compute local minima values (excluding origin)\n        vals = [val for i, val in enumerate([self.f(c) for c in self.centers])]\n        if len(vals) <= 1:\n            min_local = val_global\n        else:\n            min_local = min(vals[1:])\n\n        mean_center_value = float(np.mean(vals))\n        std_center_value = float(np.std(vals))\n\n        diff = float(min_local) - float(val_global)  # should be >= 0 if global is deepest\n        denom = std_center_value + 1e-9\n\n        gl_score = diff / denom  # normalized by dispersion (scale-invariant)\n\n        return float(gl_score)\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_glocal_enhanced scored on:GlobalLocal 0.097, Basins 0.923,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["683d47d6-8785-4c4d-b750-007fcfaa57f3"], "operator": null, "metadata": {"ela_features_2D": [-0.0036975005105470693, 0.880919650039518, 0.004749149726159794, 0.009789626689088723, 3.2915973208996108, -0.005470153620540685, 0.48120554126101894, 1.0108996529061058, 0.6419358343383319, -2.1826114694318193, 4.526972128632352, 2.4, 0.6871986602736604, 0.711913803011681, 0.5262331672405998, 0.3437446804003665, -0.16717867873093242, 0.15025802017966422, 0.22601191649833016, 0.3159974387700323, 0.49712566324510876, 0.15026726639407212, 0.22574562224474998, 0.31477499935059156, 0.4960413070289379, -0.44472348948378315, -0.40507373410897224, -0.3579762189249068, -0.2631777155762088, -0.4364412813312696, -0.39766267270711075, -0.3519329678172617, -0.25882498154215217, 1.0, 1.0, 1.0, 1.0, 0.5101933342835674, 0.5101755794811098, 0.41280479480276605, 0.34216071864470154, 0.4942110459564583, 0.6536536536536535, 0.043821227166062744, -0.6756756756756754, 0.3485943775100401], "score_GlobalLocal_2D": 0.9374160170555115, "score_Basins_2D": 0.18554836511611938, "ela_features": [-0.003195878881702896, 0.9918100213539708, 0.0006572283264243833, 0.0035621812891289545, 16.03067414381098, -0.010999364206501872, 0.07008912047901741, 1.235812340426938, 0.1679713960018366, -12.64321728122214, 200.2634730848102, 6.6, 0.8884530586100764, 0.8700800513949727, 0.6258958637823102, 0.185386142729502, -0.2769320408442598, 0.46476639990902735, 0.5433084995027645, 0.6135478104163937, 0.724808085793607, 0.47005412815041997, 0.547746763067978, 0.6181067558961988, 0.7286614264562132, -0.4710418777976595, -0.40191828140201274, -0.3401022759142047, -0.2421853473259267, -0.4692631457949824, -0.4004676966597921, -0.3381618349171709, -0.24026459097056488, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21363640777263537, 0.21361460288640072, 0.21219677824183386, 0.17858979165785124, 0.47997271185906387, 0.09709709709709705, 1.0518431227388301e-05, -Infinity, 0.4958333333333333], "score_GlobalLocal_5D": 0.02111530303955078, "score_Basins_5D": 0.9704805612564087, "ela_features_10D": [-0.003386258647543805, 0.9995862861578093, 7.034988978272082e-05, 0.0015561359828150548, 24.107757248712765, -0.02092361352615595, 0.007358005904576315, 3.124550170773028, -0.017518721256789903, -33.45694823462777, 1318.7686765584408, 3.6, 0.9277759935177847, 0.9144454418255361, 0.6405982809266042, 0.11912637279245067, -0.18291184424673496, 0.6145296955975137, 0.6713867272024601, 0.7238395745658607, 0.804441799587457, 0.6176778526972689, 0.6750877068504326, 0.7281159659061043, 0.8091144787153626, -0.4888250683714147, -0.41672318800167546, -0.35020573940671645, -0.24799167743968029, -0.4860472284468842, -0.41306100268854073, -0.3456440652316381, -0.24266995060208735, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11014591475071096, 0.11015151140375537, 0.11003341860910121, 0.10017756084036182, 0.5939007563218889, -1.7447447447447448, 0.0, -Infinity, 0.4697357886309047], "score_GlobalLocal_10D": 0.09687958657741547, "score_Basins_10D": 0.9225232601165771}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [7.89982054390237e-08, -0.000444365425079259], -3.038631686028549]], "nr_of_basins": 1, "f_opt_dim_2": -3.0386319544901204, "x_opt_dim_2": [-1.600335633476055e-09, 5.8821867053453595e-09], "f_opt_dim_5": -3.5465798862253006, "x_opt_dim_5": [5.234160452018652e-09, -4.5804199899308936e-09, 5.595098436302435e-10, 1.8787271575332957e-09, 4.084021682956106e-09]}
{"id": "8db63a15-c151-4ca7-b0f3-1e433a59a02e", "fitness": 0.5499005913734436, "name": "landscape_improved_homogeneous_basins", "description": "A torus-wrapped, multi-well Gaussian landscape with a deeply deep global well on a regular grid, augmented by an automatic basin-balancing step to promote homogeneous basin sizes while preserving global-local contrast.", "code": "import numpy as np\n\nclass landscape_improved_homogeneous_basins:\n    def __init__(self, dim, balance_basins=True, seed=None):\n        self.dim = int(dim)\n        self.balance_basins = bool(balance_basins)\n        if seed is not None:\n            np.random.seed(int(seed))\n        self.sigma = 1.0  # common Gaussian width\n        self.L = 10.0     # torus period length per dimension (domain [-5,5] => length 10)\n        \n        # Build a grid of centers on the first two dimensions; include origin for a global well\n        if self.dim <= 1:\n            # 1D: 5-point grid including the origin\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.centers = [np.array([g], dtype=float) for g in grid]\n        else:\n            # 2D+ : 5x5 grid in the first two dimensions, including origin\n            grid2d = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            centers_tmp = []\n            for a in grid2d:\n                for b in grid2d:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.centers = centers_tmp\n        \n        self.N_wells = len(self.centers)\n        # Pad centers for dim > 2 to full dimensionality\n        if self.dim > 2:\n            for i in range(self.N_wells):\n                if self.centers[i].shape[0] < self.dim:\n                    new_center = np.zeros(self.dim, dtype=float)\n                    new_center[:self.centers[i].shape[0]] = self.centers[i]\n                    self.centers[i] = new_center\n        \n        # Amplitudes (depths) for each well\n        # Global deepest well is first (index 0); others are shallower\n        # We start with a strong global-local contrast\n        self.A = [40.0] + [10.0] * (self.N_wells - 1)\n        \n        # Balance basin sizes to improve Basin homogeneity\n        if self.balance_basins:\n            self._balance_basins(iterations=3, samples_per_it=1000)\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        vals = []\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            # Torus distance per dimension\n            dist_vec = np.abs(diff)\n            dist_vec = np.minimum(dist_vec, self.L - dist_vec)\n            dist2 = float(np.dot(dist_vec, dist_vec))\n            val = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            vals.append(val)\n        return float(min(vals))\n    \n    def _torus_dist2(self, x, center):\n        diff = x - center\n        diff = np.abs(diff)\n        diff = np.minimum(diff, self.L - diff)\n        return float(np.dot(diff, diff))\n    \n    def _argmin_gaussian(self, x):\n        x = np.asarray(x, dtype=float)\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        best_i = 0\n        best_val = None\n        for i in range(self.N_wells):\n            dist2 = self._torus_dist2(x, self.centers[i])\n            val = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if (best_val is None) or (val < best_val):\n                best_val = val\n                best_i = i\n        return best_i\n    \n    def _balance_basins(self, iterations=3, samples_per_it=1000, target_tol=0.02):\n        \"\"\"\n        Simple basin-balancing heuristic:\n        - Treat each center as a basin; sample random points in the domain.\n        - Determine which well dominates (min value) at each sample.\n        - Adjust local wells' depths to push basin sizes toward equal share.\n        - Keep the global deepest well (index 0) fixed to preserve global-local contrast.\n        - Use a modest update factor to avoid destabilizing the landscape.\n        \"\"\"\n        if self.N_wells <= 1:\n            return\n        # We'll perform several balancing iterations\n        for it in range(iterations):\n            counts = np.zeros(self.N_wells, dtype=float)\n            for _ in range(samples_per_it):\n                # Uniformly sample in [-5,5]^dim (domain)\n                x = -5.0 + 10.0 * np.random.rand(self.dim)\n                i_min = self._argmin_gaussian(x)\n                counts[i_min] += 1.0\n            target = samples_per_it / float(self.N_wells)\n            # Update amplitudes for non-global wells to push counts toward target\n            # We apply small multiplicative adjustments to avoid instability\n            max_allow = 200.0  # cap for safety\n            min_allow = 0.1\n            for i in range(1, self.N_wells):  # skip global well at index 0\n                diff = counts[i] - target\n                if abs(diff) <= max(1.0, target * target_tol):  # within tolerance\n                    continue\n                if diff > 0:\n                    # Decrease depth to slightly shrink basin\n                    factor = max(0.92, 0.98 - 0.0005 * diff)\n                    self.A[i] = max(min_allow, self.A[i] * factor)\n                else:\n                    # Increase depth to enlarge basin\n                    factor = min(max_allow, 1.02 + 0.0005 * (-diff))\n                    self.A[i] = min(max_allow, self.A[i] * factor)\n            # After adjustments, ensure origin remains the deepest\n            max_local = max(self.A[1:]) if self.N_wells > 1 else self.A[0]\n            if self.A[0] <= max_local * 1.1:\n                # nudge global depth to remain clearly deeper than the deepest local\n                self.A[0] = max(self.A[0], max_local * 1.3)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_improved_homogeneous_basins scored on:GlobalLocal 0.785, Basins 0.431,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["70b13637-56c4-4f6d-b087-7edcc41b879a"], "operator": null, "metadata": {"ela_features_2D": [0.18032423953236992, 0.7009081392966294, 0.1563466093264935, 0.16701829386648903, 1.0736363061978278, 0.2861734084899562, 0.31877162116719454, 1.115056160782904, 0.6863674004144542, -3.5830870384691167, 13.778750112136759, 4.6, 0.19057453385737044, 0.563281546335381, 0.20601434546369024, 0.37754067293293553, -0.21460921823521625, 0.11745205161619535, 0.3810122032947416, 0.9100029921572746, 1.0761896969566631, 0.12449678345947121, 0.20821298457481943, 0.6363185459364589, 1.1474149564675524, -0.46174733041174576, -0.32384547687026843, -0.04707475858024281, 0.03986356050103301, -0.4497844998274306, -0.40676339756769053, -0.18664210887140326, 0.07574695166243679, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5230112526197097, 0.523007129637217, 0.47181080137073506, 0.473547297542122, 0.79251279930276, 0.7497497497497496, 0.5535275955035492, -0.05505505505505507, 0.4590361445783132], "score_GlobalLocal_2D": 0.921618640422821, "score_Basins_2D": 0.0018125682836398482, "ela_features": [-0.000871834341730593, 0.9874043741981344, 0.0006724941899018658, 0.009184521088011224, 136.4499516486131, -0.005524234341614043, 0.10740622163892262, 17.483446813998835, 0.2134425153465352, -11.542513273419257, 211.10748166509447, 7.2, 0.8046020686917288, 0.861933259744674, 0.5892528131742145, 0.19013166609408402, -0.3241491179205637, 0.6815150807404963, 0.6913777390251211, 0.716255009019803, 0.7891325080744558, 0.6523234157880387, 0.6717388291549343, 0.695488503035633, 0.7760350447625233, -0.28013516169599095, -0.2714671581791828, -0.24958408526213657, -0.18547985699701547, -0.30746870432615364, -0.290324638513403, -0.26931520755504357, -0.1980758923916797, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21581274715097587, 0.215855742015788, 0.21366360737412307, 0.18139414483012622, 0.5803384110152218, 0.1531531531531531, 1.251916156500956e-05, -3.558558558558559, 0.5174679487179488], "score_GlobalLocal_5D": 0.4901540279388428, "score_Basins_5D": 0.6695837378501892, "ela_features_10D": [-0.002857603940649067, 0.9987610932326888, 6.444374645155651e-05, 0.002038411677952035, 44.88218844935077, -0.019306875703493452, 0.006634234379588077, 8.759979260175175, -0.016587106250565455, -35.48587599330742, 1401.0591856577753, 3.2, 0.9722997575372757, 0.9301140134804406, 0.6849163593899169, 0.11012350098482851, -0.21580193754818042, 0.6793213181859207, 0.7212486494292355, 0.7617528647866256, 0.8297629692716892, 0.6718695115315363, 0.7163475786901209, 0.7598721531557607, 0.8304818304455626, -0.4066991365468649, -0.3535248074278955, -0.302155240400171, -0.2159017346166475, -0.41729450984900784, -0.36073034389619085, -0.30537817101005826, -0.21558062491172167, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10972494099866115, 0.10972851168248363, 0.10964621107112667, 0.09978619815850517, 0.5549392090148639, -1.5165165165165166, 0.0, -Infinity, 0.5692554043234588], "score_GlobalLocal_10D": 0.785033106803894, "score_Basins_10D": 0.43120133876800537}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], -14.715177646857693], [2, [-5.0, 0.00044444444444512003], -6.20800236583539], [4, [0.00044444444444512003, 0.00044444444444512003], -9.720367829927154], [4, [4.00000000000011, 0.00044444444444512003], -10.235265549109526], [3, [-1.999211223029915, -2.0005805010853566], -9.750708683799747], [4, [0.00044444444444512003, -4.00000000000011], -10.64853376329291], [4, [0.00044444444444512003, -1.9997777777778631], -9.764350794524518], [4, [-1.9997777777778631, 0.00044444444444512003], -9.964261269844213], [2, [-4.00000000000011, -2.0006666666666666], -10.847731024392834], [4, [1.999777777777864, 0.00044444444444512003], -10.250275484533812], [4, [0.00044444444444512003, 1.999777777777864], -10.219812557044671], [4, [1.999777777777864, -4.00000000000011], -10.711224050525328], [4, [1.999777777777864, -1.9997777777778631], -10.214999495555569], [4, [-4.00000000000011, 1.999777777777864], -10.000269753079756], [4, [-1.9997777777778631, 1.999777777777864], -10.004712005940139], [4, [1.999777777777864, 1.999777777777864], -9.994709506434086], [3, [5.0, -4.00000000000011], -24.261226388505335], [3, [-4.00000000000011, 5.0], -24.261226388505335], [9, [-4.00000000000011, -4.00000000000011], -40.0], [1, [4.000611760316367, 4.000611760316367], -10.204827368335653], [2, [-3.986301568238979, 0.0004906801673320435], -9.988181627188832], [1, [3.941391335534621, 5.10182747091462], -7.220655093639465], [2, [0.008213785898943405, 5.168685175656086], -7.53716717286771], [2, [1.9746943260730616, 5.1619879079351385], -7.537117927846814], [1, [-1.965066923090587, 5.149166245591457], -7.534149370306395], [2, [2.00090733312127, 4.0003434228861465], -10.235491580714033], [2, [0.00078246335334872, 3.9991483582597054], -9.989818319094216], [2, [3.9994975109326543, 1.999138946236362], -9.765043972216999], [2, [-3.9998225857654695, 3.9996839672693785], -10.810948477477433], [2, [-2.0004813220024342, -3.999654082999827], -10.826696241881267], [1, [5.0711397892912, 3.9643002421608564], -7.018373895247787], [2, [5.158551431364596, 1.9883914600349577], -7.01834100967068], [1, [5.081108702971755, -1.9848538763698698], -7.111127763452286], [2, [4.000000524258207, -2.000999999646471], -10.224815950092957], [2, [-2.0002716066509323, 3.997908166553371], -10.480586683093163], [2, [3.999484876121541, -3.9998465049749474], -10.826750516003601]], "nr_of_basins": 36, "f_opt_dim_2": -10.20006567, "x_opt_dim_2": [-1.0347739928265784e-09, 1.9999999942789646], "f_opt_dim_5": -40.0, "x_opt_dim_5": [6.000000002653766, -4.000000003785522, -4.603440144463053e-09, -1.437036465559178e-09, 5.396621282102992e-09]}
{"id": "8a416ee5-0c61-4c08-8710-e52755d90a63", "fitness": 0.5492842793464661, "name": "landscape_circle_enhanced", "description": "A novel circular-wells landscape with an enhanced global-local contrast. The global well at the origin is significantly deeper than the local circular wells, yielding a high GlobalLocal score while preserving homogeneous basin sizes through identical quadratic wells. The GlobalLocal score is explicitly computed as (A_global - A_local) / |mean(depths)| to quantify peak recognizability relative to the overall landscape.", "code": "import numpy as np\nimport math\n\nclass landscape_circle_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Global-local contrast parameters (enhanced)\n        # Global minimum depth (at origin)\n        self.A_global = 3.0\n        # Local wells depth\n        self.A_local = 1.0\n        # Radius for placing local wells (in the first two dimensions)\n        self.r = 2.5\n\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # 1D fallback: place wells along the line at -r and +r\n            c_left = np.array([-self.r])\n            c_right = np.array([ self.r])\n            centers.append(c_left)\n            centers.append(c_right)\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a circle in the first two dimensions\n            n_local = max(3, min(self.dim, 12))  # reasonable number of wells\n            for i in range(n_local):\n                theta = 2.0 * math.pi * i / float(n_local)\n                c = np.zeros(self.dim)\n                c[0] = self.r * math.cos(theta)\n                c[1] = self.r * math.sin(theta)\n                centers.append(c)\n                depths.append(-self.A_local)\n\n        # Convert to numpy arrays for efficient evaluation\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n        # GlobalLocal score (normalized contrast measure)\n        self.GLscore = self._compute_gl_score()\n\n    def _compute_gl_score(self):\n        mean_depth = float(np.mean(self.depths))\n        denom = max(1e-12, abs(mean_depth))  # guard against zero\n        delta = self.A_global - self.A_local\n        return float(delta / denom)\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i { depth_i + || x - center_i ||^2 }\n        - Global minimum sits at origin with value -A_global\n        - Local wells have equal shape/width; centers on a circle ensure homogeneous basins\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_vals = []\n        for c, d in zip(self.centers, self.depths):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            min_vals.append(d + dist2)\n        return float(min(min_vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_circle_enhanced scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1541bb5b-6ee8-49e4-a572-d159a1132122"], "operator": null, "metadata": {"ela_features_2D": [0.01863980452382428, 0.2306965126193246, 0.03141079399311141, 0.0943790532015317, 3.8601143775956785, 0.019077222656586245, 0.769081033347802, 1.07059475498581, 0.9596118694382308, 1.0539759223965208, 0.7633674647312875, 1.2, 0.6389483642177279, 0.6984902916023015, 0.5127198439585786, 0.35102318530242865, -0.2015535848203495, 0.14198290725510354, 0.22523325245246967, 0.3977290698904813, 0.561026273830155, 0.14923495426668562, 0.228943805602077, 0.3788719115699656, 0.5545100757658574, -0.44877432579945487, -0.40522909003604884, -0.3150061673294936, -0.22959618924420938, -0.43699912880455083, -0.3960570258105715, -0.3190394205972365, -0.2288269332571228, 1.0, 1.0, 1.0, 1.0, 0.5095129139644967, 0.5094932678225075, 0.4160974594837182, 0.3823403964865066, 0.7042336846843107, 0.4734734734734733, 0.4018081616027807, -0.13513513513513514, 0.37309236947791163], "score_GlobalLocal_2D": 0.9149110317230225, "score_Basins_2D": 0.3806856572628021, "ela_features": [0.0014497576170297232, 0.3906778161059618, 0.0036653764391156177, 0.031234240351999197, 63.85897652740779, 0.0024929689726731264, 0.9885789082777159, 2.405766157770082, 0.9922019565732537, 0.3411738067774016, -0.19033408899285603, 1.0, 0.8945083904037088, 0.8746413710182616, 0.6363051317621256, 0.18085869902606472, -0.46792356318462225, 0.49419674829412885, 0.5649493918469765, 0.62817545294853, 0.7389861457157119, 0.48301548429182556, 0.5571777316699815, 0.6217029436740498, 0.7364870002196053, -0.44504761427681316, -0.3827952241744822, -0.3271637712636342, -0.22966318486895326, -0.4573655852132097, -0.3917585884803594, -0.33467504849430973, -0.23312687722634115, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21351745458971086, 0.21357126814940092, 0.19843996016126303, 0.18072539876352697, 0.8233850570433063, 0.1491491491491491, 0.2542885812326692, -0.3513513513513512, 0.5100961538461538], "score_GlobalLocal_5D": 0.0002812097663991153, "score_Basins_5D": 0.9997896552085876, "ela_features_10D": [0.0017198567471849557, 0.4332331464148623, 0.001686441795820099, 0.025946282603740427, 33.83822625761715, 0.010791603930743654, 0.9974477811782805, 2.621248199682672, 0.9989082103271596, 0.18952617604012575, -0.14560613769301867, 1.2, 1.01570260847036, 0.9379454903734683, 0.7109978631503877, 0.10560287905620117, -0.6062879832765697, 0.6304616612041986, 0.6908407351150267, 0.7368358187456776, 0.8144482792550164, 0.627951433662275, 0.6909545516505033, 0.7386500565627953, 0.8178221850719269, -0.46864341956433064, -0.39207129122303847, -0.33374111854175925, -0.23531402896738446, -0.47305729419239456, -0.3929485375019627, -0.3323042346910611, -0.23163731853018388, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10925867678792636, 0.10926017741370128, 0.1060541500401796, 0.10065821915856792, 0.854089750654382, -0.09509509509509508, 0.13719822214944952, -0.6276276276276274, 0.5881505204163331], "score_GlobalLocal_10D": 0.00016852287808433175, "score_Basins_10D": 0.9998694658279419}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[14, [0.00044444444444512003, 0.00044444444444512003], -2.999999604938272], [25, [-1.249555555555556, -2.1648888888890787], -0.9999997719767917], [34, [2.5000000000002753, 0.00044444444444512003], -0.9999998024691358], [27, [-1.249555555555556, 2.164666666666649], -0.9999996449849323]], "nr_of_basins": 4, "f_opt_dim_2": -3.0, "x_opt_dim_2": [-9.558789031241097e-10, 1.3732749682960141e-08], "f_opt_dim_5": -3.0, "x_opt_dim_5": [-8.68463079196213e-09, 1.2521626145312691e-09, -1.637646079639306e-09, 2.4378368098322643e-09, 5.926946918649683e-10]}
{"id": "137c1707-0443-42f6-a515-a1c74646093f", "fitness": 0.5347666144371033, "name": "landscape_min_gaussians_homogeneous_improved", "description": "A homogeneous multi-basin Gaussian landscape with a toroidal distance metric to enforce basin-size homogeneity while preserving a deeper global well at the origin for global-local contrast.", "code": "import numpy as np\n\nclass landscape_min_gaussians_homogeneous_improved:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Shared width for all Gaussian wells\n        self.sigma = 1.0\n        # Domain is [-5, 5] in each dimension, so wrap-around (toroidal) distance uses L=10\n        self.L = 10.0\n\n        if self.dim <= 1:\n            # 1D: symmetric grid of wells with origin included\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.N_wells = min(5, len(grid))\n            self.centers = [np.array([g], dtype=float) for g in grid[:self.N_wells]]\n            # Ensure a global well at the origin (override first center with origin)\n            if self.N_wells > 0:\n                self.centers[0] = np.array([0.0], dtype=float)\n        else:\n            # 2D+ case: place wells on a regular 4x4 grid in the first two dims\n            grid = [-4.0, -1.0, 2.0, 5.0]  # spacing ~3, within [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # Ensure origin is one of the centers to guarantee a global well at the origin\n            self.centers[0] = np.zeros(self.dim, dtype=float)\n            # If dim > 2, pad centers to match self.dim\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes: a deeper global well (global) plus identical local wells\n        self.A = [6.0] + [2.0] * (self.N_wells - 1)\n\n    def _dist2_toroidal(self, x, center):\n        # Toroidal squared distance on [-5,5]^dim (wrap-around with L=10)\n        x = np.asarray(x, dtype=float)\n        center = np.asarray(center, dtype=float)\n        dist2 = 0.0\n        for d in range(self.dim):\n            xd = x[d]\n            cd = center[d]\n            delta = abs(xd - cd)\n            if delta > self.L / 2.0:\n                delta = self.L - delta\n            dist2 += delta * delta\n        return dist2\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = float('inf')\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            dist2 = self._dist2_toroidal(x, self.centers[i])\n            candidate = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if candidate < val:\n                val = candidate\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_min_gaussians_homogeneous_improved scored on:GlobalLocal 0.440, Basins 0.960,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["59e097eb-1e98-4edf-a76b-9c21aef339d0"], "operator": null, "metadata": {"ela_features_2D": [-0.0010172704025900759, 0.7885550519004536, 0.016174184200297696, 0.021681984851234237, 1.9430089399646782, -0.0028320549322971454, 0.04989326367902465, 1.1756054901838644, 0.13525501267732332, -2.4824210155327076, 8.495383992841976, 4.0, 0.2384719391867105, 0.5753824833738914, 0.2768807281259325, 0.38447271899123725, -0.30870433365219263, 0.1322482866004833, 0.2118926939811053, 0.590324258562947, 0.9423182509492094, 0.1371227525333774, 0.2103021328024794, 0.48088923587667154, 0.9396682423704401, -0.4539675794242676, -0.4122973720269897, -0.21431458520590682, -0.030179567859724997, -0.44283751025599427, -0.40527195154829904, -0.26634029102842105, -0.030956346305557637, 1.0, 1.0, 1.0, 1.0, 0.5304547349295401, 0.530337958275856, 0.4653721665165881, 0.3587483563368184, 0.7631752893252832, 0.7577577577577576, 0.6017017235323922, 0.033033033033032996, 0.4204819277108435], "score_GlobalLocal_2D": 0.7090036273002625, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.0018501392190723108, 0.9867899028773826, 0.0002407130238677019, 0.008318476500253354, 105.89674100731857, -0.009339879882192027, 0.08456046421163081, 12.53497426927574, 0.1620035789911553, -12.268560731289629, 209.69468144256433, 6.6, 0.8503449224715741, 0.8635496736216337, 0.6217386581132927, 0.19039235157842793, -0.3059896583962005, 0.61535458145251, 0.6669811174413532, 0.7155742550878921, 0.7860541387828326, 0.5870847356262076, 0.6394584340556972, 0.6935766489908174, 0.7727704163000628, -0.3384488526670979, -0.293024542309548, -0.25026834102104617, -0.1882534599482038, -0.36539176939965295, -0.3190474192117086, -0.27115700833495715, -0.2010783510079209, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21666781847836775, 0.2166501149313967, 0.21493510150727943, 0.18098686882788284, 0.5705325467453105, 0.11711711711711707, 1.0541516534898343e-05, -3.706706706706707, 0.5025641025641026], "score_GlobalLocal_5D": 0.2269209623336792, "score_Basins_5D": 0.8710113763809204, "ela_features_10D": [-0.002696883612502843, 0.9999050806443419, 7.150490855142039e-05, 0.002007583314186532, 198.68365426123486, -0.019566361898634498, 0.0041044700541998935, 3.129305625630473, -0.01723459185194698, -40.345321935469414, 1786.3753738821893, 2.6, 0.9619798324603304, 0.9296727796441934, 0.6816233178085004, 0.10965472398726453, -0.1859741278720237, 0.6687247556396236, 0.7183722801299943, 0.760490055784034, 0.8284948228094337, 0.6599080583524419, 0.7133539732163684, 0.7586372722778532, 0.829310925904233, -0.4201511009089611, -0.35718345939209706, -0.30376630843341446, -0.2175172186684163, -0.4325157149103429, -0.36454371065705404, -0.30695435001305177, -0.21707497717425742, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10926268361386723, 0.10925948159732721, 0.10919799611814678, 0.09945415363329685, 0.5733704469252404, -2.2612612612612613, 0.0, -Infinity, 0.555804643714972], "score_GlobalLocal_10D": 0.4404710531234741, "score_Basins_10D": 0.9598521590232849}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -2.0], [2, [5.0, -5.0], -2.0], [2, [-5.0, 5.0], -2.0], [4, [5.0, 5.0], -2.0], [2, [-0.9995555555555558, -5.0], -1.9999998024691457], [2, [-4.992807433949984, -0.9994972938429334], -1.9999480149557587], [4, [5.0, -0.9995555555555558], -1.9999998024691457], [4, [-0.9995555555555558, 5.0], -1.9999998024691457], [6, [5.0, 1.999777777777864], -1.9999999506172845], [6, [1.999777777777864, 5.0], -1.9999999506172845], [4, [1.999777777777864, -0.9995555555555558], -1.999999753086435], [4, [-0.9995555555555558, 1.999777777777864], -1.999999753086435], [2, [-5.0, -3.999777777777643], -1.9999999506172845], [4, [5.0, -3.999777777777643], -1.9999999506172845], [4, [-3.999777777777643, 5.0], -1.9999999506172845], [5, [-3.999777777777643, -5.0], -1.9999999506172845], [5, [-0.9995555555555558, -3.999777777777643], -1.9999997530864349], [3, [-4.991598276410535, 1.9998231447556336], -1.9999293810097385], [3, [1.9997891206551628, -4.995798882455843], -1.99998230621955], [6, [1.99960053424454, -4.000103809342363], -1.999999829650738], [6, [-3.999977825827661, 1.999869145722071], -1.9999999823854642], [6, [1.999777777777864, 1.999777777777864], -1.9999999012345704], [11, [0.0004326871827501134, 0.0004315017823452085], -5.999998879764146], [4, [-3.9983230745485945, -1.0005778763536204], -1.9999968539824247]], "nr_of_basins": 24, "f_opt_dim_2": -6.0, "x_opt_dim_2": [-9.31132125978976e-09, 2.710060454000055e-10], "f_opt_dim_5": -6.0, "x_opt_dim_5": [6.7578616369977785e-09, 4.2971625751043865e-09, -1.1675986616791967e-09, 1.474305197513646e-09, -3.1664252933136137e-09]}
{"id": "bcf16dea-9b7f-405e-b637-1fbfd48493a6", "fitness": 0.538486659526825, "name": "landscape_improved_basin_homogeneous", "description": "A torus-wrapped, min-of-Gaussians multi-well landscape with a deeply deeper global well on a symmetric grid. Basins homogeneity is enhanced by toroidal symmetry and equal-well spacing, while preserving a strong global-local contrast via a deeper global well.", "code": "import numpy as np\n\nclass landscape_improved_basin_homogeneous:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self.sigma = 1.0  # common Gaussian width for all wells\n        self.L = 10.0     # domain length per dimension ([-5, 5]), used for toroidal wrap\n\n        if self.dim <= 1:\n            # 1D: a symmetric 5-point grid including the origin\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            centers = [np.array([g], dtype=float) for g in grid]\n            # Ensure origin is the first center for consistency\n            origin_idx = next((i for i, c in enumerate(centers) if c[0] == 0.0), None)\n            if origin_idx is not None and origin_idx != 0:\n                centers[0], centers[origin_idx] = centers[origin_idx], centers[0]\n            self.centers = centers\n            self.N_wells = len(self.centers)\n        else:\n            # 2D+ : regular 4x4 grid in the first two dimensions, including origin\n            grid_vals = [-4.0, -2.0, 0.0, 2.0]  # symmetric grid across [-5,5]\n            centers_tmp = []\n            for a in grid_vals:\n                for b in grid_vals:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            # Put origin center first if present\n            origin_index = next((i for i, c in enumerate(centers_tmp) if c[0] == 0.0 and c[1] == 0.0), None)\n            if origin_index is not None and origin_index != 0:\n                centers_tmp[0], centers_tmp[origin_index] = centers_tmp[origin_index], centers_tmp[0]\n\n            # Cap to 16 wells for consistency and symmetry\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n\n            # Pad centers for dim > 2 to the full dimensionality\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Depths (amplitudes) for wells: global deep well first, locals shallower\n        self.A = [12.0] + [4.0] * max(0, self.N_wells - 1)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        # Evaluate as the minimum over Gaussian wells (min_i g_i(x)),\n        # yielding well-defined basins with more homogeneous sizes on a torus.\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        best = float('inf')\n\n        for i in range(self.N_wells):\n            diff = x - self.centers[i]\n            # Toroidal wrap-around distance per dimension\n            if self.L > 0:\n                diff = (diff + self.L / 2.0) % self.L - self.L / 2.0\n            dist2 = float(np.dot(diff, diff))\n            val = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if val < best:\n                best = val\n\n        return float(best)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_improved_basin_homogeneous scored on:GlobalLocal 0.956, Basins 0.210,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["70b13637-56c4-4f6d-b087-7edcc41b879a"], "operator": null, "metadata": {"ela_features_2D": [0.11240700560490731, 0.6600363312041135, 0.12181190347193693, 0.13051939357343773, 1.071472414239628, 0.11232228954409182, 0.4262756916897203, 1.0356772696667425, 0.4901981008384465, -2.0613803440656557, 6.647488565351199, 4.0, 0.32183779662005474, 0.603388877071902, 0.3275502740950843, 0.3827794863747277, -0.2560066352274794, 0.13122347868729128, 0.20389706973895474, 0.44640205222009677, 0.681023150157636, 0.13042652961565185, 0.20453742335030575, 0.378612643782508, 0.6722266186949103, -0.4542178588884619, -0.4162193631447165, -0.28941818554345, -0.16676295697475982, -0.4458713263331295, -0.40787394798962084, -0.3185556256332554, -0.16804232241326772, 1.0, 1.0, 0.9333333333333332, 1.0, 0.5200777586343694, 0.5200663017339513, 0.46979026046030087, 0.4539282408229455, 0.7622300090263996, 0.7617617617617616, 0.5777829786234865, 0.0010010010010009813, 0.42971887550200805], "score_GlobalLocal_2D": 0.9857810139656067, "score_Basins_2D": 0.000791850674431771, "ela_features": [-0.00270750328058873, 0.9870164583263584, 0.00035563195981401833, 0.005051225804518008, 53.33350210976332, -0.009897437108389084, 0.0791237235068597, 4.391558326973045, 0.1530524005413489, -13.42793921703552, 258.7191776797071, 6.2, 0.8524749133816025, 0.866777119152611, 0.6198533304985411, 0.18682850606977577, -0.3087378097561058, 0.5901186552426795, 0.6400178270737225, 0.6893752758486906, 0.7748896898807189, 0.5740919873293253, 0.6153200667853227, 0.6662245279486357, 0.7636556292845318, -0.36054058371494524, -0.3166477734148264, -0.2732320414727517, -0.19801207261739068, -0.3765441689985708, -0.34009024162102475, -0.2950847205618752, -0.20894903905488887, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21772613252684084, 0.21771960123686407, 0.2163239166318136, 0.18184137139946163, 0.5686571116184546, 0.04904904904904903, 1.1230021037312223e-05, -3.638638638638639, 0.5139423076923076], "score_GlobalLocal_5D": 0.25183600187301636, "score_Basins_5D": 0.8264086246490479, "ela_features_10D": [-0.0025763790614924177, 0.9987415549166704, 0.0001008118565108444, 0.002206388066205414, 30.23913033217924, -0.01942009963198843, 0.0038624489211485534, 6.530981920976494, -0.023666667512224127, -36.474820724766246, 1458.308890279733, 3.4, 0.974416649649649, 0.9297293332013956, 0.6791075661032231, 0.11164646544106908, -0.17323791770702437, 0.6640559084094786, 0.7111309874276623, 0.7537770327989636, 0.8249265453245502, 0.6587506855847739, 0.707589420320323, 0.7532636292473469, 0.8266959451170939, -0.4260443751433723, -0.3663438978091983, -0.3122601287534951, -0.2220280088997079, -0.43385941462468214, -0.37176520933297763, -0.3136961607707381, -0.2203346987224025, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10996104087164352, 0.10996907587906939, 0.10988067665163534, 0.10010914146851253, 0.5653182893692911, -2.0930930930930933, 0.0, -Infinity, 0.5634907926341073], "score_GlobalLocal_10D": 0.9560787081718445, "score_Basins_10D": 0.21002380549907684}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], -1.4715177646857693], [4, [0.00044444444444512003, 0.00044444444444512003], -11.999997629629863], [4, [0.00044444444444512003, -4.00000000000011], -3.9999996049382913], [4, [0.00044444444444512003, -1.9997777777778631], -3.99999950617287], [4, [-4.00000000000011, 0.00044444444444512003], -3.9999996049382913], [4, [-1.9997777777778631, 0.00044444444444512003], -3.99999950617287], [4, [-4.00000000000011, -4.00000000000011], -4.0], [4, [-1.9997777777778631, -4.00000000000011], -3.999999901234569], [4, [-4.00000000000011, -1.9997777777778631], -3.999999901234569], [4, [-1.9997777777778631, -1.9997777777778631], -3.9999998024691408], [6, [1.999777777777864, 0.00044444444444512003], -3.99999950617287], [6, [0.00044444444444512003, 1.999777777777864], -3.99999950617287], [6, [1.999777777777864, -4.00000000000011], -3.999999901234569], [6, [1.999777777777864, -1.9997777777778631], -3.9999998024691408], [6, [-4.00000000000011, 1.999777777777864], -3.999999901234569], [6, [-1.9997777777778631, 1.999777777777864], -3.9999998024691408], [9, [1.999777777777864, 1.999777777777864], -3.9999998024691408], [2, [5.000744593693866, -3.9620095360523298], -2.4261776610451804], [2, [5.000454976870962, -2.0037732019551733], -2.4272091902467214], [2, [5.001073336893835, -0.035551730666603915], -2.427192304814542], [3, [5.000828292995166, 1.9597889814357377], -2.426169917050321], [2, [-3.9600110019695878, 5.000819872539995], -2.426171104683182], [2, [-2.011772202155221, 5.0005181844345135], -2.4272116246481747], [2, [-0.029555125722024463, 5.000873043137241], -2.4271804388240636], [3, [1.959788954898369, 5.000825887773105], -2.426164083817435]], "nr_of_basins": 25, "f_opt_dim_2": -12.0, "x_opt_dim_2": [-6.361511710201687e-10, 7.764306548673375e-09], "f_opt_dim_5": -12.0, "x_opt_dim_5": [1.008131646176335e-09, 4.473092790415161e-09, -4.150981651183056e-09, -4.286586982830145e-09, -5.497829556967126e-09]}
{"id": "e89fb015-7dc7-4872-ae63-832a79a5dcbb", "fitness": 0.5205843448638916, "name": "landscape_min_gaussians_homogeneous_torus", "description": "A homogeneous multi-basin Gaussian landscape with torus-wrapped distances to enforce basin-size homogeneity (Basins) while preserving a deeper global well for GlobalLocal contrast. The landscape is built as a min-over-Gaussians with identical widths on a symmetric grid, using wrap-around distances to equalize basin sizes across the domain.", "code": "import numpy as np\n\nclass landscape_min_gaussians_homogeneous_torus:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Shared Gaussian width for all wells\n        self.sigma = 1.0\n        # Torus circumference per axis to enforce homogeneous basins\n        self.L = 10.0\n        self.L_half = self.L / 2.0\n\n        if self.dim <= 1:\n            # 1D: symmetric grid of wells\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.N_wells = min(5, len(grid))\n            self.centers = [np.array([g], dtype=float) for g in grid[:self.N_wells]]\n        else:\n            # 2D+ case: wells on a regular 4x4 grid in the first two dimensions\n            grid = [-4.0, -1.0, 2.0, 5.0]  # spacing ~3, inside [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # If dim > 2, pad centers to match self.dim\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes: a deeper global well (global) plus identical local wells\n        # Global well deeper to induce GlobalLocal contrast\n        self.A = [8.0] + [3.0] * (self.N_wells - 1)\n\n        # Note: landscape is constructed as f(x) = min_i { -A[i] * exp(-||torus_dist(x, center_i)||^2 / (2*sigma^2)) }\n\n    def _torus_dist2(self, x, c):\n        # Compute squared distance on a torus of side L per axis\n        diff = x - c\n        # Element-wise wrap-around distance per axis\n        d = np.abs(((diff + self.L_half) % self.L) - self.L_half)\n        return float(np.dot(d, d))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = float('inf')\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            dist2 = self._torus_dist2(x, self.centers[i])\n            candidate = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if candidate < val:\n                val = candidate\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_min_gaussians_homogeneous_torus scored on:GlobalLocal 0.231, Basins 0.974,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["59e097eb-1e98-4edf-a76b-9c21aef339d0"], "operator": null, "metadata": {"ela_features_2D": [0.15921510088562957, 0.6502330932570034, 0.14031509553269933, 0.15293247481817507, 1.0884571129792924, 0.21903218772622712, 0.2858772690859733, 1.18162475736059, 0.47578873169430763, -2.169520535135459, 7.308121996485417, 3.4, 0.18274078248332887, 0.5610784557347056, 0.208778027472091, 0.37602230978856377, -0.3365221219534625, 0.14512103775032098, 0.6003033765042464, 0.9913628026778113, 1.0597225988403194, 0.1498476734172714, 0.26654159006646944, 1.085671337675561, 1.1124842064732956, -0.4474417425065629, -0.20923955293468363, -0.004517227642768152, 0.031256646897904264, -0.43772985675879195, -0.37764226270258106, 0.044172098625459864, 0.05792058225167125, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5073439033114261, 0.507316393105222, 0.4655459557519136, 0.46745260128423655, 0.7689977319422548, 0.7617617617617616, 0.7689715340623495, 0.10510510510510507, 0.4208835341365463], "score_GlobalLocal_2D": 0.9158856868743896, "score_Basins_2D": 0.0013632604386657476, "ela_features": [-0.00014469176370324188, 0.9832035631958931, 0.0004842318090317749, 0.006963858221388361, 32.88922605573147, -0.005497951224216857, 0.10151142999406462, 12.288445663213901, 0.20601657926436218, -11.33561790787539, 192.4189536884579, 7.2, 0.8106941853415129, 0.8644087691254662, 0.5974526788229964, 0.1888484214565758, -0.3133889622080726, 0.6770280946551415, 0.6970723938844323, 0.7246191808367655, 0.7873507973114815, 0.6604341279899397, 0.680789083422407, 0.7027910892585895, 0.7746056289212783, -0.28408830126310286, -0.26645338501112875, -0.242221024572639, -0.18704401249344632, -0.30027802830317213, -0.2822703285352978, -0.2628107699768079, -0.19930815065360366, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2164877020482126, 0.216491063414982, 0.21480742751340962, 0.18195007637598734, 0.558244056143191, 0.14914914914914912, 1.3312157206787065e-05, -3.598598598598599, 0.5091346153846155], "score_GlobalLocal_5D": 0.3411921560764313, "score_Basins_5D": 0.6598532795906067, "ela_features_10D": [-0.0031239668544300603, 0.999127576196614, 5.289058998383592e-05, 0.0016454389082209149, 133.35641531264184, -0.020165304413160445, 0.005001545935801976, 13.275719891089683, -0.024298137285839783, -36.84826119624083, 1546.225280538433, 2.8, 0.9630613780999131, 0.9301928791992073, 0.6894230336609912, 0.10851232082202458, -0.21250871340361138, 0.6702152844649449, 0.7268639128078667, 0.7647540379522588, 0.8292670558490658, 0.6613901696579946, 0.7222014214636838, 0.7627774442894818, 0.8299856073577777, -0.4182352646379437, -0.34639324394424786, -0.2983407054600957, -0.21652505113514692, -0.4305411495047685, -0.353220598271981, -0.3016277888280597, -0.21617425922478498, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11082186197311332, 0.11083081006567444, 0.11072615518538367, 0.10081593721998106, 0.5635022138396575, -1.964964964964965, 0.0, -Infinity, 0.5616493194555645], "score_GlobalLocal_10D": 0.23123407363891602, "score_Basins_10D": 0.9739776849746704}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -3.0], [2, [5.0, -5.0], -3.0], [2, [-5.0, 5.0], -3.0], [4, [5.0, 5.0], -3.0], [2, [-0.9995555555555558, -5.0], -2.9999997037037183], [2, [-4.991209211603485, -0.9994685222949533], -2.9998836616120537], [4, [5.0, -3.888888888888889], -4.822385401284501], [4, [5.0, -0.9995555555555558], -2.9999997037037183], [4, [-3.888888888888889, 5.0], -4.822385401284501], [4, [-0.9995555555555558, 5.0], -2.9999997037037183], [4, [-0.9995555555555558, -0.9995555555555558], -2.999999407407466], [6, [5.0, 1.999777777777864], -2.999999925925927], [6, [1.999777777777864, 5.0], -2.999999925925927], [6, [1.999777777777864, -0.9995555555555558], -2.9999996296296527], [6, [-0.9995555555555558, 1.999777777777864], -2.9999996296296527], [9, [1.999777777777864, 1.999777777777864], -2.9999998518518556], [8, [-3.988989630224118, -3.998992586648638], -7.999511042446028], [4, [-0.9995555555555558, -3.999777777777643], -2.9999996296296523], [3, [1.999823144805559, -4.991598271773828], -2.9998940713977698], [3, [-4.997199240168081, 1.9997828190895819], -2.999988162888577], [6, [-3.9998562955498285, 1.9995951767547406], -2.9999997232007694], [6, [1.9998340411963915, -4.0000468717642494], -2.99999995539107], [4, [-4.0002030974506795, -0.9990232532946955], -2.99999850707632]], "nr_of_basins": 23, "f_opt_dim_2": -3.0, "x_opt_dim_2": [-1.0000000038798718, -3.9999999973026625], "f_opt_dim_5": -8.0, "x_opt_dim_5": [5.9999999989882635, -3.999999995233798, 2.4931251719991883e-09, -3.695879762239459e-09, 6.036740061087631e-09]}
{"id": "286fb2be-697e-4467-9a41-0381048f4e54", "fitness": 0.5033063888549805, "name": "landscape_parabolic_grid_uniform_improved", "description": "A multi-basin parabolic landscape with wells on a 3-ary grid, global optimum at the origin. GlobalLocal score is improved by a robust normalization that combines the mean and spread (standard deviation) of center energies to quantify peak prominence, while basin sizes remain homogeneous via Monte Carlo basin-volume estimation.", "code": "import numpy as np\nimport itertools\n\nclass landscape_parabolic_grid_uniform_improved:\n    def __init__(self, dim):\n        self.dim = dim\n\n        # Global settings for the multi-basin construction\n        self.alpha = 1.0        # common quadratic coefficient\n        self.a = 1.5              # half-range for centers along each axis\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n\n        # Build centers on a small grid: coordinates in {-a, 0, a} for each dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local basins: set a deep global minimum at the origin (0,...,0)\n        self.beta = np.full(self.K, -9.5, dtype=float)\n        # Find index of the origin center\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the centers.\")\n        self.beta[origin_index] = -12.0  # deepest well at the origin\n        self.origin_index = origin_index\n\n        # Compute improved global-local minima contrast\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = np.mean(f_center_values)\n        std_center = np.std(f_center_values)\n        # Denominator combines mean magnitude and variability for robust normalization\n        denom = max(abs(avg_center) + 1e-9, std_center + 1e-9)\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / denom\n        )\n\n        # Basins homogeneity: estimate basin sizes via Monte Carlo sampling\n        self._estimate_basins(n_samples=20000, seed=12345)\n\n    def _estimate_basins(self, n_samples=20000, seed=12345):\n        rng = np.random.RandomState(seed)\n        counts = np.zeros(self.K, dtype=int)\n\n        domain_span = self.domain_hi - self.domain_lo\n        for _ in range(n_samples):\n            x = rng.rand(self.dim) * domain_span + self.domain_lo\n            d2 = np.sum((self.centers - x) ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n\n        # Consider only basins that actually attract samples (nonzero)\n        nonzero_mask = counts > 0\n        nonzero = counts[nonzero_mask]\n\n        if nonzero.size <= 1:\n            self.basin_homogeneity = 1.0\n        else:\n            self.basin_homogeneity = float(np.max(nonzero) / np.min(nonzero))\n\n        # Store for potential external introspection\n        self._basin_counts = counts\n        self._basin_n_samples = n_samples\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) for x in R^dim as the minimum over all wells:\n          f(x) = min_k (alpha * ||x - c_k||^2 + beta_k)\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        d2 = np.sum((self.centers - x) ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_parabolic_grid_uniform_improved scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9b0029de-8ccc-44f0-90bf-ecf540ce31f6"], "operator": null, "metadata": {"ela_features_2D": [-0.0029977570064835036, 0.3397540847606271, 0.006088576833831226, 0.019045580401150806, 6.80626718768642, -0.002815099394942955, 0.9630537085202867, 1.0126586733734746, 0.964352699111209, 0.6607098396507014, -0.25660567166746945, 1.2, 0.6882587643214124, 0.7142244673590687, 0.558077714964171, 0.3407950443663144, -0.21880460431507806, 0.15064945078586006, 0.23390870407053416, 0.3432082236865187, 0.5079476873712514, 0.1537361765065359, 0.2397894504547209, 0.3475965652550863, 0.5113957579874753, -0.44426960929381104, -0.4007171389838492, -0.3435454526630677, -0.2573746690595534, -0.43461639293681553, -0.39042624897905603, -0.33504698178319126, -0.25091414452095995, 1.0, 1.0, 1.0, 1.0, 0.5111447553309066, 0.511071368971904, 0.40328094407787096, 0.3444641143257214, 0.6983883094117628, 0.5135135135135134, 0.45863662410533246, -0.07907907907907906, 0.3738955823293173], "score_GlobalLocal_2D": 0.9777002930641174, "score_Basins_2D": 0.042118970304727554, "ela_features": [-0.0012937565769220783, 0.3445889326721129, 0.004165466476669269, 0.023861185817259482, 9.392827190119275, 0.0028008741752965304, 0.9484398698462579, 1.0354790689468267, 0.9489072491951056, 0.4534020010345358, -0.1762679990416097, 1.2, 0.877187056222773, 0.8684365608901841, 0.6074598892181209, 0.18998523578362558, -0.49712516296877995, 0.489298224886908, 0.5454384165759809, 0.6116000988615916, 0.72653851218965, 0.4888388601320866, 0.5496926445096492, 0.6160173613904625, 0.7303983494267294, -0.449272942370864, -0.39988745522685454, -0.3416838938175815, -0.2405698187855842, -0.4522104032080625, -0.3983825566916563, -0.33970722378320806, -0.23851522845023582, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21798724891424498, 0.21794501677143865, 0.20096751659009882, 0.18289816662241304, 0.8348295287196923, 0.24924924924924916, 0.29450990064378246, -0.29529529529529525, 0.5375], "score_GlobalLocal_5D": 0.00032580277184024453, "score_Basins_5D": 0.9998378753662109, "ela_features_10D": [-0.0012526419454242266, 0.372307419774459, 0.001245460442932338, 0.01655830478286598, 21.80647972709333, 0.004993185367749864, 0.948307979045779, 1.0428869041921456, 0.9485693217652663, 0.35228564429546844, 0.00987968808255566, 1.4, 1.0108817386307671, 0.9382814252468634, 0.6981678185820142, 0.10623145176766269, -0.6111438406783639, 0.62827323208865, 0.6872410370638822, 0.7363975294644396, 0.8116259696200929, 0.6309946165055658, 0.6907107244546562, 0.7398852024750021, 0.8156821601123211, -0.4714161291185944, -0.3966352251612883, -0.3342957234213846, -0.23889266813478532, -0.46916705824798804, -0.39324330752053355, -0.3307206858211295, -0.23434977361525172, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1099421192114747, 0.10993859381152091, 0.10689582084031028, 0.10004445490331704, 0.8593744699372889, -0.0790790790790791, 0.13359831263185146, -0.6316316316316314, 0.6022417934347477], "score_GlobalLocal_10D": 0.00023008426069281995, "score_Basins_10D": 0.999625563621521}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[24, [0.00044444444444512003, 0.00044444444444512003], -11.999999604938271], [16, [-1.4997894663066353, -1.4997894663066353], -9.499999911351129], [22, [1.499965466413299, -1.498173332048716], -9.499996662091627], [20, [-1.5006240281732002, 1.493709654811069], -9.499960042146244], [18, [1.498721264699605, 1.500921947464993], -9.499997514848904]], "nr_of_basins": 5, "f_opt_dim_2": -12.0, "x_opt_dim_2": [2.272057996436181e-08, 1.6593464498850752e-09], "f_opt_dim_5": -12.0, "x_opt_dim_5": [-7.403876679579623e-09, -1.8541002062505666e-08, 1.0975105562641386e-08, 4.4773761801136766e-09, 3.382190775037384e-09]}
{"id": "c3980e32-d8ba-42a1-a5ea-6bccbed0e4dc", "fitness": 0.5739575624465942, "name": "GridParabolicGridLandscapeHomogeneousBasin", "description": "A torus-wrapped multi-basin parabolic landscape with a deep global minimum at the origin and shallow local wells on a regular grid. Basin sizes are improved to be more homogeneous by computing basin assignments using toroidal distances (wrap-around) so each basin occupies a nearly equal volume on the domain, while preserving a strong global-local contrast with a deeper origin well. The function remains a minimization objective.", "code": "import numpy as np\nimport itertools\n\nclass GridParabolicGridLandscapeHomogeneousBasin:\n    \"\"\"\n    Multi-basin parabolic landscape on a regular grid of centers.\n    Global minimum at the origin is substantially deeper than local wells.\n    Basin sizes are improved to be homogeneous by using toroidal (wrap-around) distances\n    when assigning points to wells, promoting equal-volume basins on the domain.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Domain and basic parameters\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n        self.alpha = 1.0  # common quadratic coefficient\n        self.a = 2.0        # centers along each axis: -a, 0, +a\n\n        # Build centers on a regular grid: coordinates in {-a, 0, a} per dimension\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local wells: set depths beta_k\n        # Global minimum at origin is made significantly deeper than local wells\n        self.beta = np.full(self.K, -1.0, dtype=float)\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the grid centers.\")\n        self.beta[origin_index] = -50.0  # deep global minimum\n        self.origin_index = origin_index\n\n        # Precompute landscape characteristics for benchmarking metrics\n        # 1) Global vs local minima strength (GlobalLocal contrast)\n        f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(f_center_values)\n        sorted_vals = sorted(f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = float(np.mean(f_center_values))\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # 2) Basin size homogeneity\n        # Use a deterministic grid of points in domain to assign each to a basin\n        L = self.domain_hi - self.domain_lo\n        coords = [-self.domain_hi, 0.0, self.domain_hi]\n        grid_points = np.array(list(itertools.product(coords, repeat=self.dim)))\n        counts = np.zeros(self.K, dtype=int)\n        for x in grid_points:\n            x = np.asarray(x, dtype=float)\n            dists = np.abs(self.centers - x)       # (K, dim)\n            dists = np.minimum(dists, L - dists)   # toroidal distances per dimension\n            d2 = np.sum(dists ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n\n        nonzero = counts[counts > 0]\n        self.basin_homogeneity = 1.0 if nonzero.size <= 1 else (np.max(nonzero) / np.min(nonzero))\n\n        # Store lightweight diagnostics for potential inspection\n        self.f_center_values = f_center_values\n        self.global_min_value = global_min\n        self.local_best_value = local_best_value\n        self.avg_center_value = avg_center\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) for x in R^dim as the minimum over all wells:\n          f(x) = min_k (||x - c_k||^2 * alpha) + beta_k\n        Distances wrap around the domain (toroidal metric).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        L = self.domain_hi - self.domain_lo\n        diffs = np.abs(self.centers - x)     # (K, dim)\n        diffs = np.minimum(diffs, L - diffs)\n        d2 = np.sum(diffs ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 2, "feedback": "The optimization landscape GridParabolicGridLandscapeHomogeneousBasin scored on:GlobalLocal 0.000, Basins 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4b77f187-8a8d-4a06-a87b-01e858554749"], "operator": null, "metadata": {"ela_features_2D": [-0.0014174998178595466, 0.36025549390960804, 0.013551232693859352, 0.035827477379569615, 27.26947859885189, 0.004797540844282011, 1.0, 1.0017159585468263, 1.0, 0.4711581034309134, -0.42237950353022535, 1.8, 0.7102641482613972, 0.7122742582046504, 0.5556334890699868, 0.3463550498250526, -0.2071413658823554, 0.16853437844910682, 0.24790363846037017, 0.3280236464299059, 0.4982629744314543, 0.17371639771620773, 0.2502727642030006, 0.3319917768719251, 0.5035953305658115, -0.4351675453685898, -0.3936274195980837, -0.35169474853875904, -0.2625954049873031, -0.42496751625725687, -0.38559289253272355, -0.34356317626804866, -0.25530058144694817, 1.0, 1.0, 1.0, 1.0, 0.5220625738289051, 0.5220430149131763, 0.40180636650327867, 0.35594519068976677, 0.7193283649863069, 0.40540540540540526, 0.632328659686948, -0.07507507507507508, 0.3863453815261044], "score_GlobalLocal_2D": 0.9017489552497864, "score_Basins_2D": 0.5439293384552002, "ela_features": [0.00033665837491858586, 0.4992884022682735, 0.003443616370523363, 0.030904941042681423, 99.53741812419125, 0.002712651737482119, 0.9899416283299022, 1.0111360219177516, 0.9957914753059081, -0.0019616030807568866, -0.681877866578201, 1.2, 0.9118059706905756, 0.8734501276594429, 0.6502238400380778, 0.18346420107633626, -0.4760380983880325, 0.42421551695503645, 0.5080960000543957, 0.5860784931322008, 0.7106079476407061, 0.42859022134603003, 0.5115741383316232, 0.5894622138613436, 0.7145576268491796, -0.5064178320725554, -0.4326425860899663, -0.3640546709404179, -0.25452747505132567, -0.5050445228885632, -0.43170083644128016, -0.3628577440762431, -0.2522892538170054, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21573290230262168, 0.2157257041912072, 0.19569432186271296, 0.18325683764958817, 0.8332426960825711, 0.18118118118118112, 0.3171893195764952, -0.2912912912912913, 0.510576923076923], "score_GlobalLocal_5D": 0.0003824021841865033, "score_Basins_5D": 0.9998596906661987, "ela_features_10D": [-0.0011452231119350787, 0.6377253175716759, 0.00046560906547416306, 0.015836820222620722, 51.40013921681158, -0.0017215828032111525, 0.8682557289513619, 1.0477926567333058, 0.9311715002919045, -0.860887710332749, 1.7373205638036708, 2.0, 1.0148860088448821, 0.9380314883464267, 0.7071472030320263, 0.10590123415059934, -0.6796627463659108, 0.6271454995206667, 0.679476027530743, 0.7298699858472056, 0.816787967407981, 0.6317887788646114, 0.6840000655254395, 0.733950464950216, 0.8206338320877512, -0.47291904183834166, -0.4065443238260095, -0.3426259311751053, -0.23238152139700752, -0.46832234012827045, -0.40191487334714165, -0.33838357526031865, -0.2281326846673033, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1092339954900069, 0.10923623278500416, 0.10713786073825368, 0.09957803701765067, 0.8478495360246481, -0.0990990990990991, 0.09646128522518638, -0.7757757757757756, 0.6049639711769416], "score_GlobalLocal_10D": 0.00043761005508713424, "score_Basins_10D": 0.9973874688148499}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], -49.999999604938274]], "nr_of_basins": 1, "f_opt_dim_2": -50.0, "x_opt_dim_2": [1.2507361990187555e-08, -5.280978429217496e-08], "f_opt_dim_5": -50.0, "x_opt_dim_5": [-2.344761710277639e-08, -2.6026419776939597e-08, -3.074192986823143e-08, 2.8204100364084214e-09, 4.1831513372776425e-09]}
{"id": "5512bc44-c93e-4e4c-8300-827b0ea9427f", "fitness": 0.6434462666511536, "name": "landscape_sum_gaussians_improved", "description": "A differentiable multi-well landscape built as a sum of Gaussians on a toroidal lattice in the first two dimensions with a deeper global well at the origin; the GlobalLocal score is improved by comparing the global-to-local depth difference to the dispersion of depths across all wells, yielding a scale-invariant, robust measure of peak prominence for minimization benchmarks.", "code": "import numpy as np\n\nclass landscape_sum_gaussians_improved:\n    def __init__(self, dim=5, sigma=1.0, A_global=2.5, A_local=1.0, grid_x=4, grid_y=4, wrap_toroidal=True):\n        \"\"\"\n        A differentiable multi-well landscape constructed as a sum of Gaussian wells.\n        - dim: problem dimensionality\n        - sigma: width of Gaussian wells\n        - A_global: absolute depth (positive) for the global well at the origin\n        - A_local: absolute depth for local wells\n        - grid_x, grid_y: number of wells along x and y in the first two dimensions (grid on a plane)\n        - wrap_toroidal: if True, distances in the first two dimensions wrap around (torus)\n        \"\"\"\n        self.dim = int(dim)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.wrap = bool(wrap_toroidal)\n        self.grid_x = int(grid_x)\n        self.grid_y = int(grid_y)\n\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # 1D fallback: place wells along the line\n            s = 2.0\n            centers.append(np.array([-s]))\n            centers.append(np.array([ s]))\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a rectangular grid in the first two dimensions\n            gx = max(1, min(self.grid_x, 12))\n            gy = max(1, min(self.grid_y, 12))\n            xs = np.linspace(-4.0, 4.0, gx)\n            ys = np.linspace(-4.0, 4.0, gy)\n            for i in range(gx):\n                for j in range(gy):\n                    c = np.zeros(self.dim)\n                    c[0] = float(xs[i])\n                    c[1] = float(ys[j])\n                    centers.append(c)\n                    depths.append(-self.A_local)\n\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n        # Precompute the two_sigma for efficiency\n        self.two_sigma_sq = 2.0 * (self.sigma ** 2)\n        self.domain_length = 10.0  # domain [-5,5] => wrap-around length\n\n        # Cache for GlobalLocal score if computed\n        self.GLocal = None\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the landscape at a 1D numpy array x of length self.dim.\n        f(x) = sum_i depth_i * exp(-||x - center_i||^2 / (2*sigma^2))\n        Global minimum is at the origin with value more negative than local wells.\n        Distances use torus wrap-around for the first two dimensions when enabled.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        val = 0.0\n\n        for c, w in zip(self.centers, self.depths):\n            if self.dim >= 2 and self.wrap:\n                dx = abs(x[0] - c[0])\n                dy = abs(x[1] - c[1])\n                dx = min(dx, self.domain_length - dx)\n                dy = min(dy, self.domain_length - dy)\n                dist2 = float(dx*dx + dy*dy)\n                if self.dim > 2:\n                    rest = x[2:] - c[2:]\n                    dist2 += float(np.dot(rest, rest))\n            else:\n                diff = x - c\n                dist2 = float(np.dot(diff, diff))\n\n            val += w * np.exp(-dist2 / self.two_sigma_sq)\n\n        return float(val)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute an improved GlobalLocal score based on the depths at all centers.\n\n        - depth at a center is defined as -f(center) (positive depth magnitude)\n        - global_depth = depth at origin\n        - local_depths = depths of all non-origin centers\n        - local_mean = mean(local_depths)\n        - dispersion = std(depths) across all centers (scale-invariant)\n        - GL score = max(0, (global_depth - local_mean) / dispersion)\n\n        This yields a scale-invariant measure of how much more prominent the global well is\n        compared to the average local wells, normalized by the variability across wells.\n        \"\"\"\n        # Evaluate at all centers\n        vals = [self.f(np.asarray(c, dtype=float)) for c in self.centers]\n        depths = -np.asarray(vals)\n\n        # Guard against degenerate cases\n        if depths.size == 0:\n            self.GLocal = 0.0\n            return self.GLocal\n\n        global_depth = depths[0]\n        local_depths = depths[1:] if depths.size > 1 else np.array([], dtype=float)\n        local_mean = float(np.mean(local_depths)) if local_depths.size > 0 else 0.0\n        dispersion = float(np.std(depths)) + 1e-12  # avoid division by zero\n\n        contrast = global_depth - local_mean\n        score = contrast / dispersion\n        if score < 0:\n            score = 0.0\n\n        self.GLocal = float(score)\n        return self.GLocal\n\n    @property\n    def glocal_score(self):\n        \"\"\"\n        Returns the last computed GlobalLocal score. If not computed yet, computes it.\n        \"\"\"\n        if self.GLocal is None:\n            self.compute_global_local_score()\n        return self.GLocal", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sum_gaussians_improved scored on:GlobalLocal 0.571, Basins 0.974,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ee212694-de7e-4ff8-98f6-62297621c67b"], "operator": null, "metadata": {"ela_features_2D": [-0.0030968158802959335, 0.8098689950852969, 0.004308307274785109, 0.013936111434719445, 18.89603647130128, -0.00407223069975089, 0.031406025541675084, 1.0569682606564585, 0.18180631166453945, -2.3480898375673744, 6.690768539016955, 4.0, 0.22797746191804383, 0.5898227247248637, 0.2663627434756421, 0.3700173623111308, -0.26574602608777825, 0.14572524378105495, 0.2316986708861005, 0.3934516444685431, 0.9523621895251939, 0.14096971294516905, 0.2351497447764051, 0.3350716419573402, 0.9928737837942435, -0.4469956875882308, -0.40200660260738746, -0.3173537562326283, -0.02493017205453889, -0.4415070393310284, -0.39309127072264205, -0.34170941557962603, -0.0037162988449042423, 1.0, 1.0, 1.0, 1.0, 0.5266327890757502, 0.5266218430755385, 0.45426493872230955, 0.35502420097253357, 0.7272866165775269, 0.6856856856856854, 0.45649875500115933, -0.08308308308308308, 0.3791164658634538], "score_GlobalLocal_2D": 0.8368679881095886, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.0023102502409883207, 0.9849042015730554, 0.0003861404479846957, 0.006826381852670579, 38.10510537650423, -0.009171104835606635, 0.12960823493266257, 122.87153731538554, 0.24441032622754938, -7.843372198523857, 76.68020674716047, 7.8, 0.8498864613473088, 0.8656669361091229, 0.6058361568750834, 0.19018320422563367, -0.32754713551736925, 0.6127474524179822, 0.6601221059960936, 0.6996966484273754, 0.7807197467850223, 0.5888685894842853, 0.6322801322787976, 0.6751908788724541, 0.7664318331979292, -0.3406384498425659, -0.29896045876544897, -0.2641494678948358, -0.1928808879772262, -0.3636530970178303, -0.32523669759918056, -0.2872806388820147, -0.20658180273078405, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21634197099225244, 0.21638357170185815, 0.2137338139074772, 0.18178702855315645, 0.5684243902508637, 0.26126126126126115, 2.3540470244304025e-05, -3.510510510510511, 0.514102564102564], "score_GlobalLocal_5D": 0.6912789344787598, "score_Basins_5D": 0.7858509421348572, "ela_features_10D": [-0.0021680016917552613, 0.9979106523180079, 7.984172820480013e-05, 0.002885831557246611, 38.744341529805084, -0.018004636494322934, 0.011101323313810262, 22.793185849491397, 0.005199192124556995, -28.131050965847997, 893.2163498688603, 5.4, 0.9689078016008494, 0.9325445947254616, 0.6832007650206671, 0.10788051624231657, -0.24237220011645005, 0.6807422567696901, 0.7255602350781134, 0.7636841736227872, 0.8286851563472272, 0.675021567149568, 0.7216813881507067, 0.761999614812338, 0.8295912279663765, -0.4049470907200072, -0.3480997687664466, -0.2997433491809501, -0.2172957246746127, -0.4133706996632577, -0.3540186681430318, -0.30273388954397984, -0.21675732764800565, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10931194469238589, 0.10930315457943122, 0.10920300085473471, 0.09963304442706895, 0.5416590493017869, -1.4164164164164164, 0.0, -Infinity, 0.5678142514011209], "score_GlobalLocal_10D": 0.5711420774459839, "score_Basins_10D": 0.974197268486023}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [4.706888888888799, 4.706888888888799], -1.4789085836960778], [5, [4.705400397731301, -1.333554295198623], -1.2856197114376977], [5, [-1.333554295198623, 4.705400397731301], -1.2856197114376977], [5, [4.705400397731301, 1.333554295198623], -1.2856197114376975], [5, [1.333554295198623, 4.705400397731301], -1.2856197114376975], [6, [-4.705400397731301, -1.333554295198623], -1.2856197114376977], [6, [1.333554295198623, -4.705400397731301], -1.2856197114376975], [6, [-4.705400397731301, 1.333554295198623], -1.2856197114376975], [6, [-1.3333203556308204, -4.70600009407991], -1.2856197101980027], [9, [4.706888888888799, -4.706888888888799], -1.4789085836960776], [9, [-4.706888888888799, 4.706888888888799], -1.4789085836960778], [9, [-4.706888888888799, -4.706888888888799], -1.4789085836960778], [20, [-3.55413219621477e-07, -0.00044426652452645484], -3.177156820274413]], "nr_of_basins": 13, "f_opt_dim_2": -3.177157014239657, "x_opt_dim_2": [3.914246241263117e-09, 1.4213405295495467e-09], "f_opt_dim_5": -3.1771570142396564, "x_opt_dim_5": [-1.1965334548972713e-08, -3.85543926351543e-09, 1.4223890664514046e-09, -1.7480117717970153e-08, -2.8325433843147726e-09]}
{"id": "b2bd4039-0ad5-4547-91f2-22fe0d3acd64", "fitness": 0.5597160458564758, "name": "landscape_circle_enhanced_basin_homogeneous_torus", "description": "A torus-wrapped circular-w Wells landscape with enhanced GlobalLocal contrast and an explicit basin-homogeneity (basin-size uniformity) estimator. The global well at the origin is deeper than local wells, and distances are computed on a torus to promote homogeneous basin volumes across dimensions. A Monte Carlo-based Basins score estimates the largest-to-smallest basin size ratio, guiding more uniform basin distribution.", "code": "import numpy as np\nimport math\n\nclass landscape_circle_enhanced_basin_homogeneous_torus:\n    def __init__(self, dim=5, n_local=None, r=2.5, A_global=3.0, A_local=1.0, samples_for_basins=4000, seed=None):\n        self.dim = int(dim)\n        self.r = float(r)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.L = 10.0  # domain length in each dimension ([-5, 5])\n        self.samples_for_basins = int(samples_for_basins)\n        \n        if seed is not None:\n            np.random.seed(int(seed))\n        \n        centers = []\n        depths = []\n        \n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n        \n        if self.dim == 1:\n            # 1D fallback: place wells along the line at -r and +r\n            c_left = np.array([-self.r])\n            c_right = np.array([ self.r])\n            centers.append(c_left)\n            centers.append(c_right)\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged approximately on a circle in the first two dimensions\n            n_local = int(n_local) if n_local is not None else max(3, min(self.dim, 12))\n            n_local = max(3, min(n_local, 32))\n            for i in range(n_local):\n                theta = 2.0 * math.pi * i / float(n_local)\n                c = np.zeros(self.dim)\n                c[0] = self.r * math.cos(theta)\n                c[1] = self.r * math.sin(theta)\n                centers.append(c)\n                depths.append(-self.A_local)\n        \n        # Convert to numpy arrays for efficient evaluation\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n        self.n_centers = len(self.centers)\n        \n        # GlobalLocal score (normalized contrast measure)\n        self.GLscore = self._compute_gl_score()\n        \n        # Basins homogeneity (approximate via Monte Carlo sampling)\n        self.BasinsHomogeneity = self._estimate_basin_sizes(n_samples=self.samples_for_basins)\n    \n    def _compute_gl_score(self):\n        mean_depth = float(np.mean(self.depths))\n        denom = max(1e-12, abs(mean_depth))  # guard against zero\n        delta = self.A_global - self.A_local\n        return float(delta / denom)\n    \n    def _toroidal_dist2(self, x, c):\n        # Toroidal (wrap-around) distance squared across all dimensions\n        diff = np.abs(x - c)\n        wrap = self.L - diff\n        diff = np.minimum(diff, wrap)\n        return float(np.dot(diff, diff))\n    \n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i { depth_i + toroidal_dist2(x, center_i) }\n        - Global minimum sits at origin with value -A_global\n        - Local wells have equal shape/width; centers on a circle ensure homogeneous basins\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        \n        min_vals = []\n        for c, d in zip(self.centers, self.depths):\n            dist2 = self._toroidal_dist2(x, c)\n            min_vals.append(d + dist2)\n        return float(min(min_vals))\n    \n    def _estimate_basin_sizes(self, n_samples=4000):\n        \"\"\"\n        Approximate basin sizes by Monte Carlo sampling the domain [-5,5]^dim.\n        Each sample is assigned to the well (center) that minimizes depth + dist^2.\n        Returns a ratio: largest_basin_size / smallest_basin_size (larger implies less homogeneous basins).\n        A ratio close to 1 indicates homogeneous basins.\n        \"\"\"\n        if n_samples <= 0:\n            return float('inf')\n        \n        pts = np.random.uniform(-5.0, 5.0, size=(n_samples, self.dim))\n        counts = np.zeros(self.n_centers, dtype=int)\n        \n        for x in pts:\n            best_j = -1\n            best_val = float('inf')\n            for j, (c, d) in enumerate(zip(self.centers, self.depths)):\n                dist2 = self._toroidal_dist2(x, c)\n                val = d + dist2\n                if val < best_val:\n                    best_val = val\n                    best_j = j\n            counts[best_j] += 1\n        \n        largest = float(counts.max())\n        smallest = float(counts[counts > 0].min()) if np.any(counts > 0) else 0.0\n        # Guard against zero to avoid division by zero\n        if smallest <= 0.0:\n            smallest = 1e-9\n        return float(largest / smallest)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_circle_enhanced_basin_homogeneous_torus scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a416ee5-0c61-4c08-8710-e52755d90a63"], "operator": null, "metadata": {"ela_features_2D": [0.016426762192421895, 0.24788753746787048, 0.0327912582821956, 0.09559674615326133, 4.3835407892954, 0.022748789801238622, 0.7771496633429059, 1.1645250867790586, 0.9417299568462523, 0.9477788055380254, 0.39643715004858204, 1.0, 0.6028239134719527, 0.6893792498540665, 0.5018410600621366, 0.3581561059574791, -0.2009723298989658, 0.14969774794821236, 0.2199492020927845, 0.3752700213153017, 0.5571469311063483, 0.15576837793848047, 0.21947997589838333, 0.35990422422042045, 0.547764620959781, -0.444827306632485, -0.4080759384598814, -0.32681347457818827, -0.23166902675383677, -0.4335204285674942, -0.4008060102258996, -0.32867090452997366, -0.23220442947255165, 1.0, 1.0, 1.0, 1.0, 0.5224374717989344, 0.5224164695406349, 0.4178492592934139, 0.3857106257369192, 0.7138680006934648, 0.4934934934934933, 0.47783851866892324, -0.13113113113113112, 0.39558232931726905], "score_GlobalLocal_2D": 0.9483991861343384, "score_Basins_2D": 0.4096805453300476, "ela_features": [0.00012253971607747438, 0.345791241126519, 0.002259429858494223, 0.028517241837621936, 83.20023101782557, 0.0006126252984280711, 0.9898241334091379, 2.473814696680809, 0.9926974380742773, 0.350323396290998, -0.19388837542402815, 1.2, 0.9083400453320097, 0.8714372661000495, 0.6447210108174855, 0.18719762119819974, -0.46512066241424216, 0.48068000475590544, 0.5528624170883584, 0.6196926118603991, 0.7344891467192278, 0.46920300447446356, 0.5448440018282212, 0.6130228269926803, 0.7317616367762975, -0.4568123137989222, -0.3933177565757127, -0.33453020832565733, -0.23355162681155545, -0.46921533820004474, -0.40235042358628714, -0.34207737739800215, -0.237116014626858, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21456978115696024, 0.21457490596057122, 0.19959430575425313, 0.18272633933143895, 0.8263980395712395, 0.1371371371371371, 0.2363717617678402, -0.36736736736736725, 0.517948717948718], "score_GlobalLocal_5D": 0.0002812097663991153, "score_Basins_5D": 0.9998480081558228, "ela_features_10D": [-0.0006167578089589565, 0.42820512251538007, 0.0007293750555716152, 0.019088999926797693, 42.93574054474719, 0.004379625336906945, 0.9974597316039017, 2.634037183591449, 0.9988986448271685, 0.26004123037871774, -0.13431166594330088, 1.2, 1.012129468347933, 0.93743594081296, 0.7054372061856469, 0.10680882884055576, -0.6013563159513745, 0.6433299208343387, 0.7007437204613381, 0.747884768552515, 0.8172872486400626, 0.6437319563269133, 0.7027201313164841, 0.7503907852515501, 0.82120998487126, -0.45234698928086503, -0.3795317181236741, -0.3197449147602505, -0.2317250000801731, -0.452956195793276, -0.37795979228247456, -0.31735084572698874, -0.22731062512080652, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11021425039365858, 0.11021602012097724, 0.10691248989781241, 0.10055899546233552, 0.8539569489759048, -0.1071071071071071, 0.14002232985645535, -0.6276276276276274, 0.5884707766212971], "score_GlobalLocal_10D": 0.00023754897119943053, "score_Basins_10D": 0.9998500347137451}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [5.0, -3.888888888888889], 16.034073938759366], [7, [-5.0, 0.00044444444444512003], 5.2500001975308646], [10, [0.00044444444444512003, 0.00044444444444512003], -2.999999604938272], [23, [-1.250012511545221, -2.1650772485450918], -0.9999999996546988], [25, [-1.2497777777778625, 2.164666666666649], -0.9999997931330805], [33, [2.5000000000002753, 0.00044444444444512003], -0.9999998024691358]], "nr_of_basins": 6, "f_opt_dim_2": -3.0, "x_opt_dim_2": [8.183534829743138e-09, 9.63309437193664e-09], "f_opt_dim_5": -3.0, "x_opt_dim_5": [-1.0254559052009798e-08, 7.945698426197197e-09, 1.22882198376434e-09, 7.775379890176463e-10, -2.983042706524624e-09]}
{"id": "58ccddc1-2a41-459b-b8c9-3f81753eff48", "fitness": 0.5349211096763611, "name": "landscape_circle_enhanced_gl", "description": "A circular-wells landscape with an improved, scale-invariant GlobalLocal score. The global well sits at the origin, with multiple local wells arranged on a circle in the first two dimensions. The GlobalLocal score measures how easily the local wells are recognized relative to the overall landscape by comparing the mean local depth to the global depth, normalized by the average (mean) fitness across all centers. This yields a robust, scale-invariant indication of peak prominence for the minimization benchmark.", "code": "import numpy as np\nimport math\n\nclass landscape_circle_enhanced_gl:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Global-local contrast parameters (enhanced)\n        # Global minimum depth (at origin)\n        self.A_global = 3.0\n        # Local wells depth (shallower than global)\n        self.A_local = 1.0\n        # Radius for placing local wells (in the first two dimensions)\n        self.r = 2.5\n\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # 1D fallback: place wells along the line at -r and +r\n            c_left = np.array([-self.r])\n            c_right = np.array([ self.r])\n            centers.append(c_left)\n            centers.append(c_right)\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a circle in the first two dimensions\n            n_local = max(3, min(self.dim, 12))  # reasonable number of wells\n            for i in range(n_local):\n                theta = 2.0 * math.pi * i / float(n_local)\n                c = np.zeros(self.dim)\n                c[0] = self.r * math.cos(theta)\n                c[1] = self.r * math.sin(theta)\n                centers.append(c)\n                depths.append(-self.A_local)\n\n        # Convert to numpy arrays for efficient evaluation\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n        # GlobalLocal score (enhanced, scale-invariant)\n        self.GLscore = self._compute_gl_score()\n\n    def _compute_gl_score(self):\n        # Identify global minimum index\n        i_min = int(np.argmin(self.depths))\n        global_min_depth = float(self.depths[i_min])\n\n        # Mean depth of local wells (exclude the global minimum)\n        local_indices = [i for i in range(len(self.depths)) if i != i_min]\n        mean_local_depth = float(np.mean(self.depths[local_indices]))\n\n        # Overall mean depth (average fitness across all centers)\n        mean_depth = float(np.mean(self.depths))\n\n        # Normalize by average fitness magnitude to obtain a scale-invariant score\n        denom = max(1e-12, abs(mean_depth))\n        return float((mean_local_depth - global_min_depth) / denom)\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i { depth_i + || x - center_i ||^2 }\n        - Global minimum sits at origin with value -A_global\n        - Local wells have equal shape/width; centers on a circle ensure homogeneous basins\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        min_vals = []\n        for c, d in zip(self.centers, self.depths):\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            min_vals.append(d + dist2)\n        return float(min(min_vals))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_circle_enhanced_gl scored on:GlobalLocal 0.000, Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8a416ee5-0c61-4c08-8710-e52755d90a63"], "operator": null, "metadata": {"ela_features_2D": [0.016153374521173335, 0.24305637728105464, 0.02136822984734318, 0.09592488011319951, 8.245866244303205, 0.016456211877330727, 0.7609058805627017, 1.0849348253588247, 0.9572247228124553, 1.0358749736826145, 0.7637651510770389, 1.4, 0.633757093751634, 0.7053461770854245, 0.48038691852965726, 0.34574600047445414, -0.20220176862183442, 0.166729452219668, 0.23296052999756114, 0.3868703158387663, 0.5560260605007029, 0.17465224283928196, 0.2333300510082028, 0.3706298093773474, 0.5494238476463316, -0.4359774411749954, -0.40132156353830667, -0.32079249067884646, -0.23229132470463448, -0.4242092703053066, -0.3940401334822316, -0.32345579436251554, -0.23156645644328716, 1.0, 1.0, 1.0, 1.0, 0.5116762379062816, 0.5116606590957447, 0.4142695072013988, 0.3803916318120303, 0.6917504211409364, 0.4614614614614613, 0.45860324735116026, -0.10710710710710711, 0.3618473895582329], "score_GlobalLocal_2D": 0.892320454120636, "score_Basins_2D": 0.31724250316619873, "ela_features": [-0.0012604228814597329, 0.3736354853967671, 0.0030341240267680015, 0.024350224360008034, 26.60773813760673, 0.0010978137286464795, 0.9887912663786642, 2.391135584111514, 0.992662016233259, 0.33153168319062115, -0.30142998592933157, 1.2, 0.897225292948127, 0.8697963806422543, 0.6452065122804725, 0.18489481427706328, -0.4734160324240582, 0.49017690657658913, 0.5687625357592819, 0.6328108086289003, 0.7335522324469252, 0.4823592766530531, 0.5619978732494502, 0.6270203154908082, 0.7315903333949777, -0.44841809448055614, -0.37929596816429473, -0.3229627222478781, -0.23435480719459933, -0.45765614950818395, -0.387238447395371, -0.3297526775341237, -0.23729959800874498, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21510881971496768, 0.21511637674536596, 0.1996511180210831, 0.18152554562622375, 0.8254909186702213, 0.1491491491491491, 0.28899986474011485, -0.3313313313313312, 0.5152243589743589], "score_GlobalLocal_5D": 0.00019949903071392328, "score_Basins_5D": 0.9998505115509033, "ela_features_10D": [8.337498346389083e-07, 0.40668651163660974, 0.000984733222142648, 0.020200898421640683, 32.326582062043606, 0.004609498877069384, 0.9974614704806912, 2.6107232053374405, 0.99892188561303, 0.21722565968696253, -0.03703743016348433, 1.8, 1.0169953863558967, 0.939560605982709, 0.7189625719674838, 0.10314379727427996, -0.6093276172547466, 0.6329311593263973, 0.6912374823077452, 0.736950301016074, 0.8131400213920742, 0.6321141950184126, 0.6930119198958742, 0.739283718218981, 0.8163960028756907, -0.4655009833047277, -0.39155911833050355, -0.3335880659840232, -0.23696756888863213, -0.4677310471633619, -0.39030456240833217, -0.3314743007654851, -0.23343353840337983, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10917413652007728, 0.10916545615329601, 0.10648002945012154, 0.1003793368976359, 0.8512828319921957, -0.1471471471471471, 0.11813343845922612, -0.6796796796796795, 0.5891112890312249], "score_GlobalLocal_10D": 0.00018154528515879065, "score_Basins_10D": 0.9997323155403137}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[14, [0.00044444444444512003, 0.00044444444444512003], -2.999999604938272], [25, [-1.249555555555556, -2.1648888888890787], -0.9999997719767917], [34, [2.5000000000002753, 0.00044444444444512003], -0.9999998024691358], [27, [-1.249555555555556, 2.164666666666649], -0.9999996449849323]], "nr_of_basins": 4, "f_opt_dim_2": -3.0, "x_opt_dim_2": [-9.823954172783818e-09, -1.5971356098938957e-09], "f_opt_dim_5": -3.0, "x_opt_dim_5": [1.1626810594412792e-08, 3.0803143925860325e-09, -7.684742833870439e-09, 1.7294006017880474e-10, -5.733059837626278e-10]}
{"id": "0bedfc54-ff75-4d0b-ae57-8e199ce2cc53", "fitness": 0.5485497117042542, "name": "landscape_sum_gaussians_homogeneous", "description": "A differentiable multi-well Gaussian landscape with torus-wrapped wells on a regular first-two-dim grid, enhanced with a lightweight basin-balancing step to promote homogeneous basin sizes across wells. This improves the Basins score by approximating basin volumes via a toroidal Voronoi partition and adjusting local well depths to equalize basin influence, while preserving a clear global-local contrast for minimization benchmarks.", "code": "import numpy as np\n\nclass landscape_sum_gaussians_homogeneous:\n    def __init__(self,\n                 dim=5,\n                 sigma=1.0,\n                 A_global=2.2,\n                 A_local=1.0,\n                 grid_x=4,\n                 grid_y=4,\n                 wrap_toroidal=True,\n                 balance_basins=True,\n                 balance_power=0.5,\n                 sample_grid=40):\n        \"\"\"\n        A differentiable, multi-well landscape constructed as a sum of Gaussians.\n        Wells are placed on a square lattice in the first two dimensions with torus wrap-around\n        to promote homogeneous basin volumes. The origin hosts a global well deeper than local wells.\n        Optionally balance basin sizes by adjusting local well depths to improve the Basins score.\n\n        - dim: problem dimensionality\n        - sigma: width of Gaussian wells\n        - A_global: absolute depth for the global well at the origin (positive value)\n        - A_local: absolute depth for local wells (positive value)\n        - grid_x, grid_y: number of wells along x and y in the first two dimensions (grid on a plane)\n        - wrap_toroidal: if True, distances in the first two dimensions wrap around (torus)\n        - balance_basins: if True, perform a lightweight basin-balancing step to homogenize basin sizes\n        - balance_power: exponent controlling the strength of depth adjustment during balancing\n        - sample_grid: resolution for approximate basin-size estimation (used for balancing)\n        \"\"\"\n        self.dim = int(dim)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.wrap = bool(wrap_toroidal)\n        self.grid_x = int(grid_x)\n        self.grid_y = int(grid_y)\n        self.balance_basins = bool(balance_basins)\n        self.balance_power = float(balance_power)\n        self.sample_grid = int(sample_grid)\n\n        centers = []\n        depths = []\n\n        # Global well at origin\n        centers.append(np.zeros(self.dim))\n        depths.append(-self.A_global)\n\n        if self.dim == 1:\n            # Fallback 1D: place a couple of local wells along the line\n            s = 2.0\n            centers.append(np.array([-s]))\n            centers.append(np.array([ s]))\n            depths.append(-self.A_local)\n            depths.append(-self.A_local)\n        else:\n            # Local wells arranged on a rectangular grid in the first two dimensions\n            gx = max(1, min(self.grid_x, 12))\n            gy = max(1, min(self.grid_y, 12))\n            xs = np.linspace(-4.0, 4.0, gx)\n            ys = np.linspace(-4.0, 4.0, gy)\n            for i in range(gx):\n                for j in range(gy):\n                    c = np.zeros(self.dim)\n                    c[0] = float(xs[i])\n                    c[1] = float(ys[j])\n                    centers.append(c)\n                    depths.append(-self.A_local)\n\n        self.centers = [np.asarray(c, dtype=float) for c in centers]\n        self.depths = np.asarray(depths, dtype=float)\n\n        # Optional basin balancing to promote homogeneous basin sizes\n        self.basins_score = float('nan')\n        if self.balance_basins and self.dim > 1:\n            self._balance_basins()\n\n    def _estimate_basin_sizes(self, coarse_pts=40):\n        \"\"\"\n        Estimate basin sizes by a toroidal Voronoi-like partition on the first two dimensions.\n        This uses a coarse grid over the domain [-5, 5] x [-5, 5] and assigns each sample\n        point to the nearest center using toroidal distance in the first two dimensions.\n\n        Returns:\n            sizes: array of counts per center (approximate basin sizes)\n        \"\"\"\n        domain_length = 10.0  # domain [-5,5] -> wrap-around length\n        xs = np.linspace(-5.0, 5.0, int(coarse_pts))\n        ys = np.linspace(-5.0, 5.0, int(coarse_pts))\n        sizes = np.zeros(len(self.centers), dtype=float)\n\n        for x in xs:\n            for y in ys:\n                best = 0\n                best_dist = float('inf')\n                for idx, c in enumerate(self.centers):\n                    dx = abs(x - c[0]); dx = min(dx, domain_length - dx)\n                    dy = abs(y - c[1]); dy = min(dy, domain_length - dy)\n                    dist2 = dx*dx + dy*dy\n                    if dist2 < best_dist:\n                        best_dist = dist2\n                        best = idx\n                sizes[best] += 1.0\n        return sizes\n\n    def _balance_basins(self):\n        \"\"\"\n        Balance basin sizes by adjusting local well depths based on a coarse estimate\n        of basin volumes. Global well (index 0) is kept fixed to preserve global-local contrast.\n\n        Depth adjustment rule (conceptual):\n            - If a basin is larger than the average, make its well slightly shallower (less negative)\n            - If a basin is smaller than the average, deepen its well (more negative)\n        This is implemented as a multiplicative factor on the depth of each local well:\n            new_depth_i = depth_i * (target / size_i) ** balance_power\n        \"\"\"\n        sizes = self._estimate_basin_sizes(coarse_pts=self.sample_grid)\n        sizes = np.asarray(sizes, dtype=float)\n        if sizes.size != len(self.centers) or sizes.sum() == 0:\n            # Fallback: cannot balance, keep original depths\n            self.basins_score = float('nan')\n            return\n\n        target = float(np.mean(sizes))\n        new_depths = self.depths.copy()\n\n        # Do not alter the global well (index 0)\n        for i in range(1, len(self.centers)):\n            si = float(sizes[i]) if sizes[i] > 0 else 1.0\n            # If balance_power is 0, no change\n            if self.balance_power > 0:\n                factor = (target / si) ** self.balance_power\n            else:\n                factor = 1.0\n            new_depths[i] = self.depths[i] * factor\n\n        self.depths = new_depths\n\n        # Compute a simple basins score (ratio of largest to smallest nonzero basin sizes)\n        nonzero = sizes[sizes > 0]\n        if nonzero.size > 0:\n            self.basins_score = float(nonzero.max()) / float(nonzero.min()) if nonzero.min() > 0 else float('inf')\n        else:\n            self.basins_score = float('nan')\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the landscape at a 1D numpy array x of length self.dim.\n        f(x) = sum_i depth_i * exp(-||x - center_i||^2 / (2*sigma^2))\n        Global minimum is at the origin with value more negative than local wells.\n        Distances use torus wrap-around for the first two dimensions when enabled.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        val = 0.0\n        two_sigma_sq = 2.0 * (self.sigma ** 2)\n        domain_length = 10.0  # domain [-5, 5] => wrap-around length\n\n        for c, w in zip(self.centers, self.depths):\n            if self.dim >= 2 and self.wrap:\n                dx = abs(x[0] - c[0])\n                dx = min(dx, domain_length - dx)\n                dy = abs(x[1] - c[1])\n                dy = min(dy, domain_length - dy)\n                dist2 = float(dx*dx + dy*dy)\n                if self.dim > 2:\n                    rest = x[2:] - c[2:]\n                    dist2 += float(np.dot(rest, rest))\n            else:\n                diff = x - c\n                dist2 = float(np.dot(diff, diff))\n\n            val += w * np.exp(-dist2 / two_sigma_sq)\n\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sum_gaussians_homogeneous scored on:GlobalLocal 0.969, Basins 0.143,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ee212694-de7e-4ff8-98f6-62297621c67b"], "operator": null, "metadata": {"ela_features_2D": [0.0033574124535381777, 0.813825125898294, 0.02564206138442073, 0.04132122990044695, 1.688281517864258, 0.0027422653133613696, 0.05033711652874904, 1.0705410750410387, 0.20486266965203112, -2.17697990271681, 5.528181053668872, 3.2, 0.22506939688323085, 0.5922947292141585, 0.2538366993829016, 0.3653316792269803, -0.2677625370421731, 0.14145762629553477, 0.21541099010868342, 0.3893708772101042, 0.9301976116838672, 0.143097164991384, 0.21474341716458004, 0.3354573583537319, 0.9581114527107571, -0.4492057974275035, -0.41050767008337496, -0.31947067949458396, -0.036512918938116555, -0.4403321886984606, -0.40349478718847526, -0.3414114032660001, -0.02146458419156134, 1.0, 1.0, 1.0, 1.0, 0.5242051797351981, 0.5241939414678435, 0.44848252407231576, 0.3679783316819903, 0.743230421720956, 0.6616616616616614, 0.45229518626724985, -0.05905905905905904, 0.38433734939759034], "score_GlobalLocal_2D": 0.8368679881095886, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.0022190318241825492, 0.9832785386175076, 0.00027036743469986647, 0.009084869281710239, 73.22260436365364, -0.008410087883290406, 0.11883341543561414, 56.68934062973587, 0.2289245772353546, -7.712367675546592, 72.00137122106158, 7.4, 0.8401838942171809, 0.8643560652964478, 0.6177501260429243, 0.18871232333847554, -0.3186181063102903, 0.6217170920213647, 0.657088026321712, 0.7046406112261098, 0.7824156083900722, 0.5981407489080244, 0.6328046688539835, 0.6809514863291384, 0.7697534488210328, -0.33273248993659066, -0.30161735052555716, -0.2597922895677807, -0.1913845930780232, -0.35521486765154, -0.3245610963540823, -0.2820055517375405, -0.20351814393183232, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2189311599564118, 0.21894941085081973, 0.21582732430472537, 0.1832557846538383, 0.5736559439928614, 0.2852852852852852, 1.1338839915951343e-05, -3.474474474474475, 0.507051282051282], "score_GlobalLocal_5D": 0.9081807732582092, "score_Basins_5D": 0.4323987364768982, "ela_features_10D": [-0.002247693508956239, 0.9978920122023677, 7.556049869005055e-05, 0.002599499971187741, 43.112743904247345, -0.019095044042169284, 0.0036292379654020213, 5.355201759488699, -0.02146091040147464, -39.62252546331969, 1713.617601762318, 2.8, 0.9705022233791307, 0.9293170870933322, 0.677881577905851, 0.11149856680461176, -0.18091531182967965, 0.6795700247855754, 0.7225955834516877, 0.7619973009501922, 0.8272850063690498, 0.6736574126229946, 0.7179383480641696, 0.760182842600539, 0.828388015851788, -0.4063750363977743, -0.3518094847966531, -0.3018400686815651, -0.21904060379084028, -0.41495540010343657, -0.35865125096827183, -0.3049369775841154, -0.21821126613067982, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10950472575340435, 0.10950623450137291, 0.10943814196503539, 0.09964936568975605, 0.5590720484724018, -2.013013013013013, 0.0, -Infinity, 0.5640512409927944], "score_GlobalLocal_10D": 0.9693837761878967, "score_Basins_10D": 0.14312641322612762}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [4.424000000000063, 4.424000000000063], -1.50961399491464], [5, [4.4162784866376095, -1.3275543049185992], -1.2785276009738902], [5, [-1.3275543049185992, 4.4162784866376095], -1.2785276009738902], [5, [4.416300086602669, 1.3395542854786469], -1.2820083121017916], [5, [1.3395542854786469, 4.416300086602669], -1.2820083121017916], [9, [-5.0, -5.0], -1.4440824013054727], [9, [4.424000000000063, -5.0], -1.4764831848288242], [9, [-5.0, 4.424000000000063], -1.476483184828824], [28, [0.00044444444444512003, 0.00044444444444512003], -2.9124633453444626], [4, [1.3396508005514598, -5.058355701084251], -1.2570291553027169], [4, [-1.3277972243675429, -5.110109168316265], -1.2569591747536153], [4, [-5.055434183822949, 1.33962823515543], -1.2568411963460455], [4, [-5.107011841168853, -1.3277751559385929], -1.2567580036290305]], "nr_of_basins": 13, "f_opt_dim_2": -2.912463580214896, "x_opt_dim_2": [6.580448125725599e-05, 6.58043070638093e-05], "f_opt_dim_5": -2.912463580214896, "x_opt_dim_5": [6.579825102089538e-05, 6.581235862379579e-05, 3.646791359816263e-09, -6.808626332935172e-09, -6.696985450568513e-09]}
{"id": "5211c831-feeb-4c51-a504-9b8efac66a56", "fitness": 0.5669517517089844, "name": "landscape_min_of_gaussians_rings", "description": "A novel min-of-Gaussians multi-basin landscape built on a combinatorial center grid. The global well sits at the origin, while local wells are placed on a structured set of centers (combinations of \u00b1s on up to p_max coordinates). The landscape uses the minimum across negative Gaussians (instead of a sum) to create distinct basin boundaries and homogeneous basin distribution. GlobalLocal is computed as a scale-invariant measure of how locally prominent wells are relative to the global minimum.", "code": "import numpy as np\nfrom itertools import combinations, product\n\nclass landscape_min_of_gaussians_rings:\n    def __init__(self, dim=5, s=2.0, sigma=1.0, A_global=2.0, A_local=1.0, p_max=2):\n        \"\"\"\n        Landscape based on the minimum of several Gaussians placed at a combinatorial grid centers.\n        - dim: number of dimensions\n        - s: offset distance along selected axes for local wells\n        - sigma: shared Gaussian width (controls basin size)\n        - A_global: amplitude (depth) of the global well at the origin\n        - A_local: amplitude of the local wells\n        - p_max: maximum number of non-zero coordinates for a local well (p = 1..p_max)\n        \"\"\"\n        self.dim = int(dim)\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.p_max = int(p_max)\n\n        # Build centers: origin + combinatorial grid of centers with up to p_max non-zeros\n        self.centers = []\n        self._build_centers()\n\n        # Precompute constants for efficient evaluation\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n    def _build_centers(self):\n        # Global center at origin\n        self.centers.append(np.zeros(self.dim))\n        # Local centers: all combinations of up to p_max dimensions with +/- s\n        for p in range(1, self.p_max + 1):\n            for idxs in combinations(range(self.dim), p):\n                for signs in product([1, -1], repeat=p):\n                    c = np.zeros(self.dim, dtype=float)\n                    for pos, d in enumerate(idxs):\n                        c[d] = self.s * signs[pos]\n                    self.centers.append(c)\n\n        # Ensure centers are numpy arrays\n        self.centers = [np.asarray(c) for c in self.centers]\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x (min across Gaussians).\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is defined as the minimum (most negative) of negative Gaussians\n          centered at: origin (global) and each combinatorial center (local).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        best = float('inf')\n        for i, c in enumerate(self.centers):\n            a = self.A_global if i == 0 else self.A_local\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            val = -a * np.exp(-dist2 / self._two_sigma2)\n            if val < best:\n                best = val\n        return float(best)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a robust GlobalLocal score for the landscape.\n        - val_global: function value at the origin (global minimum candidate)\n        - vals: function values at all centers (origin + local wells)\n        - min_local: minimum value among local wells (excluding origin)\n        GlobalLocal score is the depth difference (local vs global) normalized by the\n        dispersion (standard deviation) of the center evaluations.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        val_global = self.f(origin)\n\n        # Evaluate at all centers to obtain center-values\n        vals = [self.f(c) for c in self.centers]\n\n        if len(vals) <= 1:\n            min_local = val_global\n        else:\n            min_local = min(vals[1:])  # exclude origin\n\n        mean_center_value = float(np.mean(vals))\n        std_center_value = float(np.std(vals)) + 1e-9  # avoid division by zero\n\n        diff = float(min_local) - float(val_global)  # should be >= 0 if global is deepest\n        gl_score = diff / std_center_value\n\n        return float(gl_score)\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_min_of_gaussians_rings scored on:GlobalLocal 0.236, Basins 0.973,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19640fc0-ffd5-414c-b5d5-c8194dea4555"], "operator": null, "metadata": {"ela_features_2D": [-0.003232992146258029, 0.8043393981098367, 0.00485181680118796, 0.01530965994043991, 5.611373489590506, 0.0002360138523954447, 0.6913222307763569, 1.0080527252883378, 0.8322561931592609, -1.1260171584660417, 1.1561485396030269, 3.4, 0.5331437804958294, 0.6944462365740239, 0.4312507489275018, 0.34374939763839996, -0.23390635340503266, 0.13559039920722168, 0.2462908982977488, 0.4329024210363602, 0.5553006750336624, 0.13757110464674707, 0.23121416278255738, 0.4161594024446848, 0.5479530181239709, -0.4518710160159151, -0.39399190216247176, -0.2964492222033455, -0.23246752973668522, -0.4419482514935769, -0.39392217950417074, -0.29917221923737125, -0.23164719304797227, 1.0, 1.0, 1.0, 1.0, 0.5355198690107404, 0.535509374057526, 0.4283357750615477, 0.36010724357402085, 0.6337183325661379, 0.7297297297297295, 0.4256085991689183, -0.10310310310310308, 0.3859437751004017], "score_GlobalLocal_2D": 0.9926372766494751, "score_Basins_2D": 0.004310382064431906, "ela_features": [-0.0029319063828390666, 0.9794945943266029, 0.0009066137992924291, 0.006722596673083457, 10.621362457962082, -0.010294087929152118, 0.23393990212452617, 1.1869285805655974, 0.46958174451839385, -5.7516013731685325, 43.171895924071485, 7.0, 0.8792456454666286, 0.86881469505858, 0.6294328794770362, 0.18643139768256708, -0.39122952195242466, 0.46492069479062287, 0.5406809894808069, 0.6100652254946544, 0.7237156763276951, 0.45934587212357425, 0.5414774244545929, 0.6123040458592908, 0.7273682150806892, -0.4707168648158748, -0.40407045192648605, -0.34303193851466063, -0.24305133465481976, -0.47820889485662166, -0.4055667879102202, -0.34292213046551195, -0.24114720529484054, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2129401079166353, 0.21292451964915618, 0.20888764464718057, 0.17819071098885153, 0.5960111392249644, 0.3413413413413412, 0.0001147713121625779, -2.2572572572572573, 0.5185897435897436], "score_GlobalLocal_5D": 0.6238160729408264, "score_Basins_5D": 0.5716830492019653, "ela_features_10D": [-0.0030683222288070853, 0.999832577575042, 9.426957392154228e-05, 0.0016278886836303102, 19.01991319362506, -0.020614930749703886, 0.009111539978498428, 6.925254129613384, -0.005244953660060947, -35.265666268637936, 1455.8471610493111, 2.8, 1.0016483145941897, 0.9355205061716129, 0.7105990336842649, 0.10530404153356876, -0.2240699460719456, 0.636009623299637, 0.6912065637440847, 0.7375988079329959, 0.8115534019744551, 0.6403454835242245, 0.6948267187612702, 0.7422019222564196, 0.8161900546252738, -0.46169091371103194, -0.3916782568566094, -0.332833435020902, -0.23902808870527553, -0.45742866451684516, -0.3881369403043111, -0.32788181951324874, -0.23377871168170178, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11044976715235458, 0.11045079599832841, 0.11035698975243535, 0.10053708777649129, 0.505881123968966, -1.4884884884884886, 0.0, -Infinity, 0.5720576461168936], "score_GlobalLocal_10D": 0.23587799072265625, "score_Basins_10D": 0.973385751247406}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], -1.9999996049383106], [8, [0.00044444444444512003, -1.9997777777778631], -0.9999998765432175], [8, [-1.9997777777778631, 0.00044444444444512003], -0.9999998765432175], [16, [-1.9997777777778631, -1.9997777777778631], -0.9999999506172852], [8, [0.0004472787195694952, 1.9998766261106389], -0.999999892360321], [8, [1.9998888752166453, 0.00044762993156350635], -0.9999998936393691], [16, [-1.9997724659992862, 1.9999309505004337], -0.9999999717302229], [16, [1.999945925448276, -1.9997721711435086], -0.9999999725849779], [16, [1.9999582425318236, 1.9999366790581499], -0.999999997123386]], "nr_of_basins": 9, "f_opt_dim_2": -2.0, "x_opt_dim_2": [6.281660219805613e-10, 3.362862663010518e-09], "f_opt_dim_5": -2.0, "x_opt_dim_5": [3.852705163845724e-09, 7.747694388932955e-09, -3.9683778027152274e-10, -2.516263200386886e-09, 1.240367330743622e-09]}
{"id": "22e2d652-c606-4df5-af68-ee55648df06b", "fitness": 0.5156945586204529, "name": "landscape_min_gaussians_homogeneous_improved_glocal", "description": "A homogeneous multi-basin Gaussian landscape on a toroidal domain with a globally deepest well at the origin. Wells are placed on a regular grid (1D or higher), and the GlobalLocal score is computed as a scale-invariant measure of peak recognizability by comparing the depth gap between the global and strongest local wells to the spread (std) of all well depths.", "code": "import numpy as np\n\nclass landscape_min_gaussians_homogeneous_improved_glocal:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Shared width for all Gaussian wells\n        self.sigma = 1.0\n        # Domain is [-5, 5] in each dimension, so wrap-around (toroidal) distance uses L=10\n        self.L = 10.0\n\n        if self.dim <= 1:\n            # 1D: symmetric grid of wells with origin included\n            grid = [-4.0, -2.0, 0.0, 2.0, 4.0]\n            self.N_wells = min(5, len(grid))\n            self.centers = [np.array([g], dtype=float) for g in grid[:self.N_wells]]\n            # Ensure a global well at the origin (override first center with origin)\n            if self.N_wells > 0:\n                self.centers[0] = np.array([0.0], dtype=float)\n        else:\n            # 2D+ case: place wells on a regular 4x4 grid in the first two dims\n            grid = [-4.0, -1.0, 2.0, 5.0]  # spacing ~3, within [-5,5]\n            centers_tmp = []\n            for a in grid:\n                for b in grid:\n                    c = np.zeros(self.dim, dtype=float)\n                    c[0] = a\n                    c[1] = b\n                    centers_tmp.append(c)\n            self.N_wells = min(16, len(centers_tmp))\n            self.centers = centers_tmp[:self.N_wells]\n            # Ensure origin is one of the centers to guarantee a global well at the origin\n            self.centers[0] = np.zeros(self.dim, dtype=float)\n            # If dim > 2, pad centers to match self.dim\n            if self.dim > 2:\n                for i in range(self.N_wells):\n                    if self.centers[i].shape[0] < self.dim:\n                        new_center = np.zeros(self.dim, dtype=float)\n                        new_center[:self.centers[i].shape[0]] = self.centers[i]\n                        self.centers[i] = new_center\n\n        # Amplitudes: a deeper global well (global) plus identical local wells\n        self.A = [6.0] + [2.0] * (self.N_wells - 1)\n\n    def _dist2_toroidal(self, x, center):\n        # Toroidal squared distance on [-5,5]^dim (wrap-around with L=10)\n        x = np.asarray(x, dtype=float)\n        center = np.asarray(center, dtype=float)\n        dist2 = 0.0\n        for d in range(self.dim):\n            xd = x[d]\n            cd = center[d]\n            delta = abs(xd - cd)\n            if delta > self.L / 2.0:\n                delta = self.L - delta\n            dist2 += delta * delta\n        return dist2\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = float('inf')\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        for i in range(self.N_wells):\n            dist2 = self._dist2_toroidal(x, self.centers[i])\n            candidate = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if candidate < val:\n                val = candidate\n        return float(val)\n\n    def global_local_score(self):\n        \"\"\"\n        Compute a scale-invariant GlobalLocal score.\n        - Depths at centers are the A[i] values (larger A -> deeper well).\n        - global_depth = max(A)\n        - strongest_local_depth = max(A excluding the global one)\n        - depth_diff = global_depth - strongest_local_depth\n        - score = depth_diff / (std(A) + eps)\n        Returns a non-negative float. If there is only one well, returns 0.0.\n        \"\"\"\n        depths = np.array(self.A, dtype=float)\n        if depths.size <= 1:\n            return 0.0\n\n        global_idx = int(np.argmax(depths))\n        global_depth = depths[global_idx]\n\n        # Collect local depths (excluding the global well)\n        local_depths = np.delete(depths, global_idx)\n        if local_depths.size == 0:\n            strongest_local_depth = 0.0\n        else:\n            strongest_local_depth = float(np.max(local_depths))\n\n        depth_diff = max(global_depth - strongest_local_depth, 0.0)\n        sd = float(np.std(depths)) if depths.size > 0 else 0.0\n        eps = 1e-12\n        score = depth_diff / (sd + eps)\n        return float(score)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_min_gaussians_homogeneous_improved_glocal scored on:GlobalLocal 0.315, Basins 0.571,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["137c1707-0443-42f6-a515-a1c74646093f"], "operator": null, "metadata": {"ela_features_2D": [-0.0004194010533916215, 0.7880333336420524, 0.01586189816873505, 0.022846669532266696, 1.6739711796806809, -0.0009313849767631055, 0.044734412581848584, 1.1625786575689137, 0.12794369631677102, -2.3803124492438767, 8.362285111937217, 3.6, 0.23924957127519245, 0.5858240815458642, 0.23577915533737107, 0.3758893258221476, -0.3277536050629605, 0.14287533744836228, 0.22895988769743436, 0.5832718237097472, 0.9179864210579375, 0.14367843819557877, 0.23235991139545503, 0.47655776487307894, 0.9098260989828428, -0.4482283419346357, -0.4032077161546269, -0.21791161096151793, -0.042887169176594894, -0.4386767364841294, -0.3932338772368179, -0.26806054921728106, -0.04617222043807723, 1.0, 1.0, 1.0, 1.0, 0.5190888873807548, 0.5190755788992838, 0.4582770158365159, 0.3554021963316736, 0.7501379535230134, 0.7697697697697696, 0.6729892688138378, 0.053053053053053, 0.4096385542168675], "score_GlobalLocal_2D": 0.8368679881095886, "score_Basins_2D": 0.0013403280172497034, "ela_features": [-0.0019935985672448362, 0.987508413229118, 0.0003329074704375393, 0.007650942256761507, 110.25154452364002, -0.009276200019426018, 0.09904345432839075, 159.38611212980666, 0.18957977271824653, -9.868662986443216, 129.2398831099029, 7.4, 0.8424433425582973, 0.8624078994308801, 0.605153484242358, 0.19109754817032348, -0.3280100616361611, 0.6243304023969181, 0.6656791511461442, 0.7067289913326732, 0.7804171677860309, 0.5981128704098164, 0.6431469359626628, 0.6870336470892908, 0.7682776936538022, -0.3304141085314547, -0.29404686347460796, -0.25794260182423423, -0.1931316683278329, -0.35521505986177015, -0.3154125746295672, -0.27662887793714575, -0.2048183676517498, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21258126618033982, 0.21253459360962773, 0.21067441576354246, 0.17907979804245955, 0.5730749634642219, 0.18918918918918912, 1.4143209136106675e-05, -3.614614614614615, 0.5125], "score_GlobalLocal_5D": 0.5700156092643738, "score_Basins_5D": 0.7993757724761963, "ela_features_10D": [-0.003406376271766387, 0.9992214519085987, 9.027686974043337e-05, 0.001333732824208541, 89.54031178652927, -0.021284696057124332, 0.0027757731117826977, 5.683116721326616, -0.03164129015474493, -39.06193465139138, 1639.6812445505552, 2.6, 0.9774699918576711, 0.9306134971691524, 0.6865574160828776, 0.11007332014411804, -0.20976256245027664, 0.666448245726998, 0.7115333327115623, 0.7561480232675303, 0.8253831151899039, 0.6623888157009665, 0.7076105136514392, 0.7542047755170003, 0.8261255893598471, -0.42301227304224687, -0.3658359028158835, -0.30925528841543876, -0.22145095661856265, -0.4292969721452927, -0.3717957867802194, -0.31254772862594926, -0.2210953085965412, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10979277423091223, 0.10979787666957759, 0.10972001147178398, 0.09983613439256127, 0.5661309255486127, -2.2732732732732734, 0.0, -Infinity, 0.5518014411529224], "score_GlobalLocal_10D": 0.31517234444618225, "score_Basins_10D": 0.5713951587677002}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -2.0], [2, [5.0, -5.0], -2.0], [2, [-5.0, 5.0], -2.0], [4, [5.0, 5.0], -2.0], [2, [-0.9995555555555558, -5.0], -1.9999998024691457], [2, [-4.992807430308151, -0.9994972937839286], -1.9999480149033124], [4, [5.0, -0.9995555555555558], -1.9999998024691457], [4, [-0.9995555555555558, 5.0], -1.9999998024691457], [6, [5.0, 1.999777777777864], -1.9999999506172845], [6, [1.999777777777864, 5.0], -1.9999999506172845], [4, [1.999777777777864, -0.9995555555555558], -1.999999753086435], [4, [-0.9995555555555558, 1.999777777777864], -1.999999753086435], [2, [-5.0, -3.999777777777643], -1.9999999506172845], [4, [5.0, -3.999777777777643], -1.9999999506172845], [4, [-3.999777777777643, 5.0], -1.9999999506172845], [5, [-3.999777777777643, -5.0], -1.9999999506172845], [5, [-0.9995555555555558, -3.999777777777643], -1.9999997530864349], [3, [-4.9929983965241025, 1.9998092838471642], -1.9999509417778025], [3, [1.9997979421996783, -4.9943986221400705], -1.9999685839854597], [6, [1.9995754888033057, -4.0000620261257875], -1.9999998159430121], [6, [-4.0000190627443635, 1.9998709253953857], -1.9999999829763584], [6, [1.999777777777864, 1.999777777777864], -1.9999999012345704], [11, [0.00044444444444512003, 0.00044444444444512003], -5.999998814814932], [4, [-3.9985332301025474, -1.0005715631344336], -1.9999975219031865]], "nr_of_basins": 24, "f_opt_dim_2": -6.0, "x_opt_dim_2": [1.7448578615073546e-09, -1.9795489546428853e-09], "f_opt_dim_5": -6.0, "x_opt_dim_5": [-2.2471319975114967e-09, -8.394060784668521e-10, -4.708991505298289e-09, 4.723932803136597e-10, 2.678186941727129e-09]}
{"id": "32a201f2-3078-4113-be02-f6b84f4135c4", "fitness": 0.54973965883255, "name": "landscape_spherical_wells", "description": "A novel high-dimensional, non-torus multi-well landscape built from evenly distributed Gaussian wells on a hypersphere. The global minimum sits at the origin (a deep well), while many local wells lie on a spherical shell around the origin with identical width and shallower depths. This design yields clear global-local contrast and roughly homogeneous basin sizes across wells, within the domain [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_spherical_wells:\n    def __init__(self, dim, seed=None, n_wells=None, radius=3.0, sigma=1.0,\n                 A_global=60.0, A_local=15.0):\n        \"\"\"\n        A novel multi-well landscape.\n        - Global well at the origin (depth A_global)\n        - Local wells distributed on a hypersphere of radius 'radius'\n          with equal width 'sigma' and depth 'A_local'\n        - The objective is minimization (lower is better)\n        - Domain is [-5, 5] per dimension\n        \"\"\"\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be >= 1\")\n        if seed is not None:\n            np.random.seed(int(seed))\n\n        self.radius = float(radius)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n\n        # Build centers: origin (global well) + local wells on a sphere\n        self.centers = []\n        # Global well at origin\n        self.centers.append(np.zeros(self.dim, dtype=float))\n\n        if self.dim == 1:\n            # 1D special case: place a few local wells along the line\n            local_positions = np.array([-4.0, -2.0, 2.0, 4.0], dtype=float)\n            for p in local_positions:\n                self.centers.append(np.array([p], dtype=float))\n        else:\n            # Determine number of local wells on the hypersphere\n            if n_wells is None:\n                n_on_sphere = max(12, min(72, self.dim * 8))\n            else:\n                n_on_sphere = max(4, int(n_wells))\n\n            for _ in range(n_on_sphere):\n                # Uniform random point on the unit sphere in 'dim' dimensions\n                v = np.random.normal(size=self.dim)\n                norm = np.linalg.norm(v)\n                if norm == 0:\n                    continue\n                v = (v / norm) * self.radius\n                self.centers.append(v)\n\n        self.N_wells = len(self.centers)\n        # Amplitudes: global well deeper than locals\n        self.A = [self.A_global] + [self.A_local] * (self.N_wells - 1)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at x.\n        f(x) = min_j [ -A_j * exp(-||x - c_j||^2 / (2*sigma^2)) ]\n        Global minimum is at the origin due to the center at the origin with depth A_global.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        two_sigma2 = 2.0 * (self.sigma ** 2)\n        best = None\n        for i in range(self.N_wells):\n            c = self.centers[i]\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            val = - self.A[i] * np.exp(- dist2 / two_sigma2)\n            if (best is None) or (val < best):\n                best = val\n        return float(best)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_spherical_wells scored on:GlobalLocal 0.247, Basins 0.975,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8db63a15-c151-4ca7-b0f3-1e433a59a02e"], "operator": null, "metadata": {"ela_features_2D": [-0.0029122129406146335, 0.8458720809649316, 0.007355506895336759, 0.014176551755365373, 4.30640936888436, -0.001795937069599507, 0.5435565018594755, 1.041502998133163, 0.6118792642963343, -2.414410579586749, 7.718702307573747, 4.4, 0.5018696936301875, 0.672247574644328, 0.41928547372381697, 0.35876043127262924, -0.21048435473202795, 0.1572728974754916, 0.22945950231140055, 0.3817916998938683, 0.6130927493967093, 0.16369017587410967, 0.2342672597765354, 0.361292647485696, 0.6054847506484123, -0.44092038846630643, -0.4031554676828577, -0.32344523832998806, -0.20243099366823816, -0.4298253472239898, -0.3935619171429048, -0.32826031360302943, -0.20275873823326745, 1.0, 1.0, 1.0, 1.0, 0.5173145667921153, 0.5172802919382218, 0.4459017245583823, 0.35010671441011054, 0.6796365677587428, 0.7417417417417415, 0.2934581508610833, -0.2232232232232232, 0.40682730923694777], "score_GlobalLocal_2D": 0.941045880317688, "score_Basins_2D": 0.0019067480461671948, "ela_features": [-0.0005142962575486853, 0.9792037389440367, 0.0015162217097159571, 0.012605967184939578, 9.357638410535031, -0.007023105235684901, 0.20217410885683532, 1.2011373287435654, 0.4048083805613259, -6.311324902543369, 52.7815261882105, 7.2, 0.875599947208085, 0.8639718660808743, 0.6171320017652943, 0.1921025901333861, -0.3857839149160056, 0.47979739121435516, 0.537905426007361, 0.6093764631764865, 0.7218092707389699, 0.47157979334969913, 0.5337261579977509, 0.6097459390138862, 0.723677106518148, -0.457499824864415, -0.4063941383246263, -0.34353792588734855, -0.24465870465044107, -0.4669603851805123, -0.41203125607388874, -0.3448534472991054, -0.24417831057711448, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21364705171243598, 0.21370953770912954, 0.21006243837348754, 0.17975352485667817, 0.6064084979924824, 0.3253253253253252, 0.00012529021825904743, -2.3613613613613618, 0.5193910256410257], "score_GlobalLocal_5D": 0.6238160729408264, "score_Basins_5D": 0.5093193054199219, "ela_features_10D": [-0.0030900175364049877, 0.9997887053573878, 4.394284008118744e-05, 0.0015457501236202055, 42.39724667613227, -0.02066529053026218, 0.006305319520707941, 2.30090274601547, -0.017288806914582833, -38.04377853516794, 1628.8160648409764, 3.0, 1.0115120571811649, 0.9379236695520012, 0.7109713910131125, 0.10439178799370115, -0.21149232145073887, 0.6188622600777117, 0.6813916886111852, 0.7325206123781565, 0.8109808006693655, 0.6214513991151668, 0.684282720731901, 0.7358644174085508, 0.8147774188499557, -0.4833323888491169, -0.4040373938618407, -0.33919936388361205, -0.23970152035186576, -0.4812996217180464, -0.40141475962624484, -0.33583188269572817, -0.23549841066263782, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10882253118278899, 0.10882943427985962, 0.1087500678794036, 0.09900735537651935, 0.49001404147181715, -1.6806806806806809, 0.0, -Infinity, 0.5851080864691753], "score_GlobalLocal_10D": 0.24715742468833923, "score_Basins_10D": 0.9751926064491272}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [0.00044444444444512003, 0.00044444444444512003], -59.99998814814932], [8, [-2.2269384836105126, 1.9273218938669758], -14.976818143894958], [9, [0.2124444444444453, 2.992888888888988], -14.99999855323834], [2, [-0.6086395694203254, -2.9190641962530886], -14.997482092915742], [7, [0.9773622793657347, -2.826256523275233], -14.999316253773669], [6, [-2.981643857493519, -0.3154086446456368], -14.999972420214569], [3, [0.09898880362819806, -2.9966778535722005], -14.999976650478265], [3, [-2.9639118898491947, -0.4651367175103934], -14.999995953752498], [2, [1.3983253832067615, 2.654006103170304], -14.999996279232926], [4, [-1.452124180275227, 2.6257384846434726], -14.999994990782543], [13, [-1.5288308409169473, -2.5803968694525823], -14.999991167692123], [13, [1.899777777777864, -2.321777777777828], -14.999999981143942], [4, [-1.8962930920016468, 2.32494940995916], -14.999995004661452], [14, [2.2337847123147387, 2.0023843968498007], -14.999997547995898]], "nr_of_basins": 14, "f_opt_dim_2": -60.0, "x_opt_dim_2": [-5.7545427719325044e-09, -4.370186167519834e-09], "f_opt_dim_5": -60.0, "x_opt_dim_5": [5.921578450336842e-10, 1.701300496048081e-09, 7.725986229521942e-09, 3.078107856635895e-09, -2.7536667250895177e-09]}
{"id": "ab9ed447-e212-4342-9bbd-0855792ad8ec", "fitness": 0.5005574226379395, "name": "landscape_minquad_torus", "description": "A torus-wrapped min-of-quadratics landscape on a centered grid of wells. The global minimum sits at the origin and local wells are placed on a regular grid; basin sizes are homogenized using toroidal distances. GlobalLocal and Basin properties are exposed via a score computed from center evaluations.", "code": "import numpy as np\nfrom itertools import product\n\nclass landscape_minquad_torus:\n    def __init__(self, dim=5, grid_step=2.0, gamma=0.75, A_global=3.0, A_local=1.0):\n        \"\"\"\n        A heterogenous, yet basin-homogeneous, multi-well landscape based on a\n        min of quadratics with toroidal distances.\n        - dim: number of dimensions\n        - grid_step: spacing of centers along each dimension (grid in {-step, 0, +step})\n        - gamma: curvature factor (controls basin width)\n        - A_global: depth of the global well at origin (more negative means deeper)\n        - A_local: depth of local wells (shallower than global)\n        \"\"\"\n        self.dim = int(dim)\n        self.grid_step = float(grid_step)\n        self.gamma = float(gamma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n\n        # domain length per dimension ([-5, 5] -> length 10)\n        self.domain_len = 10.0\n\n        # Build centers and corresponding depths\n        self._build_centers()\n\n        # Precompute nothing else; evaluation uses dynamic vectorization\n        # (centers is shape (N, dim), depths is shape (N,))\n    \n    def _build_centers(self):\n        # Create a grid with coordinates in {-step, 0, +step} for each dimension\n        coords = [-self.grid_step, 0.0, self.grid_step]\n        centers_list = list(product(coords, repeat=self.dim))\n        self.centers = np.asarray(centers_list, dtype=float)  # shape (N, dim)\n\n        # Depths: origin (all zeros) is global minimum; others are local wells\n        N = self.centers.shape[0]\n        self.depths = np.zeros(N, dtype=float)\n        origin_mask = np.all(np.isclose(self.centers, 0.0), axis=1)\n        self.depths[origin_mask] = -self.A_global\n        self.depths[~origin_mask] = -self.A_local\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape definition: f(x) = min_k [ depth_k + gamma * dist_toroidal^2(x, c_k) ]\n        dist_toroidal uses wrap-around distance on each dimension with domain_len = 10.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        # Toroidal distance per center\n        # For each center c_k, compute per-dimension delta = |x_i - c_k,i|\n        # then d_i = min(delta, domain_len - delta); dist^2 = sum_i d_i^2\n        delta = np.abs(self.centers - x)  # shape (N, dim)\n        d = np.minimum(delta, self.domain_len - delta)\n        dist2 = np.sum(d**2, axis=1)  # shape (N,)\n\n        # Value at each center: depth_k + gamma * dist^2\n        values = self.depths + self.gamma * dist2\n        return float(np.min(values))\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Scale-invariant GlobalLocal score for the landscape.\n        - min_global: value at origin (global minimum)\n        - min_local: smallest value among local wells (excluding origin)\n        - mean_center_value, std_center_value: statistics of values at all centers\n        GlobalLocal = (min_local - min_global) / (std_center_value + eps)\n        Positive score indicates pronounced global-local contrast.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        min_global = self.f(origin)\n\n        # compute local minima (excluding origin)\n        min_local = None\n        # Identify origin center index\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, origin):\n                origin_index = idx\n                break\n        for idx, c in enumerate(self.centers):\n            if idx == origin_index:\n                continue\n            val = self.f(c)\n            if (min_local is None) or (val < min_local):\n                min_local = val\n        if min_local is None:\n            min_local = min_global  # safeguard\n\n        # Values at all centers (including origin) for dispersion\n        center_values = np.array([self.f(c) for c in self.centers], dtype=float)\n        mean_center_value = float(np.mean(center_values))\n        std_center_value = float(np.std(center_values, ddof=0))\n\n        diff = float(min_local) - float(min_global)\n        eps = 1e-9\n        gl_score = diff / (std_center_value + eps)\n        return gl_score\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_minquad_torus scored on:GlobalLocal 0.000, Basins 0.999,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3f837acd-f37f-4cbf-a83e-2752f8bb7375"], "operator": null, "metadata": {"ela_features_2D": [-0.0026359724911468874, 0.33771996413407296, 0.0048613891467729695, 0.021711721621297413, 9.233653519372231, -0.00040099919811926733, 0.913008143087793, 1.0093948671770587, 0.9156937553842119, 0.7524050865831599, 0.08705667042492768, 1.2, 0.6232587042956673, 0.7037657751738564, 0.5002061655992658, 0.34357461280984125, -0.24154203968619417, 0.147242827155335, 0.22355713190071586, 0.33668033009449677, 0.5363431906525548, 0.14540608425021756, 0.2225662020380032, 0.33314791705711233, 0.5298159399301281, -0.44605025085120265, -0.40613176006737783, -0.34695822303415935, -0.24252180123703554, -0.43871938790102555, -0.3991079690619434, -0.34233662930888553, -0.24137335301462634, 1.0, 1.0, 1.0, 1.0, 0.5229412443441305, 0.5229366209907834, 0.42973427982628226, 0.35371530514412103, 0.7132063543520054, 0.5255255255255253, 0.4719073131394914, -0.047047047047047055, 0.3859437751004016], "score_GlobalLocal_2D": 0.9875122904777527, "score_Basins_2D": 0.024540415033698082, "ela_features": [-0.00030008067009390516, 0.3462912995455695, 0.002987930404720177, 0.03175083929298647, 61.637365060816805, 0.008304585462352377, 0.8730789388930174, 1.0478427966348618, 0.8739142549069779, 0.6099671913003937, 0.07770868130994871, 1.6, 0.83079467630093, 0.8645468422405422, 0.5789681632437529, 0.19262391313860722, -0.5086532365133356, 0.5588368784167881, 0.6003646845497095, 0.6385336698215333, 0.7424803042431203, 0.5538885476646996, 0.6008285365401349, 0.6407590078174749, 0.7451207627909542, -0.3881152544216957, -0.35158133355591775, -0.3180014342546242, -0.2265543489677852, -0.3945976447321521, -0.35308343902863926, -0.31775892487659807, -0.22544724678514746, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2160091600194428, 0.21604045598365054, 0.19964944260688294, 0.18233397004962912, 0.8397201830894805, 0.27327327327327317, 0.32063114476302, -0.25125125125125114, 0.5415064102564102], "score_GlobalLocal_5D": 0.0037825850304216146, "score_Basins_5D": 0.9882088899612427, "ela_features_10D": [0.00017124935241841222, 0.35091510520582164, 0.0021855162536354904, 0.018039496845688657, 21.553324618808013, 0.0019774080402893634, 0.8750632168661271, 1.0652372118146218, 0.8756901383635688, 0.432663799573452, 0.0810270028834493, 1.6, 0.9887293337877938, 0.9353472566637798, 0.6706440336709936, 0.11020098083444926, -0.6079691928831031, 0.653318213596735, 0.7098010478597836, 0.754977083416726, 0.8223421738686627, 0.653800620124626, 0.7110142668960153, 0.7573798489910484, 0.8256882370406455, -0.4396493694269178, -0.3680208811239516, -0.3107306464425063, -0.22530066912124141, -0.44018539007054747, -0.367439954173468, -0.30848791144195353, -0.22163504767818898, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10951697187764027, 0.10951646880090919, 0.10631203281022625, 0.10033530685600862, 0.8644356729526953, -0.059059059059059046, 0.13667380956174247, -0.6196196196196194, 0.6134507606084868], "score_GlobalLocal_10D": 0.00038102903636172414, "score_Basins_10D": 0.9989194869995117}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], -2.9999997037037036], [6, [1.999777777777864, 0.00044444444444512003], -0.9999998148148148], [6, [0.00044444444444512003, 1.999777777777864], -0.9999998148148148], [9, [1.999777777777864, 1.999777777777864], -0.999999925925926], [8, [0.00044444444444512003, -1.9997777777778631], -0.9999998148148148], [8, [-1.9997777777778631, 0.00044444444444512003], -0.9999998148148148], [12, [1.999777777777864, -1.9997777777778631], -0.999999925925926], [12, [-1.9997777777778631, 1.999777777777864], -0.999999925925926], [16, [-1.9997777777778631, -1.9997777777778631], -0.999999925925926], [2, [5.00102076744145, 0.07643559615124627], 5.749789128257349], [3, [5.001653909681692, 1.9017960327530126], 5.749792472382598], [4, [1.9980003377180262, 5.001423959063116], 5.743596703947469], [2, [0.09642712553266382, 5.001603554146719], 5.74975957778306], [4, [-1.9097920002906408, 5.001406012662079], 5.749777538083023], [4, [5.0016507514721305, -1.9017960578229987], 5.749806672805057]], "nr_of_basins": 15, "f_opt_dim_2": -3.0, "x_opt_dim_2": [-1.1065616002350283e-08, 8.166215018634458e-09], "f_opt_dim_5": -3.0, "x_opt_dim_5": [-6.3642194736406395e-09, 6.1830424108773e-09, 6.274641110807068e-09, 2.8041076581672003e-09, -3.979830868484703e-10]}
{"id": "696b72d9-e5e0-4d24-8604-f173cfe9af38", "fitness": 0.5663442611694336, "name": "GridParabolicGridLandscapeBalancedBasins", "description": "A torus-wrapped multi-basin parabolic landscape with balanced basins.", "code": "import numpy as np\nimport itertools\n\nclass GridParabolicGridLandscapeBalancedBasins:\n    \"\"\"\n    Multi-basin parabolic landscape on a torus with balanced basin sizes.\n    Centers are placed on a regular 3^dim grid and then iteratively relocated\n    to achieve more uniform basin volumes (basin_size_homogeneity).\n    The global minimum at the origin is substantially deeper than local wells.\n    Distances wrap around the domain (torus metric). The f(x) objective is:\n        f(x) = min_k ( ||x - c_k||^2 * alpha ) + beta_k\n    where centers c_k are balanced in the toroidal domain and beta_k control depths.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Domain and basic parameters\n        self.domain_lo = -5.0\n        self.domain_hi = 5.0\n        self.alpha = 1.0  # quadratic coefficient\n        self.a = 2.0      # centers along each axis: -a, 0, +a\n\n        # Build centers on a regular grid: coordinates in {-a, 0, +a}\n        grid_vals = [-self.a, 0.0, self.a]\n        centers_list = list(itertools.product(grid_vals, repeat=self.dim))\n        self.centers = np.array(centers_list, dtype=float)  # shape (K, dim)\n        self.K = self.centers.shape[0]\n\n        # Local wells: depths beta_k\n        # Global minimum at origin is much deeper\n        self.beta = np.full(self.K, -1.0, dtype=float)\n        origin_index = None\n        for idx, c in enumerate(self.centers):\n            if np.allclose(c, 0.0, atol=1e-12):\n                origin_index = idx\n                break\n        if origin_index is None:\n            raise ValueError(\"Origin center not found in the grid centers.\")\n        self.origin_index = origin_index\n        self.beta[origin_index] = -50.0  # deep global minimum\n\n        # Balance basin sizes to improve homogeneity\n        self._balance_basins(iterations=4, sample_points_count=2000, lr=0.25)\n\n        # Diagnostics after balancing\n        self.f_center_values = [self._value_at(ci) for ci in self.centers]\n        global_min = min(self.f_center_values)\n        sorted_vals = sorted(self.f_center_values)\n        local_best_value = None\n        for v in sorted_vals:\n            if v > global_min + 1e-12:\n                local_best_value = v\n                break\n        avg_center = float(np.mean(self.f_center_values))\n        self.global_local_contrast = 0.0 if local_best_value is None else (\n            (local_best_value - global_min) / (abs(avg_center) + 1e-9)\n        )\n\n        # Basin homogeneity (size balance) computed on a coarse grid\n        self._compute_basin_homogeneity()\n\n        # Store diagnostics\n        self.global_min_value = global_min\n        self.local_best_value = local_best_value\n        self.avg_center_value = avg_center\n\n    def wrap_to_domain(self, v):\n        \"\"\"\n        Wrap a vector v back into the domain [domain_lo, domain_hi] using torus wrap.\n        \"\"\"\n        L = self.domain_hi - self.domain_lo\n        return self.domain_lo + ((v - self.domain_lo) % L)\n\n    def _balance_basins(self, iterations=4, sample_points_count=2000, lr=0.25):\n        \"\"\"\n        Iteratively relocate centers to improve basin-size homogeneity.\n\n        Procedure:\n        - Sample random points uniformly in the domain.\n        - For each point, assign it to the nearest center under toroidal distance.\n        - Move each center a small step toward the mean of its assigned points.\n        - Wrap centers back into the domain.\n        \"\"\"\n        for it in range(iterations):\n            # Sample random points in the domain\n            X = self.domain_lo + (self.domain_hi - self.domain_lo) * np.random.rand(sample_points_count, self.dim)\n\n            # Compute g_k(x) = alpha * d^2(x, c_k) + beta_k for all k\n            g = self._compute_g_matrix(X)  # shape (N, K)\n\n            # Assign each sample to the best center\n            idx = np.argmin(g, axis=1)\n\n            # Move centers toward their assigned points\n            for k in range(self.K):\n                cluster_pts = X[idx == k]\n                if cluster_pts.size == 0:\n                    continue\n                mean_pt = cluster_pts.mean(axis=0)\n                new_center = (1.0 - lr) * self.centers[k] + lr * mean_pt\n                self.centers[k] = self.wrap_to_domain(new_center)\n\n    def _compute_g_matrix(self, X):\n        \"\"\"\n        Compute the matrix G where G[i, k] = alpha * ||X[i] - c_k||^2 + beta_k\n        with toroidal distance per dimension.\n        \"\"\"\n        N = X.shape[0]\n        K = self.K\n        g = np.empty((N, K), dtype=float)\n        L = self.domain_hi - self.domain_lo\n        for k in range(K):\n            diffs = np.abs(self.centers[k] - X)      # (N, dim)\n            diffs = np.minimum(diffs, L - diffs)     # torus per-dimension\n            d2 = np.sum(diffs ** 2, axis=1)\n            g[:, k] = self.alpha * d2 + self.beta[k]\n        return g\n\n    def _compute_basin_homogeneity(self):\n        \"\"\"\n        Compute basin sizes using a coarse, deterministic grid ([-5,0,5] per axis)\n        and toroidal distance to centers. Basin homogeneity is the max count divided\n        by the min non-zero count.\n        \"\"\"\n        coords = [-self.domain_hi, 0.0, self.domain_hi]\n        grid_points = np.array(list(itertools.product(coords, repeat=self.dim)))\n        K = self.K\n        counts = np.zeros(K, dtype=int)\n        L = self.domain_hi - self.domain_lo\n        for x in grid_points:\n            x = np.asarray(x, dtype=float)\n            dists = np.abs(self.centers - x)\n            dists = np.minimum(dists, L - dists)\n            d2 = np.sum(dists ** 2, axis=1)\n            g = self.alpha * d2 + self.beta\n            idx = int(np.argmin(g))\n            counts[idx] += 1\n        nonzero = counts[counts > 0]\n        self.basin_homogeneity = 1.0 if nonzero.size <= 1 else (np.max(nonzero) / np.min(nonzero))\n\n    def _value_at(self, x):\n        \"\"\"\n        Evaluate f(x) = min_k (||x - c_k||^2 * alpha + beta_k) with toroidal metric.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        L = self.domain_hi - self.domain_lo\n        dists = np.abs(self.centers - x)       # (K, dim)\n        dists = np.minimum(dists, L - dists)\n        d2 = np.sum(dists ** 2, axis=1)\n        g = self.alpha * d2 + self.beta\n        return float(np.min(g))\n\n    def f(self, x):\n        \"\"\"\n        Public minimization objective. Returns a scalar value.\n        \"\"\"\n        return self._value_at(x)", "configspace": "", "generation": 3, "feedback": "The optimization landscape GridParabolicGridLandscapeBalancedBasins scored on:GlobalLocal 0.000, Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c3980e32-d8ba-42a1-a5ea-6bccbed0e4dc"], "operator": null, "metadata": {"ela_features_2D": [-0.0014738410084880415, 0.3677373466934059, 0.014647154907649248, 0.031858126196045625, 2.394526117063479, -0.0014929796172799437, 0.9999936716839922, 1.0025824942928203, 0.999994005954617, 0.3986509138315822, -0.4688240435363881, 2.0, 0.711406794079392, 0.7112640114560873, 0.5734754011189536, 0.3489543014238375, -0.20288951616572204, 0.1463909689801473, 0.23369610331774374, 0.3210281792043254, 0.4913552590726118, 0.15020644480028447, 0.23371746823206774, 0.32206093535808555, 0.4966160906953737, -0.4467632106789776, -0.4010726287175048, -0.3553638055452607, -0.2662156324131236, -0.4371470453907693, -0.39419847023412685, -0.34875279235944934, -0.2589479886702798, 1.0, 1.0, 1.0, 1.0, 0.507594774799434, 0.507558203985141, 0.39333151246959647, 0.35039700270840635, 0.7201296119205783, 0.40140140140140124, 0.5853871226188723, -0.047047047047047055, 0.3666666666666667], "score_GlobalLocal_2D": 0.9727391600608826, "score_Basins_2D": 0.4249017834663391, "ela_features": [-0.0013013246711356175, 0.5917187138036785, 0.0032699312519007652, 0.02701023838761204, 22.740462110745934, -0.0015798677339189382, 0.9321139746449795, 1.030756025614372, 0.9820366619675625, -0.30783097768875844, -0.8007862170919087, 2.0, 0.910502205464123, 0.875878948717129, 0.6573829214806797, 0.18010159087447758, -0.47713328545834627, 0.42705948020912415, 0.5137345759590026, 0.5868347234519051, 0.7088943781528696, 0.4259460997233554, 0.5173891144851956, 0.591356678951943, 0.7134322496894565, -0.5038425894804582, -0.42761870848747785, -0.3633349687045413, -0.2559965931648551, -0.5070860833651182, -0.4263018176122804, -0.360964038709683, -0.25313153023970325, 1.0, 1.0, 0.9, 1.0, 0.21635373148370246, 0.2163306501503201, 0.19447130880600325, 0.18165266306693528, 0.8191186900079075, 0.22522522522522515, 0.2948937068074569, -0.2912912912912913, 0.5165064102564102], "score_GlobalLocal_5D": 0.0023183643352240324, "score_Basins_5D": 0.9997287392616272, "ela_features_10D": [-0.00021942563930807957, 0.668645561552261, 0.0007227233530452381, 0.014544348335029234, 58.949279292415255, -0.004190059264176838, 0.750001261402147, 1.098954556965233, 0.8723677358915014, -1.3466100600821571, 3.0753680117954967, 2.6, 0.9916502260864772, 0.93591326969016, 0.6948277364626876, 0.10651259997523, -0.690573156871461, 0.616306016020798, 0.6754009758163196, 0.7266656489501929, 0.8225526329702257, 0.6207549611201134, 0.6801336929591273, 0.7310529658586588, 0.8248009568556934, -0.48660933197952827, -0.41166374120694266, -0.34664867288339407, -0.22504231537898164, -0.4822192370340173, -0.4067172319768493, -0.34197181152751, -0.2227675015550652, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11031474595408133, 0.1103114658846162, 0.1082060135197334, 0.10131435631020595, 0.8477294278415612, -0.04704704704704705, 0.09014471627095219, -0.7837837837837835, 0.6144915932746196], "score_GlobalLocal_10D": 0.0004911386640742421, "score_Basins_10D": 0.9978864789009094}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], -0.8521745526257121], [9, [-5.0, -0.04733333333333453], -25.38190530264807], [9, [0.03844444444444514, 5.0], -25.470269231628013], [81, [0.03844444444444514, -0.04733333333333453], -49.99999998165037]], "nr_of_basins": 4, "f_opt_dim_2": -50.0, "x_opt_dim_2": [-0.008896947714440407, 0.02792752227495965], "f_opt_dim_5": -50.0, "x_opt_dim_5": [0.000277511497026079, 0.01374918656171538, 0.039753778256212326, 0.001447781834700588, 0.005427211331141264]}
{"id": "f5afcbc3-0d23-4950-bd7b-e9dfe4edb249", "fitness": 0.6274040341377258, "name": "landscape_glocal_enhanced_basin_homogeneous", "description": "A torus-wrapped, uniform-basin multi-well landscape with scalable GlobalLocal contrast. Wells are placed on a regular grid inside [-s, s] per axis and replicated across dimensions to ensure homogeneous basin sizes via toroidal distances. The global minimum at the origin is deeper, and a tunable contrast scales its depth. A Basins metric quantifies how uniform the basin sizes are on the torus, while a GlobalLocal score remains available to compare local vs global prominence.", "code": "import numpy as np\n\nclass landscape_glocal_enhanced_basin_homogeneous:\n    def __init__(self, dim=5, s=2.0, sigma=0.9, A_global=1.8, A_local=1.0, contrast=0.5, n_per_dim=3, samples_for_basin=1000):\n        \"\"\"\n        A multi-basin minimization landscape with uniform (homogeneous) basins.\n        - dim: number of dimensions\n        - s: spread along each axis for grid centers (grid coordinates in [-s, s])\n        - sigma: Gaussian width (controls basin size)\n        - A_global: base amplitude of global well (located at origin)\n        - A_local: amplitude of local wells\n        - contrast: fractional increase applied to the global well depth\n        - n_per_dim: number of grid points per axis (default 3 -> coordinates [-s, 0, s])\n        - samples_for_basin: number of Monte Carlo samples to estimate basin volumes on torus\n        \"\"\"\n        self.dim = int(dim)\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.contrast = float(contrast)\n        self.n_per_dim = int(n_per_dim)\n        self.samples_for_basin = int(samples_for_basin)\n\n        # Build a regular grid of centers on each axis within [-s, s]\n        coords_per_dim = np.linspace(-self.s, self.s, max(2, self.n_per_dim))\n        grids = np.meshgrid(*[coords_per_dim for _ in range(self.dim)], indexing='ij')\n        centers_arr = np.stack([g.flatten() for g in grids], axis=-1)\n        self.centers = [centers_arr[i] for i in range(centers_arr.shape[0])]\n\n        # Ensure origin is included as the global minimum\n        has_origin = any(np.allclose(c, np.zeros(self.dim)) for c in self.centers)\n        if not has_origin:\n            self.centers.append(np.zeros(self.dim))\n\n        # Assign amplitudes: A_local to all wells, override origin with boosted global depth\n        self.weights = np.full(len(self.centers), self.A_local, dtype=float)\n        for i, c in enumerate(self.centers):\n            if np.allclose(c, np.zeros(self.dim)):\n                self.weights[i] = self.A_global * (1.0 + self.contrast)\n                break\n\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.weights = np.asarray(self.weights, dtype=float)\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n        # Seeding randomness is not fixed to keep results deterministic across runs unless explicitly set.\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is a sum of negative Gaussians centered at:\n          - origin (global basin, deeper)\n          - each grid center (local wells)\n        f(x) = sum_i -a_eff_i * exp(-||x - c_i||^2 / (2*sigma^2))\n        where a_eff_i for i==0 (origin) is scaled by (1 + contrast)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        total = 0.0\n        for i, c in enumerate(self.centers):\n            # Apply contrast to the global basin (origin)\n            a_eff = self.weights[i]\n            diff = x - c\n            dist2 = float(np.dot(diff, diff))\n            total += -a_eff * np.exp(-dist2 / self._two_sigma2)\n        return float(total)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a robust, normalized GlobalLocal score.\n        - val_global: f at the origin (global minimum candidate)\n        - val_local_min: minimum value among local wells (excluding origin)\n        - vals: f at all basin centers (origin + local wells)\n        GlobalLocal score is the local-prominence relative to the global minimum,\n        normalized by the dispersion (std dev) of center values.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        val_global = self.f(origin)\n\n        # compute values at all centers\n        vals = [self.f(c) for c in self.centers]\n        if len(vals) <= 1:\n            min_local = val_global\n        else:\n            # Exclude origin if it's the first center\n            min_local = min(vals)\n\n        mean_center_value = float(np.mean(vals))\n        std_center_value = float(np.std(vals)) + 1e-12  # avoid division by zero\n\n        diff = float(min_local) - float(val_global)  # should be >= 0 if global is deepest\n        gl_score = diff / std_center_value  # normalized, scale-invariant\n\n        return float(gl_score)\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()\n\n    def compute_basin_homogeneity(self, samples=None):\n        \"\"\"\n        Approximate basin sizes via toroidal Voronoi regions.\n        - Uses Monte Carlo sampling over the domain [-5,5]^dim\n        - Assigns each sample to the nearest center using toroidal distances\n        - Returns ratio max_basin_size / min_basin_size\n        Higher ratio indicates stronger inhomogeneity; 1.0 indicates perfect homogeneity.\n        \"\"\"\n        N = int(self.samples_for_basin) if samples is None else int(samples)\n        if N <= 0:\n            N = 1000\n        # Sample uniformly in the domain\n        samples_pts = np.random.uniform(-5.0, 5.0, size=(N, self.dim))\n        domain_len = 10.0  # length per dimension for torus wrap\n        counts = np.zeros(len(self.centers), dtype=int)\n        centers_arr = np.array(self.centers)\n\n        for p in samples_pts:\n            diffs = p - centers_arr  # shape (num_centers, dim)\n            wrapped = np.abs(diffs)\n            wrapped = np.minimum(wrapped, domain_len - wrapped)\n            dist2s = np.sum(wrapped ** 2, axis=1)\n            idx = int(np.argmin(dist2s))\n            counts[idx] += 1\n\n        if counts.size == 0:\n            return 0.0\n        maxc = float(np.max(counts))\n        minc = float(np.min(counts))\n        if minc <= 0:\n            # If any basin is unvisited in sampling, indicate high heterogeneity\n            return float('inf')\n        ratio = maxc / minc\n        return float(ratio)\n\n    @property\n    def Basins(self):\n        \"\"\"\n        Basins homogeneity score: ratio of largest to smallest basin volumes\n        (via toroidal sampling). Closer to 1.0 indicates homogeneous basin sizes.\n        \"\"\"\n        return self.compute_basin_homogeneity()", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_glocal_enhanced_basin_homogeneous scored on:GlobalLocal 0.180, Basins 0.975,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19640fc0-ffd5-414c-b5d5-c8194dea4555"], "operator": null, "metadata": {"ela_features_2D": [-0.003615033897759412, 0.8253270989601635, 0.003416346483452113, 0.013301007280820088, 7.99610415401479, -0.004748671640776659, 0.676636704822167, 1.0204466884115795, 0.8600132452510909, -1.3425260852385703, 1.292914473597694, 2.4, 0.7082707533476233, 0.7171298335110634, 0.5478955730375076, 0.33982224289526264, -0.18192581842287497, 0.14087673911829265, 0.22712562119649005, 0.3246663698164166, 0.5054934715312807, 0.14124884830623746, 0.2240290875973437, 0.3242377545364724, 0.5062738969337136, -0.44952343134852074, -0.40439894961994555, -0.35336322029456546, -0.25874661630924584, -0.4413430442238432, -0.3988039211719077, -0.34731896267051116, -0.253756409395968, 1.0, 1.0, 1.0, 1.0, 0.5177907621338184, 0.5177689686909259, 0.40346006643554766, 0.3479092953453942, 0.5800896781841713, 0.5295295295295294, 0.3487274562360573, -0.31931931931931923, 0.37429718875502005], "score_GlobalLocal_2D": 0.9940953254699707, "score_Basins_2D": 0.008041981607675552, "ela_features": [-0.0032932702494420595, 0.9362312676810207, 0.0013081535204890829, 0.008690696061123644, 11.245798609924263, -0.00908951681236685, 0.3762722644447906, 1.110791288579413, 0.7083833929632363, -3.3345095168739673, 12.151878275477792, 4.2, 0.8994849697621126, 0.8699744191607748, 0.6247782714285655, 0.18767013227212476, -0.4329213329482949, 0.4504253449617555, 0.5410892157721049, 0.6132751181632127, 0.7287234291130068, 0.44654443030450486, 0.5413018243726946, 0.6149076996963029, 0.7320547730823345, -0.48350088520411594, -0.40373656018561765, -0.34022906478380477, -0.2386615894817461, -0.4895190644595683, -0.40570157803702556, -0.3406003769418958, -0.2369905897619124, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21833283710157608, 0.21833931652212418, 0.2094489463431078, 0.18210015052834116, 0.6466518544741575, 0.37337337337337323, 0.0036112724951047693, -1.3243243243243243, 0.5352564102564102], "score_GlobalLocal_5D": 0.9650437235832214, "score_Basins_5D": 0.6419664621353149, "ela_features_10D": [-0.0027883729150337544, 0.9875753219757257, 0.00019031478745134693, 0.0043074135887293434, 64.65869285097202, -0.01850600852353308, 0.10914951941692914, 1.3119955522852471, 0.2785423929227079, -10.422554014635185, 132.74417676737428, 5.8, 1.010812479964193, 0.9373475035655454, 0.7002804245828849, 0.10749553805932632, -0.4755314107774436, 0.6441635500230573, 0.6969434296634279, 0.7451008082258295, 0.8164126690428116, 0.6452662425821446, 0.7009728679192443, 0.7485674655637544, 0.8202008529660507, -0.4513041133209241, -0.3843625255726931, -0.32328535421299065, -0.23284108849453317, -0.451109124000057, -0.3802641064063484, -0.31974001454720613, -0.22864494051471876, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11098084542137228, 0.11097654170061792, 0.11052551874975461, 0.10094714715654933, 0.6534977865634748, -0.08708708708708705, 1.7402063666369994e-05, -3.2462462462462462, 0.611689351481185], "score_GlobalLocal_10D": 0.1800840198993683, "score_Basins_10D": 0.9751926064491272}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-2.3552887608095565e-05, 0.00042035549460059905], -3.0672996260052936]], "nr_of_basins": 1, "f_opt_dim_2": -3.0672998546405705, "x_opt_dim_2": [-1.6812304213547477e-09, 5.590679714472155e-09], "f_opt_dim_5": -3.8860466176021187, "x_opt_dim_5": [2.5513297574543303e-10, -2.9418367811685907e-09, 1.2612420731282104e-08, -9.583414483497168e-09, -1.0840753828785725e-08]}
{"id": "ae513536-4e77-41ba-93dd-8306ab710f7c", "fitness": 0.629360556602478, "name": "landscape_glocal_enhanced_homogeneous", "description": "A homogeneous-basin, torus-wrapped multi-well Gaussian landscape. Wells are placed on a regular grid (including the origin as global well) with toroidal distances to enforce equal basin volumes across the domain. The global basin at the origin is deeper (with adjustable contrast). The GlobalLocal score remains a scale-invariant measure of local peak prominence relative to the global minimum.", "code": "import numpy as np\nfrom itertools import product\n\nclass landscape_glocal_enhanced_homogeneous:\n    \"\"\"\n    A multi-basin minimization landscape with homogeneous basins by placing wells on a regular grid\n    and evaluating with a torus-wrapped distance to enforce equal basin volumes. The origin is the\n    global, deeper basin. GlobalLocal score is computed similarly to the reference implementation.\n\n    Properties:\n    - dim: number of dimensions\n    - s: coordinate distance from origin along each axis to place local wells (grid step)\n    - sigma: Gaussian width (controls basin size)\n    - A_global: base amplitude of the global well (will be amplified by 'contrast')\n    - A_local: amplitude of the local wells\n    - contrast: fractional increase applied to the global well depth\n    - coords_per_axis: list of coordinate values along each axis for grid generation\n    - domain is assumed to be [-5, 5] per dimension by default (torus wrap uses domain length)\n    \"\"\"\n    def __init__(self, dim=5, s=2.0, sigma=0.9, A_global=1.8, A_local=1.0, contrast=0.0, coords_per_axis=None, domain_bounds=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.contrast = float(contrast)\n\n        # Domain bounds and torus wrap length\n        self.domain_min, self.domain_max = float(domain_bounds[0]), float(domain_bounds[1])\n        self.domain_len = self.domain_max - self.domain_min  # e.g., 10.0 for [-5, 5]\n\n        # Grid coordinates per axis\n        if coords_per_axis is None:\n            coords_per_axis = [-self.s, 0.0, self.s]\n        self.coords_per_axis = [float(v) for v in coords_per_axis]\n\n        # Build centers: all combinations of grid coordinates across all dimensions\n        grid_coords = list(product(self.coords_per_axis, repeat=self.dim))\n        self.centers = [np.asarray(t, dtype=float) for t in grid_coords]\n\n        # Identify origin index (all zeros)\n        origin_vec = np.zeros(self.dim, dtype=float)\n        self.origin_idx = None\n        for i, c in enumerate(self.centers):\n            if np.allclose(c, origin_vec):\n                self.origin_idx = i\n                break\n        if self.origin_idx is None:\n            self.centers.insert(0, origin_vec)\n            self.origin_idx = 0\n\n        # Weights (amplitudes) for each center: local wells share A_local, origin gets A_global*(1+contrast)\n        self.weights = np.full(len(self.centers), self.A_local, dtype=float)\n        self.weights[self.origin_idx] = self.A_global * (1.0 + self.contrast)\n\n        # Precompute constant for Gaussian\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n    def _dist2_torus(self, x, c):\n        \"\"\"\n        Toroidal (wrap-around) squared distance between x and center c.\n        For each dimension, distance is min(|dx|, domain_len - |dx|).\n        \"\"\"\n        diff = x - c\n        dist = np.abs(diff)\n        L = self.domain_len\n        w = np.minimum(dist, L - dist)\n        return float(np.dot(w, w))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        x: 1D numpy array of length self.dim\n        Returns: scalar fitness value (to be minimized)\n        Landscape is a sum of negative Gaussians centered at all wells.\n        f(x) = sum_i -a_i * exp(-dist^2 / (2*sigma^2))\n        where a_i is the (global or local) amplitude for center i (origin has the amplified depth).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n        total = 0.0\n        for i, c in enumerate(self.centers):\n            a_eff = self.weights[i]\n            dist2 = self._dist2_torus(x, c)\n            total += -a_eff * np.exp(-dist2 / self._two_sigma2)\n        return float(total)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a robust, normalized GlobalLocal score.\n        - val_global: function value at the origin (global minimum candidate)\n        - val_local_min: minimum value among local wells (excluding origin)\n        - vals: function values at all basin centers (origin + local wells)\n        GlobalLocal score is the local-prominence relative to the global minimum,\n        normalized by the dispersion (standard deviation) of center values.\n        \"\"\"\n        origin = self.centers[self.origin_idx]\n        val_global = self.f(origin)\n\n        vals = [self.f(c) for c in self.centers]\n        # Exclude the origin when looking for the best local well\n        min_local = min(vals[i] for i in range(len(vals)) if i != self.origin_idx)\n\n        mean_center_value = float(np.mean(vals))\n        std_center_value = float(np.std(vals) + 1e-12)\n\n        diff = float(min_local) - float(val_global)  # should be >= 0 if global is deepest\n        gl_score = diff / std_center_value  # normalized by dispersion (scale-invariant)\n\n        return float(gl_score)\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_glocal_enhanced_homogeneous scored on:GlobalLocal 0.180, Basins 0.975,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19640fc0-ffd5-414c-b5d5-c8194dea4555"], "operator": null, "metadata": {"ela_features_2D": [-0.003791000353706142, 0.7545421149392648, 0.00560082112320575, 0.01202249405676005, 2.8961377314952026, -0.0037651317432071175, 0.7308031481441765, 1.0182473243526853, 0.9146343688844821, -0.8811183857559748, -0.5209905416591288, 2.0, 0.740058468772062, 0.7343747658500129, 0.5749536632925782, 0.3260041962034938, -0.1735338447299515, 0.14757932985738828, 0.22199274415062345, 0.3153414675269873, 0.493692717836326, 0.14914671283770026, 0.22668117572799415, 0.31925055797864976, 0.49493687221007787, -0.44576582194134895, -0.40685270063131307, -0.358036725056403, -0.2647659670023206, -0.43669926621466876, -0.39690546896270057, -0.3493921753305112, -0.25920148675309307, 1.0, 1.0, 1.0, 1.0, 0.5201982787715669, 0.5201749125781119, 0.3664143049892602, 0.3488661358549069, 0.5821897246348235, 0.5575575575575573, 0.2170029722341845, -0.2592592592592592, 0.35261044176706824], "score_GlobalLocal_2D": 0.9945245981216431, "score_Basins_2D": 0.006372386589646339, "ela_features": [-0.0030879323986313435, 0.9389670699900012, 0.0022595843240969644, 0.011550692205916886, 11.077515826523413, -0.00986996309408772, 0.38335078762110725, 1.0852676259065217, 0.7106523739582504, -3.2001381449762767, 10.49442061853604, 3.8, 0.895623487395546, 0.8707445583619279, 0.6202449450905531, 0.1871001917853645, -0.4393754690593542, 0.45363848745494345, 0.5431467018121727, 0.6147827994460254, 0.7297127765449688, 0.45551188582903157, 0.545121710769949, 0.6180919142018853, 0.7323633045230051, -0.48063144323782403, -0.4018914388179238, -0.33887493008162917, -0.23777130027256418, -0.4817005119104489, -0.40242405412332183, -0.3378707286734679, -0.23677644677043935, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21656873162253776, 0.2165548592521888, 0.20341396626417266, 0.18086774960985597, 0.6494105651131533, 0.4654654654654653, 0.00595629158637995, -1.2282282282282284, 0.5227564102564102], "score_GlobalLocal_5D": 0.9117748141288757, "score_Basins_5D": 0.708215057849884, "ela_features_10D": [-0.002839339511181915, 0.9883477194305463, 0.00017631105501389775, 0.003936090961891691, 128.2073661617117, -0.01919528370059278, 0.10203344104057017, 1.2923560784700538, 0.2665310695792507, -11.284745990577154, 159.92451827192218, 6.8, 1.0053066846306247, 0.9377944729264431, 0.6930467906045189, 0.10690234044648303, -0.4824017254396152, 0.6465724383655915, 0.6965649662117437, 0.7438114922423024, 0.8158115490423595, 0.6502745357213242, 0.6997003268512801, 0.7476624463034902, 0.8198494805129517, -0.44822527813216995, -0.3848237781539193, -0.324905067561568, -0.23359294140395628, -0.4446459576149451, -0.3818058701343035, -0.32082629450355016, -0.22904705611729717, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10894076181761589, 0.10893786184828165, 0.10853393903618277, 0.0991728654206481, 0.6476315933125146, -0.13113113113113112, 2.973782342085494e-05, -3.186186186186186, 0.601361088871097], "score_GlobalLocal_10D": 0.1800840198993683, "score_Basins_10D": 0.9751926064491272}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-6.797851378426752e-06, -3.325352830169928e-05], -2.167299853794624]], "nr_of_basins": 1, "f_opt_dim_2": -2.16729985464057, "x_opt_dim_2": [2.0098386405082312e-09, -8.295990246028628e-09], "f_opt_dim_5": -2.9860466176021188, "x_opt_dim_5": [2.139898037745921e-08, -2.028934188650856e-08, -2.1317138274801035e-08, -1.4229173894421623e-08, 1.6173144073408413e-08]}
{"id": "ec887cfa-946c-4fb9-aeeb-1f483d5eaf45", "fitness": 0.6492395401000977, "name": "landscape_glocal_enhanced_homogeneous_basins", "description": "A torus-wrapped, grid-based multi-well landscape with homogeneous basin volumes. It extends the selected GlobalLocal-enhanced design by placing wells on a symmetric grid (including the origin) with toroidal distances to enforce equal basin volumes, and it adds a gradient-descent based Basin size homogeneity score. The GlobalLocal score remains scale-invariant, while the Basins score quantifies how evenly basin sizes are distributed across all wells.", "code": "import numpy as np\nfrom itertools import product\n\nclass landscape_glocal_enhanced_homogeneous_basins:\n    def __init__(self, dim=5, grid=3, s=2.0, sigma=0.9, A_global=1.8, A_local=1.0, contrast=0.5):\n        \"\"\"\n        A torus-wrapped, multi-well landscape with a grid of wells to enforce homogeneous basin sizes.\n        - dim: number of dimensions\n        - grid: number of wells per axis (coordinates chosen from [-s, 0, s] for simplicity)\n        - s: axis center distance for local wells (grid centers lie on -s, 0, +s along each axis)\n        - sigma: Gaussian width (controls basin size)\n        - A_global: depth (amplitude) of the global well at the origin\n        - A_local: depth of the local wells\n        - contrast: additional depth factor applied to the global well (1+contrast)\n        Notes:\n        - The domain is [-5, 5] along each axis; wrap-around (torus) is used for distance computations.\n        - Wells are placed on a symmetric grid in all dimensions, excluding duplicates at the origin.\n        - Basins are estimated by gradient-descent trajectories from a coarse grid of sample points.\n        - The GlobalLocal score is computed similarly to the original implementation (scale-invariant).\n        \"\"\"\n        self.dim = int(dim)\n        self.grid = int(grid)\n        if self.grid < 2:\n            self.grid = 2\n        self.s = float(s)\n        self.sigma = float(sigma)\n        self.A_global = float(A_global)\n        self.A_local = float(A_local)\n        self.contrast = float(contrast)\n\n        # Domain\n        self.L = 10.0  # domain length per axis (from -5 to 5)\n        self.bounds = (-5.0, 5.0)\n\n        # Build centers and corresponding weights\n        self.centers = []\n        self.weights = []\n        self._build_centers()\n\n        # Precompute constants for efficient evaluation\n        self._two_sigma2 = 2.0 * (self.sigma ** 2)\n\n        # Basin cache to avoid recomputation for repeated calls\n        self._basin_cache = {}\n        self._basin_grid_cache = {}\n\n    def _build_centers(self):\n        \"\"\"\n        Build a symmetrical grid of centers on coordinates drawn from [-s, 0, s] along each axis.\n        The origin is included as the first (global) well.\n        All non-origin wells share the same local amplitude A_local; the origin uses A_global*(1+contrast).\n        \"\"\"\n        self.centers = []\n        self.weights = []\n\n        # Global well at origin\n        origin = np.zeros(self.dim, dtype=float)\n        self.centers.append(origin)\n        self.weights.append(self.A_global * (1.0 + self.contrast))\n\n        # Local wells on a grid defined by coordinates in [-s, 0, s]\n        coords = [-self.s, 0.0, self.s]\n        # Create all combinations except the origin\n        for combo in product(coords, repeat=self.dim):\n            c = np.array(combo, dtype=float)\n            if np.allclose(c, 0.0):\n                continue  # skip origin (already added)\n            self.centers.append(c)\n            self.weights.append(self.A_local)\n\n        # Convert to numpy arrays for faster operations\n        self.centers = [np.asarray(c) for c in self.centers]\n        self.weights = np.asarray(self.weights, dtype=float)\n\n    def _wrap_domain(self, x):\n        \"\"\"\n        Wraps a point into the domain [-5, 5) per axis (torus wrapping).\n        \"\"\"\n        return ((np.asarray(x) + 5.0) % self.L) - 5.0\n\n    def _torus_diff(self, x, c):\n        \"\"\"\n        Compute the toroidal (minimum image) difference vector between x and center c.\n        \"\"\"\n        diff = x - c\n        diff = (diff + self.L/2.0) % self.L - self.L/2.0\n        return diff\n\n    def f(self, x):\n        \"\"\"\n        Landscape value at point x.\n        f(x) = - sum_i a_i * exp(-||x - c_i||^2 / (2*sigma^2))  with toroidal distance.\n        The global well (origin) is amplified by the 'contrast' factor.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.size != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}. Got shape {x.shape}.\")\n\n        total = 0.0\n        for i, c in enumerate(self.centers):\n            diff = self._torus_diff(x, c)\n            dist2 = float(np.dot(diff, diff))\n            a_eff = self.weights[i] * (1.0 + self.contrast) if i == 0 else self.weights[i]\n            total += -a_eff * np.exp(-dist2 / self._two_sigma2)\n        return float(total)\n\n    def compute_global_local_score(self):\n        \"\"\"\n        Compute a robust, normalized GlobalLocal score.\n        - val_global: function value at the origin (global minimum candidate)\n        - val_local_min: minimum value among local wells (excluding origin)\n        - vals: function values at all basin centers (origin + local wells)\n        GlobalLocal score is the local-prominence relative to the global minimum,\n        normalized by the dispersion (standard deviation) of center values.\n        \"\"\"\n        origin = np.zeros(self.dim)\n        val_global = self.f(origin)\n\n        # compute local minima values (excluding origin)\n        vals = [self.f(c) for c in self.centers]\n        if len(vals) <= 1:\n            min_local = val_global\n        else:\n            min_local = min(vals[1:])\n\n        mean_center_value = float(np.mean(vals))\n        std_center_value = float(np.std(vals))\n\n        diff = float(min_local) - float(val_global)  # should be >= 0 if global is deepest\n        denom = std_center_value + 1e-9\n\n        gl_score = diff / denom  # normalized by dispersion (scale-invariant)\n\n        return float(gl_score)\n\n    @property\n    def GlobalLocal(self):\n        return self.compute_global_local_score()\n\n    def _gradient(self, x):\n        \"\"\"\n        Analytic gradient of f with torus-aware diffs.\n        grad f = sum_i a_i_eff * exp(-dist2_i/(2*sigma^2)) * diff_i / sigma^2\n        Note: dist is computed on the torus (minimum image).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        grad = np.zeros(self.dim, dtype=float)\n        for i, c in enumerate(self.centers):\n            diff = self._torus_diff(x, c)\n            dist2 = float(np.dot(diff, diff))\n            a_eff = self.weights[i] * (1.0 + self.contrast) if i == 0 else self.weights[i]\n            term = a_eff * np.exp(-dist2 / (2.0 * (self.sigma ** 2)))\n            grad += (term / (self.sigma ** 2)) * diff\n        return grad\n\n    def _nearest_center_idx(self, x):\n        \"\"\"\n        Find the index of the center whose toroidal distance to x is smallest.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        best_idx = 0\n        best_dist2 = None\n        for i, c in enumerate(self.centers):\n            diff = self._torus_diff(x, c)\n            dist2 = float(np.dot(diff, diff))\n            if best_dist2 is None or dist2 < best_dist2:\n                best_dist2 = dist2\n                best_idx = i\n        return best_idx\n\n    def _wrap_batch(self, X):\n        \"\"\"\n        Apply domain wrap to a batch of points X (shape: N x dim).\n        \"\"\"\n        X = np.asarray(X, dtype=float)\n        X_wrapped = self._wrap_domain(X)\n        return X_wrapped\n\n    def _gradient_descent_from(self, x0, lr=0.25, max_steps=200, tol=1e-6):\n        \"\"\"\n        Run a lightweight gradient-descent trajectory from x0 to a basin minimum.\n        Returns the final point after descent.\n        \"\"\"\n        x = np.asarray(x0, dtype=float).reshape(-1)\n        for _ in range(max_steps):\n            grad = self._gradient(x)\n            grad_norm = np.linalg.norm(grad)\n            if grad_norm < tol:\n                break\n            x = x - lr * grad\n            x = self._wrap_domain(x)\n        return x\n\n    def _compute_basin_counts(self, grid_points=3):\n        \"\"\"\n        Estimate basin sizes by performing gradient-descent starting from a coarse grid\n        across the domain and assigning each end-point to the nearest center.\n        Returns counts per center (array of length = number of centers).\n        \"\"\"\n        # Build or reuse a grid of starting points\n        key = f\"grid_{grid_points}\"\n        if key in self._basin_grid_cache:\n            pts = self._basin_grid_cache[key]\n        else:\n            coords = np.linspace(-5.0, 5.0, grid_points, endpoint=False)\n            mesh = np.meshgrid(*([coords] * self.dim), indexing='ij')\n            pts = np.stack([m.ravel() for m in mesh], axis=-1)  # shape (N, dim)\n            self._basin_grid_cache[key] = pts\n\n        counts = np.zeros(len(self.centers), dtype=int)\n\n        # Gradient descent parameters\n        lr = 0.25\n        max_steps = 200\n        tol = 1e-6\n\n        for x0 in pts:\n            x_final = self._gradient_descent_from(x0, lr=lr, max_steps=max_steps, tol=tol)\n            idx = self._nearest_center_idx(x_final)\n            counts[idx] += 1\n\n        return counts\n\n    def compute_basins_score(self, grid_points=3):\n        \"\"\"\n        Compute a Basin sizes homogeneity score.\n        - We estimate basin sizes by gradient-descent trajectories from a coarse grid.\n        - Basins sizes are given by counts per center.\n        - Basins score = max_count / max(1, min_nonzero_count) to avoid division by zero\n          and to reflect relative size uniformity across basins.\n        \"\"\"\n        counts = self._basin_cache.get(grid_points)\n        if counts is None:\n            counts = self._compute_basin_counts(grid_points=grid_points)\n            self._basin_cache[grid_points] = counts\n\n        maxc = int(counts.max()) if counts.size > 0 else 0\n        nonzero = counts[counts > 0]\n        if nonzero.size > 0:\n            minc = int(nonzero.min())\n        else:\n            minc = 1  # avoid division by zero; all-zero case\n        if minc <= 0:\n            minc = 1\n        basins_score = float(maxc) / float(minc)\n        return basins_score\n\n    @property\n    def Basins(self):\n        \"\"\"\n        Public accessor for the Basin homogeneity score. It computes a fresh estimate\n        using a moderate grid for stability.\n        \"\"\"\n        return self.compute_basins_score(grid_points=self.grid)\n", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_glocal_enhanced_homogeneous_basins scored on:GlobalLocal 0.404, Basins 0.975,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19640fc0-ffd5-414c-b5d5-c8194dea4555"], "operator": null, "metadata": {"ela_features_2D": [-0.003581376882895926, 0.8587754032648942, 0.00386965759391822, 0.012753064287145835, 4.364557263980006, -0.004824718973687814, 0.6014460892112778, 1.0130099935581574, 0.7754920587362493, -1.9072347220401535, 3.8717632346572564, 2.6, 0.7111314307512131, 0.7148817487218194, 0.5568214843730628, 0.34273330166056903, -0.17509973847650526, 0.14170117260966467, 0.22395410668017296, 0.31742823716738455, 0.4992231221563571, 0.14622730232630948, 0.228095490706869, 0.31928878409395367, 0.4986026295661491, -0.449134461732974, -0.40609280198753084, -0.35717903936304396, -0.2620464200599534, -0.4391818346694974, -0.3970722523355707, -0.350164649157509, -0.25791622337458503, 1.0, 1.0, 1.0, 1.0, 0.515416718969111, 0.5154090905078925, 0.4204071879457077, 0.3470294762950653, 0.5669714072008094, 0.6376376376376374, 0.18806813232102618, -0.43143143143143126, 0.3473895582329317], "score_GlobalLocal_2D": 0.953476071357727, "score_Basins_2D": 0.0026476862840354443, "ela_features": [-0.0032521678379532127, 0.9348154823564373, 0.0015858343379321013, 0.009576365735455101, 14.360652948585052, -0.009578660586878396, 0.3688367588865001, 1.140299265443325, 0.6997173173123808, -3.2803766394518816, 11.02053171686922, 4.2, 0.8968365197472238, 0.8726813899334769, 0.6292423693333415, 0.1849029015518734, -0.4287172080408011, 0.4554832048391022, 0.5360197725357854, 0.6121969406783923, 0.7294786949244904, 0.45717579707791095, 0.5405285033510812, 0.6141947155369223, 0.7325691069047127, -0.478934288587168, -0.40809974990995473, -0.3410975114976041, -0.2379405354263458, -0.4798654782985146, -0.4061886397374311, -0.3410668364586093, -0.2364193809370362, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2168874476060813, 0.21688947658580587, 0.20564925464673686, 0.1811222263297309, 0.642628618107699, 0.4294294294294293, 0.005066004613321754, -1.2842842842842845, 0.5373397435897436], "score_GlobalLocal_5D": 0.9558270573616028, "score_Basins_5D": 0.603797197341919, "ela_features_10D": [-0.0027254795126577134, 0.9923760935035173, 0.0002197522360596335, 0.0035207344654234725, 42.72947905888268, -0.018950420026320237, 0.10466734690204851, 1.3327498380403244, 0.270728220709212, -11.448690709037043, 165.6165219853288, 6.2, 1.0024545158658458, 0.9362929380370586, 0.6842575766662055, 0.10849489096785776, -0.47500428610383605, 0.6427871089530973, 0.6982002947916338, 0.7444859465854976, 0.8166097903292705, 0.6429322621420089, 0.7016051898958644, 0.7485080234889161, 0.8203453169504076, -0.4530600311957896, -0.38277838977240863, -0.32407328815526065, -0.2325970617453669, -0.4541090891903658, -0.37949066146455096, -0.31984031573667104, -0.22847899766846363, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10869643449132134, 0.10869890588274174, 0.10833716603037494, 0.09906604968214171, 0.6536439360815837, -0.12312312312312308, 2.0279583985978987e-05, -3.2262262262262262, 0.610408326661329], "score_GlobalLocal_10D": 0.4044966995716095, "score_Basins_10D": 0.9751926064491272}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\n- Basin size homogeneity, meaning the size relation (largest to smallest) of all basins of attraction should be homogeneous. (Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, -0.00044444444444512003], -4.4172990158413]], "nr_of_basins": 1, "f_opt_dim_2": -4.417299854640572, "x_opt_dim_2": [-6.83910118114612e-09, 5.467365980323393e-10], "f_opt_dim_5": -5.236046617602135, "x_opt_dim_5": [-1.1787827355165763e-08, 1.2368107847829232e-08, 1.0766308353089054e-09, 2.3209751488059744e-09, 1.5699256210923302e-09]}
