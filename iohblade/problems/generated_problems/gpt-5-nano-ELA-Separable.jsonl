{"id": "5520eaad-c3de-406f-a6ca-184be121dabc", "fitness": 1.0, "name": "landscape", "description": "Separable, multi-modal landscape where each dimension is attracted toward 1 but modulated by a per-dimension periodic ripple. The global minimum occurs at x = [1, 1, ..., 1], with f(x) = 0. Each dimension has its own frequency, creating many local minima while preserving separability.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # per-dimension ripple amplitude and frequency\n        self.A = 0.3  # ripple amplitude\n        self.k = np.arange(1, self.dim + 1)  # frequency parameter per dimension (1, 2, ..., dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        # Separable per-dimension function:\n        # g_i(x_i) = (x_i - 1)^2 + A * sin^2(2*pi * k_i * x_i)\n        quad_term = (x - 1.0) ** 2\n        ripple_term = self.A * np.sin(2.0 * np.pi * self.k * x) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.36954775344365043, 0.5732110578404226, 0.2854187796067939, 0.30557889433799873, 1.0724342736790644, 0.374477627361553, 0.9998746878416641, 1.0029206652729865, 0.999873716505131, 0.8211314150103094, 0.22038842490538374, 1.2, 0.7181687236080043, 0.7194130265911396, 0.5727287916326096, 0.3389418128435596, -0.1597769269762101, 0.14117400893458848, 0.21342033855651174, 0.3033521774254917, 0.4883235749712659, 0.143759952140948, 0.214437132142469, 0.30600394219102584, 0.4879213068609006, -0.44915149318664893, -0.41136765187790736, -0.3643345024654163, -0.26759835028632933, -0.43935630106744095, -0.4030909809839372, -0.35610065534165763, -0.2627567045111682, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5293058982261526, 0.529297686567922, 0.5001811438666108, 0.5377792381134369, 0.7148858917112484, 0.30130130130130117, 0.3596905158737521, -0.25525525525525516, 0.3755020080321285], "score_Separable_2D": 1.0, "ela_features": [0.37881595967854825, 0.7701650592408094, 0.1510744543088027, 0.1800412434669588, 1.1912856833899117, 0.38395011843812626, 0.9998722660712843, 1.0020351582098432, 0.9998727439377134, 0.5031809496516675, 0.008513245886638644, 1.4, 0.9081420106145677, 0.8755435412326914, 0.6467083836568496, 0.18134831259103112, -0.4013254714396606, 0.4447706965407269, 0.5281491775918981, 0.6013577272987287, 0.7211076697189553, 0.4504975042537299, 0.5327433070838673, 0.6052691833113946, 0.7263041778835871, -0.48843289465126427, -0.41508503788993484, -0.35068396141793684, -0.24534041482548857, -0.4859735790666922, -0.41323606933323365, -0.3490949008036939, -0.24205283203259076, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21525478782043456, 0.21526308363371469, 0.21794348624877724, 0.26773743642203385, 0.8205228109002147, 0.06106106106106102, 0.18920902036111226, -0.4674674674674673, 0.5049679487179487], "score_Separable_5D": 1.0, "ela_features_10D": [0.3662064338682436, 0.9005524390588986, 0.08947728471908023, 0.11326721939938197, 1.2696018399733449, 0.36836098235847914, 0.9998720632320042, 1.002843923815456, 0.9998725658909567, 0.3603123484788117, -0.00047359672265789854, 1.4, 1.0134541227179321, 0.9381221001784332, 0.7176022631585144, 0.10423942562481134, -0.5249542697492877, 0.6237694452663635, 0.6883441365679183, 0.7415985007145063, 0.8222754533506557, 0.6289522380511279, 0.692253003264663, 0.7463545780126594, 0.8270039768732425, -0.4771420687609835, -0.39524697904804773, -0.3277089069609377, -0.22539296098593037, -0.47177508181880984, -0.39128930709763105, -0.322501169400122, -0.21995795450444283, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11034116354617655, 0.11033646366960141, 0.11123415476605873, 0.14605257040345287, 0.8510727903502936, -0.18718718718718713, 0.11629613060750144, -0.7037037037037035, 0.5698959167333867], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [0.5400836592504821, -0.46368172651823275], 2.43078472851452], [1, [1.4579831293446766, -0.4523719472718103], 2.4347907752371034], [6, [0.5429351963476987, -0.7052992788524064], 3.2233761167789767], [2, [1.3375249335023438, 2.2026985048602907], 1.8725496828835049], [6, [0.511420550843995, 0.5425901647357383], 0.5275107271837842], [1, [1.4526711755615684, 0.5551852053936077], 0.5511071803481223], [5, [0.5112112123051271, 1.6801626628069348], 0.8805264956540894], [1, [1.4546704942981694, 1.6669953947214116], 0.8992170232918335], [8, [0.5405923375475195, 2.705743616281345], 3.2233200565004947], [3, [1.887784492800815, 1.6671343786905235], 1.5827027613099136], [3, [1.8797914938581912, 0.5546596870667642], 1.2339683914889024], [10, [1.8990972518860332, 2.7046504852466655], 3.906805690764204], [10, [1.4591920269455647, -0.7056430181035607], 3.2233180223974367], [18, [0.10112294570035318, -0.7046960733692619], 3.9068054532068324], [11, [0.10863887140996044, 1.6846981140658144], 1.5432671175326989], [2, [0.12751275398844822, 1.489150591137376], 1.1607798621079621], [11, [1.9000692434025996, -0.4642522113427254], 3.114257827767907]], "nr_of_basins": 17, "f_opt_dim_2": 8.998558695971146e-32, "x_opt_dim_2": [1.0, 1.0], "f_opt_dim_5": 0.08872572595908619, "x_opt_dim_5": [1.0000000003412333, 1.2448176078158737, 1.1651167272339487, 1.0000000001273128, 0.9999999998984178]}
{"id": "06427b31-0240-4ea8-8eaf-548fe78725e7", "fitness": 1.0, "name": "landscape", "description": "A separable, non-convex benchmark with per-dimension ridges. Each dimension contributes g(x) = x^2 * (1 + sin^2(3x)), ensuring a global minimum at x = 0 with f(x) = 0. The function is the sum over dimensions, making it separable: optimization reduces to independent single-dimension subproblems. The landscape features oscillatory ridges due to the sin^2 term while preserving non-negativity and bounded input in [-5, 5].", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension {x.size} does not match landscape dimension {self.dim}.\")\n        # Per-dimension separable part: g(x) = x^2 * (1 + sin^2(3x))\n        per_dim = x**2 * (1.0 + np.sin(3.0 * x)**2)\n        return float(np.sum(per_dim))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.00219667877996661, 0.29530612020270164, 0.01620340076441421, 0.022906640709347295, 1.4826197003982124, 0.0022914066575415726, 0.9083326865449314, 1.0103051288121692, 0.9093668733670661, 0.7408705631547342, 0.16614360687917246, 1.2, 0.5222626453194831, 0.6376198663543537, 0.42625987648780617, 0.38943836591727765, -0.2531146628431985, 0.12814408126684512, 0.21099363440569835, 0.3148560813083875, 0.5002062396459379, 0.12542548940049306, 0.21252588761021746, 0.31018798556342936, 0.49623322743803877, -0.4563873157571451, -0.4130151836849413, -0.35864692878168314, -0.26162059898269546, -0.44994925518174494, -0.4051340038823046, -0.35488621861050246, -0.25916124344095987, 1.0, 1.0, 1.0, 1.0, 0.5079713572963127, 0.5079110040002156, 0.4087630448303444, 0.3477536099927774, 0.764754217020746, 0.9019019019019016, 0.70998466146671, 0.12512512512512508, 0.5144578313253012], "score_Separable_2D": 1.0, "ela_features": [-0.0004064872485791904, 0.36226890081007473, 0.003391804209879721, 0.025799832054755317, 16.736956767588445, 0.002817903323547677, 0.9097882941405022, 1.0520084062589379, 0.9103688317283838, 0.4457712882600508, 0.03818827859476599, 1.4, 0.880998310919221, 0.8654082045155824, 0.6079166785550786, 0.19171224668518408, -0.5011375888619095, 0.4377857118600539, 0.5223808107531065, 0.6055910178643087, 0.7250982008697806, 0.43780220221395416, 0.5233326199747719, 0.606166689030539, 0.72665578154616, -0.49453986974663, -0.42012676617460043, -0.3469341462396674, -0.24181242513279977, -0.4970689476178439, -0.421445019871307, -0.3482096123046194, -0.24167802425771684, 1.0, 1.0, 0.8333333333333334, 1.0, 0.22005078588502433, 0.2200509267265752, 0.20573907052591117, 0.18563253485303094, 0.8453312050157962, 0.26126126126126115, 0.2863744186876016, -0.3073073073073072, 0.5538461538461539], "score_Separable_5D": 1.0, "ela_features_10D": [-0.000967065353986496, 0.41051122576698373, 0.000843511600318223, 0.015888467393042706, 70.38142946862014, 0.0032435591913802186, 0.9110133429066943, 1.064746287068455, 0.9119601175577401, 0.32223419126023856, 0.056540052022697296, 1.4, 1.0049673886055506, 0.9368438940368042, 0.7001791652308219, 0.10680104599437679, -0.6074332232166445, 0.6235377993779082, 0.6857657026494534, 0.7367276124229453, 0.8152063153960398, 0.6269916524869451, 0.6883511809605463, 0.7398576117002482, 0.8187387576653423, -0.47747692929948904, -0.39855200413637704, -0.33391585239346777, -0.23437899537156687, -0.47439202045032597, -0.3963558772762072, -0.33085058343481444, -0.23052889402441398, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10855763411916722, 0.10854111831869698, 0.10588047327977368, 0.09926949670149411, 0.8577454504440724, -0.10310310310310307, 0.13845111840931182, -0.6516516516516514, 0.6027221777421937], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 71.1437137528104], [1, [-3.888888888888889, -5.0], 59.97072205016008], [1, [-2.7777777777777777, -5.0], 49.36268121482774], [1, [2.7777777777777786, -5.0], 49.362681214827724], [1, [3.8888888888888893, -5.0], 59.97072205016006], [1, [5.0, -5.0], 71.1437137528104], [1, [-5.0, -3.888888888888889], 59.97072205016008], [1, [-3.888888888888889, -3.888888888888889], 48.797730347509756], [1, [3.8888888888888893, -3.888888888888889], 48.79773034750974], [1, [5.0, -3.888888888888889], 59.97072205016008], [1, [-5.0, -2.7777777777777777], 49.36268121482774], [1, [5.0, -2.7777777777777777], 49.36268121482774], [1, [-5.0, 2.7777777777777786], 49.362681214827724], [1, [5.0, 2.7777777777777786], 49.362681214827724], [1, [-5.0, 3.8888888888888893], 59.97072205016006], [1, [-3.888888888888889, 3.8888888888888893], 48.79773034750974], [1, [3.8888888888888893, 3.8888888888888893], 48.79773034750972], [1, [5.0, 3.8888888888888893], 59.97072205016006], [1, [-5.0, 5.0], 71.1437137528104], [1, [-3.888888888888889, 5.0], 59.97072205016008], [1, [-2.7777777777777777, 5.0], 49.36268121482774], [1, [2.7777777777777786, 5.0], 49.362681214827724], [1, [3.8888888888888893, 5.0], 59.97072205016006], [1, [5.0, 5.0], 71.1437137528104], [4, [0.00044444444444512003, -5.0], 35.571857073936414], [4, [0.00044444444444512003, -3.888888888888889], 24.398865371286092], [4, [0.00044444444444512003, -2.7777777777777777], 13.790824535953753], [4, [-5.0, 0.00044444444444512003], 35.571857073936414], [4, [-3.888888888888889, 0.00044444444444512003], 24.398865371286092], [4, [-2.7777777777777777, 0.00044444444444512003], 13.790824535953753], [4, [2.7777777777777786, 0.00044444444444512003], 13.790824535953737], [4, [3.8888888888888893, 0.00044444444444512003], 24.398865371286075], [4, [5.0, 0.00044444444444512003], 35.571857073936414], [4, [0.00044444444444512003, 2.7777777777777786], 13.790824535953737], [4, [0.00044444444444512003, 3.8888888888888893], 24.398865371286075], [4, [0.00044444444444512003, 5.0], 35.571857073936414], [16, [0.00044444444444512003, 0.00044444444444512003], 3.9506243072780816e-07], [1, [2.0354281806091574, -3.943734754987945], 26.82089229625676], [1, [-3.943748424373362, 2.033428210585957], 26.820759196572055], [1, [-2.898754298383426, 2.0435743662003523], 16.399740046693985], [1, [2.898842695590509, 2.04378114903815], 16.398353969429447], [1, [2.037428233646383, 3.9437294242412686], 26.820987847800932], [1, [-3.9441418968294264, -2.015425656943194], 26.821061096026618], [1, [-2.0194231762006445, -3.9440021781730294], 26.821176869247726], [1, [3.943861650195279, 2.025429073032459], 26.820662232509452], [1, [3.944153201342831, -2.015425524113326], 26.820665671602587], [1, [-2.0194231868244055, 3.9440041909853565], 26.821106424520863], [1, [2.0416775611602116, -2.8987966169824406], 16.398356478464663], [1, [-2.027567991817586, -2.8989203531563073], 16.398513259737975]], "nr_of_basins": 49, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.401862015981187e-163, 1.0470681646456818e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.3896396322340963e-162, 1.0879183324481955e-162, -6.55807443008055e-163, 9.559706800136676e-163, 5.812487779436165e-163]}
{"id": "f9df51a3-f743-4613-8cf0-cf830443a74d", "fitness": 1.0, "name": "landscape", "description": "A novel separable landscape combining a per-dimension quadratic term with a cosine modulation. Each dimension has its own amplitude and frequency, creating multiple local undulations while preserving a unique global minimum at the origin. The overall function is a sum of independent 1D landscapes: f(x) = sum_i [ w_i * x_i^2 + b_i * (1 - cos(k_i * x_i)) ].", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic parameters for reproducibility\n        rng = np.random.RandomState(12345)\n        # Per-dimension parameters\n        self.w = rng.uniform(0.5, 5.0, size=self.dim)  # quadratic weights\n        self.b = rng.uniform(0.5, 5.0, size=self.dim)  # cosine modulation amplitudes\n        self.k = rng.uniform(0.5, 3.0, size=self.dim)  # cosine frequencies\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension {} does not match landscape dimensionality {}\".format(x.shape[0], self.dim))\n        # Separable per-dimension landscape: g_i(x_i) = w_i * x_i^2 + b_i * (1 - cos(k_i * x_i))\n        return float(np.sum(self.w * (x ** 2) + self.b * (1.0 - np.cos(self.k * x))))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.001286159916594598, 0.34186149853738235, 0.007795973753840679, 0.037034401218868626, 15.250844095325501, 0.005160914698973218, 0.9987370246830176, 2.407334669751761, 0.9987329144550063, 0.5693299279662124, -0.6217874706392713, 1.2, 0.7213276821814159, 0.7199422526805517, 0.5640923964553501, 0.3371789757658938, -0.20292655838756266, 0.13093371529192327, 0.21848389894091555, 0.32536350974793204, 0.5060803196627457, 0.13423397768484419, 0.21710842381048842, 0.31458922083664426, 0.49315039832696794, -0.4545600411395436, -0.40876767208911524, -0.3528654768486151, -0.25834209347263026, -0.44386089123267036, -0.40137376739468866, -0.35140013228253153, -0.2598506481722959, 1.0, 1.0, 1.0, 1.0, 0.5234720317755055, 0.5234164774179817, 0.39592961599659704, 0.3581780331070381, 0.6818517040586135, 0.4494494494494493, 0.5785889253415994, -0.0790790790790791, 0.3437751004016064], "score_Separable_2D": 1.0, "ela_features": [-0.0014922570554829929, 0.42934302674723, 0.0018968352310878571, 0.025864005869965602, 18.59400671992443, 0.0002802936561145497, 0.9894602735137183, 2.9415586704933387, 0.9894358934045735, 0.31040922826916034, -0.38552936555834216, 1.0, 0.8890459772993713, 0.869635084247177, 0.6334184436951299, 0.1859579540259047, -0.46435856150109184, 0.4727138584891775, 0.5501465513431804, 0.6277923351669831, 0.7375149179036504, 0.46587915617304976, 0.5467717845101053, 0.6259676083222461, 0.7365654313007457, -0.4639353528766872, -0.3958050171076688, -0.32748937794758726, -0.23094792355354646, -0.4725444033505338, -0.4009780387273631, -0.330916129539792, -0.23306482664108885, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21675912226417432, 0.21674407245451519, 0.1999998215195891, 0.18164563457819977, 0.8224453592930503, 0.1731731731731731, 0.26138372727724074, -0.3353353353353352, 0.5064102564102564], "score_Separable_5D": 1.0, "ela_features_10D": [-0.00024653257474644975, 0.42585088281384725, 0.0014115678489734175, 0.018554997640746564, 51.75239397224209, 0.005100919653151159, 0.991425195157165, 3.6203962534810366, 0.9913922964662101, 0.2668944433799634, -0.07266365171422899, 1.4, 1.0128482840020743, 0.9363765264499202, 0.7018528218795487, 0.10796509243156113, -0.5951362079794945, 0.6385433575597383, 0.7019747769591966, 0.7490006527091728, 0.820906740463981, 0.6399625840682258, 0.7022517598880352, 0.7501002825457016, 0.8235403801343896, -0.4583853317759504, -0.37794401724918536, -0.31830762341044616, -0.22711908059456087, -0.4576962443243472, -0.3785107961897311, -0.31768337682108455, -0.2243230274330176, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10913587148903017, 0.10913590136263607, 0.10594340952335098, 0.09943418246401041, 0.8558217858305127, -0.1071071071071071, 0.12719591510397388, -0.6316316316316314, 0.5876701361088872], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.3430701623785526e-06]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.5658793336373957e-162, -1.1366681047827635e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [7.306974647593202e-163, -3.0281193046638815e-163, 2.2022702028512042e-164, -3.508449620798975e-163, -3.107722827781062e-163]}
{"id": "5dc7f412-7c1b-4e97-b18d-841457558527", "fitness": 1.0, "name": "landscape", "description": "A separable, multi-modal benchmark where each dimension is a quadratic base with a high-frequency cosine modulation. This creates many local minima per dimension while preserving separability; the global minimum is at the origin (x = 0) with f = 0. The landscape is defined on [-5, 5] per dimension and allows easy subproblem partitioning.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = dim\n        rng = np.random.default_rng(seed=42)\n        # Per-dimension frequency (k_i) and amplitude (a_i) for diversity across dimensions\n        self.k = rng.integers(3, 9, size=dim).astype(float)  # frequencies in [3,8]\n        self.a = rng.uniform(0.25, 0.75, size=dim)         # amplitudes in [0.25, 0.75]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        # Separable per-dimension landscape: g_i(x_i) = x_i^2 + a_i * (1 - cos(k_i * x_i))\n        g = x**2 + self.a * (1.0 - np.cos(self.k * x))\n        return float(np.sum(g))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0023259546242402783, 0.37457962719622506, 0.008856876165245926, 0.02512490695088852, 8.561358024191614, -0.0012710356874886086, 0.9970090408668894, 1.008145825075211, 0.9970116925697201, 0.49364410423416805, -0.33434536597526454, 1.6, 0.6800482001077089, 0.7070684668316669, 0.5458931835771137, 0.34386786054114865, -0.19851111610252242, 0.15361879802135758, 0.2232833817691558, 0.31771472248167704, 0.49014562426817304, 0.14608251433649208, 0.21961630643148808, 0.31720317018659616, 0.4909275928127398, -0.4428481505676759, -0.406389043414973, -0.3569832611905096, -0.2667657547692924, -0.43874795735698574, -0.40094470977708124, -0.35081232293051723, -0.2615579684688011, 1.0, 1.0, 1.0, 1.0, 0.5126381423799083, 0.5126048965132173, 0.3999213372725111, 0.35116660643747566, 0.7230954411028747, 0.4694694694694693, 0.514924325233294, -0.12312312312312308, 0.38915662650602406], "score_Separable_2D": 1.0, "ela_features": [-0.0016433038045601922, 0.40970140631847185, 0.0042853027333679, 0.0216603207411109, 18.601549960199968, 0.004809156420394411, 0.9967866898639821, 1.0137938008036456, 0.9967816822631917, 0.267115081232861, -0.22068544616325828, 1.0, 0.9081764698665407, 0.8746824750575805, 0.6427234251803895, 0.1811191447130439, -0.47341843060511424, 0.42485205635632156, 0.514800609367787, 0.5959933702093769, 0.7160011410367881, 0.42691229763154476, 0.5164882704091116, 0.5980907092453233, 0.7198464260913094, -0.5059458379020766, -0.4268178100097663, -0.35539326737735655, -0.24982473432242527, -0.5067784013166532, -0.42755779649283704, -0.35539648911900806, -0.24772738922687432, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2181385514664959, 0.21815443062617962, 0.20346467745282482, 0.1826833631853087, 0.828151293320518, 0.12512512512512508, 0.2666089253822253, -0.38738738738738726, 0.5165064102564102], "score_Separable_5D": 1.0, "ela_features_10D": [-0.00041580331759520915, 0.4202742435286715, 0.0007517935686306844, 0.01868060254063213, 39.991679276458946, 0.004679070517462325, 0.9970097631639915, 1.0175170613145608, 0.997000846810816, 0.1914015099648956, -0.10436293065459604, 1.4, 1.018812713287487, 0.9396780179243793, 0.7132134660963189, 0.10396029336517536, -0.608263668379785, 0.6214627563082956, 0.6788984239911218, 0.7298789306786976, 0.8082272047618515, 0.6242746275880634, 0.6826367094250806, 0.7338497629577925, 0.8129873834701564, -0.48009263669235847, -0.407248168275739, -0.3425905384020281, -0.24322263123640755, -0.4778062390988119, -0.4035883829583432, -0.3384613512488944, -0.23782271516319894, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10877584101877757, 0.1087803431872143, 0.10581243839821378, 0.09948727528252857, 0.8531820598944526, -0.12712712712712704, 0.12981290749772834, -0.6436436436436435, 0.5903122497998399], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[40, [0.00044444444444512003, -1.6828888888890965], 3.031438183765002], [40, [0.00044444444444512003, 1.682666666666667], 3.0314386140295286], [10, [0.00044444444444512003, -0.5555555555555554], 1.4862271611832072], [10, [0.00044444444444512003, 0.5555555555555554], 1.4862271611832072]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.5714400991680712e-162, -3.6928147684764504e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.5324129470718393e-163, 9.721184082420392e-163, 7.25389671735245e-163, 1.1939548195657432e-162, 1.2408020624853769e-163]}
{"id": "18b926d4-f4a7-4e3e-801a-4d4481f85c9a", "fitness": 1.0, "name": "landscape", "description": "A separable multi-well benchmark where each dimension is a sum of a quadratic basin centered at a_i plus a cosine-based micro-well with frequency \u03c9_i and amplitude p_i. The per-dimension parameters are deterministically chosen from the dimension index, yielding diverse but decoupled landscapes. The global optimum is the sum of the per-dimension optima.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic and reproducible)\n        self.a = np.zeros(self.dim)      # center offset per dimension\n        self.omega = np.zeros(self.dim)  # frequency per dimension\n        self.p = np.zeros(self.dim)      # amplitude per dimension\n\n        for i in range(self.dim):\n            # Normalize i to [0,1] across dimensions\n            t = i / float(max(1, self.dim - 1))\n            # Offsets in [-2, 2]\n            self.a[i] = -2.0 + 4.0 * t\n            # Frequencies: a small set of distinct values, ensuring multiple local minima\n            self.omega[i] = 2.0 * np.pi * (1.0 + (i % 5) / 5.0)\n            # Amplitudes in [0.3, ~2.0]\n            self.p[i] = 0.3 + 1.7 * ((i % 7) / 7.0)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape == (self.dim,):\n            xi = x\n        else:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension landscape: (x_i - a_i)^2 + p_i * (1 - cos(omega_i * x_i))\n        diff = xi - self.a\n        term = diff**2 + self.p * (1.0 - np.cos(self.omega * xi))\n        return float(np.sum(term))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.693984234755771, 0.27514686589449555, 0.4344120547618632, 0.44522563339249704, 1.024895598129255, 0.6953362775653553, 0.9994959825065161, 1.000964039446697, 0.999492887128827, 0.7730046146706212, -0.08565607528866233, 1.4, 0.7047750934188471, 0.7066175733772153, 0.5538587627191399, 0.3522195550255898, -0.12606757425428944, 0.18524360415635283, 0.22812546996966465, 0.3168923797620162, 0.4859675436549483, 0.18228980229607922, 0.22792568759958898, 0.3180433382558562, 0.48948396250783655, -0.4261593675102192, -0.4037290127880732, -0.3572986797167201, -0.26886480488097725, -0.4192326987431934, -0.39583735853635826, -0.34963479793484725, -0.2617377250223318, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5226485342257761, 0.5226304501109078, 0.5575803228331631, 0.6078570099702529, 0.7164847151536577, 0.26126126126126115, 0.26423503827582645, -0.3513513513513513, 0.3951807228915663], "score_Separable_2D": 1.0, "ela_features": [0.5354635912069396, 0.344199270091722, 0.003950576001272757, 0.2774483820747002, 81.36107341062296, 0.5365724295023914, 0.9970153242532257, 1.0074811748971828, 0.9970192017037881, 0.5021625962690115, -0.05736174598862975, 1.8, 0.8986032550532403, 0.8666317583142049, 0.6341337989377289, 0.18999840101740956, -0.36544045385727497, 0.4286848343005586, 0.5209295582119988, 0.6006728233431521, 0.7296463684616701, 0.4263804640094574, 0.522373973665221, 0.602972971944312, 0.7326429561514555, -0.5024143171673146, -0.42129373571766393, -0.35116796897239677, -0.23774894327342827, -0.5068928714175744, -0.42206506219005585, -0.3508427005032994, -0.2362560816284323, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2159818334333452, 0.21598225737392066, 0.22770866610911575, 0.2878510939939453, 0.8198926680586194, 0.009009009009009, 0.17088898785673126, -0.5275275275275273, 0.5004807692307691], "score_Separable_5D": 1.0, "ela_features_10D": [0.4871955213156851, 0.39012170314406225, 0.01768948352591556, 0.17916582752200774, 10.732599864910913, 0.48879923440260376, 0.9954640711454292, 1.0179048649175118, 0.995453929097654, 0.3829978670097388, 0.07553392385521711, 1.6, 1.0079419424168752, 0.9374359996570536, 0.711632228361646, 0.10472976545850683, -0.4975414710354501, 0.6246129950697001, 0.6906494427532787, 0.7459997407816924, 0.8284180948707517, 0.6263153999446401, 0.6940833220838882, 0.749892295387428, 0.8321801821123955, -0.47606116528676257, -0.3923144450360758, -0.3221199250839109, -0.21759823801323472, -0.47507408680744306, -0.3889189707103812, -0.31796770765792975, -0.21335279152120265, 0.9, 0.9, 0.8545454545454545, 0.909090909090909, 0.10928150591317332, 0.10928319665321914, 0.11442745786064043, 0.15581677576115677, 0.8457990538191641, -0.22722722722722719, 0.10578084773663048, -0.7637637637637635, 0.5650920736589271], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-1.6666666666666665, 1.666666666666667], 0.6722222222222225], [3, [-2.82882936202025, 3.2467051267600313], 2.51038133507193], [3, [-1.6667536841073642, 2.465779107743334], 0.7958312806542137], [3, [-2.8288888888890056, 2.4697777777778125], 1.0790936884754785], [4, [-2.8288888888890056, 0.9075555555555557], 2.1206141860949153], [1, [-1.9249306124707493, 3.071318155555217], 1.9427445335460725], [3, [-2.8051355472374304, 1.6803887151018628], 0.9514357625576801], [4, [-2.816988689355123, 3.989655544799551], 5.219466722032978], [2, [-1.184382813034251, 3.9895889912716136], 5.219591734376379], [15, [-2.828754678279194, 0.14958529743416227], 4.578589305583855], [34, [-1.170592916492856, 0.1497325073423043], 4.578589807038807], [10, [-1.1706522246638507, 3.2419965711380563], 2.5106447651717305], [7, [-1.1714654456490114, 0.9080729007476167], 2.120612320059145], [10, [-1.1716855271155975, 1.687154072735413], 0.9487073443132449]], "nr_of_basins": 14, "f_opt_dim_2": 0.20248772805321102, "x_opt_dim_2": [-2.089951952262928, 1.7395407216595355], "f_opt_dim_5": 0.19716741593038262, "x_opt_dim_5": [-1.999999998791645, -0.8434864296844585, 2.0225437380546968e-11, 1.2452791573876942, 1.6707175873303208]}
{"id": "521d64e2-cc68-4029-94dd-4b1c57a43be9", "fitness": 1.0, "name": "landscape", "description": "A novel separable landscape combining a quadratic well with a dimension-dependent periodic modulation. Each dimension contributes g_i(x_i) = (x_i)^2 + a_i*(1 - cos(b_i*x_i)), where b_i is a fixed frequency and a_i is a dimension-specific amplitude. The sum across dimensions yields a separable, smooth, multi-modal landscape with a unique global minimum at x = 0 for all dimensions, while the periodic term introduces controllable roughness to the search space. All coordinates lie in [-5, 5].", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension frequencies for the cosine modulation\n        # Use a small preset list and wrap if needed to ensure reproducibility\n        base_freq = np.array([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0], dtype=float)\n        if self.dim <= len(base_freq):\n            self.freq = base_freq[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_freq)))\n            self.freq = np.tile(base_freq, reps)[:self.dim]\n\n        # Amplitude of the periodic modulation per dimension (increasing slightly across dims)\n        if self.dim == 1:\n            self.amp_per_dim = np.array([0.6], dtype=float)\n        else:\n            self.amp_per_dim = 0.3 + 0.4 * (np.arange(self.dim) / (self.dim - 1))\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension component: g_i(x_i) = (x_i)^2 + a_i*(1 - cos(b_i * x_i))\n        quad = x**2\n        periodic = self.amp_per_dim * (1.0 - np.cos(self.freq * x))\n        return float(np.sum(quad + periodic))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.001215897390465992, 0.3693772478472287, 0.010538339301537667, 0.027719588423785635, 10.942019731904027, -0.0012683198356752134, 0.9976139098294509, 1.0139052666316364, 0.9976150922774913, 0.452628826767939, -0.5107043458880517, 1.6, 0.6998918650064271, 0.7115832037516103, 0.5457265590600707, 0.3458401437729367, -0.2034348357533359, 0.13556416417068406, 0.21688963869684708, 0.31127898069272647, 0.487081182418342, 0.12945116952212593, 0.2180811559891774, 0.3110917418632355, 0.48965086378543976, -0.45229964872446377, -0.4097480740418761, -0.36036034509616754, -0.2683755035946539, -0.4467859556408162, -0.4013171280386419, -0.35357515673872, -0.26193127793816134, 1.0, 1.0, 1.0, 1.0, 0.5150352670923934, 0.5149229806165807, 0.39754353585376995, 0.35159246541447253, 0.7242371982310065, 0.44144144144144126, 0.5351034615707146, -0.09109109109109106, 0.38714859437751004], "score_Separable_2D": 1.0, "ela_features": [0.0008815436826354218, 0.4258136164035708, 0.002859410842935972, 0.03402968925357508, 16.5166744710724, 0.00905486740639223, 0.9976032321883519, 1.0158508215822173, 0.9976036555175961, 0.31074697743373203, -0.21375294220870905, 1.0, 0.9171054562811263, 0.8728081971286461, 0.6569694024252826, 0.18385437178475508, -0.47214966716705664, 0.44362171106100706, 0.5329813437619794, 0.6013995180002573, 0.7165714665492141, 0.4441461587981719, 0.5362864129622047, 0.605556737336568, 0.7213158185319526, -0.4894059005486026, -0.410800408863328, -0.35061579938857934, -0.2493076908619046, -0.4914773060508675, -0.41000334796467575, -0.3487470581194813, -0.24639685745402645, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21790687766145403, 0.2179591457772537, 0.20336775477762986, 0.18495440838566685, 0.8208473445957891, 0.12112112112112108, 0.24730221547650308, -0.3633633633633632, 0.49967948717948724], "score_Separable_5D": 1.0, "ela_features_10D": [-0.000323440738861791, 0.43720396569545866, 0.001769665412784777, 0.017786211873146836, 36.15650751040982, 0.006804835346077365, 0.9976183953310821, 1.0178039590538825, 0.9976148129429445, 0.23794553699830753, -0.0818246518638932, 1.2, 1.0211110053328085, 0.9383398154713325, 0.7166385827264952, 0.10533214452911213, -0.615181754850856, 0.6296338265271817, 0.6859713845676678, 0.7351840665752116, 0.8103439949439993, 0.6337705090305905, 0.6903782148845894, 0.7399435032845997, 0.8154067449116624, -0.4697382753999674, -0.3982855505071921, -0.3358689379655383, -0.2405429756402851, -0.465687539645809, -0.3937077438105406, -0.33068213280441033, -0.2347249381943654, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10938203368655357, 0.10938539678068501, 0.10650174131862725, 0.10033249078227627, 0.8525954086677416, -0.1271271271271271, 0.12856219886962025, -0.6516516516516514, 0.5833466773418735], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.1358023691107616e-06]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.462410715970289e-162, 7.034803866016528e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.468729292749695e-163, -1.4857243205498896e-162, 1.0963557072389242e-162, -1.3121948237215481e-163, 4.409448982876303e-163]}
{"id": "222556ee-8a2b-4b4c-869a-903197d084cf", "fitness": 1.0, "name": "landscape", "description": "Separable ripple landscape with dimension-specific cosine modulation", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5, seed=42):\n        self.dim = int(dim)\n        self.seed = int(seed)\n        self._params = self._build_params()\n    \n    def _build_params(self):\n        rng = np.random.RandomState(self.seed)\n        # Per-dimension amplitude for the cosine modulation\n        a = rng.uniform(0.2, 0.9, size=self.dim)\n        # Per-dimension frequency for the cosine modulation\n        b = rng.uniform(0.5, 3.0, size=self.dim)\n        return a, b\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input vector must be 1D with length {self.dim}. Got shape {x.shape}.\")\n        a, b = self._params\n        # Separable per-dimension function: h_i(z) = z^2 - a_i * cos(b_i * z)\n        # Global minimum is at x = 0 with value -sum(a).\n        return float(np.sum(x**2 - a * np.cos(b * x)))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.00221059623097859, 0.366900186464894, 0.011230041969626448, 0.023817974914759017, 4.135375179229658, -0.0032776005663441186, 0.9959710160174838, 1.011847259724979, 0.9959581866749048, 0.4561393885519209, -0.5060405014109385, 1.6, 0.7150538308085195, 0.7208304742725337, 0.5571054402505421, 0.33738972149965407, -0.20204388686738373, 0.14645209073345594, 0.220734302035559, 0.3087076776037975, 0.4774084054359937, 0.13936560252741362, 0.21922098806190893, 0.3109812551593021, 0.47998680934813526, -0.44647371912853495, -0.4076206544242112, -0.3616033999532326, -0.2733575776714571, -0.4412473890313004, -0.400308248971767, -0.35326256257032407, -0.2666118490527508, 1.0, 1.0, 1.0, 1.0, 0.5096374408747189, 0.5096131992971122, 0.39532320442172464, 0.3452928149835447, 0.7374929422758059, 0.41341341341341326, 0.5074978522557199, -0.10310310310310308, 0.37630522088353413], "score_Separable_2D": 1.0, "ela_features": [0.0013016790247095233, 0.4117722759198606, 0.004858874183006791, 0.029568722525566297, 7.842078626488498, 0.002852749954382605, 0.9980692568117732, 1.0960242890478678, 0.9980756567176752, 0.28767223569567435, -0.19212564976481153, 1.2, 0.9099181219020309, 0.8767686090407489, 0.6425865793873256, 0.1790990255848292, -0.4842123981654843, 0.4411310420529363, 0.5317969254118775, 0.6057217491022706, 0.7201531016259981, 0.44320479192084034, 0.5341921245167732, 0.608911663106617, 0.7245794140945635, -0.4916686376120567, -0.4119047635074522, -0.34686906057879546, -0.24619738558684107, -0.49251869623634487, -0.4120349953215164, -0.34594019584907965, -0.24362629361360327, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21721952113000925, 0.2172457901796697, 0.20280717942690568, 0.18465620360883747, 0.8285337053562445, 0.11311311311311308, 0.26189849402301707, -0.3633633633633632, 0.5094551282051282], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0012718181855068788, 0.4371995862313951, 0.0007647274967729492, 0.016583971335534416, 105.2102450064734, 0.002381431181503757, 0.9972544608245466, 1.062863656322307, 0.9972624041153262, 0.18120522283498375, -0.08317605693022516, 1.2, 1.0240672578862, 0.9407138335385398, 0.7248529377475198, 0.10257955037095776, -0.6081955088053769, 0.6166372636080958, 0.6770977622637578, 0.7279695028741046, 0.8076534276353919, 0.6208298519932376, 0.6816645942749728, 0.7323659449531077, 0.812256780565674, -0.4861712253351792, -0.40949715428057376, -0.3449828538972852, -0.24392971114426915, -0.4821401503911507, -0.4047849455459511, -0.34031459389834073, -0.23872801131783156, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11094484492291415, 0.11094800550626864, 0.10799106658963695, 0.10096933765732272, 0.8512828775127849, -0.1351351351351351, 0.12501387767108998, -0.6596596596596594, 0.588070456365092], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], -1.327677114027305]], "nr_of_basins": 1, "f_opt_dim_2": -1.327678097680095, "x_opt_dim_2": [2.179654945404267e-09, -4.1721206983212e-09], "f_opt_dim_5": -2.96834784419571, "x_opt_dim_5": [-7.733584173963329e-09, 5.981652386984212e-09, 1.1132695487705725e-08, -1.5216828330999858e-09, 4.287631145943946e-09]}
{"id": "989f2e7f-8032-4ca6-a3fd-5e5ff7fefa18", "fitness": 1.0, "name": "landscape", "description": "A novel separable multimodal landscape. Each dimension follows a nonconvex 1D profile with periodic ripples atop a quadratic base, creating multiple local minima while preserving a unique global minimum at the origin. The overall function is the sum of independent per-dimension contributions, suitable for separable optimization benchmarking in any dimension within [-5, 5].", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n    def _one_dimensional(self, t):\n        # Novel 1D landscape with multiple local minima but a global minimum at t = 0\n        t = float(t)\n        return t**2 + (np.sin(np.pi * t))**2 + 0.5 * (1.0 - np.cos(2.0 * np.pi * t))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n        # Vectorized evaluation across dimensions\n        vals = x**2 + (np.sin(np.pi * x))**2 + 0.5 * (1.0 - np.cos(2.0 * np.pi * x))\n        return float(np.sum(vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.00264988409786211, 0.37379719714701876, 0.00866356439228547, 0.023848041208208007, 6.91693906444325, -0.0008199184870482767, 0.9912156886688951, 1.0083426195471954, 0.9912218174456532, 0.464290996284013, -0.38486701400812917, 1.6, 0.6187274780712123, 0.6894525356606795, 0.4845724860521058, 0.35706888683378923, -0.19386147039885665, 0.2277832320341397, 0.24949401462849274, 0.31589491399091446, 0.4914065720578581, 0.23430908666067504, 0.24793095708631374, 0.31365368831544854, 0.4915234409906625, -0.40397863275586704, -0.39261819454192287, -0.3578819742869731, -0.2660582881394386, -0.39280042146344724, -0.38581364064362, -0.35209811993443413, -0.2608458779042679, 1.0, 1.0, 1.0, 1.0, 0.5087463815469768, 0.5087302977645187, 0.39162474910474654, 0.3477802665320432, 0.7725284044927951, 0.5135135135135134, 0.6401190171851023, -0.027027027027027035, 0.41084337349397587], "score_Separable_2D": 1.0, "ela_features": [-0.0011883292811853742, 0.42643273545859417, 0.003700956444669323, 0.020157558033326004, 6.70182025888645, 0.006315141767625576, 0.9907267951523109, 1.0121468340618809, 0.9907175672746753, 0.2873217949257677, -0.15059851146068262, 1.0, 0.9009624383072014, 0.8715920026600393, 0.633685643293554, 0.1859763543549599, -0.48171121702508213, 0.4501135217885093, 0.5305871244403051, 0.6066070874874776, 0.7228274751818751, 0.4520624664712436, 0.5330046512642099, 0.611033637453805, 0.7266415994610339, -0.4837900838202328, -0.41299048292711926, -0.34610807013582606, -0.24385697913542276, -0.4848622053558804, -0.41323862524101, -0.3441930687814126, -0.24189274381998693, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21952549681353334, 0.21951004472733643, 0.20538116065916925, 0.18473664785946808, 0.8291536238735843, 0.12512512512512508, 0.2658330619582844, -0.36736736736736725, 0.5238782051282052], "score_Separable_5D": 1.0, "ela_features_10D": [-0.00042513472612084604, 0.44558349207765274, 0.0008387985800287382, 0.021579686601426784, 67.2442906983941, 0.0056742866940621365, 0.9908285428268538, 1.0195080580397882, 0.9908192135873733, 0.16949849269918954, -0.10873822678171034, 1.0, 1.017452440083611, 0.9390276392311959, 0.707537912988418, 0.1038901451106277, -0.6097314380526395, 0.6198014101970103, 0.6792256215648229, 0.7295070861321789, 0.8077940829592967, 0.6244885454185974, 0.6836089815357669, 0.7341341798827246, 0.8121685403769938, -0.4822126126431098, -0.4068440085028442, -0.3430710817596217, -0.2437782454598177, -0.47758423124630844, -0.40239356780261587, -0.33813424335222475, -0.23888824047166984, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11021712061814912, 0.11021773071115795, 0.10709018519566424, 0.10071683982601956, 0.8543583140272514, -0.11511511511511507, 0.13439573413917, -0.6436436436436435, 0.5931144915932747], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-0.5555555555555554, -0.5555555555555554], 4.496669192189101], [1, [0.5555555555555554, -0.5555555555555554], 4.496669192189101], [1, [-0.5555555555555554, 0.5555555555555554], 4.496669192189101], [1, [0.5555555555555554, 0.5555555555555554], 4.496669192189101], [9, [-2.8228888888890062, -2.8228888888890062], 17.053139058704208], [7, [-1.8951187729092982, -1.8969911307944511], 7.601677487017319], [4, [-0.8780264193481148, -1.743018202539984], 5.132472546372167], [4, [-1.7430181309786266, -0.8780271810870455], 5.132470764415751], [3, [1.745769061592632, 0.8751212587634544], 5.132482158594535], [3, [0.8780250782378275, 1.743015649229629], 5.132483161918587], [9, [-2.8228888888890062, 2.8228888888890067], 17.053139058704208], [9, [2.8228888888890067, -2.8228888888890062], 17.053139058704208], [7, [1.8969307315310526, -1.8972911109601225], 7.601631881692786], [7, [-1.894638657829343, 1.8969919428271491], 7.601708714218277], [7, [1.897092345497312, 1.8973186874941133], 7.601633300981552], [1, [2.804669651427239, -1.899370989978249], 12.330310105088332], [9, [2.8228888888890067, 2.8228888888890067], 17.053139058704208], [4, [1.8685747092305873, -0.8455597602230916], 4.963562387785704], [4, [0.8855081006945688, -1.7363838634363482], 5.132383425601169], [4, [-0.8465056600401165, 1.869093724546834], 4.959815544093384], [4, [-1.7363851867254594, 0.8855092043959014], 5.132377122297692], [1, [-1.897974623741141, 2.805356820351544], 12.330016427279105]], "nr_of_basins": 22, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.887672401417967e-164, -1.7109756697843603e-163], "f_opt_dim_5": 0.951421606648122, "x_opt_dim_5": [-0.951051149618939, 9.570100900961403e-10, 8.988988954149167e-10, -1.340644424809527e-10, -1.196529166028228e-09]}
{"id": "94ba0fec-a981-48e9-8d7f-6bfa30d421bf", "fitness": 1.0, "name": "landscape_separable_attractor_ripple", "description": "A fully separable, additive landscape with per-dimension attraction to 1 and dimension-specific ripple. Each dimension contributes an independent 1D function, enabling exact subproblem partitioning; the global optimum is at x = [1, ..., 1] with f(x) = 0. The per-dimension parameters (weight and ripple amplitude) vary slightly across dimensions to preserve diversity while maintaining separability.", "code": "import numpy as np\n\nclass landscape_separable_attractor_ripple:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension base quadratic weight (slightly varying to emphasize separability)\n        # Keeps the minimum at x_i = 1 for all i\n        base = 1.0\n        self.w = base + 0.2 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [1.0, ~1.2]\n        \n        # Per-dimension ripple amplitude (slightly varying to maintain separability)\n        self.A = 0.3 * (1.0 + 0.4 * (np.arange(self.dim) / max(self.dim - 1, 1)))  # in [0.3, ~0.42]\n        \n        # Per-dimension ripple frequency\n        self.k = np.arange(1, self.dim + 1)  # (1, 2, ..., dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        # Separable per-dimension function:\n        # g_i(x_i) = w_i * (x_i - 1)^2 + A_i * sin^2(2 * pi * k_i * x_i)\n        quad_term = self.w * (x - 1.0) ** 2\n        ripple_term = self.A * np.sin(2.0 * np.pi * self.k * x) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_attractor_ripple scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5520eaad-c3de-406f-a6ca-184be121dabc"], "operator": null, "metadata": {"ela_features_2D": [0.37433840948752606, 0.5863027675377723, 0.2804545157455125, 0.32009443769932117, 1.1496093893547124, 0.3753095107055128, 0.9998481797060654, 1.2004958765579326, 0.9998478896247178, 0.8593697885581453, 0.34617323930483357, 1.2, 0.7119822599270881, 0.7129036502025384, 0.5485335280656881, 0.3466284729481403, -0.1642314330482963, 0.14847743016019171, 0.21869144928562173, 0.32345507881069857, 0.4954159139916509, 0.1477873864607512, 0.22023230117628545, 0.3210273911353462, 0.49674627459261345, -0.4454984909241917, -0.408759671566908, -0.3539483514815246, -0.2639834472118197, -0.4374989362180767, -0.40030626825917687, -0.34855968971875445, -0.2583521007876608, 1.0, 1.0, 0.8666666666666666, 1.0, 0.5276180159426114, 0.5276156670368577, 0.5171601693629198, 0.5499715774578288, 0.7145037626769722, 0.3333333333333332, 0.43941952630585773, -0.20320320320320312, 0.3714859437751004], "score_Separable_2D": 1.0, "ela_features": [0.3829987924945647, 0.7532784741718885, 0.14045720402245845, 0.17714574515767068, 1.265294705796904, 0.3844035215473047, 0.9998532728926504, 1.1993151394252355, 0.9998531598644858, 0.47164933008559434, -0.008519459075052093, 1.4, 0.8995807536174718, 0.8699672608187763, 0.6407836063213619, 0.1856178696785157, -0.3971362169666122, 0.4156289894049706, 0.5075186390478581, 0.5845150851979513, 0.7133721029192117, 0.4168913897049249, 0.5085392335555242, 0.5858372710221617, 0.716006777090839, -0.5139860059934197, -0.4331645724207984, -0.3654417211080845, -0.25210457570304246, -0.5154432404983029, -0.4344324444658145, -0.36610410507690555, -0.25103825981489686, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21489862608733623, 0.21488446461995836, 0.22382913705184565, 0.274061615666721, 0.816849211238571, 0.049049049049049, 0.19465996492472076, -0.4994994994994994, 0.5056089743589743], "score_Separable_5D": 1.0, "ela_features_10D": [0.379053722655591, 0.8930375511425815, 0.08238843815989708, 0.11473378394028896, 1.4125533362659126, 0.38244308754670897, 0.9998473210874094, 1.1995943091341117, 0.9998474866753945, 0.34811754019405566, 0.011838260230618758, 2.0, 1.0237684233866364, 0.9375096295812089, 0.7206783447269697, 0.10607093937078722, -0.5254859876302197, 0.6144015052713876, 0.6822586743688551, 0.7373667753743514, 0.8193298696137653, 0.6210552832415035, 0.6848531256788093, 0.7417152054346745, 0.8236010693700543, -0.48900927873280525, -0.4029539759683846, -0.333066897146948, -0.22912270529118345, -0.48182310103201065, -0.4007050427276293, -0.32840555896351575, -0.2242888409195844, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10985126249709327, 0.1098526339584636, 0.111697888286203, 0.1473611940450671, 0.8540417313940495, -0.18718718718718716, 0.11378231901216782, -0.7117117117117114, 0.5686148919135308], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [0.5407650841941636, -0.4715359290694554], 2.880135886683514], [4, [1.4596177349971584, 2.7132542006756135], 3.835806161097054], [3, [1.8729697316854705, 3.1897174128430548], 6.868040348385172], [6, [0.5007407810953897, 0.5389826166451137], 0.5972906269983591], [3, [1.4518249809201105, 0.5496234411983244], 0.6174294266136657], [6, [0.4945167342003439, 1.6859088673611395], 1.0388300123333152], [6, [0.5419315161499093, 3.191044819809943], 6.182301763692081], [6, [0.5404771189142101, 2.7137516078330544], 3.8357672020676237], [9, [1.4536453955782918, -0.46736261794894063], 2.8810895935808905], [5, [1.8997311754176527, 2.9548892216520404], 5.620671790589214], [11, [1.8987738745410931, -0.47100444927632695], 3.5636070461455103], [1, [1.9236867874255992, -0.2210464005782637], 2.75937854245744], [24, [0.5411243008435918, -1.1911388923584574], 6.1822836650758966], [4, [1.4518871851553774, 1.6677056609185767], 1.0760056472550943], [2, [0.13466255396171609, 1.4919144165984728], 1.2116745337772525], [6, [0.09933554193258343, 1.7151119150501195], 1.603002804626896], [2, [0.10117578851882819, -0.4711410031225351], 3.5636099535300323]], "nr_of_basins": 17, "f_opt_dim_2": 1.1878097478681911e-31, "x_opt_dim_2": [1.0, 1.0], "f_opt_dim_5": 0.07629255456425171, "x_opt_dim_5": [0.9999999995019924, 1.2450497081131127, 1.0000000000570322, 0.9999999999376741, 0.9002886691620572]}
{"id": "277b25e5-10cb-4acd-9e97-05f408acf5d4", "fitness": 1.0, "name": "landscape_quartic_sine", "description": "Separable multi-modal landscape with a quartic base and dimension-specific sine-squared modulation. Each dimension has its own amplitude and frequency, creating many local minima while preserving a unique global minimum at the origin (f(0)=0). The function is a sum of independent per-dimension landscapes: f_i(x_i) = x_i^4 + a_i * sin^2(b_i * x_i).", "code": "import numpy as np\n\nclass landscape_quartic_sine:\n    \n    def __init__(self, dim=5, seed=42):\n        self.dim = int(dim)\n        self.seed = int(seed)\n        self._params = self._build_params()\n    \n    def _build_params(self):\n        rng = np.random.RandomState(self.seed)\n        # Per-dimension amplitude for the sine modulation\n        a = rng.uniform(0.1, 1.0, size=self.dim)\n        # Per-dimension frequency for the sine modulation\n        b = rng.uniform(0.5, 4.0, size=self.dim)\n        return a, b\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input vector must be 1D with length {self.dim}. Got shape {x.shape}.\")\n        a, b = self._params\n        # Per-dimension function: f_i(z) = z^4 + a_i * sin^2(b_i * z)\n        # Global minimum at x = 0 with f(0) = 0\n        return float(np.sum(x**4 + a * np.sin(b * x) ** 2))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_quartic_sine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["222556ee-8a2b-4b4c-869a-903197d084cf"], "operator": null, "metadata": {"ela_features_2D": [-0.003164060069249386, 0.2162623873457799, 0.005373147059409061, 0.017630797358902533, 7.938095168455538, -0.002510740512027243, 0.9140538796009056, 1.0078893375025137, 0.9143818731034774, 1.0236008402327343, 0.574039735890477, 1.2, 0.7277415337908433, 0.72991000178523, 0.5755009560755997, 0.33039980794168405, -0.2323994177857966, 0.1473356816323387, 0.21788334041568377, 0.31438922709741846, 0.49626726766058543, 0.14854229697393556, 0.22030039146642952, 0.3151857536827232, 0.4962436791141033, -0.4464613313104466, -0.4095177061838937, -0.358986649411226, -0.2637551979447822, -0.4380678902299719, -0.40114024428138606, -0.3523239244896407, -0.2591716176880033, 1.0, 1.0, 1.0, 1.0, 0.519347778838364, 0.5193400475738671, 0.4164985595621816, 0.35007797235258037, 0.6252648511748369, 0.6216216216216214, 0.5011513325965755, -0.07107107107107107, 0.3662650602409638], "score_Separable_2D": 1.0, "ela_features": [-0.00146103107874187, 0.294553113501902, 0.002587269905121958, 0.02034225604571437, 21.703582613526592, 0.0035243216407262468, 0.9200130046314241, 1.047767887906371, 0.9213826615279253, 0.6542757299490136, 0.23704129332671126, 1.6, 0.9094052234242802, 0.8736725710148636, 0.6334930383459776, 0.18496664383570677, -0.5040240160844924, 0.4452797477580435, 0.5298404683283606, 0.6057673707678486, 0.7280323088844443, 0.44294846362763085, 0.5301564096262341, 0.6091239117718993, 0.731634218133858, -0.48790878786065794, -0.4135292890838554, -0.346747217467977, -0.23920787321237266, -0.49238818125814615, -0.41529193497267664, -0.3454914702729944, -0.23720100750479883, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2188336731329407, 0.2188240017184344, 0.20400176456361646, 0.18372756600843837, 0.8278407393365818, 0.24924924924924916, 0.2926233524901266, -0.2992992992992992, 0.5440705128205128], "score_Separable_5D": 1.0, "ela_features_10D": [2.3333773101419374e-05, 0.36629416755827976, 0.000799419680240249, 0.022322302487863183, 43.247219075096055, 0.005103685346703024, 0.9170584283850853, 1.0585764015715262, 0.9172903043644292, 0.4355230466455571, 0.03641837598079371, 1.0, 1.0049886600992748, 0.9370130111824763, 0.6891592045248661, 0.10758266975907398, -0.6055777158910857, 0.642860732218208, 0.697875267304284, 0.7470830310783197, 0.8171429022569671, 0.6474926583925782, 0.7017627734935462, 0.7510286912229434, 0.8211757360142901, -0.4529743398038774, -0.3831967513639433, -0.3207845468241545, -0.23192506440345614, -0.44831452438134, -0.37929364448656466, -0.3166378135899638, -0.22742625169597958, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10921583868443052, 0.10921257568961777, 0.10581963193676984, 0.10002999310044389, 0.8650387920828766, -0.039039039039039033, 0.14550104976772027, -0.5955955955955954, 0.6156124899919936], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[28, [0.00044444444444512003, -0.8286666666666658], 1.1403110279271984], [47, [0.00044444444444512003, 0.00044444444444512003], 2.080952836322232e-06], [25, [0.00044444444444512003, 0.8286666666666662], 1.1403110279271982]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [8.849089353396903e-163, 3.318485810149155e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.1460099591526008e-162, -2.173504456330555e-162, -6.723130196345706e-165, 5.690346365193479e-163, -7.977783935210033e-163]}
{"id": "d269b7ba-9ba9-421d-bbfc-463bea40106d", "fitness": 1.0, "name": "landscape_sep_cos_ripple", "description": "A fully separable benchmark where each dimension has an independent 1D landscape formed by a quadratic base plus a dimension-specific cosine ripple. The global minimum is at x = 0 with f(x) = 0, and the problem naturally decomposes into per-dimension subproblems for efficient solving.", "code": "import numpy as np\n\nclass landscape_sep_cos_ripple:\n    def __init__(self, dim=5, seed=42):\n        self.dim = int(dim)\n        self.seed = int(seed)\n        self._params = self._build_params()\n\n    def _build_params(self):\n        rng = np.random.RandomState(self.seed)\n        # Per-dimension quadratic coefficient\n        w = rng.uniform(0.5, 2.0, size=self.dim)\n        # Per-dimension cosine ripple amplitude\n        a = rng.uniform(0.2, 0.8, size=self.dim)\n        # Per-dimension cosine ripple frequency\n        b = rng.uniform(0.5, 3.0, size=self.dim)\n        return w, a, b\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input vector must be 1D with length {self.dim}. Got shape {x.shape}.\")\n        w, a, b = self._params\n        # Separable per-dimension landscape: h_i(z) = w_i * z^2 + a_i * (1 - cos(b_i * z))\n        return float(np.sum(w * x**2 + a * (1 - np.cos(b * x))))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_sep_cos_ripple scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["222556ee-8a2b-4b4c-869a-903197d084cf"], "operator": null, "metadata": {"ela_features_2D": [-0.0030957585361488958, 0.36488184617126607, 0.011533349243135486, 0.020721335194740398, 3.3739019090644495, 0.0011192845100228333, 0.9994033555190326, 1.7786088732950405, 0.9994048912385883, 0.4447297865973103, -0.6370891567678224, 1.2, 0.7256133214549194, 0.7257130660591082, 0.5830806459468805, 0.3326456559158978, -0.19398216703498564, 0.14909171266624296, 0.2179590527671223, 0.3152670137803224, 0.4999876670439242, 0.1514257236723615, 0.2179269481338102, 0.31441545362966916, 0.4949149829616958, -0.4450815140560125, -0.4090548991683229, -0.35815673805091264, -0.2615362800769597, -0.43599483679505785, -0.4018204825754669, -0.3522341735836048, -0.2594973325897724, 1.0, 1.0, 1.0, 1.0, 0.5270265592146149, 0.5270229123511116, 0.39744712060707243, 0.35357957658408246, 0.7171264746363977, 0.41341341341341326, 0.5586512571450619, -0.11111111111111108, 0.3714859437751004], "score_Separable_2D": 1.0, "ela_features": [-0.0003639045423771803, 0.40617408941835265, 0.003948666637084196, 0.02683860885110393, 9.232191896643554, 0.003992256340568589, 0.9990528225223047, 2.5030495491426525, 0.9990480446079426, 0.31202158792467927, -0.19910155393368295, 1.0, 0.9177342782511767, 0.8765673199332948, 0.6561418990327801, 0.17929088957049308, -0.4692337332919522, 0.4404281720574363, 0.5313498194425202, 0.6076415858641682, 0.7250859299882014, 0.43547952818914853, 0.5306128314600329, 0.6069341371006508, 0.7257415561280405, -0.4922397188750917, -0.4122588664861115, -0.34514739985660425, -0.24183445451919844, -0.49918891020415385, -0.415065806383094, -0.34757798296521836, -0.24251910423190082, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21539461340726213, 0.2153799821928441, 0.20088829551728601, 0.18071569158410597, 0.8266092028901173, 0.12512512512512508, 0.25963205945251455, -0.36736736736736725, 0.5017628205128205], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0007294003572042351, 0.427482570004042, 0.0009207611863639679, 0.018785044856314593, 51.1316117399546, 0.0009877462059244336, 0.9992555124452351, 3.295177129866386, 0.9992574985924791, 0.2113584999461729, -0.1293042306180034, 1.2, 1.0060377124212323, 0.9382793306944401, 0.7102476173995302, 0.10462337726729883, -0.6019212175069757, 0.6283311183486759, 0.6929482271097942, 0.7440326817539998, 0.8179929314786427, 0.6281867024884651, 0.6934355011471242, 0.7457312757118356, 0.8209647311442548, -0.4713834247252501, -0.38943032438747843, -0.3246397912979254, -0.23083699514505152, -0.4727914378850717, -0.38982122898613636, -0.3233209427559019, -0.22765578838039952, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.109274439173774, 0.10927445678714373, 0.10615875529246002, 0.0999191246381843, 0.8573005101790228, -0.1151151151151151, 0.13500932120742276, -0.6476476476476474, 0.5960768614891914], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 6.839554096365803e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.421335638587082e-163, 9.245224545606693e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2891898665515607e-162, -8.658420891629238e-163, 1.0689640304705648e-163, 1.0760852217685038e-162, 1.137499804824653e-162]}
{"id": "505be0e2-5410-4fd2-a720-519a1d6f799a", "fitness": 1.0, "name": "landscape_separable_quad_cosine_enhanced", "description": "A novel fully separable landscape with dimension-specific quadratic wells and cosine modulation. Each dimension contributes an independent 1D landscape f_i(x_i) = w_i*(x_i)^2 + a_i*(1 - cos(b_i*x_i)), with deteministic per-dimension weight w_i, amplitude a_i, and frequency b_i. The global objective is the sum over dimensions, ensuring a unique global minimum at x = 0. This design emphasizes separability, enabling subproblem partitioning into independent 1D optimizations, and provides controllable ruggedness across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_quad_cosine_enhanced:\n    \"\"\"\n    Fully separable landscape: sum_i [ w_i * x_i^2 + a_i * (1 - cos(b_i * x_i)) ]\n    - Each dimension has its own weight w_i, amplitude a_i, and frequency b_i\n    - Global minimum at x = 0\n    - Bounds: x_i in [-5, 5]\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension frequencies for the cosine modulation\n        base_freq = np.array([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0], dtype=float)\n        if self.dim <= len(base_freq):\n            self.freq = base_freq[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_freq)))\n            self.freq = np.tile(base_freq, reps)[:self.dim]\n\n        # Per-dimension amplitude for the cosine modulation\n        # (increasing across dimensions to introduce dimension-specific ruggedness)\n        if self.dim == 1:\n            self.amp_per_dim = np.array([0.25], dtype=float)\n        else:\n            self.amp_per_dim = 0.25 + 0.50 * (np.arange(self.dim) / (self.dim - 1))\n\n        # Per-dimension weight for the quadratic term\n        if self.dim == 1:\n            self.weight = np.array([0.5], dtype=float)\n        else:\n            self.weight = 0.5 + 0.50 * (np.arange(self.dim) / (self.dim - 1))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension contribution: w_i*(x_i)^2 + a_i*(1 - cos(b_i*x_i))\n        quad = self.weight * (x**2)\n        periodic = self.amp_per_dim * (1.0 - np.cos(self.freq * x))\n        return float(np.sum(quad + periodic))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_quad_cosine_enhanced scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["521d64e2-cc68-4029-94dd-4b1c57a43be9"], "operator": null, "metadata": {"ela_features_2D": [-0.00042401865124603867, 0.37734159678270823, 0.015070722541749232, 0.04091964328405515, 5.338638206763095, -0.0007834467854501259, 0.9957868499293301, 1.96474135669101, 0.995769981752183, 0.551200465792092, -0.48509804160915815, 1.4, 0.700875296331405, 0.7118599182616464, 0.538481381001396, 0.34495408663254196, -0.19408434089916513, 0.15236984493020908, 0.2415682773723266, 0.3235982716830347, 0.49104845486213566, 0.15689923322851926, 0.22868023902503182, 0.31366771830435775, 0.4886870301838148, -0.4432356305890145, -0.3965955525267092, -0.35369795735193954, -0.2661226382266121, -0.43240157213752023, -0.39557921542836627, -0.3519995616922019, -0.26220593681937787, 1.0, 1.0, 1.0, 1.0, 0.5070868026799161, 0.5070068064059267, 0.3878979004616665, 0.35426216808507405, 0.7142773766516284, 0.5015015015015013, 0.5029774321188059, -0.07907907907907909, 0.37269076305220883], "score_Separable_2D": 1.0, "ela_features": [-0.0003522682559611301, 0.41959009791991997, 0.0015960590953873546, 0.025912051159177513, 206.39025833222314, 0.006757486138136893, 0.9958408304936986, 1.9885424256343704, 0.9958634928436847, 0.2771934801829656, -0.3129399312024124, 1.2, 0.9065952467546511, 0.8721679098780137, 0.6413606636977424, 0.18517928162028455, -0.46928863120245057, 0.4412791589139869, 0.5221162249938346, 0.6016656897634931, 0.7212539187050113, 0.44151185336682486, 0.5222459753226154, 0.6019309644985021, 0.7233688797361817, -0.4914663041803369, -0.4203577749956011, -0.3503842378057168, -0.2451916659266848, -0.4937546757880879, -0.422371719036744, -0.35192268335298105, -0.24456075471349709, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2176466134873678, 0.21762734631340513, 0.2016787807642019, 0.1832359218581641, 0.8304265530404681, 0.1371371371371371, 0.27084739383358913, -0.3433433433433432, 0.5189102564102563], "score_Separable_5D": 1.0, "ela_features_10D": [-0.00067366590561726, 0.44165396503703747, 0.001512055752127668, 0.019087048703506415, 38.13340980623791, 0.005367471441154237, 0.9958678918960535, 1.9808974771752084, 0.9958863401246514, 0.18741744147076123, -0.14808004830288066, 1.2, 1.0184301771823305, 0.9383215585128596, 0.7147156886332768, 0.10479738605674385, -0.6052489291627661, 0.628045708290751, 0.6844609604686693, 0.7348565154923686, 0.8123879716809155, 0.6306767256324071, 0.6874786379920392, 0.738428473911781, 0.8164337365734312, -0.47172239454845216, -0.4001752363783016, -0.3362622645766007, -0.2379347837032982, -0.469623596569397, -0.39739492809524385, -0.33260829087622934, -0.2334184008051793, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10920765637511423, 0.10920624886986074, 0.10604783591157307, 0.09957662244624019, 0.8559816258960401, -0.11111111111111112, 0.13079582462157194, -0.6316316316316314, 0.5959167333867093], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.0617282897518876e-06]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.9538082092086014e-162, -5.434889726399291e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.3602914119839577e-162, -5.960193691109903e-163, 2.7749978344996517e-163, -1.1930782228518447e-162, 5.697696081976823e-163]}
{"id": "01497983-debe-4be8-85fb-1346c2d339aa", "fitness": 1.0, "name": "landscape_separable_mixed", "description": "A strictly separable, multimodal benchmark where each dimension uses a distinct nonconvex 1D profile built from a quadratic base plus a periodic ripple and a cosine-based micro-well. Each dimension has its own deterministic parameters, preserving additivity across dimensions and ensuring a unique global minimum at the origin. This enhances separability by explicitly decoupling subproblems while introducing dimension-specific difficulty.", "code": "import numpy as np\n\nclass landscape_separable_mixed:\n    \"\"\"\n    A separable, multimodal landscape with per-dimension distinct 1D profiles.\n    Each dimension contributes g_i(t) = a_i * t^2 + c_i * sin^2(pi * s_i * t) + d_i * (1 - cos(2 * pi * r_i * t)),\n    where t is the coordinate in dimension i. The global minimum is at x = 0 with f(x) = 0.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Deterministic, dimension-dependent parameters (to ensure variety but reproducibility)\n        # Quadratic base weight per dimension\n        self.a = np.array([0.5 + 0.05 * (i % 20) for i in range(self.dim)], dtype=float)\n\n        # Amplitude for the sine-square ripple (per-dimension)\n        self.c = np.array([0.2 + 0.05 * ((i * 3) % 20) for i in range(self.dim)], dtype=float)\n\n        # Amplitude for the cosine-based micro-well (per-dimension)\n        self.d = np.array([0.5 + 0.05 * ((i * 7) % 20) for i in range(self.dim)], dtype=float)\n\n        # Per-dimension frequency multipliers for the ripple term\n        self.s = np.array([1.0 + 0.2 * (i % 6) for i in range(self.dim)], dtype=float)\n\n        # Per-dimension frequency multipliers for the cosine term\n        self.r = np.array([1.0 + 0.15 * (i % 5) for i in range(self.dim)], dtype=float)\n\n    def _one_dimensional(self, t, i):\n        \"\"\"\n        1D subproblem for dimension i with its specific parameters.\n        \"\"\"\n        t = float(t)\n        ai = float(self.a[i])\n        ci = float(self.c[i])\n        di = float(self.d[i])\n        si = float(self.s[i])\n        ri = float(self.r[i])\n\n        # g_i(t) = ai * t^2 + ci * sin^2(pi * si * t) + di * (1 - cos(2 * pi * ri * t))\n        return ai * t ** 2 + ci * (np.sin(np.pi * si * t)) ** 2 + di * (1.0 - np.cos(2.0 * np.pi * ri * t))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape on a 1D array x of length dim.\n        Global minimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            total += self._one_dimensional(x[i], i)\n\n        return float(total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_mixed scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["989f2e7f-8032-4ca6-a3fd-5e5ff7fefa18"], "operator": null, "metadata": {"ela_features_2D": [-0.002038374706879109, 0.36738782948935456, 0.0093832594275636, 0.03095423703171173, 5.197147132049039, 0.003624284978893533, 0.9797873282278756, 1.1189254274949676, 0.9797794415014038, 0.4477404713498644, -0.4718727541308116, 1.4, 0.566968148651819, 0.6635638833558958, 0.4609208405257057, 0.37404337976981694, -0.2051345570099993, 0.2381952944634552, 0.3119008686530556, 0.35773381813213645, 0.4964125429700933, 0.2291128621548256, 0.31004344098268083, 0.357807728205134, 0.49792489267158907, -0.39850374589959875, -0.3599475365944258, -0.3359760346568902, -0.263430554083869, -0.3957694271741694, -0.35420340020605606, -0.329700214927968, -0.25776205958497067, 1.0, 1.0, 1.0, 1.0, 0.5226728053213717, 0.5226690759421521, 0.4078792698383005, 0.35610333545778144, 0.8156607461572282, 0.6096096096096094, 0.731600231551297, 0.037037037037037014, 0.4927710843373494], "score_Separable_2D": 1.0, "ela_features": [0.0014711824857518208, 0.4195039906017496, 0.004441004264467324, 0.029795875444889368, 90.66790404931514, 0.008493583696623296, 0.9802091013751418, 1.4088178195924381, 0.9801010933482528, 0.24758755739930516, -0.18810105586660386, 1.2, 0.8904793133601228, 0.8694550673830441, 0.6344515687854002, 0.18582120080248826, -0.4765658541562553, 0.4436883119327913, 0.5322702890261276, 0.6050421987505107, 0.7189076506334123, 0.4464050413569426, 0.5337057343277016, 0.6067916997251418, 0.7223940412269554, -0.48934783846739427, -0.41142655645548476, -0.3474132040279906, -0.24725422335360783, -0.48948081006631006, -0.4122788514461594, -0.34765754179192593, -0.2454453099931148, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21548985258342931, 0.21548647994503614, 0.2025333596004193, 0.18358901896663476, 0.8389186927594426, 0.12912912912912908, 0.2433970645071081, -0.40340340340340336, 0.5378205128205128], "score_Separable_5D": 1.0, "ela_features_10D": [0.0007662804349106933, 0.42813290070394394, 0.0012159243785112108, 0.022390317867188446, 20.05347649663972, 0.0056769100130591, 0.983040441050969, 1.9099454628865058, 0.9830092986239581, 0.2095891803206953, -0.10094425474941131, 1.0, 1.009871732778708, 0.9388094236935223, 0.7082596320344617, 0.10417634193090057, -0.6101982243056046, 0.6379500606311822, 0.6876681684224358, 0.7366255967387599, 0.8133147941098564, 0.6406440290542588, 0.6918220454599766, 0.7402811534307518, 0.8171575743854893, -0.459179206297642, -0.3961226882826948, -0.3340312137693462, -0.23676821603788117, -0.45696890652236155, -0.39188857251478354, -0.3302667135811399, -0.2325081487830222, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11006790897671581, 0.11006843657415559, 0.10691522714982064, 0.10034074970482965, 0.856831953327346, -0.1151151151151151, 0.13702559513643453, -0.6316316316316314, 0.5883106485188151], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [2.7777777777777786, -5.0], 18.95383578475787], [1, [-1.6666666666666665, -1.6666666666666665], 3.930545073449896], [1, [1.666666666666667, -1.6666666666666665], 3.9305450734498946], [1, [-1.6666666666666665, 1.666666666666667], 3.930545073449895], [1, [1.666666666666667, 1.666666666666667], 3.9305450734498937], [1, [-2.7777777777777777, 5.0], 18.95383578475787], [2, [2.8628897790024435, -2.533771101888281], 7.965475438876634], [2, [2.862889780526537, 2.5337705557127808], 7.965475463731994], [1, [-2.778085142972123, 3.372909048578336], 10.852979539283572], [3, [-2.8628897620379723, 2.533771112056731], 7.9654754383762345], [1, [-2.7780080441899613, -3.372899807152142], 10.853052792384675], [3, [-2.8540992840159123, -2.5346128090249054], 7.966056588669026], [2, [3.748895783886545, -5.00054158474577], 22.230926594861707], [2, [3.7468969715780465, 5.000606982296002], 22.23092833597334], [3, [1.8653587241404979, 3.3444558912392752], 8.461832882869308], [1, [-0.6821370756714784, -2.435925332896541], 4.9450609504301735], [1, [-0.6821332534011212, 2.4359204541456787], 4.945089800840735], [1, [0.6789056333464524, 2.438283216870958], 4.945106098982346], [1, [-1.789233645053393, -3.2884007482275135], 8.69370207439579], [1, [1.7894756780493177, -3.288741723044035], 8.692282552765457], [1, [-1.791148059088666, 3.287645514911632], 8.692292818614176], [3, [-2.839853192812845, -1.6820081336502246], 5.939937929561834], [3, [-2.8398531386864723, 1.6820079526836038], 5.939938031691959], [2, [-1.6718405701222385, 2.5282782347248403], 5.939650783587453], [2, [-1.6718374200590889, -2.5282777295000507], 5.939656146295089], [2, [-3.7590551460143242, 3.3757207852194036], 14.130339865598817], [2, [-3.759054752145446, -3.3757209964570087], 14.130339863739113], [1, [-0.720354183899534, -1.564321941431313], 2.9586184104130986], [2, [-0.9519473660262264, -0.667432907352299], 1.6016820675173453], [2, [0.9479495618299586, -0.6675632467771744], 1.601683044816654], [1, [-0.7255255182959165, 1.5612792924847356], 2.958615728842835], [1, [0.7255601092508523, 1.5613339363662133], 2.9582323763373233], [2, [-0.9499482369381081, 0.6674892123702679], 1.6016942920537456], [2, [0.9499482864125428, 0.6674919333477388], 1.6016762621454632], [1, [3.756974860777871, -2.5348380993104995], 11.289314632209173], [3, [2.85623882283801, -1.6888509866443664], 5.934269769001439], [3, [2.862889143438721, -3.3768751228561564], 10.80650315514799], [3, [2.855923958206709, 1.6888903151702117], 5.93429935284625], [1, [3.756285926741064, 2.5345091389875583], 11.28932199392191], [2, [1.6891227156427688, 2.5066281151273144], 5.927358181112057], [1, [2.7098009041316757, 0.8455580210365746], 4.82818341338147], [1, [2.739149054110834, -0.8534489712316786], 4.800716253054429], [2, [1.6875157008026915, -2.5079643620761227], 5.928547031124154], [1, [0.6869871680923721, -2.432393300749586], 4.9450443338706425], [1, [2.812500886130503, 4.969830597323593], 18.948375183335454], [2, [1.9148850990974393, 0.8028339254241325], 2.37318388028056], [2, [1.9165850796664177, -0.8024519953309601], 2.374072765305353], [1, [0.7255426597071213, -1.5613060342910616], 2.9584274757093647], [1, [2.8529164166198746, 3.312000238731341], 10.886519142147872], [2, [1.917590427827584, -4.202776941876616], 12.064155759992158], [3, [-1.911494909639397, 0.8007512386226994], 2.3781553523504915], [3, [-1.910360034435877, -0.7998330645369854], 2.3804547659672743], [2, [-1.9146735735843872, -4.201452035805764], 12.064580910285594], [2, [1.9134536258431891, 4.197823525453685], 12.066226529230509], [2, [-1.9188727836563055, 4.199873178225913], 12.065375376108562], [3, [-2.862902714309868, -5.000422392818246], 18.90701384145487], [2, [-3.7468929140625584, 5.000307146898596], 22.231119340357502]], "nr_of_basins": 57, "f_opt_dim_2": 1.6265375315770825, "x_opt_dim_2": [1.338372113213159e-09, 1.6908544084279176], "f_opt_dim_5": 0.32755061198550145, "x_opt_dim_5": [-7.693892335775325e-10, -7.67802348513667e-10, -4.453720859621737e-10, -9.648404094002332e-10, -0.5942761014436172]}
{"id": "efaec5ff-3031-49e3-9df3-08da7134383d", "fitness": 1.0, "name": "landscape", "description": "A strictly separable, multi-well benchmark where each dimension is an independent 1D landscape composed of a quadratic basin centered at a dimension-dependent offset a_i plus a dimension-specific cosine modulation. The per-dimension parameters are deterministically derived from the dimension index to ensure diverse yet decoupled subproblems. The global optimum is the sum of the per-dimension optima, with f(x) achieving its minimum value of 0 at x = a.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic and reproducible)\n        self.a = np.zeros(self.dim)      # center offset per dimension\n        self.omega = np.zeros(self.dim)  # frequency per dimension\n        self.p = np.zeros(self.dim)      # amplitude per dimension (cos modulation)\n\n        for i in range(self.dim):\n            # Normalize i across dimensions to derive a per-dimension scale\n            # Frequencies: distinct per dimension, ensuring multiple local minima\n            c = 1.0 + (i % 5) / 5.0        # c in {1.0, 1.2, 1.4, 1.6, 1.8}\n            self.omega[i] = 2.0 * np.pi * c  # omega_i = 2*pi*c_i\n\n            # Choose a_i so that omega_i * a_i = 2*pi*m_i for some small integer m_i\n            # This makes cos(omega_i * a_i) = 1, so the per-dimension term is purely quadratic at its optimum\n            m_i = (i % 5) - 2               # m_i in {-2, -1, 0, 1, 2}\n            self.a[i] = float(m_i) / c      # a_i = m_i / c_i\n\n            # Amplitude for the cosine modulation, varied deterministically with dimension\n            self.p[i] = 0.3 + 0.7 * (i / float(max(1, self.dim - 1)))\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape == (self.dim,):\n            xi = x\n        else:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension landscape: (x_i - a_i)^2 + p_i * (1 - cos(omega_i * x_i))\n        diff = xi - self.a\n        term = diff**2 + self.p * (1.0 - np.cos(self.omega * xi))\n        return float(np.sum(term))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["18b926d4-f4a7-4e3e-801a-4d4481f85c9a"], "operator": null, "metadata": {"ela_features_2D": [0.5849044302603891, -0.07721725511956287, 0.20727363697583998, 0.5290296807154272, 2.553949088186141, 0.5844211039976887, 0.9979118690893873, 1.0038965556593584, 0.9979088361147909, 0.811230571178362, -0.07845439625812167, 1.0, 0.6589750509521313, 0.6986922225609089, 0.5042537347519354, 0.35272920415912606, -0.13896887782537476, 0.21839959961906424, 0.2583098830221987, 0.3236743286055646, 0.49186182056704225, 0.22283696113160625, 0.25624023810270924, 0.3242436782203422, 0.49472278199471287, -0.4089352431915797, -0.3880516960002936, -0.35385419797122797, -0.26585925816507744, -0.3993812085560383, -0.3821727844178201, -0.3472385553577834, -0.25964128799600045, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5088858554870075, 0.5088277925386132, 0.5438223656047367, 0.5886017691507107, 0.7448268777605538, 0.34134134134134125, 0.39577704682056475, -0.19919919919919912, 0.38313253012048193], "score_Separable_2D": 1.0, "ela_features": [0.4367891662125043, 0.2721594481847637, 0.0038187967847106196, 0.32631923809260677, 5257.725197382223, 0.443405981233327, 0.9975068826144498, 1.0087730138600948, 0.9974986915293155, 0.5351198198781587, 0.023519442550556047, 1.0, 0.9034898550554894, 0.8703612096444301, 0.638581615219431, 0.18584533361146285, -0.3973431942883906, 0.4480675610797628, 0.5313836111696263, 0.6050793294831064, 0.7266003495777317, 0.4519233736710106, 0.5339962090491959, 0.6089537332373123, 0.7300231204769236, -0.4855679302628588, -0.4122690023511069, -0.34743410456562146, -0.24052525462303623, -0.484843968767524, -0.41223941230536887, -0.3459284194242044, -0.2388274005627787, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21601326978142477, 0.21599252867765686, 0.2283268219356028, 0.27895152265302425, 0.8210960907575876, 0.061061061061061, 0.2111515018405222, -0.4474474474474473, 0.49935897435897436], "score_Separable_5D": 1.0, "ela_features_10D": [0.4238975244262013, 0.27221475932453343, 0.002972136741236141, 0.19848048838175156, 101.2197031963253, 0.4274818112861274, 0.9975561831496986, 1.0104532798476018, 0.9975465906207767, 0.37402028197325754, 0.04217890660668093, 1.4, 1.0150249106530012, 0.9392025733836082, 0.7239760728579849, 0.1029764415778243, -0.517244365637012, 0.6272345224646745, 0.6891448886814305, 0.7419910142919326, 0.8220600447351465, 0.63104459420136, 0.6937872476183434, 0.7458972922922588, 0.8259939402972873, -0.4727524851223583, -0.39423606971180825, -0.32721401446647397, -0.22566761062146418, -0.4691383697132032, -0.3893592180366612, -0.3230975233980854, -0.22125069819781257, 0.9, 0.9, 0.8727272727272727, 0.909090909090909, 0.11016668788871024, 0.11016987734767428, 0.11263342443285937, 0.15016354123191097, 0.8538625057689927, -0.20320320320320318, 0.11318609628278473, -0.7317317317317314, 0.5716573258606885], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-1.6666666666666665, 0.5555555555555554], 3.9901234567901254], [6, [-2.8288888888890056, -4.032000000000107], 11.548526220371537], [3, [-2.828869692201891, -1.6385747045179382], 1.5151308649823538], [3, [-2.8288888888890056, 1.5746666666666669], 6.873924737648983], [3, [-2.8288577480840797, -2.4412710611397106], 3.526280260908405], [1, [-1.7837050759667388, -2.359315132985315], 3.1241178458976413], [3, [-2.7274656028809456, -0.731894347328466], 1.1603318920817864], [1, [-1.6886657268884178, -0.6766068110891624], 1.154902550998735], [1, [-1.7322116003008312, -1.580964207180434], 1.1657341260624923], [1, [-1.7701057871569896, 1.4812704866405686], 6.500363135294072], [9, [-2.7730573032659867, 2.3644132849806323], 11.558485972629693], [3, [-2.8108926238749716, 0.5558796723541826], 4.273341731457863], [2, [-2.138086952098659, -3.172296254360271], 6.246728584095884], [21, [-1.1711664327618465, 2.365114928613785], 11.548528986589757], [12, [-1.171436958745587, -4.031999749328208], 11.548526731993835], [6, [-1.1713866847552992, 1.5743253853241383], 6.873929362657833], [6, [-1.1713942598248264, -1.6366666552848737], 1.5151874965667544], [6, [-1.1842994359644228, -2.408709654055507], 3.5545040685121005], [6, [-1.1776627183220278, -0.7272308584986938], 1.1590789506047599], [6, [-1.1873267540914134, 0.5564774310893831], 4.270873521073252]], "nr_of_basins": 20, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.0, -0.8333333333333334], "f_opt_dim_5": 0.835472697567069, "x_opt_dim_5": [-2.0441223749021957, -0.6580206484910166, 0.10939216639194066, 0.680307650854416, 1.1266591087685525]}
{"id": "212de4eb-fb5b-4a0f-bab4-38440d113223", "fitness": 1.0, "name": "landscape_log_sine", "description": "A separable, smooth multi-modal landscape built from a log-space sinusoidal rug. Each dimension has its own amplitude, frequency, and phase, creating many local minima along each axis while preserving a global minimum at the origin. The function is separable: f(x) = sum_i g_i(x_i), with g_i(x) = x_i^2 * (1 + a_i * sin( omega_i * log(1 + x_i^2) + phi_i )). This keeps the problem within [-5, 5] per dimension and ensures f(0) = 0.", "code": "import numpy as np\n\nclass landscape_log_sine:\n    def __init__(self, dim=5):\n        self.dim = dim\n        rng = np.random.default_rng(seed=4242)\n        # Per-dimension ruggedness amplitude (0.3 to 0.9) to keep nonnegativity and controlled roughness\n        self.a = rng.uniform(0.3, 0.9, size=dim)\n        # Per-dimension frequencies for the log-domain modulation\n        self.omega = rng.integers(2, 8, size=dim).astype(float)\n        # Per-dimension phase offsets to decorrelate dimensions\n        self.phase = rng.uniform(0, 2 * np.pi, size=dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        # 1D landscape: g_i(x_i) = x_i^2 * (1 + a_i * sin(omega_i * log(1 + x_i^2) + phase_i))\n        t = np.log1p(x * x)  # log(1 + x^2), ensures smoothness at 0\n        g = x * x * (1.0 + self.a * np.sin(self.omega * t + self.phase))\n        return float(np.sum(g))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_log_sine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5dc7f412-7c1b-4e97-b18d-841457558527"], "operator": null, "metadata": {"ela_features_2D": [-0.002672580559250193, 0.2757154693861088, 0.014818101894228261, 0.024788054304318387, 1.7787254602558407, 0.0007259281236035253, 0.8612416154317497, 4.242511566552021, 0.8612655192501093, 1.0826121821267662, 0.12976462638873426, 1.8, 0.48024696654618887, 0.6768560520868723, 0.387046410531449, 0.354125944697394, -0.2134108511848841, 0.19176064194215964, 0.32684135890875, 0.3935127274014726, 0.5612736888615575, 0.1790027160366034, 0.3283084195856705, 0.3765035536033424, 0.5511861096530896, -0.4228808534911164, -0.35220572605200273, -0.3173266912077306, -0.22955192920193673, -0.42179796550985776, -0.34508289303650114, -0.3203353848490206, -0.23058897088775415, 1.0, 1.0, 1.0, 1.0, 0.5186066014800963, 0.5185956895639567, 0.37995698753878626, 0.35030343207965203, 0.6741306112679645, 0.6496496496496494, 0.4992010398326444, -0.047047047047047055, 0.39477911646586344], "score_Separable_2D": 1.0, "ela_features": [0.0002933745711571234, 0.38681638776111144, 0.002886368316275736, 0.02635258809852361, 13.119231668948242, 0.0026901736397631827, 0.8845889763922721, 2.7660142391249365, 0.8862782985888001, 0.3519852845034073, -0.1841031147520095, 1.4, 0.8569610443729317, 0.8630832030943445, 0.5970722858076282, 0.19142119040410088, -0.4798961506713061, 0.4741127644108697, 0.5617018964829323, 0.6367532788907718, 0.7369858854991834, 0.47122320857008104, 0.5526210328830032, 0.6282671191243066, 0.7354762380278351, -0.46256782148122133, -0.3855242287679147, -0.3195078790924497, -0.2313439078181639, -0.46742110610463233, -0.3954607841064009, -0.32858914165957326, -0.23382269641769984, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2148893347072473, 0.21488658517364376, 0.1997112796954224, 0.18160510699865276, 0.8388637500862443, 0.24924924924924916, 0.2841040643702713, -0.33933933933933924, 0.5503205128205128], "score_Separable_5D": 1.0, "ela_features_10D": [-8.692705232247189e-05, 0.38918502025365614, 0.001472783583603384, 0.019529896536102164, 36.02965668738078, 0.006146758898484572, 0.8161013686939083, 3.0339778042634102, 0.8173575596283481, 0.4364566589238258, 0.005125701466427213, 2.0, 0.9655574965926146, 0.9304580629198466, 0.6640587289913793, 0.11263583936739527, -0.59215642531894, 0.6620270411401845, 0.7205287360020097, 0.769682195215674, 0.8362290594109213, 0.6618958428271438, 0.7208689610576904, 0.7705763372270623, 0.8381567968214441, -0.42863059332280146, -0.35443682852789166, -0.292097945036798, -0.20770074586173748, -0.4299181008557055, -0.3549311897056182, -0.2917250048470332, -0.20579261934565446, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10960905241054997, 0.10961957380048278, 0.10660569191135467, 0.1004277354387579, 0.8607811162152273, -0.05505505505505507, 0.14504776264693067, -0.6076076076076073, 0.6073658927141713], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 6.463810952451494e-07], [4, [0.00044444444444512003, 4.118000000000097], 5.178629758581514], [4, [0.00044444444444512003, -4.118000000000097], 5.178629758581514], [4, [0.00044444444444512003, 1.0506666666666664], 0.3633499505914611], [4, [-2.1077777777778515, 1.0506666666666664], 1.4536637037130231], [6, [2.1077777777778524, 1.0506666666666664], 1.453663703713024], [4, [0.00044444444444512003, -1.050666666666666], 0.36334995059146113], [4, [-2.1077777777778515, -1.050666666666666], 1.4536637037130231], [6, [2.1077777777778524, -1.050666666666666], 1.453663703713024], [16, [-2.1077777777778515, 0.00044444444444512003], 1.0903143995026572], [8, [-2.1077777777778515, 4.118000000000097], 6.268943511703076], [8, [-2.1077777777778515, -4.118000000000097], 6.268943511703076], [12, [2.1077777777778524, 0.00044444444444512003], 1.090314399502658], [8, [2.1077777777778524, 4.118000000000097], 6.2689435117030765], [8, [2.1077777777778524, -4.118000000000097], 6.2689435117030765]], "nr_of_basins": 15, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.551429193132382e-162, -7.866587239225318e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.601871296442279e-163, -4.6281666155153746e-163, -1.3569964685637469e-163, 2.7698914570961664e-163, -2.2708067744634458e-163]}
{"id": "71375e33-aa07-43d3-8417-27cc4eea5b7d", "fitness": 1.0, "name": "landscape_new", "description": "A completely different separable landscape where each dimension uses a multiplicative sine modulation on a quadratic base, yielding smooth multiperiodic hills while keeping a unique global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_new:\n    \n    def __init__(self, dim=5, seed=123):\n        self.dim = int(dim)\n        self.seed = int(seed)\n        self._params = self._build_params()\n    \n    def _build_params(self):\n        rng = np.random.RandomState(self.seed)\n        # Per-dimension amplitude for the sine modulation (kept below 1 to keep positivity)\n        amp = rng.uniform(0.3, 0.9, size=self.dim)\n        # Per-dimension frequency for the sine modulation\n        freq = rng.uniform(0.5, 3.0, size=self.dim)\n        return amp, freq\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input vector must be 1D with length {self.dim}. Got shape {x.shape}.\")\n        amp, freq = self._params\n        # Separable per-dimension function: h_i(z) = z^2 * (1 + a_i * sin(b_i * z))^2\n        # Global minimum at x = 0 with f(x) = 0. The multiplicative sine term creates multiple local minima\n        # while preserving separability and non-negativity.\n        z = x\n        return float(np.sum(z**2 * (1.0 + amp * np.sin(freq * z))**2))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_new scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["222556ee-8a2b-4b4c-869a-903197d084cf"], "operator": null, "metadata": {"ela_features_2D": [0.2913774602695006, 0.3030583999183512, 0.14728064570798693, 0.35128567232317015, 2.399742426176336, 0.292003050747138, 0.7148269496255618, 1.275644405955548, 0.9257019725272938, 1.4410448790777401, 1.5224204941440518, 2.4, 0.4179597573783722, 0.6525548444031941, 0.3407930727710947, 0.36732729870711767, -0.18582097543888293, 0.15231019613697974, 0.22393809001073475, 0.49156465603715666, 0.6794026639234269, 0.15407177057136742, 0.2221053448575346, 0.41546074092367713, 0.6552122861089792, -0.4436121688348284, -0.40612615876277935, -0.2660791667991531, -0.16777209337548146, -0.4352491258012347, -0.4002398999108088, -0.3007535994016849, -0.1773820572557657, 1.0, 1.0, 1.0, 1.0, 0.5132667018098995, 0.5132200039202217, 0.48190658964000666, 0.5128747174234353, 0.6844285578047982, 0.6136136136136134, 0.27104816329857134, -0.23123123123123115, 0.4048192771084337], "score_Separable_2D": 1.0, "ela_features": [0.040156229936955265, 0.18176247908772517, 0.005426487908258098, 0.09709040966400317, 31.691246816392226, 0.04419791733658758, 0.4792132532309707, 1.176768203043146, 0.732245532480773, 0.8124563124863691, 0.5206381379048095, 1.6, 0.6863666619586283, 0.8272950211588261, 0.5083449269401596, 0.21871032285336658, -0.5100560210537946, 0.5773161152260076, 0.6404556709135918, 0.7137152389746613, 0.8159550671043331, 0.5714600984814494, 0.628042556860512, 0.7012033361469878, 0.8059049752177494, -0.37185049852755303, -0.31630492615864514, -0.25185592960710823, -0.16191169884034667, -0.3791331973545667, -0.32907760354346854, -0.2643509663066709, -0.1717184725364453, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2169005378985301, 0.21689393867493162, 0.20385512431280733, 0.20170362742917272, 0.8420596633753579, 0.38538538538538525, 0.2945481886482002, -0.25125125125125125, 0.6051282051282051], "score_Separable_5D": 1.0, "ela_features_10D": [0.1588149787519499, 0.40054220306006727, 0.008505058899557674, 0.12633532584283508, 17.278369558117426, 0.16043171724382005, 0.5968115667478198, 1.5939644021356196, 0.8367338760580486, 0.6545408317900308, 0.4163356172827539, 1.2, 0.8843640476626847, 0.9195498280488422, 0.6131446677343158, 0.1217699273966939, -0.556289390954867, 0.7315592908615643, 0.7706199679538491, 0.8117337862657065, 0.8651265122577806, 0.7280658873921346, 0.7688590283066337, 0.8111085246365957, 0.8651125358810194, -0.34044837062466293, -0.29090946660351175, -0.23876786015899482, -0.1710521771617175, -0.34581677311701975, -0.2939412229250168, -0.24021405382969738, -0.17153553004915784, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11026508254363401, 0.11025625663598879, 0.1085022572685053, 0.12848674907201904, 0.8607744025553522, -0.0070070070070070226, 0.1423501461012727, -0.6036036036036034, 0.622738190552442], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 88.43234181614238], [6, [4.336000000000073, -4.102888888888866], 6.314440359672597], [9, [4.335828319557802, 2.369250397236001], 3.188115219875889], [4, [-5.0, -0.00044444444444512003], 62.63993064046716], [12, [4.336000000000073, -0.00044444444444512003], 1.5242083885240987], [6, [-0.00044444444444512003, 5.0], 25.792411570446927], [12, [-0.00044444444444512003, -4.102888888888866], 4.790232365920212], [18, [-0.00044444444444512003, 2.3686666666666265], 1.6639089173894124], [24, [-0.00044444444444512003, -0.00044444444444512003], 3.9477171374246895e-07], [3, [-5.000749577036034, 2.326675258552981], 64.30365812419862], [2, [-5.000208560225812, -4.090891185306333], 67.43009876579426], [3, [4.214017549843136, 5.001813136745818], 27.314211795369626]], "nr_of_basins": 12, "f_opt_dim_2": 0.0, "x_opt_dim_2": [3.5416385441354795e-163, 6.874450396997503e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.461591091971245e-162, -7.956524275033345e-164, 5.512156128949704e-163, 1.7113627113665553e-164, -1.1271761348822225e-162]}
{"id": "96cdd850-2e93-4ba0-b04a-6ca3590e2b44", "fitness": 1.0, "name": "landscape_cos_quadratic_sep", "description": "A separable quadratic-well with per-dimension cosine modulation around distinct optima. Each dimension has its own center m_i, a small modulation amplitude \u03b5_i, and a frequency \u03c9_i, creating multiple local features while preserving separability. The global minimum lies at x = m (f(x) = 0), with each dimension contributing independently.", "code": "import numpy as np\n\nclass landscape_cos_quadratic_sep:\n    \"\"\"\n    Separable landscape: per-dimension quadratic well centered at a dimension-specific\n    optimum m_i, perturbed by a cosine modulation. The problem is separable:\n    f(x) = sum_i [ (x_i - m_i)^2 + eps_i * (1 - cos( omega_i * (x_i - m_i) )) ].\n    Global minimum is at x = m with f(x) = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension optima distributed across [-4, 4] to ensure diverse centers\n        if self.dim == 1:\n            self.m = np.array([0.0])\n        else:\n            self.m = np.linspace(-4.0, 4.0, self.dim)\n\n        # Per-dimension modulation amplitudes (positive)\n        self.eps = 0.15 + 0.05 * (np.arange(self.dim) % 4)  # varies between 0.15 and 0.29\n\n        # Per-dimension modulation frequencies\n        # Use a small set of frequencies to introduce multiple local features\n        self.omega = 2.0 + (np.arange(self.dim) % 3) * 1.5  # values in {2.0, 3.5, 5.0}\n\n        # Evaluation bounds (not strictly enforced here; provided for clarity)\n        self.bound = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}\")\n\n        dx = x - self.m\n        # Per-dimension contribution: quadratic well + cosine modulation\n        per_dim = (dx ** 2) + self.eps * (1.0 - np.cos(self.omega * dx))\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_cos_quadratic_sep scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5520eaad-c3de-406f-a6ca-184be121dabc"], "operator": null, "metadata": {"ela_features_2D": [0.9048888821040777, 0.3254640004092592, 0.5250635518463872, 0.5356264041379177, 1.0201354959061277, 0.9054198572400496, 0.9999740557480331, 1.0017806300258625, 0.9999744784710657, 0.5286155517990273, -0.40899781925548107, 1.8, 0.694527251389933, 0.7074905440410968, 0.5418006753637254, 0.34885606577208744, -0.10229694067177741, 0.1530556773161435, 0.2327648206448385, 0.32093757585282545, 0.49823824728608584, 0.1535078025198672, 0.23364517825712666, 0.3192856500651092, 0.49457407542371296, -0.443099558250697, -0.40139471081550077, -0.3552692524571566, -0.26250844167234744, -0.43498953593293904, -0.3937950268431093, -0.3498056901842711, -0.25973004318382137, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5208323253629921, 0.5206849120542155, 0.6057684382879498, 0.651782519169869, 0.6851649818230903, 0.1531531531531531, 0.25972088959167544, -0.40340340340340336, 0.355421686746988], "score_Separable_2D": 1.0, "ela_features": [0.8294744689166624, 0.3527723585148528, 0.003944586123757934, 0.3667735858568321, 113.79786877375838, 0.8309613752956905, 0.9999298573717045, 1.0078484438792725, 0.9999307129510491, 0.4287476447214173, -0.2330356971648917, 1.0, 0.8909081902199285, 0.8683491084838494, 0.6433135322671821, 0.18583917409928577, -0.3014503052465872, 0.4516494630192402, 0.5466943988811985, 0.6366548293065065, 0.7614724800768632, 0.44957196244585995, 0.5475186423735476, 0.6347407367070436, 0.7583092921765234, -0.48233376938872785, -0.3987290971373863, -0.3195990876176795, -0.20981013764733544, -0.4866529857380534, -0.4000441645685779, -0.3229248083446324, -0.21368177568595476, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2195646503746898, 0.21957027723240724, 0.2539136729779122, 0.3208628854113763, 0.8050378024858738, -0.07107107107107108, 0.16120834468568512, -0.6036036036036034, 0.49198717948717946], "score_Separable_5D": 1.0, "ela_features_10D": [0.7944505345360438, 0.3972133453212496, 0.025130652231233792, 0.2488190271413131, 10.469376050707476, 0.7955238713685843, 0.9999108269750467, 1.0089944888539801, 0.9999118726012792, 0.320743319969592, -0.14957782703359382, 1.6, 0.9835995590009622, 0.9336697903933754, 0.7093162710883967, 0.10664563192982439, -0.4241405555530699, 0.6698355652258229, 0.7278363854118247, 0.7787013999622836, 0.8552725288822096, 0.6712904005598925, 0.7302457024176955, 0.7812712826474362, 0.8572738148408149, -0.4187001427567333, -0.3451463650570348, -0.2806414053057412, -0.18353687637241486, -0.4178819055942958, -0.3429349364358903, -0.2780661009614658, -0.18144489168151523, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10887215032564437, 0.10886555920566617, 0.12172616852756306, 0.17142370901656187, 0.8389105587620268, -0.2792792792792792, 0.08974340711248277, -0.8118118118118115, 0.542994395516413], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 2.4259050557356555e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 9.182425196865679e-177, "x_opt_dim_5": [-4.0, -2.0, 9.582497167683212e-89, 2.0, 4.0]}
{"id": "718c4844-3553-47e1-bf11-a1106888dc63", "fitness": 1.0, "name": "landscape_enhanced_ridges", "description": "A novel separable ridge benchmark with per-dimension weights, frequencies and phase offsets; f(x) = sum_i w_i * x_i^2 * (1 + sin^2(k_i x_i + phi_i)), ensuring a global minimum at x = 0 and preserving separability for easy subproblem partitioning.", "code": "import numpy as np\n\nclass landscape_enhanced_ridges:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Deterministic per-dimension parameters to diversify the landscape while keeping it separable\n        idx = np.arange(self.dim)\n        # Quadratic base weight per dimension, small variation around 1.0\n        self.w = 0.8 + 0.4 * (idx / max(1, self.dim - 1))  # in [0.8, 1.2]\n        # Per-dimension frequency for the sine modulation\n        self.k = 1 + 2 * (idx % 3)  # values in {1, 3, 5}\n        # Phase offsets to introduce variety in the ridges without destroying separability\n        self.phi = (idx % 4) * 0.5  # values in {0.0, 0.5, 1.0, 1.5}\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension {x.size} does not match landscape dimension {self.dim}.\")\n\n        # Separable per-dimension contribution: w_i * x_i^2 * (1 + sin^2(k_i * x_i + phi_i))\n        per_dim = self.w * (x ** 2) * (1.0 + np.sin(self.k * x + self.phi) ** 2)\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_enhanced_ridges scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["06427b31-0240-4ea8-8eaf-548fe78725e7"], "operator": null, "metadata": {"ela_features_2D": [-0.001052728371850309, 0.29744268124964973, 0.015889875531048175, 0.027516764429316342, 2.0885045629230716, 0.00422151503572028, 0.9064518904967356, 1.287076932441954, 0.9078072323075519, 0.7380256057600662, 0.043599410215136115, 1.4, 0.5723935966346361, 0.6654898763480855, 0.468315886132214, 0.3718617256358673, -0.2506952276921434, 0.14567644372187755, 0.2229675288500504, 0.32065422929973536, 0.5152141137782588, 0.15043835266246242, 0.22336202731237229, 0.3193475594981038, 0.5076334243923533, -0.44716209167900445, -0.4067034395311052, -0.35557660327257845, -0.2537391884858587, -0.43721228476541657, -0.39967680621016927, -0.35028013406869835, -0.25337984503301325, 1.0, 1.0, 1.0, 1.0, 0.5149578159223492, 0.5149326009423559, 0.4139687244230573, 0.3497600959234939, 0.7288332055544482, 0.9019019019019016, 0.4935966595058911, 0.07707707707707703, 0.4481927710843373], "score_Separable_2D": 1.0, "ela_features": [-0.0010617762488194238, 0.3605766352030508, 0.0025851158551373115, 0.022081871551577308, 16.3801715457143, 0.0030744035710405402, 0.9032653708834909, 1.493739080973486, 0.9045581574877579, 0.4289320931946873, -0.021315798303110256, 1.4, 0.866204671852455, 0.861128298341215, 0.6080533550306308, 0.192889575694616, -0.48855114942232003, 0.42811654491373374, 0.5236663816120921, 0.6088774972605216, 0.7264143961826433, 0.4295659902646748, 0.5218253437494305, 0.6079381955138545, 0.7279403203497538, -0.5029742970180869, -0.4189384428776754, -0.34399516196053254, -0.24061967412448695, -0.5041524884369898, -0.4226254273170832, -0.34651483345018474, -0.240449162645058, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2138667620133469, 0.21383363916503212, 0.1998500222981328, 0.17966873939710584, 0.8377590461804691, 0.2572572572572572, 0.2714286284855322, -0.31931931931931923, 0.5424679487179487], "score_Separable_5D": 1.0, "ela_features_10D": [0.0024479737307225857, 0.3910455634667107, 0.0015662496808404737, 0.022642259168240413, 18.137942034847423, 0.006760675043292852, 0.9032245770368844, 1.8023857975397726, 0.9054414956148973, 0.2980485661806006, 0.0832919989527408, 1.8, 0.9931663799456162, 0.936122895090886, 0.695707048210475, 0.10599040444439652, -0.6065456638383907, 0.6285548273261812, 0.6861954242851513, 0.7399838430562755, 0.8185107659727991, 0.6319887210841217, 0.688151215301985, 0.7428537655636915, 0.8214819178805903, -0.4710965103753332, -0.3979915080768535, -0.3297725345967054, -0.2301782650029785, -0.46802972996576786, -0.39660135124227675, -0.3270312140260878, -0.22703307286954938, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10902005963167154, 0.10901631934024533, 0.10655842216766538, 0.10138131996617512, 0.8571547396817433, -0.11911911911911913, 0.13026167593018478, -0.6716716716716714, 0.6034427542033627], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [0.00044444444444512003, -1.082666666666666], 1.6134821255464904], [10, [0.00044444444444512003, -2.2077777777778405], 5.9973317337064085], [10, [0.00044444444444512003, -5.0], 56.22086310335974], [10, [0.00044444444444512003, 1.666666666666667], 4.992623994711304], [10, [0.00044444444444512003, 2.7777777777777786], 12.137723233405776], [10, [0.00044444444444512003, 3.8888888888888893], 20.896400988534147], [10, [0.00044444444444512003, 5.0], 31.278864790956757], [22, [0.00044444444444512003, -0.00044444444444512003], 4.4927873089875184e-07], [10, [0.00044444444444512003, -3.2728888888889567], 12.998352585402124]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-8.205364435370722e-163, -1.0381446743218163e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [7.261598833453013e-163, 4.609988836896859e-164, 8.657609879973735e-163, -1.3961711118149307e-163, 2.230968650887273e-164]}
{"id": "663907e7-57cb-4240-aa9d-e8ae44d04b22", "fitness": 1.0, "name": "landscape_damped_cosine_sep", "description": "Novel separable landscape based on a damped quadratic with cosine ripples per dimension. Each dimension combines a smooth, damped quadratic term with a dimension-dependent cosine modulation, ensuring a unique global minimum at the origin and separability across dimensions.", "code": "import numpy as np\n\nclass landscape_damped_cosine_sep:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n        \n        # Deterministic, per-dimension parameters to induce diverse, separable landscapes\n        idx = np.arange(self.dim, dtype=float)\n        max_index = max(self.dim - 1, 1)\n\n        # A_i: quadratic amplitude per dimension\n        self.A = 0.25 * (1.0 + 0.7 * (idx / max_index))\n        # B_i: exponential damping coefficient per dimension (controls how fast the quadratic term decays away from 0)\n        self.B = 0.12 * (1.0 + 0.8 * (idx / max_index))\n        # D_i: cosine frequency per dimension\n        self.D = 0.8 + 0.6 * (idx / max_index)\n        # C_i: cosine modulation amplitude per dimension\n        self.C = 0.2 * (1.0 + 0.9 * (idx / max_index))\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension contributions:\n        # g_i(x_i) = A_i * x_i^2 * exp(-B_i * |x_i|) + C_i * (1 - cos(D_i * x_i))\n        term1 = self.A * (x**2) * np.exp(-self.B * np.abs(x))\n        term2 = self.C * (1.0 - np.cos(self.D * x))\n        return float(np.sum(term1 + term2))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_damped_cosine_sep scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["521d64e2-cc68-4029-94dd-4b1c57a43be9"], "operator": null, "metadata": {"ela_features_2D": [-0.0028687071169744894, 0.48801801276893375, 0.011799801471343681, 0.019819129747325227, 1.877087989449461, -0.0031099504709206196, 0.9067976423788938, 1.1521740762193815, 0.9065932308419663, -0.024102894750989878, -0.5314872266166911, 1.2, 0.7185783159230648, 0.7169192881154878, 0.5598000217453262, 0.3420667882652254, -0.1945300723854267, 0.15384589280579317, 0.23807520126053544, 0.3300953339998612, 0.5174995257093051, 0.15240261789584114, 0.23139555651881855, 0.3219955707871907, 0.5142655773860827, -0.44286617240172765, -0.398778876117562, -0.3506159390353193, -0.2525313772875468, -0.43640830213859994, -0.39573926939422643, -0.3490828421617291, -0.25008255997514245, 1.0, 1.0, 1.0, 1.0, 0.5169041516765696, 0.5168991514773162, 0.3981312148163693, 0.35112697435345935, 0.7171910650052172, 0.32932932932932923, 0.585558588149999, -0.09109109109109106, 0.35180722891566263], "score_Separable_2D": 1.0, "ela_features": [0.00014544203766799768, 0.4826748267073441, 0.003084097916609495, 0.027648748441692406, 14.194406444432659, 0.0023389249596738938, 0.9083835309193183, 1.1816742628307388, 0.9086576438788091, -0.041655383123843176, -0.3644166011377658, 1.0, 0.8713466451789256, 0.8690716724855732, 0.6405025854143831, 0.18306770144611967, -0.46193169998445593, 0.45108762522278845, 0.5448695848901779, 0.6161101439321858, 0.7318736522977793, 0.45234550469267115, 0.5447030134694905, 0.6187302504315091, 0.7332836761533545, -0.4828556526012708, -0.40035939744201177, -0.3376927144254161, -0.23585959617446983, -0.4845091647320688, -0.4028060948746722, -0.33731674843330833, -0.2359665211143191, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2162883705729251, 0.2163119115437336, 0.20117722572897456, 0.18284973969800114, 0.8229329482759301, 0.06906906906906903, 0.26354671024836496, -0.37537537537537524, 0.4950320512820513], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0004845379481336565, 0.501689562457652, 0.0013015395989936936, 0.01805198635794952, 156.2472781129323, 0.0005226221601608572, 0.9134105409167166, 1.1918679758732924, 0.9137970434182039, -0.015062159204143017, -0.16115796629533047, 1.4, 0.9873788735390889, 0.9345975767747229, 0.695769266460398, 0.10616467302398631, -0.605919989060378, 0.6338726181215981, 0.6919961315628126, 0.7406056789270623, 0.8145167482781679, 0.6355516606585923, 0.6945735357211086, 0.7436679438676034, 0.8180041123581148, -0.4643170956871404, -0.3906060685058942, -0.32896041943600357, -0.23522786152832348, -0.46337038264035996, -0.3883288913875162, -0.3259093071790157, -0.23139648053875583, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11015683333908899, 0.11014725588288059, 0.10713720005825897, 0.10080859304353443, 0.8553660281433842, -0.1271271271271271, 0.13895097841050713, -0.6396396396396394, 0.5859087269815852], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.195251073981943e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.3858052971947867e-162, 2.315212863323285e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.196166399272554e-165, -4.79776782487153e-163, 1.7902402314054824e-162, -2.7036225192040027e-163, -2.6275385089822557e-162]}
{"id": "411932fb-03d1-424a-bc87-65a631194d0d", "fitness": 1.0, "name": "landscape_mixed_separable", "description": "A novel separable landscape combining a quadratic base with two independent periodic modulations (cosine and sine-squared) per dimension, introducing multiple local minima while preserving a unique global minimum at the origin. The function is separable and defined on [-5,5] per dimension.", "code": "import numpy as np\n\nclass landscape_mixed_separable:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension cosine frequency (wrapped if needed)\n        base_cos_freq = np.array([1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5], dtype=float)\n        if self.dim <= len(base_cos_freq):\n            self.cos_freq = base_cos_freq[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_cos_freq)))\n            self.cos_freq = np.tile(base_cos_freq, reps)[:self.dim]\n\n        # Dimension-specific parameters (deterministic and increasing with dimension)\n        if self.dim == 1:\n            self.a = np.array([0.15], dtype=float)  # quadratic base coefficient\n            self.b = np.array([0.2], dtype=float)   # cosine modulation amplitude\n            self.d = np.array([0.02], dtype=float)  # sine^2 modulation amplitude\n            self.e = np.array([0.5], dtype=float)   # sine frequency\n        else:\n            idx = np.arange(self.dim, dtype=float)\n            self.a = 0.15 + 0.10 * (idx / (self.dim - 1))  # quadratic base coefficients in [0.15, 0.25]\n            self.b = 0.2 + 0.8 * (idx / (self.dim - 1))    # cosine amplitudes in [0.2, 1.0]\n            self.d = 0.02 + 0.08 * (idx / (self.dim - 1))   # sine^2 amplitudes in [0.02, 0.10]\n            self.e = 0.5 + 0.8 * (idx / (self.dim - 1))     # sine frequencies in [0.5, 1.3]\n\n        # Ensure arrays are numpy arrays for broadcasting\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n        self.d = np.asarray(self.d, dtype=float)\n        self.e = np.asarray(self.e, dtype=float)\n        self.cos_freq = np.asarray(self.cos_freq, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension function: g_i(x_i) = a_i*x_i^2 + b_i*(1 - cos(freq_i * x_i)) + d_i*(sin(e_i * x_i))^2\n        quad_term = self.a * (x ** 2)\n        cos_term = self.b * (1.0 - np.cos(self.cos_freq * x))\n        sin_term = self.d * (np.sin(self.e * x) ** 2)\n\n        return float(np.sum(quad_term + cos_term + sin_term))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_mixed_separable scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["521d64e2-cc68-4029-94dd-4b1c57a43be9"], "operator": null, "metadata": {"ela_features_2D": [-0.003155611315935891, 0.43566298696031147, 0.007405178618996933, 0.01778968902222449, 6.8315475034065, -0.0031205819262648538, 0.9032346305792369, 1.318729872627458, 0.902876220901409, 0.05970671936853898, -0.39078821443280837, 1.0, 0.6974408492656112, 0.7128827148649975, 0.5413221349733129, 0.34535897170532726, -0.2098410000050191, 0.17073882265845314, 0.25103589021077155, 0.35202667678415256, 0.5317064860611176, 0.16481490367649884, 0.23505190576763874, 0.3279808887893607, 0.5056935119469412, -0.4334584426331524, -0.3914878658969188, -0.3387007334907439, -0.24477664963553852, -0.42771575225017544, -0.3917509367314831, -0.34416205269684974, -0.25314398377910374, 1.0, 1.0, 1.0, 1.0, 0.5142370340846503, 0.5140937592019867, 0.41160507705533106, 0.3474971268941478, 0.7196497934334886, 0.5215215215215214, 0.5646083561317924, -0.08708708708708705, 0.378714859437751], "score_Separable_2D": 1.0, "ela_features": [-0.00184553603243649, 0.4463652220277753, 0.002699423051224969, 0.020512774815951103, 21.44314630446599, -0.0006784025005382111, 0.9087782841773807, 1.5540745341531452, 0.9080648137876235, 0.22905811788460556, -0.1353231252304033, 1.0, 0.8401885265101207, 0.8589097530661581, 0.5788378483817491, 0.1953272466777432, -0.48939965398694196, 0.48296902111352197, 0.5618037000364049, 0.6293623052520422, 0.7363099044162917, 0.47517597813560136, 0.5604462338005187, 0.6270984653501837, 0.7363681429314248, -0.4547889435683098, -0.3854449530685551, -0.3260189817962622, -0.23194621987753167, -0.4642322305787855, -0.38880919044171725, -0.32984969085458893, -0.23319447699180543, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21384337736602843, 0.21379538632635478, 0.20091222866636974, 0.17961058245660125, 0.8514180198301409, 0.20120120120120114, 0.26969732597182083, -0.3433433433433432, 0.55625], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0003661507330194436, 0.43884268668106863, 0.0007866940615752476, 0.018611533570840097, 49.14115954231172, 0.0036132419461287536, 0.9125083290843043, 1.6224942864599226, 0.9121012987272241, 0.15633720090205444, -0.0740782040677935, 1.4, 0.9957392373963128, 0.9347660626036804, 0.687187988703715, 0.10860717832353302, -0.6166721839674878, 0.6404488750998122, 0.698221279351375, 0.7463567107298801, 0.8182506572953286, 0.6414733584524119, 0.7002024020654184, 0.7488798616084102, 0.8213624135974437, -0.4559999695631437, -0.38273020790988566, -0.3216826533309013, -0.23050356673315214, -0.45593570264242966, -0.38125044839624006, -0.31934755234860673, -0.22717236435143584, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10853880334327501, 0.1085422206898696, 0.10571168039481875, 0.09928759926981719, 0.8592819651528135, -0.0990990990990991, 0.13839709631742786, -0.6516516516516514, 0.5996797437950361], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.553580123825411e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.2842970893712444e-162, -3.229881002884678e-163], "f_opt_dim_5": 7.814450395981009e-295, "x_opt_dim_5": [4.59630692674192e-149, -1.0595542535872363e-147, -8.621128672845443e-148, -3.8257670239444046e-148, -8.885099624581407e-148]}
{"id": "20cf8e06-8149-471a-8c6c-7bbd9337a091", "fitness": 1.0, "name": "logsin_landscape", "description": "A separable, smooth landscape using a log-based base per dimension with a dimension-dependent sinusoidal modulation. Each dimension contributes h_i(x_i) = log(1 + x_i^2) + a_i * sin^2(b_i * x_i), ensuring a global minimum at x = 0 and allowing controllable multimodality via the sinusoidal term.", "code": "import numpy as np\n\nclass logsin_landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension modulation amplitudes\n        base_amps = np.array([0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2], dtype=float)\n        if self.dim <= len(base_amps):\n            self.amps = base_amps[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_amps)))\n            self.amps = np.tile(base_amps, reps)[:self.dim]\n\n        # Per-dimension frequencies for the sinusoidal modulation\n        self.freqs = 1.0 + 0.5 * np.arange(self.dim, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        # Per-dimension contribution: log(1 + x_i^2) + a_i * sin^2(b_i * x_i)\n        log_term = np.log1p(x**2)\n        sin_sq = np.sin(self.freqs * x)**2\n        return float(np.sum(log_term + self.amps * sin_sq))", "configspace": "", "generation": 1, "feedback": "The optimization landscape logsin_landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["521d64e2-cc68-4029-94dd-4b1c57a43be9"], "operator": null, "metadata": {"ela_features_2D": [-0.0034194807059729103, 0.5636887018862081, 0.0066524722789623545, 0.013431381545804106, 2.1710230061225695, 0.0011314114032216383, 0.8314774153280396, 1.0595902783750806, 0.8306429279296268, -0.27732498402565325, -0.38340756621392114, 1.8, 0.6383589325667484, 0.7010541291799139, 0.5043103038357435, 0.34797890586385694, -0.21704141845271158, 0.14415573745273394, 0.2325111993026324, 0.3455400920390217, 0.5601550862811544, 0.1444581498420889, 0.2303978547746542, 0.3422489934985, 0.5555507340392071, -0.4478583720481494, -0.401625127939705, -0.34247737734784345, -0.23016574894618458, -0.4398753583561056, -0.3956918715623019, -0.3381900230814002, -0.22850417508207208, 1.0, 1.0, 1.0, 1.0, 0.5237452616971539, 0.5237425531561977, 0.420018767407681, 0.35030109655255404, 0.7299057496322032, 0.44144144144144126, 0.5857156378909029, -0.09109109109109109, 0.37791164658634535], "score_Separable_2D": 1.0, "ela_features": [-0.00090145171395557, 0.5581882819298867, 0.002774061758739743, 0.022294573861621335, 49.7886122610562, 0.0036710218919213445, 0.792622416190083, 1.1374902333540393, 0.792294135927363, -0.1003832725567531, -0.16144613545345338, 1.6, 0.8069413216668803, 0.8500385253301829, 0.561447183463133, 0.20212639330483445, -0.4913507704439068, 0.5113432547081589, 0.5859390063372553, 0.6483215086184758, 0.7553262530559467, 0.5120078186313637, 0.583070595002134, 0.645624077258356, 0.7544425371816776, -0.4299240494879961, -0.3642956943685797, -0.3094066085679558, -0.215263311321488, -0.4317087504971459, -0.368845836749747, -0.31349716102591973, -0.21723089658627695, 1.0, 1.0, 0.8333333333333334, 1.0, 0.22150130072343152, 0.22147870505046613, 0.2077057805296288, 0.1847047937157762, 0.8460288466118765, 0.20120120120120114, 0.2713098190093833, -0.3433433433433433, 0.55], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0008485512270444362, 0.525278238095192, 0.0011084615304354907, 0.016804089472661658, 23.314987151534122, 0.005172869180121542, 0.6936452366259334, 1.2062805285488372, 0.6942819195823271, -0.08860395930805262, -0.06891661215233187, 1.2, 0.923799029085051, 0.9244744693673228, 0.6432427770753026, 0.11631827370003227, -0.6175964170476742, 0.680835466696104, 0.7332828897427048, 0.7741384797094956, 0.8394111801374937, 0.6792719615422873, 0.7340186564173411, 0.7747949983161124, 0.8407627780634191, -0.4047446729874678, -0.3382340638958071, -0.28642388611655456, -0.20364881253630518, -0.4077274448238398, -0.3381320524389243, -0.28629483131709954, -0.20243147065902142, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1106863864523471, 0.11067919137011535, 0.10778851783114414, 0.10107685359193756, 0.8609937409944525, -0.059059059059059074, 0.13840255987383682, -0.6156156156156154, 0.6162530024019215], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [0.00044444444444512003, -4.0060000000001095], 2.880022768302206], [20, [0.00044444444444512003, 4.0060000000001095], 2.880022768302206], [60, [0.00044444444444512003, 0.00044444444444512003], 7.407406570159262e-07]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.8433222366158815e-163, -8.956233642899785e-163], "f_opt_dim_5": 2.351753729402109e-192, "x_opt_dim_5": [-1.017421369407857e-96, -1.8088336307206445e-97, 8.18258912371225e-98, -9.408144639638621e-98, -2.4929846818664073e-97]}
{"id": "22934d04-7374-46c8-8fff-44cbaa88c42a", "fitness": 1.0, "name": "landscape", "description": "A strictly separable multi-well benchmark with per-dimension quadratic basins plus cosine micro-wells. Each dimension is independent, enabling easy partitioning into subproblems. Deterministic per-dimension parameters ensure reproducible, diverse landscapes while preserving additivity across dimensions. The global optimum value is the sum of the per-dimension minima.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic and reproducible)\n        self.a = np.zeros(self.dim)      # center offset per dimension\n        self.omega = np.zeros(self.dim)  # frequency per dimension\n        self.p = np.zeros(self.dim)      # amplitude per dimension\n\n        for i in range(self.dim):\n            # Normalize i to [0,1] across dimensions\n            t = i / float(max(1, self.dim - 1))\n            # Offsets in [-2, 2]\n            self.a[i] = -2.0 + 4.0 * t\n            # Frequencies: a small set of distinct values, ensuring multiple local minima\n            self.omega[i] = 2.0 * np.pi * (1.0 + (i % 5) / 5.0)\n            # Amplitudes in [0.3, ~2.0]\n            self.p[i] = 0.3 + 1.7 * ((i % 7) / 7.0)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension landscape: (x_i - a_i)^2 + p_i * (1 - cos(omega_i * x_i))\n        diff = x - self.a\n        cos_term = 1.0 - np.cos(self.omega * x)\n        return float(np.sum(self.p * cos_term + diff**2))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["18b926d4-f4a7-4e3e-801a-4d4481f85c9a"], "operator": null, "metadata": {"ela_features_2D": [0.6991125473636722, 0.2817020874050966, 0.4364927422579664, 0.44926189036460046, 1.0290825822762135, 0.7006939421511905, 0.9994786286647066, 1.0020417253504075, 0.9994771379974715, 0.7717461054837511, 0.004387202129353262, 1.6, 0.6760549766815919, 0.7058268955075485, 0.5276414842979971, 0.3476418404792279, -0.12325150770453108, 0.16090287942117407, 0.21314912446270756, 0.29862382973076784, 0.47835195557021615, 0.16127614750065042, 0.21310064417564564, 0.2957350252073526, 0.4773577228005008, -0.43885789274290266, -0.4115345325785178, -0.36682531715096245, -0.27281861732861823, -0.4306434338961978, -0.40403058112622325, -0.3615971676274877, -0.26832742731817866, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5222648830717908, 0.5222560708972375, 0.561302032896166, 0.6105708231523245, 0.7166915584344801, 0.26526526526526517, 0.32534677314917315, -0.3233233233233233, 0.3819277108433735], "score_Separable_2D": 1.0, "ela_features": [0.5500128311080266, 0.35312436129775754, 0.009490594364004776, 0.284053976191146, 61.61483442482745, 0.5502290096253459, 0.9970602485394421, 1.0107504401988627, 0.997054108971871, 0.5013977011414308, -0.030414910105538696, 1.2, 0.8971208194378291, 0.8717396193274475, 0.6356481998230371, 0.184601004897207, -0.3616913043189462, 0.4373960677968468, 0.5174270724116854, 0.5954797414420164, 0.7260429755269965, 0.43962832039908245, 0.5208465489304773, 0.596562178196962, 0.7282903184298813, -0.49494464561159085, -0.4245366344039031, -0.355870892317499, -0.2410104270439854, -0.49562669090623734, -0.4237870916905682, -0.3568204008622564, -0.24031521971417885, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21201160173174668, 0.21202010702284974, 0.230287596794917, 0.29143995088317426, 0.8209213317897206, 0.025025025025024995, 0.18945459324137262, -0.5315315315315314, 0.5100961538461539], "score_Separable_5D": 1.0, "ela_features_10D": [0.4948060788775349, 0.4143767764914189, 0.018414811164159363, 0.19097811341669008, 10.94442847163591, 0.49808222128251556, 0.9954980626983915, 1.0170826757322293, 0.9955089737760533, 0.3928066028250034, 0.0687961392096322, 1.4, 1.0047900436411965, 0.93817275115245, 0.7135665030211822, 0.10298742164259844, -0.5009011758192295, 0.6301291655826681, 0.6957782994200198, 0.7490740678460479, 0.8300993204822451, 0.6346357014816488, 0.6994502672248537, 0.7528575507110359, 0.8339222499504212, -0.469115020393623, -0.3858506014298066, -0.31825440097209556, -0.21548846145834424, -0.4646688379854232, -0.38223741063541067, -0.3143140680792216, -0.21121653767214874, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.10941886231510481, 0.10941189543577567, 0.11620274221471785, 0.15616028367559873, 0.8509100571676964, -0.19919919919919918, 0.10795376591848449, -0.7317317317317314, 0.5676541232986388], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-1.6666666666666665, 1.666666666666667], 0.6722222222222225], [3, [-2.8288292786256775, 3.2467051275382834], 2.510381335141306], [3, [-2.8288888888890056, 2.4697777777778125], 1.0790936884754785], [3, [-2.8268890399597404, 1.6666912483695657], 0.9554800784508609], [4, [-2.8288888888890056, 0.9075555555555557], 2.1206141860949153], [1, [-1.924934275981637, 3.0713213788255347], 1.9427356250953982], [6, [-2.815294826969596, 3.989561961369553], 5.219622982214358], [15, [-2.8287522604010285, 0.14958836476136003], 4.578589300347869], [34, [-1.1709611811171192, 0.1497653476608126], 4.578588974483634], [7, [-1.171463560033145, 0.9079216960056284], 2.1206122545824804], [6, [-1.1733328781065693, 1.6668397246923696], 0.9553851906185532], [17, [-1.1708968100052433, 2.4693021598694753], 1.0790903230967808]], "nr_of_basins": 12, "f_opt_dim_2": 0.10433612242264045, "x_opt_dim_2": [-2.0000000010892833, 1.6870292762899206], "f_opt_dim_5": 0.6039429618578963, "x_opt_dim_5": [-2.0000000010082486, -1.625472495340774, 7.489997540360409e-10, 0.6320845310042571, 2.2195221267615026]}
{"id": "b1373a9b-e536-4791-9160-054e9936b565", "fitness": 1.0, "name": "landscape_separable_quad_cosine", "description": "A novel separable landscape with independent per-dimension 1D profiles. Each dimension has its own quadratic weight and cosine modulation, yielding a smooth, multi-modal, yet fully separable function whose global minimum is at the origin. The problem can be partitioned into independent subproblems across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_quad_cosine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension frequencies for the cosine modulation\n        base_freq = np.array([2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0], dtype=float)\n        if self.dim <= len(base_freq):\n            self.freq = base_freq[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_freq)))\n            self.freq = np.tile(base_freq, reps)[:self.dim]\n\n        # Separable per-dimension quadratic weights (w_i) and cosine amplitudes (a_i)\n        # Ensure the global minimum occurs at x = 0 with f(0) = 0\n        if self.dim == 1:\n            self.weight = np.array([0.25], dtype=float)\n            self.amp_per_dim = np.array([0.5], dtype=float)\n        else:\n            # Quadratic weights grow smoothly from 0.1 to 0.9 across dimensions\n            self.weight = 0.1 + 0.8 * (np.arange(self.dim) / (self.dim - 1))\n            # Cosine amplitudes grow from ~0.25 to ~0.75 across dimensions\n            self.amp_per_dim = 0.25 + 0.5 * (np.arange(self.dim) / (self.dim - 1))\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension contribution: w_i * x_i^2 + a_i * (1 - cos(b_i * x_i))\n        quad = self.weight * (x**2)\n        periodic = self.amp_per_dim * (1.0 - np.cos(self.freq * x))\n        return float(np.sum(quad + periodic))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_quad_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["521d64e2-cc68-4029-94dd-4b1c57a43be9"], "operator": null, "metadata": {"ela_features_2D": [-0.002582454622225461, 0.3681541745692697, 0.004849433401805187, 0.024845371542435303, 9.53905806941265, -0.0029902230344480253, 0.9932621141849092, 8.271166308395557, 0.9932315051739709, 0.6013050492479588, -0.8108682160323708, 2.0, 0.6816942540272767, 0.7125251527000792, 0.5510240380330749, 0.3455233570120935, -0.19217960256682193, 0.20218630269655852, 0.3600806445801845, 0.4698269035514301, 0.5910734012810174, 0.19336931833143675, 0.32726486224442836, 0.4141815593478954, 0.5378841935712781, -0.41736300073849913, -0.3347723134061992, -0.2773579903516886, -0.21392063727366809, -0.4149841014910554, -0.3461263851870546, -0.30140938178670434, -0.23774282957185394, 1.0, 1.0, 1.0, 1.0, 0.512690184463746, 0.512664254181617, 0.36475286493693115, 0.346585000007409, 0.680763042526136, 0.6096096096096094, 0.46906344052521953, -0.04704704704704705, 0.3650602409638554], "score_Separable_2D": 1.0, "ela_features": [2.8898244306185815e-06, 0.39017430031411376, 0.005533716629995082, 0.02809550172947825, 6.920980343450014, 0.00028126313847773863, 0.9928514653058716, 8.57963435297783, 0.9928301595217945, 0.4023931853109529, -0.25340544429552886, 1.4, 0.8833281306111266, 0.8702900452575143, 0.6311117128884767, 0.18392081322369302, -0.4622738937866947, 0.503093031732929, 0.5709471266796232, 0.6442205275314061, 0.7499058469561467, 0.4808238270627208, 0.5547457247566989, 0.6285346891559358, 0.7431432607084103, -0.43704519225121397, -0.37736770864960023, -0.31292110553207936, -0.21996723554372194, -0.4589011689009211, -0.3935583613744333, -0.32833731880386247, -0.22703484471235846, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21938532263618882, 0.2193790317763437, 0.2024712712871896, 0.18476996522380756, 0.8268331033318331, 0.1731731731731731, 0.2670120432957693, -0.3513513513513512, 0.5166666666666667], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0010038388316270463, 0.41375015805700455, 0.0012526751418095617, 0.018060323428276313, 32.31620699334224, 0.0059581824100817474, 0.9921788347043996, 8.411253234915657, 0.9921511643885058, 0.24379977974490585, -0.17311613266303452, 1.6, 0.9962761196795926, 0.9349190886634995, 0.69576495521893, 0.10818355345372059, -0.5892945587339902, 0.6526587477959231, 0.7127579974922312, 0.7603224401342836, 0.8287353349093258, 0.6482143626916884, 0.71070670384648, 0.7600868175224408, 0.8303474512910014, -0.44051708293275676, -0.36429537718368066, -0.3039713264104529, -0.21720637576412655, -0.4472981724653474, -0.3678367387223037, -0.30504860090194336, -0.2157117356993003, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10920475232756588, 0.10920802710667998, 0.10605553471897651, 0.0995238405005843, 0.8570359285673955, -0.10710710710710707, 0.1375002669018967, -0.6236236236236234, 0.5871096877502002], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[18, [-2.453769124166281, 0.00024119921053790752], 0.8036202972341882], [58, [0.00044444444444512003, 0.00044444444444512003], 9.629628576528218e-07], [24, [2.452146443296805, -0.00011822999150757966], 0.8036202288161615]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.834338383371673e-162, 3.067588742285388e-163], "f_opt_dim_5": 9.300541994562579e-240, "x_opt_dim_5": [5.52597033040824e-120, -2.9277042097153436e-120, -1.8781724707528926e-120, -1.4629706679203152e-120, 6.778294326977498e-121]}
{"id": "8a8f40a2-fe89-4f23-834a-897f864ae223", "fitness": 1.0, "name": "landscape", "description": "A separable, multi-modal landscape where each dimension has a nonconvex 1D profile with periodic ripples atop a quadratic base. Each dimension i uses unique w_i (quadratic weight), a_i (cosine amplitude), and b_i (frequency) to create diverse local minima while preserving a global minimum at the origin. The function is separable: f(x)=sum_i g_i(x_i) with g_i(t)=w_i*t^2 + a_i*(1 - cos(b_i*t)).", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Deterministic, dimension-dependent parameters to ensure variety yet separability\n        # Quadratic weight per dimension (non-negative)\n        self.w = 0.25 + (np.arange(self.dim) * 0.05)\n        # Amplitude of the cosine modulation per dimension\n        self.a = 0.15 + (np.arange(self.dim) * 0.04)\n        # Frequency per dimension (controls ripple density)\n        # Choose increasing frequencies to create more local minima per dimension\n        self.b = (2.0 * np.pi) * (1.0 + (np.arange(self.dim) * 0.18))\n\n        # Ensure shapes are numpy arrays for vectorized computation\n        self.w = np.asarray(self.w, dtype=float)\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n\n    def _dim_profile(self, t):\n        # g_i(t) = w_i * t^2 + a_i * (1 - cos(b_i * t))\n        return self.w * (t ** 2) + self.a * (1.0 - np.cos(self.b * t))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n\n        # Vectorized evaluation across dimensions\n        vals = self._dim_profile(x)\n        return float(np.sum(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["989f2e7f-8032-4ca6-a3fd-5e5ff7fefa18"], "operator": null, "metadata": {"ela_features_2D": [-0.0007440913825614848, 0.34690307261968456, 0.018456549466194065, 0.03727528192911768, 20.678551641963516, 0.005147755622597372, 0.9966494594728592, 1.2010020026607975, 0.9966350700750668, 0.5114388525583186, -0.31050010898858443, 1.6, 0.6954004763152792, 0.712127096395312, 0.5410677891947755, 0.344331053434707, -0.19900299258558027, 0.1873013121440681, 0.2357369962937061, 0.3227846835943192, 0.49879519940885303, 0.19095862024749505, 0.2365034195058576, 0.32225830095758173, 0.4982196121953269, -0.4249970393332229, -0.3996740416934682, -0.3541554841075648, -0.2621086919958537, -0.4153109602599508, -0.3919510059410145, -0.34793410059894425, -0.25759412639033397, 1.0, 1.0, 1.0, 1.0, 0.5138061976124335, 0.5137654248780544, 0.4005491520613035, 0.3551433114679564, 0.7349518928596728, 0.4734734734734733, 0.6107536605022227, -0.03903903903903904, 0.3859437751004016], "score_Separable_2D": 1.0, "ela_features": [-0.0013724355585826187, 0.3950303829001688, 0.0016921278902934911, 0.019671402745739936, 22.076345207897315, -0.0014925754586891048, 0.9961689983477312, 1.8005086981582061, 0.996145221274058, 0.3222547441410527, -0.17107794181864505, 1.4, 0.9135329744875491, 0.8736817346319217, 0.6490627435350312, 0.18385943540751667, -0.47853602232688985, 0.44413687505973065, 0.5243001029857741, 0.6002843333777498, 0.7211501338210633, 0.4454749873066811, 0.5240528865140968, 0.6006505376169025, 0.7234917999444714, -0.4890070684316397, -0.41848502907617524, -0.3516402439711779, -0.24531133859906343, -0.4903456625110535, -0.4208579907456487, -0.35312782521635006, -0.24450498707605156, 1.0, 1.0, 0.8333333333333334, 1.0, 0.210856149062539, 0.2108541959601892, 0.19701123806923165, 0.17746037864249575, 0.8319140056693726, 0.11311311311311308, 0.25918996168214026, -0.37937937937937927, 0.5171474358974358], "score_Separable_5D": 1.0, "ela_features_10D": [0.00020565717779252868, 0.42281230842569234, 0.0014914882836530169, 0.02112286222976078, 20.898808378139503, 0.006842495776739921, 0.9955944884159988, 2.8148831726553865, 0.9955748156201295, 0.22378417334388034, -0.18089646974922663, 1.6, 1.0128390090671815, 0.9385776668194395, 0.7155815257728073, 0.10450604316622256, -0.5981768228751997, 0.6343209699243207, 0.6928413019666736, 0.7405661137438921, 0.8149722347941057, 0.6358015407818256, 0.6946655933368773, 0.7436277259359619, 0.818191216282786, -0.4637626833546989, -0.3895465596893345, -0.3290208141100688, -0.23465693372653149, -0.46308248944366437, -0.38823708766366505, -0.32598120055922086, -0.23117239828625702, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11060552057322685, 0.11060811209958252, 0.10741874862108829, 0.10089931748972672, 0.8552310223714347, -0.11911911911911907, 0.13571066463780224, -0.6396396396396394, 0.587590072057646], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [0.9186666666666663, 1.594666666666667], 1.0431488730867], [3, [-0.9389076105744748, -0.6016349623245941], 0.5772249522745663], [3, [-0.9388142307393443, 0.6014770962131727], 0.5773724613668025], [5, [-0.5569997196118109, 1.5909364695269095], 1.181086482999803], [4, [0.9114965912105426, 0.5763035413119441], 0.6008016991424487], [4, [0.9115753993923134, -0.5748755263946804], 0.60212107301315], [8, [-1.798665947437595, 1.594637088513565], 1.7266423077881252], [6, [-1.798665947646457, -1.5946362449555636], 1.7266423050015824], [6, [1.7986467907047536, -2.340875079686854], 2.7329645106523266], [5, [-0.9094382170254629, -1.3661904739746755], 1.1251308171849899], [8, [-1.7981050804633472, 2.341769296118251], 2.7329651215693054], [10, [-1.7981050806078789, -2.3417684793731546], 2.732965120525716], [4, [-1.7933787635435146, -0.7974360646028847], 1.1173614143505897], [5, [0.9192361614315265, -1.5943853208594683], 1.0431482029138497], [2, [-0.9180371204089931, 2.318393357300867], 2.0496810747738285], [9, [1.7986372101284294, -1.588741889997737], 1.7267650078837677], [6, [1.7977568837143436, 1.5937209999482134], 1.7266431666849305], [4, [1.7978102682022243, 2.3412671360563646], 2.7329649683955743]], "nr_of_basins": 18, "f_opt_dim_2": 0.0, "x_opt_dim_2": [8.118790929274117e-163, 2.4440013704935337e-162], "f_opt_dim_5": 0.3852586103252122, "x_opt_dim_5": [1.521592906430518e-09, -0.8005277959618373, -0.7055670780294543, -8.347665093612997e-10, 5.39906309342095e-10]}
{"id": "1dffbfe8-2f30-46f3-8049-4d5df3643909", "fitness": 1.0, "name": "landscape_separable_centered_quadratic_cosine", "description": "A novel fully separable additive landscape with per-dimension quadratic wells centered at dimension-dependent optima, plus a dimension-specific sine-squared modulation to induce multi-modality while preserving separability. The global minimum occurs at x = c (one per-dimension center) with f(x) = 0.", "code": "import numpy as np\n\nclass landscape_separable_centered_quadratic_cosine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Dimension-dependent optima c_i, deterministically spread across [-5, 5]\n        self.c = -5.0 + (10.0 * np.arange(self.dim) / max(self.dim - 1, 1))\n        \n        # Per-dimension quadratic weight (keeps a smooth bowl, slightly increasing across dims)\n        self.w = 0.4 + 0.2 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [0.4, 0.6] for typical dim\n        \n        # Per-dimension modulation amplitude (cosine/ripple effect)\n        self.a = 0.1 + 0.18 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [0.1, ~0.28]\n        \n        # Per-dimension modulation frequency\n        self.b = 1.0 + 0.4 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [1.0, ~1.4]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        # g_i(x_i) = w_i * (x_i - c_i)^2 + a_i * sin^2(b_i * (x_i - c_i))\n        diff = x - self.c\n        quad_term = self.w * (diff ** 2)\n        ripple_term = self.a * np.sin(self.b * diff) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_centered_quadratic_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94ba0fec-a981-48e9-8d7f-6bfa30d421bf"], "operator": null, "metadata": {"ela_features_2D": [0.938989822441115, 0.46140347311407287, 0.43437404573271393, 0.6434212179819603, 1.481039117092736, 0.9390383900026741, 0.9999766132015953, 1.5082313741825206, 0.9999767304704047, 0.46109940330698523, -0.6101755934201571, 1.6, 0.6967781001967799, 0.7124376845028337, 0.5310087298430696, 0.34639475263935166, -0.10804554478099497, 0.16965194167200423, 0.24170639191114313, 0.33853535573113336, 0.5062560617472563, 0.16589836827978868, 0.23482507464989105, 0.33154787426071597, 0.5004249402397045, -0.4345464063227958, -0.39683987534515835, -0.34616763768660935, -0.2583924860684931, -0.4292819551139428, -0.3938198400973313, -0.34402840486358605, -0.2571136069613287, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5058260693529715, 0.5056817329375922, 0.6146231001133099, 0.6581983597407701, 0.6853129165456792, 0.12512512512512508, 0.2811672867419021, -0.39139139139139123, 0.3397590361445783], "score_Separable_2D": 1.0, "ela_features": [0.8870014415657043, 0.4697159069266409, 0.00437882937293675, 0.4451463488747101, 152.17189324804843, 0.8874941278900514, 0.9999592220745175, 1.503685214426082, 0.9999593144764741, 0.42432029764942775, -0.23821426198171958, 1.2, 0.8828413509002073, 0.868353067847433, 0.6509114733405195, 0.18439775240670575, -0.28427705447343066, 0.4741966814239039, 0.576201237559312, 0.6574851004504845, 0.7771022100971544, 0.474867390996903, 0.5714034539377693, 0.650622396090182, 0.7725118830666435, -0.4626860242876617, -0.37292425050070055, -0.30139620185697413, -0.19613884779431673, -0.4647148051596104, -0.379280096923219, -0.30916986226412163, -0.20130622948718005, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2119993967488704, 0.21197787088420483, 0.2559983400547824, 0.3251922291381916, 0.7997187207847762, -0.0790790790790791, 0.13046335608866272, -0.6356356356356354, 0.4907051282051282], "score_Separable_5D": 1.0, "ela_features_10D": [0.8597090400747242, 0.5277244634233269, 0.02517172626288165, 0.3126668822454753, 12.84051730693729, 0.8604030987983068, 0.9999535884959835, 1.502367707808697, 0.9999546620115616, 0.29180593380608294, -0.1881616620505465, 1.4, 0.9663443614693298, 0.9313012902678427, 0.7095561033971409, 0.10821475959682317, -0.4106099481850588, 0.6899420493204986, 0.7535468496774386, 0.7992457668386246, 0.870463921522779, 0.6928117727024816, 0.756005778035014, 0.8008318339539573, 0.8715822784585386, -0.3932012786337868, -0.3125405071976095, -0.25458769502291945, -0.1642720892200033, -0.3905330248778551, -0.3101930746558535, -0.25320663892616924, -0.16326049889675365, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10981309431585204, 0.10981052390909682, 0.12917411578278387, 0.17767200719786774, 0.8306767526628269, -0.27127127127127126, 0.09124716019938427, -0.8238238238238236, 0.5306645316253003], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 2.494991815707129e-159, "x_opt_dim_5": [-5.0, -2.5, -5.6790583661284556e-80, 2.5, 5.0]}
{"id": "c7f2a9bb-4f01-43d6-a65a-cf2fbaf19be9", "fitness": 1.0, "name": "landscape_separable_attractor_ripple_improved", "description": "A fully separable, additive landscape with dimension-specific optima spread across [-5, 5]. Each dimension has an independent 1D landscape centered at c_i, consisting of a quadratic basin plus a dimension-specific sine-squared ripple. The global optimum is at x = c, with f(x) = 0, and the problem remains perfectly separable so subproblems can be solved independently.", "code": "import numpy as np\n\nclass landscape_separable_attractor_ripple_improved:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Centers per dimension distributed across the domain [-5, 5]\n        if self.dim > 1:\n            self.c = -5.0 + (np.arange(self.dim) / (self.dim - 1)) * 10.0  # c_i in [-5, 5]\n        else:\n            self.c = np.array([0.0], dtype=float)\n        \n        # Per-dimension quadratic weights, increasing slightly with dimension index\n        self.w = 1.0 + 0.25 * np.linspace(0, 1, self.dim)  # in [1.0, 1.25]\n        \n        # Per-dimension ripple amplitudes\n        self.A = 0.25 * (1.0 + 0.5 * np.linspace(0, 1, self.dim))  # in [0.25, ~0.375]\n        \n        # Per-dimension ripple frequencies (positive integers)\n        self.k = np.arange(1, self.dim + 1)  # (1, 2, ..., dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        delta = x - self.c\n        # Per-dimension landscape:\n        # g_i(x_i) = w_i * (x_i - c_i)^2 + A_i * sin^2(2 * pi * k_i * (x_i - c_i))\n        quad_term = self.w * (delta) ** 2\n        ripple_term = self.A * np.sin(2.0 * np.pi * self.k * delta) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_attractor_ripple_improved scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94ba0fec-a981-48e9-8d7f-6bfa30d421bf"], "operator": null, "metadata": {"ela_features_2D": [0.936238278863321, 0.4087892684535679, 0.46393192125241356, 0.58363154164127, 1.2583410794051058, 0.9364639058526102, 0.9999889419218153, 1.2496735713727192, 0.9999889264125754, 0.4801012362307004, -0.3985359860396458, 1.8, 0.697860963970532, 0.714997914877395, 0.5463702972638302, 0.3417750831662417, -0.10580494803766882, 0.1639259374705972, 0.22811344681581538, 0.31543127181311925, 0.5126602009142809, 0.16693912014872841, 0.22848337038570357, 0.3104487631951399, 0.5060195662935417, -0.43719421694876015, -0.4036313665197329, -0.3579704573372527, -0.2548365791468127, -0.427537372384291, -0.3959560560820464, -0.35387010900034915, -0.25351035776798464, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5161903885737411, 0.5161800530855996, 0.6074455772089659, 0.6575622611477009, 0.6977072544551021, 0.11311311311311308, 0.2809996663880867, -0.3993993993993993, 0.3522088353413655], "score_Separable_2D": 1.0, "ela_features": [0.8803317743572586, 0.42064241684760484, 0.0015551857879139398, 0.40844167282961463, 367.2390650228419, 0.8810695019215149, 0.9999794115740235, 1.2502533374563467, 0.9999794526081377, 0.35022756927080234, -0.2267601975453884, 1.2, 0.8831885609807555, 0.8704555050227689, 0.644989508093995, 0.18219792258410178, -0.2896460881882711, 0.48353076907970466, 0.5703782425041888, 0.6521684798202638, 0.7787140608441462, 0.47755061429097934, 0.5658903898555934, 0.6482663621186777, 0.7748608679590463, -0.45432457505033447, -0.3779257556775551, -0.3059779266816271, -0.19465969455385154, -0.4618152893901611, -0.3837300142518588, -0.31091530539516365, -0.1990121883423261, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2156578309218201, 0.2156634273380086, 0.25147485931610747, 0.3229205187027229, 0.8077342014369622, -0.0950950950950951, 0.14465182457805256, -0.6196196196196194, 0.4788461538461538], "score_Separable_5D": 1.0, "ela_features_10D": [0.8609989248470669, 0.4761721199695611, 0.023039252055493696, 0.28361784319435135, 12.36598105189026, 0.8618061720813761, 0.9999753977218333, 1.2510746074737327, 0.9999754785798822, 0.29352094265001627, -0.10495152242435335, 1.2, 0.972034139209879, 0.9333149234354948, 0.7001607588884617, 0.10649066730829496, -0.40830311802437896, 0.6780363044995943, 0.7418975924128419, 0.796787774072987, 0.8683408242354442, 0.6758654605589391, 0.743073562858647, 0.7981664902888145, 0.8695551916656532, -0.40832851385204394, -0.3273366716716926, -0.2577225763247211, -0.16697581891044525, -0.412198750211219, -0.3267306428064605, -0.2566700108672884, -0.16588497112291284, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11055846227137496, 0.1105639125689332, 0.12705743217093943, 0.17696986114738522, 0.8354179258761084, -0.30730730730730726, 0.08886971012927863, -0.8358358358358355, 0.5345876701361089], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 0.0], [1, [-5.0, 4.020888888888875], 1.2235745046021578], [5, [-4.548898896039458, 4.021700866518042], 1.449897396019572], [8, [-4.548888888888817, 5.0], 0.22635812227600993], [8, [-5.0, 3.2946666666665245], 3.741450124167752], [77, [-4.54873755223166, 3.294866802384217], 3.9678057576318255]], "nr_of_basins": 6, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 0.10475134031231259, "x_opt_dim_5": [-5.000000000490303, -2.500000000160273, -0.16499382101243312, 2.748639121274871, 5.000000000036623]}
{"id": "3698aaa7-aa3b-4b19-a7fa-edfb842b2ab9", "fitness": 1.0, "name": "landscape_separable_quad_cosine_enhanced2", "description": "A novel strictly separable landscape with dimension-dependent quartic wells around a_i plus cosine modulation, increasing ruggedness while preserving exact separability so subproblems can be solved independently.", "code": "import numpy as np\n\nclass landscape_separable_quad_cosine_enhanced2:\n    \"\"\"\n    A strictly separable, multi-well benchmark where each dimension is an independent 1D landscape.\n    Each dimension features a quartic well centered at a_i with a dimension-specific cosine modulation.\n    Parameters per dimension are deterministically derived from the dimension index to ensure diverse yet decoupled subproblems.\n    The global optimum is the sum of per-dimension optima, with f(x) achieving its minimum value of 0 at x = a.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic and reproducible)\n        self.a = np.zeros(self.dim)      # center offset per dimension\n        self.omega = np.zeros(self.dim)  # frequency per dimension (for cosine term)\n        self.w = np.zeros(self.dim)      # quartic weight per dimension\n        self.p = np.zeros(self.dim)      # amplitude for cosine modulation per dimension\n\n        for i in range(self.dim):\n            # Distinct per-dimension frequency scale\n            c = 1.0 + (i % 7) / 7.0        # c in {1.0, 1.142..., ..., 1.857...}\n            self.omega[i] = 2.0 * np.pi * c  # omega_i = 2*pi*c_i\n\n            # Choose a_i so that omega_i * a_i = 2*pi*m_i for some small integer m_i\n            m_i = (i % 5) - 2               # m_i in {-2, -1, 0, 1, 2}\n            self.a[i] = float(m_i) / c      # a_i = m_i / c_i\n\n            # Dimension-specific weights and modulation amplitudes\n            self.w[i] = 0.8 + 0.4 * (i / float(max(1, self.dim - 1)))  # in [0.8, 1.2]\n            self.p[i] = 0.25 + 0.75 * (i / float(max(1, self.dim - 1)))  # in [0.25, 1.0]\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape == (self.dim,):\n            xi = x - self.a\n        else:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension landscape: f_i(x_i) = w_i*(x_i - a_i)^4 + p_i*(1 - cos(omega_i*(x_i - a_i)))\n        term = self.w * (xi**4) + self.p * (1.0 - np.cos(self.omega * xi))\n        return float(np.sum(term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_quad_cosine_enhanced2 scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["efaec5ff-3031-49e3-9df3-08da7134383d"], "operator": null, "metadata": {"ela_features_2D": [0.49907069537621024, -0.15809432585519537, 0.2276384486781195, 0.41703255117825944, 1.8443428606812482, 0.49989408480841957, 0.914648284221544, 1.1503544554687557, 0.9847942901177715, 1.4814806864809622, 1.8590241043071647, 1.8, 0.6880489038394163, 0.7082652962180399, 0.5385894246509354, 0.34892098237505575, -0.15576652492415258, 0.20403833974784588, 0.2235419241239593, 0.2975930298844499, 0.4935356928957564, 0.19984828219581127, 0.22188774473065798, 0.29940065930651205, 0.4905984340897712, -0.416489702029044, -0.4062852527629703, -0.36754222975891393, -0.26501220919594665, -0.41131952291895546, -0.39998463625556385, -0.36015414664744966, -0.2618671323125227, 1.0, 1.0, 0.6666666666666666, 0.7333333333333332, 0.5163031889245234, 0.5163009823890844, 0.5221319970523923, 0.5700587519088971, 0.5826295787454828, 0.5135135135135134, 0.1901210419483586, -0.4914914914914913, 0.3686746987951807], "score_Separable_2D": 1.0, "ela_features": [0.4553160162642211, 0.20349985597695874, 0.009916928723913589, 0.30311374727622437, 40.388614232613236, 0.45731081683121655, 0.9151554487138981, 1.7651136111084234, 0.9786151497691966, 1.0384189904075944, 0.8008773924370199, 1.8, 0.8916091708236152, 0.8708452138065883, 0.6350226704643703, 0.1843703637876444, -0.38876090358517346, 0.44214938435614604, 0.521189082795693, 0.6002133320972518, 0.7318662231248425, 0.44751966916089214, 0.5241240071518638, 0.6028033765076068, 0.7336471280253679, -0.4907543416245681, -0.4212226843460257, -0.3517026733380063, -0.23588485193334022, -0.48847876610129237, -0.42075103187277546, -0.351184604264006, -0.23550000761061782, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2146744883542134, 0.21466405152498974, 0.22742200576737645, 0.27991780441336034, 0.7953245545905749, 0.20520520520520513, 0.17457626052282266, -0.4714714714714714, 0.5334935897435897], "score_Separable_5D": 1.0, "ela_features_10D": [0.45321355987040024, 0.3258071348653121, 0.001261775484613593, 0.2126150732511825, 721.2960719493778, 0.4543936725917311, 0.9114324986459194, 2.3054939761679405, 0.977040152684286, 0.7395781169698525, 0.41509283893171955, 1.4, 0.9819718288212339, 0.9335455761659357, 0.690383767970925, 0.10859189551563068, -0.4902316622340308, 0.6345788427569028, 0.7006353500783142, 0.7549392921275683, 0.8367025041496182, 0.6369494416154285, 0.7035161686586029, 0.7574167323746372, 0.839334932239808, -0.46345013838502247, -0.3796725105203679, -0.3108010129759049, -0.2071041430094686, -0.46170178419944696, -0.3770455014349917, -0.30849874174495423, -0.20432247619113952, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10949623914590131, 0.10949580895655094, 0.11634606947986606, 0.15330641379919596, 0.8472117463323592, -0.0790790790790791, 0.11827901161030319, -0.6796796796796795, 0.5875900720576461], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [-2.7156134141372563, -0.7380876285252451], 0.9594022791181944], [3, [-1.674764182618645, -0.7157200330068599], 0.9593714350207394], [7, [-1.7150713827888469, -1.6630044867027964], 0.9612543735209378], [9, [-2.742463655747766, -0.0537698103596537], 1.1243648885583986], [9, [-2.782396081232263, -1.6974300313800303], 1.1186534716010859], [25, [-1.7212556504471248, -0.048449156971621055], 0.9197385685469666], [44, [-1.2173488695109325, -1.6972205543879335], 1.1186486237423674]], "nr_of_basins": 7, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.0, -0.875], "f_opt_dim_5": 0.9368139967463018, "x_opt_dim_5": [-1.2168743420331485, -0.8750000003088134, 5.444330723696269e-10, 0.021153988287317824, 0.6483751969845251]}
{"id": "541f5080-1675-4891-ad23-060c1706ee23", "fitness": 1.0, "name": "logsin_landscape_separable_enhanced", "description": "A novel fully separable landscape where each dimension contributes an independent 1D surface composed of three nonnegative components: a smooth log-based basin, a dimension-specific sinusoidal ruggedness, and a saturating exponential well. The per-dimension parameters are deterministically derived from the dimension index to guarantee diverse yet decoupled subproblems, with a global minimum at x = 0 and f(x) = 0. This design preserves perfect separability, enabling exact subproblem partitioning while offering controllable multimodality and ruggedness across dimensions.", "code": "import numpy as np\n\nclass logsin_landscape_separable_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension parameter generation (no randomness)\n        i = np.arange(self.dim, dtype=float)  # 0-based indices\n        t = i + 1.0  # avoid zero\n\n        # W: weight for the smooth log-based basin component\n        self.w = 0.3 + 0.7 * np.abs(np.sin(t * 0.47))\n\n        # A: amplitude for the sinusoidal (ruggedness) component\n        self.a = 0.4 + 0.6 * np.abs(np.cos(t * 0.13))\n\n        # B: frequency factor for the sinusoidal term (b_i * x_i)\n        self.b = 0.5 + 0.7 * ((t % 5) / 4.0)  # in [0.5, ~1.2]\n\n        # C: amplitude of the exponential-like saturating component\n        self.c = 0.2 + 0.6 * np.abs(np.cos(t * 0.21))\n\n        # D: rate parameter for the exponential saturation\n        self.d = 0.3 + 0.7 * np.abs(np.sin(t * 0.33))\n\n        # Ensure all arrays are numpy arrays for vectorized evaluation\n        self.w = np.asarray(self.w, dtype=float)\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n        self.c = np.asarray(self.c, dtype=float)\n        self.d = np.asarray(self.d, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        # Per-dimension contributions (additive, separable):\n        # f_i(x_i) = w_i * log(1 + x_i^2) + a_i * sin^2(b_i * x_i) + c_i * (1 - exp(-d_i * x_i^2))\n        log_term = np.log1p(x**2)          # log(1 + x^2)\n        sin_term = np.sin(self.b * x)**2    # sin^2(b_i * x_i)\n        exp_term = 1.0 - np.exp(-self.d * x**2)  # saturating exponential term\n\n        per_dim = self.w * log_term + self.a * sin_term + self.c * exp_term\n        return float(np.sum(per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape logsin_landscape_separable_enhanced scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["20cf8e06-8149-471a-8c6c-7bbd9337a091"], "operator": null, "metadata": {"ela_features_2D": [-0.0018576873793770155, 0.6456747713038664, 0.015601325339010746, 0.029431651860250152, 2.8733817572929814, -0.0014987213399229927, 0.5587973460428021, 1.4417068809107927, 0.5567677823514648, -0.7660734281419287, -0.0965358757837648, 2.2, 0.47146871962718695, 0.6819482431520486, 0.3975591729541601, 0.35208054490018653, -0.22160132888353562, 0.14181467894709382, 0.21806036268884119, 0.35074684742927503, 0.6261112450927296, 0.14349643126198844, 0.21891803381341485, 0.3164529255234033, 0.6177348471842184, -0.4492076959441058, -0.4092988916559036, -0.339843321646904, -0.19570420299742572, -0.4398721486753615, -0.40114095700065916, -0.3510495090068426, -0.19631214983705148, 1.0, 1.0, 1.0, 1.0, 0.5183397101390605, 0.5183127474576997, 0.40895120193902257, 0.3534703924511247, 0.7033727657941048, 0.5535535535535534, 0.33782171317810966, -0.1271271271271271, 0.40682730923694777], "score_Separable_2D": 1.0, "ela_features": [0.0020464608732176258, 0.624046578242631, 0.006137136410098633, 0.03153011295275153, 7.616995591948813, 0.0030108985317063965, 0.6654544558647125, 1.8732725192891302, 0.6664663359729746, -0.36095699602376846, -0.0524164852124966, 1.8, 0.7766118087888926, 0.8471847049611396, 0.5724534130518298, 0.20138617514230464, -0.5086712367543339, 0.550137140892657, 0.6268623395867999, 0.6811921300548001, 0.773409985023128, 0.5440839356712627, 0.6240311291911843, 0.6778204804903385, 0.7688168915362912, -0.3957759472591782, -0.32827215217472744, -0.28047729691574935, -0.19934622784347905, -0.4032997532965393, -0.332568557694587, -0.2849975718937311, -0.20450099723207932, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21827991855107703, 0.2183012292656285, 0.2054349639700616, 0.1858201421273075, 0.8343789603646654, 0.18918918918918912, 0.2787482305339769, -0.3353353353353352, 0.5360576923076923], "score_Separable_5D": 1.0, "ela_features_10D": [0.0005178341347368054, 0.5642365499455292, 0.0009769339926999064, 0.02465745007359777, 60.775976012155255, 0.0005607452122233791, 0.6930040793439234, 3.2863385564157817, 0.6925568862068943, -0.2552722196674199, -0.005423310416435001, 1.4, 0.9192976028118787, 0.9238127570791977, 0.6407484236520854, 0.11799867803833428, -0.6123029282941106, 0.6960135141271895, 0.7475367146335842, 0.7869858916694238, 0.8479427860719916, 0.6925413681195194, 0.7448871806411873, 0.7862547728362416, 0.8486157446855765, -0.3855057183843306, -0.32016416446970053, -0.2701367350770741, -0.19283317968254057, -0.390902849977937, -0.3243467594036347, -0.27175335027891573, -0.192468232377324, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10919331261400478, 0.10919032582410845, 0.10630952165737724, 0.0999649741299858, 0.8575572723856475, -0.07507507507507509, 0.142841993955582, -0.6156156156156154, 0.5979983987189751], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [4.348000000000072, -3.337777777777716], 5.670134101952696], [6, [-4.348000000000072, -3.337777777777716], 5.670134101952696], [6, [4.348000000000072, 3.337777777777717], 5.670134101952696], [6, [-4.348000000000072, 3.337777777777717], 5.670134101952696], [10, [4.348000000000072, 0.00044444444444512003], 2.67417878897382], [8, [-4.348000000000072, 0.00044444444444512003], 2.67417878897382], [18, [0.00044444444444512003, -3.337777777777716], 2.9959560247615675], [18, [0.00044444444444512003, 3.337777777777717], 2.9959560247615675], [22, [0.00044444444444512003, 0.00044444444444512003], 7.117826910733296e-07]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.467362009381651e-163, 6.759118212760382e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [4.554528870849537e-163, -4.9499798777747996e-163, 2.0214999023635743e-163, 9.046349348622659e-163, 1.3508189703034837e-162]}
{"id": "a02e65c9-65fb-462f-8693-42a50b6c1968", "fitness": 1.0, "name": "landscape_separable_shifted_quadratic_cosine", "description": "A novel separable landscape with per-dimension shifted quadratic wells around dimension-specific optima, plus a cosine modulation to introduce varying ruggedness. Each dimension is independent, with the global minimum located at x = m (a vector of per-dimension optima). This preserves separability and allows partitioning into independent 1D subproblems.", "code": "import numpy as np\n\nclass landscape_separable_shifted_quadratic_cosine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        if self.dim == 1:\n            # Single-dimension parameters\n            self.m = np.array([0.0], dtype=float)       # global optimum per dimension\n            self.w = np.array([0.4], dtype=float)       # quadratic weight\n            self.a = np.array([0.2], dtype=float)       # cosine modulation amplitude\n            self.b = np.array([1.0], dtype=float)       # cosine frequency\n        else:\n            # Deterministic per-dimension optima (m_i) spanning [-4, 4]\n            self.m = -4.0 + 8.0 * (np.arange(self.dim) / (self.dim - 1))\n            self.m = self.m.astype(float)\n\n            # Quadratic weights w_i growing smoothly across dimensions\n            self.w = 0.1 + 0.9 * (np.arange(self.dim) / (self.dim - 1))\n            self.w = self.w.astype(float)\n\n            # Cosine modulation amplitudes a_i spanning [0.2, 1.0]\n            self.a = 0.2 + 0.8 * (np.arange(self.dim) / (self.dim - 1))\n            self.a = self.a.astype(float)\n\n            # Cosine frequencies b_i distinct per dimension\n            self.b = 0.5 + 2.0 * (np.arange(self.dim) / (self.dim - 1))\n            self.b = self.b.astype(float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension contribution: w_i*(x_i - m_i)^2 + a_i*(1 - cos(b_i*(x_i - m_i)))\n        diff = x - self.m\n        quad = self.w * (diff**2)\n        periodic = self.a * (1.0 - np.cos(self.b * diff))\n        return float(np.sum(quad + periodic))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_shifted_quadratic_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b1373a9b-e536-4791-9160-054e9936b565"], "operator": null, "metadata": {"ela_features_2D": [0.9046806777764843, 0.7184823635816526, 0.09649042911748952, 0.9033131627906169, 9.587144049780886, 0.9048648931983261, 0.9991761456358004, 11.121968138534514, 0.9991932897871886, 0.7618597245820119, -0.6465398366993289, 1.6, 0.6884921904357338, 0.7130025723767568, 0.5553484267289692, 0.34192419925208134, -0.09924237786361716, 0.21600064540661812, 0.2907890254679948, 0.39457088764909193, 0.5850089606590279, 0.19111115979109308, 0.2648137538804214, 0.3577049625072193, 0.5369944321446857, -0.40991621303341025, -0.37080791708824173, -0.3165432654550668, -0.216964006549507, -0.4146149117082252, -0.3768274546944447, -0.32921617062804354, -0.23731035099251613, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5275652540968997, 0.5275472657163565, 0.6448874573974862, 0.6542230914526934, 0.6459985831122563, 0.32132132132132124, 0.19361096686240248, -0.3993993993993993, 0.3337349397590361], "score_Separable_2D": 1.0, "ela_features": [0.8511538148752524, 0.6691256952747785, 0.009159230567144757, 0.5931798612724941, 217.6103473077754, 0.8520897121365942, 0.9985834694953677, 10.765621574922232, 0.9986800532335286, 0.6343020584641482, -0.37238596249142, 1.2, 0.8607370378239143, 0.8642853922251185, 0.6273586606069613, 0.18741433529376952, -0.2760435437209658, 0.5048489531735797, 0.5953579221943748, 0.6822490738033349, 0.7991141746917675, 0.4914254024619759, 0.5861405090404075, 0.6738562826223223, 0.7938142002092861, -0.43564242341017145, -0.35601049939363527, -0.2795629611513583, -0.17674262578898822, -0.4499857485627043, -0.36617694002731815, -0.2885672198450926, -0.18242964594582292, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21628296073899617, 0.21630684403305275, 0.2624454688532983, 0.32065286230139955, 0.7951706222877883, 0.029029029029028996, 0.1547095450537624, -0.6196196196196194, 0.491826923076923], "score_Separable_5D": 1.0, "ela_features_10D": [0.8232838838246532, 0.7205317456644449, 0.020930289562432678, 0.39369080459676353, 20.37077036852508, 0.8242581733580343, 0.998322089673319, 10.433595574499261, 0.9984705119389007, 0.4569563913124366, -0.18370305676600918, 1.6, 0.9614519845812012, 0.9319816979035449, 0.7012041966859072, 0.1073746178715019, -0.403714250601381, 0.6811919108964094, 0.7466825135809916, 0.8018806759515019, 0.8719908385222048, 0.6802382936424706, 0.7471422941547984, 0.8017150745929282, 0.8722169910457408, -0.4043666867601174, -0.32130037257407185, -0.25128825089472573, -0.16236247056740782, -0.40666242531263713, -0.3215752864772042, -0.25217087415769207, -0.16250887048041487, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10961822598598828, 0.10961994057569265, 0.12696797703804624, 0.17415774102957243, 0.8304782344129776, -0.22722722722722719, 0.08962595520248055, -0.8158158158158155, 0.5424339471577262], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 1.3342477806546104e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 1.4426636705570612e-172, "x_opt_dim_5": [-4.0, -2.0, -1.6195755170902938e-86, 2.0, 4.0]}
{"id": "0356a802-7f95-4f51-ba67-e19ecfb8c807", "fitness": 1.0, "name": "landscape_separable_exponential_cosine", "description": "A completely different separable multimodal landscape with per-dimension profiles combining quadratic, exponential decay, and cosine ripple. Each dimension has its own deterministic parameters, ensuring additivity across dimensions and a global minimum of 0 at the origin.", "code": "import numpy as np\n\nclass landscape_separable_exponential_cosine:\n    \"\"\"\n    A separable, multimodal landscape with per-dimension independent 1D profiles.\n    Each dimension contributes g_i(t) = a_i * t^2 + b_i * (1 - exp(-c_i * t^2)) + d_i * (1 - cos(2 * pi * e_i * t)),\n    where t is the coordinate in dimension i. The global minimum is at x = 0 with f(x) = 0.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be a positive integer.\")\n\n        # Deterministic, dimension-dependent parameters to ensure reproducibility\n        i = np.arange(self.dim, dtype=int)\n\n        # Quadratic weight (must be non-negative)\n        self.a = (0.08 + 0.01 * (i % 20)).astype(float)\n\n        # Amplitude of the exponential (1 - exp(-c_i * t^2)) term\n        self.b = (0.12 + 0.05 * ((i * 3) % 20)).astype(float)\n\n        # Rate of the exponential decay (controls ruggedness around 0)\n        self.c = (0.20 + 0.15 * ((i * 5) % 10)).astype(float)\n\n        # Amplitude of the cosine ripple term\n        self.d = (0.25 + 0.05 * ((i * 7) % 12)).astype(float)\n\n        # Frequency multiplier for the cosine ripple term\n        self.e = (1.0 + 0.18 * (i % 7)).astype(float)\n\n    def _one_dimensional(self, t, i):\n        \"\"\"\n        1D subproblem for dimension i with its specific parameters.\n        \"\"\"\n        t = float(t)\n        ai = float(self.a[i])\n        bi = float(self.b[i])\n        ci = float(self.c[i])\n        di = float(self.d[i])\n        ei = float(self.e[i])\n\n        return ai * t ** 2 + bi * (1.0 - np.exp(-ci * t ** 2)) + di * (1.0 - np.cos(2.0 * np.pi * ei * t))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape on a 1D array x of length dim.\n        Global minimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            total += self._one_dimensional(x[i], i)\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_exponential_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["01497983-debe-4be8-85fb-1346c2d339aa"], "operator": null, "metadata": {"ela_features_2D": [-0.0027052545801910634, 0.42555516955100703, 0.007303600882559359, 0.023029217923977597, 4.868794658608026, -0.0010645425551971456, 0.8141457713518626, 1.1566517679474617, 0.8134290438659507, 0.2816455705356409, -0.3852317705661517, 1.0, 0.4444670076846193, 0.5930597653174094, 0.3778622853392801, 0.4158154245496101, -0.3443477767815559, 0.2886228862674284, 0.37826581075625754, 0.45844445419622765, 0.565534606012366, 0.3069935253787386, 0.372870572245295, 0.453927591499329, 0.5586026350895581, -0.37217072431413944, -0.32525445943229514, -0.28330380626126817, -0.22727641429226103, -0.3558609538296545, -0.32196938185459345, -0.28033906326721514, -0.22657386475429758, 1.0, 1.0, 1.0, 1.0, 0.517410580203545, 0.5174035237365892, 0.4151012664859839, 0.35127237222202884, 0.8607161049059691, 0.9339339339339336, 1.552800432419989, 0.4494494494494493, 0.570281124497992], "score_Separable_2D": 1.0, "ela_features": [0.00014143744382049127, 0.4788626778963333, 0.0030580410809660816, 0.02640659047067413, 12.872701600619925, 0.0044520608998236625, 0.8584236692591046, 1.8314492587723799, 0.8581608400925187, 0.19427900487238886, -0.23004042884203146, 1.0, 0.8197155532565956, 0.8533320984788183, 0.5489862081294287, 0.2028240402539167, -0.5034552131989609, 0.538601786553597, 0.6035688829252688, 0.6571001689009544, 0.7473589449505491, 0.5334979986619415, 0.5993257241921884, 0.6555539254031691, 0.7477250258913546, -0.4058591257032657, -0.34871304701959305, -0.3016236097288571, -0.22223044620558122, -0.4124542965629082, -0.35425510314979036, -0.3045371344901633, -0.22304730113033955, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21307372101214872, 0.21307532070599894, 0.19929827869139588, 0.1803294400779114, 0.8511307308491309, 0.28128128128128116, 0.3021372115893649, -0.3033033033033032, 0.5669871794871796], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0015283456559015863, 0.448758747740931, 0.0006395398531445556, 0.014994027287376449, 49.22576360438262, 0.006155561895317874, 0.8873958599417818, 2.157465914116515, 0.8884657775775728, 0.11654152295849132, -0.04177295803869567, 1.4, 0.9784764587034491, 0.9335011418518023, 0.6767439776293369, 0.1092745376812827, -0.6147580547209675, 0.6634559315424464, 0.7108463441664232, 0.7534457940518398, 0.8246551011405792, 0.6615069037437872, 0.7114798423067925, 0.7554132690060378, 0.8274433223986135, -0.4268280718605319, -0.36672493313295523, -0.3126977684918675, -0.22238484968902417, -0.43049583963794225, -0.3669420637058608, -0.31106818078625087, -0.21945925976295663, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10984182820198515, 0.10983934977693197, 0.10712377024748132, 0.10019821384205274, 0.857531365165743, -0.11111111111111108, 0.13089622197373102, -0.6596596596596594, 0.6019215372297838], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-3.888888888888889, -5.0], 4.017126498524286], [1, [-2.7777777777777777, -5.0], 3.552818421427138], [1, [-0.5555555555555554, -5.0], 3.1513877327877258], [1, [0.5555555555555554, -5.0], 3.1513877327877258], [1, [2.7777777777777786, -5.0], 3.5528184214271366], [1, [3.8888888888888893, -5.0], 4.017126498524286], [1, [-2.7777777777777777, -1.6666666666666665], 1.4320510945658667], [1, [-1.6666666666666665, -1.6666666666666665], 1.1621942882344052], [1, [-0.5555555555555554, -1.6666666666666665], 1.030620405926455], [1, [0.5555555555555554, -1.6666666666666665], 1.030620405926455], [1, [1.666666666666667, -1.6666666666666665], 1.1621942882344043], [1, [2.7777777777777786, -1.6666666666666665], 1.4320510945658655], [1, [-2.7777777777777777, 1.666666666666667], 1.4320510945658664], [1, [-1.6666666666666665, 1.666666666666667], 1.1621942882344047], [1, [-0.5555555555555554, 1.666666666666667], 1.0306204059264545], [1, [0.5555555555555554, 1.666666666666667], 1.0306204059264545], [1, [1.666666666666667, 1.666666666666667], 1.162194288234404], [1, [2.7777777777777786, 1.666666666666667], 1.4320510945658653], [1, [-3.888888888888889, 5.0], 4.017126498524286], [1, [-2.7777777777777777, 5.0], 3.552818421427138], [1, [-0.5555555555555554, 5.0], 3.1513877327877258], [1, [0.5555555555555554, 5.0], 3.1513877327877258], [1, [2.7777777777777786, 5.0], 3.5528184214271366], [1, [3.8888888888888893, 5.0], 4.017126498524286], [1, [4.901603382663482, -2.5275005799889914], 2.9353128514361657], [1, [4.90315240635136, 2.527559310208864], 2.935128433253439], [2, [-3.9254339469932797, -2.5289273854670147], 2.222108062955554], [1, [-0.5555555555555554, -0.6895555555555555], 1.0240285681133985], [1, [0.5555555555555554, -0.6895555555555555], 1.0240285681133985], [1, [-4.901603309343776, 2.5275032947534144], 2.935312774956693], [1, [-4.908002438154637, 5.000176863155157], 4.721011632045639], [1, [-0.5555555555555554, 0.6895555555555555], 1.0240285681133985], [1, [0.5555555555555554, 0.6895555555555555], 1.0240285681133985], [1, [3.9329340496819634, -2.5277959226200646], 2.2218209885821905], [1, [-3.9329341042737473, 2.5277961690534454], 2.2218209829461206], [1, [3.9329429691809783, 2.5278362178874016], 2.2218200939938453], [1, [-4.898992156602808, 1.6799282177150965], 2.5969046433589695], [1, [4.898990785890366, -1.6799248439553922], 2.5969052879545678], [1, [4.898991498269483, 1.6799276966747343], 2.596904807892719], [1, [-4.8989494517479395, -1.6798779592765125], 2.5969175353022447], [1, [3.8857362891830456, -1.6691285558565656], 1.8963001286713455], [1, [3.885736439191702, 1.6691287464774807], 1.8962999759980688], [1, [-3.8857370890911294, -1.6691295717768762], 1.8962993148358285], [1, [-1.7379159614050104, -2.4727949887505125], 1.4625949901791457], [1, [-0.59992782644954, -2.49361849128028], 1.3571197659750307], [1, [0.5999286568896396, -2.4936195712188365], 1.3571178912047872], [1, [1.7362889995241881, -2.4739582897603527], 1.4626048906455584], [1, [-3.8857364127834093, 1.6691287129230483], 1.8963000028736867], [1, [-1.7362888054445405, 2.473958035858219], 1.4626055662421595], [1, [-0.598305082129503, 2.494787489044176], 1.357118463219287], [1, [0.5983050798182584, 2.494787481767242], 1.3571184729311714], [1, [1.7362885704344475, 2.4739577376271544], 1.4626063685419242], [1, [-4.665320582259399, 4.196499577482407], 4.118682201622231], [1, [4.650857944811878, 4.199784461996479], 4.125188878330828], [1, [-4.650984657827885, -4.1995284491893425], 4.1252419608088], [1, [4.653991812632312, -4.198961844545462], 4.12389822420258], [1, [3.75825119880691, -0.8044888841713839], 1.6923261046403126], [1, [-3.758251751400768, -0.8044894887551245], 1.6923249560762885], [1, [-2.6381717332728427, -0.8124603964283877], 1.263798757059104], [1, [-1.6035879648149298, -0.7450269659639732], 1.0283301574760426], [1, [3.7582515171475275, 0.8044892325232627], 1.6923254429069934], [1, [1.6035879648149303, -0.7450269659639732], 1.0283301574760422], [1, [2.6381709606108776, -0.812459564787511], 1.2637999752567177], [1, [-3.758251253161904, 0.8044889436623303], 1.692325991640554], [1, [-2.639625567989379, 0.8110869644775983], 1.263799970262441], [1, [-1.6035879648149298, 0.7450269659639732], 1.0283301574760426], [1, [1.6035879648149303, 0.7450269659639732], 1.0283301574760422], [1, [2.6396249304973787, 0.811086261002364], 1.2638010253432863], [1, [-4.769097217608108, 0.8258663361822797], 2.3561627458253795], [1, [4.7683607706805535, 0.8246169784918702], 2.3571966197794962], [1, [4.768585346099514, -0.8246065530564983], 2.3570220756668716], [1, [-4.772356273838447, -0.8253277699027153], 2.3537696340055603], [1, [-2.788681611561036, -2.508670228680796], 1.7610002247803878], [1, [2.7886825958481043, 2.508670807680154], 1.760998817521187], [1, [-2.7886826457500584, 2.508670837116142], 1.7609987461228855], [1, [2.788681477449498, -2.508670149985045], 1.7610004163985504], [1, [-4.908002426817943, -5.000175200582761], 4.721014475898212], [1, [-1.8943848087915733, -4.029897861449807], 2.7133153505672105], [1, [-0.8787765405621428, -3.9593431724750325], 2.7112473907446697], [1, [-1.6718044094205866, -4.996901080908689], 3.282958706931492], [1, [1.8943848087915738, -4.029897861449807], 2.71331535056721], [1, [0.8787765405621428, -3.9593431724750325], 2.7112473907446697], [1, [1.6735252830579297, -4.995881928631649], 3.2829533934180875], [1, [-1.8943848087915733, 4.0298978614498076], 2.713315350567207], [1, [-0.8787765405621428, 3.959343172475033], 2.711247390744668], [1, [-1.6735246959239873, 4.995880964412907], 3.2829557859882605], [1, [1.8943848087915738, 4.0298978614498076], 2.7133153505672065], [1, [0.8787765405621428, 3.959343172475033], 2.711247390744668], [1, [1.67180549191848, 4.996902864404126], 3.2829543414561178], [2, [2.947953375987877, 4.170400853693516], 2.714961534375524], [2, [2.9479548233674335, -4.170374939134094], 2.7149969338542803], [1, [4.908002432644741, 5.0001751702132955], 4.721014527417465], [2, [-2.9419576029669376, 4.170533255228021], 2.71499874907664], [2, [-2.943956261743057, -4.170447935359295], 2.7150048513077403], [1, [4.908002397359794, -5.000174261718255], 4.721016083510071]], "nr_of_basins": 95, "f_opt_dim_2": 0.0, "x_opt_dim_2": [4.0043327639623347e-163, 4.128116640589074e-162], "f_opt_dim_5": 0.28286613291081325, "x_opt_dim_5": [4.303010464077276e-10, 0.8361872821276836, 1.0767931516600431e-10, 8.343199069571771e-10, -0.5758096653017659]}
{"id": "e1d70b0a-5276-49bd-8503-e1bbcc6ca8bf", "fitness": 1.0, "name": "landscape_centered_quad_cosine", "description": "A strictly separable, multi-well benchmark where each dimension is an independent 1D landscape with a quadratic well centered at a dimension-specific offset a_i plus a dimension-specific cosine modulation. The cosine term is now centered at the per-dimension optimum (x_i - a_i), ensuring perfect separability and well-aligned local features across dimensions. The global optimum is at x = a with f(x) = 0.", "code": "import numpy as np\n\nclass landscape_centered_quad_cosine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic and reproducible)\n        self.a = np.zeros(self.dim)      # center offset per dimension\n        self.omega = np.zeros(self.dim)  # frequency per dimension\n        self.w = np.zeros(self.dim)      # quadratic weight per dimension\n        self.p = np.zeros(self.dim)      # cosine modulation amplitude per dimension\n\n        for i in range(self.dim):\n            # Normalize i across dimensions to derive a per-dimension scale\n            # Frequencies: distinct per dimension, ensuring multiple local minima\n            c = 1.0 + (i % 5) / 5.0        # c in {1.0, 1.2, 1.4, 1.6, 1.8}\n            self.omega[i] = 2.0 * np.pi * c  # omega_i = 2*pi*c_i\n\n            # Choose a_i so that omega_i * a_i is near a multiple of 2*pi\n            # This makes cos(omega_i * (x_i - a_i)) = 1 at x_i = a_i, giving zero local penalty there\n            m_i = (i % 5) - 2               # m_i in {-2, -1, 0, 1, 2}\n            self.a[i] = float(m_i) / c      # a_i = m_i / c_i\n\n            # Dimension-specific weight and cosine amplitude (monotonic with dimension)\n            self.w[i] = 0.5 + 1.0 * (i / float(max(1, self.dim - 1)))  # 0.5 .. ~1.5\n            self.p[i] = 0.2 + 0.8 * (i / float(max(1, self.dim - 1)))  # 0.2 .. ~1.0\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension landscape:\n        # f_i(x_i) = w_i*(x_i - a_i)^2 + p_i*(1 - cos(omega_i*(x_i - a_i)))\n        diff = x - self.a\n        term = self.w * (diff ** 2) + self.p * (1.0 - np.cos(self.omega * diff))\n        return float(np.sum(term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_centered_quad_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["efaec5ff-3031-49e3-9df3-08da7134383d"], "operator": null, "metadata": {"ela_features_2D": [0.3845994644673802, -0.03049357532844371, 0.2877264496300883, 0.35740559728430954, 1.247245327167376, 0.3866314433489679, 0.9976803750949156, 2.9922943333936076, 0.9976710536335471, 0.815786465594974, 0.02947758473880837, 1.2, 0.6522027542156691, 0.6980412496578248, 0.5344465738266246, 0.3527659901432346, -0.15055316571980432, 0.20733868551719606, 0.2562872312955319, 0.3356225220338599, 0.5087633803048099, 0.20101814874701635, 0.2513680224467353, 0.3233569017988012, 0.4989668557428889, -0.41490213977092827, -0.389281962268005, -0.3477491153796274, -0.25712218112477087, -0.4108608673614286, -0.38497204500191357, -0.3479461950817361, -0.2576397769637354, 1.0, 1.0, 0.8666666666666666, 1.0, 0.5156737275521674, 0.5156154720835384, 0.5056026601965659, 0.541140707651091, 0.7537206386079219, 0.4454454454454453, 0.36183493044616927, -0.21521521521521514, 0.4088353413654618], "score_Separable_2D": 1.0, "ela_features": [0.3362637935889342, 0.41415702401400045, 0.011508388323986518, 0.2698975094483052, 57.25895352294856, 0.33945638398368094, 0.997684059639044, 3.0012430122461553, 0.9976857098264077, 0.5170224867979297, -0.05135895867438452, 1.2, 0.9067849252154236, 0.870984713824099, 0.6438399240017371, 0.18513642935814537, -0.4065484761702864, 0.439949470806023, 0.5360782118067926, 0.6057924735993069, 0.7272724490655547, 0.43940942782164016, 0.5349970956531845, 0.6066976299421057, 0.7281655172500101, -0.4925895741164526, -0.408039962507745, -0.34672261604715515, -0.23987624533094376, -0.49561082340033336, -0.4111047095946234, -0.34771341163588143, -0.24032641284145378, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21382406420933947, 0.2138090035715768, 0.21723160660090213, 0.2631166520316973, 0.8220260364239692, 0.08508508508508503, 0.21344425861480243, -0.4354354354354353, 0.5104166666666666], "score_Separable_5D": 1.0, "ela_features_10D": [0.3739672331216381, 0.3797101401683558, 0.0026869796333222474, 0.21535894737740685, 670.8078832457328, 0.3743088251155638, 0.9978207459689822, 2.99563364217978, 0.9978114163991461, 0.3161520179402772, -0.17677432746195212, 1.0, 1.0096643877751383, 0.9363504309083946, 0.7092769072487439, 0.10612230160386218, -0.5210804879966399, 0.6401874622202781, 0.7013190796187742, 0.7510561852307893, 0.8295087798895615, 0.6423029691000012, 0.703805209817101, 0.7538168839282255, 0.8328691266232667, -0.45633204499066793, -0.3788021216743423, -0.3157230905919641, -0.2162256208381755, -0.454824219896545, -0.3766210683690218, -0.3130291548569524, -0.21251197979646957, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10972901770963026, 0.10974062482948821, 0.11295370323772916, 0.14676916382376248, 0.8498159870681252, -0.1471471471471471, 0.12386379709064033, -0.6796796796796796, 0.5838270616493195], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-1.6666666666666665, 0.5555555555555554], 4.749074074074075], [3, [-2.8768888888890003, -2.409777777777818], 4.3917334095425336], [3, [-2.8768330651224354, -1.6244884315375951], 1.430409412813844], [1, [-1.770809553339503, -2.3424754927405655], 4.242665779703814], [8, [-2.8706830813689446, -3.174723580751837], 9.298487096835224], [1, [-1.6826655859411674, -0.6357409802628627], 1.310131265576876], [1, [-1.708129646522684, -1.5880221370545107], 1.3196509618957197], [12, [-2.8768888888890003, 1.5086666666666668], 9.29836311152299], [12, [-1.1228304023780225, -3.1746450691693795], 9.29835315960408], [28, [-1.1232794254709537, 1.5079015119226669], 9.298353071274208], [6, [-1.1233798392348324, -2.4088006682305556], 4.391769301263192], [6, [-1.1233603096789744, -1.6226670416808973], 1.4304752829504248], [6, [-1.125981897656923, -0.6504481571049989], 1.3008787123486676], [3, [-2.820653034495996, -0.6502646896497829], 1.3117679252316294], [6, [-1.13532947535449, 0.5561442377244307], 4.833999100708528], [3, [-2.8628925228633766, 0.5558371830180825], 4.834879484675621]], "nr_of_basins": 16, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.0, -0.8333333333333334], "f_opt_dim_5": 0.4882048713745374, "x_opt_dim_5": [-2.0000000014209878, -0.05287189634432345, 6.764502816709786e-10, 0.6249999991419699, 1.1111111113747958]}
{"id": "5519b855-d005-4fa9-a47e-3fee13f854dd", "fitness": 1.0, "name": "landscape_separable_mixed_enhanced", "description": "A novel fully separable, multi-rugged landscape where each dimension uses a richer, independent 1D profile composed of multiple frequency components (quadratic base, two sine-based ripples, and two cosine-based micro-wells). Per-dimension parameters are deterministic to ensure diversity while preserving additivity across dimensions, with a unique global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_separable_mixed_enhanced:\n    \"\"\"\n    A strictly separable, highly rugged but additive landscape.\n    Each dimension i contributes:\n        g_i(t) = a_i * t^2\n                 + c1_i * sin^2(pi * s1_i * t)\n                 + c2_i * sin^2(pi * s2_i * t)\n                 + d1_i * (1 - cos(2 * pi * r1_i * t))\n                 + d2_i * (1 - cos(2 * pi * r2_i * t))\n    with t = x[i]. The global minimum is at x = 0 with f(x) = 0.\n    Parameters are deterministically derived from the dimension index to ensure\n    diverse yet decoupled subproblems.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Deterministic, dimension-dependent parameters to ensure variety\n        i = np.arange(self.dim, dtype=float)\n\n        # Quadratic base weight per dimension\n        # Values range roughly from 0.25 up to ~0.55\n        self.a = 0.25 + 0.05 * (np.arange(self.dim) % 12)\n\n        # Amplitudes for the first and second sine-square ripples\n        self.c1 = 0.12 + 0.05 * ((np.arange(self.dim) * 3) % 20)     # 0.12..~0.37\n        self.c2 = 0.03 + 0.02 * ((np.arange(self.dim) * 5) % 26)     # 0.03..~0.09\n\n        # Amplitudes for the cosine-based micro-wells (two terms)\n        self.d1 = 0.35 + 0.08 * ((np.arange(self.dim) * 7) % 20)     # 0.35..~1.07\n        self.d2 = 0.15 + 0.05 * ((np.arange(self.dim) * 11) % 20)    # 0.15..~0.95\n\n        # Frequencies for the ripple terms\n        self.s1 = 1.0 + 0.25 * (np.arange(self.dim) % 6)               # 1.0..~2.25\n        self.s2 = 2.0 + 0.15 * ((np.arange(self.dim) * 3) % 6)         # 2.0..~3.0\n\n        # Frequencies for the cosine terms\n        self.r1 = 1.0 + 0.30 * (np.arange(self.dim) % 5)               # 1.0..~2.2\n        self.r2 = 0.5 + 0.25 * ((np.arange(self.dim) * 4) % 5)         # 0.5..~1.75\n\n    def _one_dimensional(self, t, i):\n        \"\"\"\n        1D subproblem for dimension i with its specific parameters.\n        \"\"\"\n        t = float(t)\n        ai = float(self.a[i])\n        c1i = float(self.c1[i])\n        c2i = float(self.c2[i])\n        d1i = float(self.d1[i])\n        d2i = float(self.d2[i])\n        s1i = float(self.s1[i])\n        s2i = float(self.s2[i])\n        r1i = float(self.r1[i])\n        r2i = float(self.r2[i])\n\n        # g_i(t) = ai * t^2 + c1i * sin^2(pi * s1i * t)\n        #                   + c2i * sin^2(pi * s2i * t)\n        #                   + d1i * (1 - cos(2 * pi * r1i * t))\n        #                   + d2i * (1 - cos(2 * pi * r2i * t))\n        val = (\n            ai * t ** 2\n            + c1i * (np.sin(np.pi * s1i * t)) ** 2\n            + c2i * (np.sin(np.pi * s2i * t)) ** 2\n            + d1i * (1.0 - np.cos(2.0 * np.pi * r1i * t))\n            + d2i * (1.0 - np.cos(2.0 * np.pi * r2i * t))\n        )\n        return val\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape on a 1D array x of length dim.\n        Global minimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            total += self._one_dimensional(x[i], i)\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_mixed_enhanced scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["01497983-debe-4be8-85fb-1346c2d339aa"], "operator": null, "metadata": {"ela_features_2D": [-0.002632872079854609, 0.39738903027515454, 0.009401492419608503, 0.019066017005894838, 6.241222923139284, -0.0015995498343318593, 0.9058314834192716, 1.2049491995247086, 0.90547671824066, 0.39805943118848647, -0.20692993050722838, 1.8, 0.48898953009661206, 0.6245723597299284, 0.39204204678873383, 0.39741748192859727, -0.285693645917154, 0.30267268093879746, 0.342960708897463, 0.4169072695082628, 0.5324478043978749, 0.30109694786727376, 0.3349347632162957, 0.41212236221230725, 0.5266825472668197, -0.3649215315594332, -0.343830245355191, -0.30512445834026225, -0.24466434143059906, -0.35943891240416675, -0.34203138914662656, -0.3023369634608722, -0.24341608522493904, 1.0, 1.0, 1.0, 1.0, 0.5224723277450865, 0.5224551109494004, 0.4290214506359673, 0.3506431287420727, 0.8395795410066416, 0.9059059059059056, 1.0237370654451514, 0.23723723723723716, 0.5558232931726906], "score_Separable_2D": 1.0, "ela_features": [0.0005094866519413932, 0.4234449434152071, 0.00441134142858017, 0.02624057411966586, 12.862577774291026, 0.007245138280565899, 0.9192757935211435, 1.834255277971812, 0.9191564424449388, 0.24574223965072295, -0.1799024808144331, 1.0, 0.8536157172253555, 0.8601592659213206, 0.5769926331193526, 0.19716426908947393, -0.49225799273312665, 0.49895791614058593, 0.5607883920493817, 0.625414068988858, 0.7332460042048831, 0.4956482717094028, 0.5573974230262244, 0.6223211360091512, 0.7332481314987885, -0.4407512296831662, -0.38636035740638586, -0.32951087931993117, -0.23465613315010025, -0.44593729338618343, -0.3913376749426224, -0.3339343660753221, -0.23585843834101966, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2143838052555395, 0.21437449770982092, 0.2004972033869802, 0.17988807634363213, 0.8478666872827709, 0.24124124124124116, 0.2866279824066152, -0.35535535535535523, 0.5641025641025641], "score_Separable_5D": 1.0, "ela_features_10D": [0.00035090965543527197, 0.44148888964290106, 0.0016218274750609985, 0.020455362412630924, 14.517262862463886, 0.006343593931955072, 0.9414194226014672, 2.8839735565672138, 0.9412201479355939, 0.19117493012421075, -0.1724655194304149, 1.4, 0.9896184054996615, 0.9355014923542837, 0.6965932414657028, 0.10662486380284848, -0.605976953467715, 0.6548348174448678, 0.7081369818624621, 0.7528276538385393, 0.822718197883939, 0.6520157355181004, 0.7089546064329116, 0.7544718878915052, 0.8252909857611179, -0.4377576947341253, -0.37015816883429975, -0.3134784976458594, -0.2248390899550064, -0.4425124473573582, -0.3701096363087717, -0.31222728345469075, -0.22216899562696685, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11060998183262054, 0.11060766850770949, 0.10722539933144995, 0.1010664028225187, 0.8567094273222826, -0.0750750750750751, 0.14756181345460326, -0.6036036036036034, 0.5953562850280224], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-2.7777777777777777, -3.888888888888889], 7.680971577375178], [1, [-1.6666666666666665, -3.888888888888889], 6.526097373204416], [1, [1.666666666666667, -3.888888888888889], 6.526097373204415], [1, [2.7777777777777786, -3.888888888888889], 7.6809715773751766], [1, [-2.7777777777777777, 3.8888888888888893], 7.680971577375178], [1, [-1.6666666666666665, 3.8888888888888893], 6.526097373204417], [1, [1.666666666666667, 3.8888888888888893], 6.526097373204416], [1, [2.7777777777777786, 3.8888888888888893], 7.680971577375177], [2, [-0.0004444353821918545, -3.8888955625154296], 5.119142786747497], [2, [7.876108518677812e-05, -2.1237704918648097], 2.882740494216062], [2, [0.00044444319472855326, -0.5835585700438645], 1.4429912642662057], [2, [0.0004444438293007536, -1.4406635373246623], 1.4480035969082565], [2, [0.0004444440721254382, 0.5835574432172324], 1.443005181615122], [2, [0.0004444439200250841, 1.44066500798843], 1.4480035070101382], [2, [-0.00044443660067398786, 3.888894691209372], 5.119144375483304], [1, [-2.7777777777777777, -1.4406666666666663], 4.009820026226992], [1, [2.7777777777777786, -1.4406666666666663], 4.00982002622699], [2, [-3.8928888888888884, -2.1237777777778497], 6.780853471826802], [1, [-2.7777777777777777, 1.4406666666666668], 4.009820026226991], [1, [2.7777777777777786, 1.4406666666666668], 4.00982002622699], [2, [3.892007437845477, 1.4407190129252914], 5.34611595274377], [2, [3.891994363157155, -4.6198103907924475], 10.574874713570635], [2, [3.892118172230957, -1.442336036695008], 5.346104371824259], [1, [1.8236634339465583, -2.025775645721554], 4.143655270999828], [1, [-1.821923954940061, -2.0267631602345912], 4.143666602218931], [1, [2.796200314895866, -4.605945741614354], 9.231526782403659], [1, [-2.7962071259453056, 4.605954485345797], 9.231507911665364], [1, [-2.796205772172067, -4.605954968594291], 9.231508412460489], [1, [2.796206341684737, 4.605954899309597], 9.231508005752161], [1, [-1.7085189265764675, -4.5906281144949865], 8.053649039177857], [1, [-1.7102310933138922, 4.589595020446338], 8.053653194196844], [1, [1.7085179343187211, -4.59062732113388], 8.053653421469331], [1, [1.7085179666545687, 4.590627446766949], 8.053652966443172], [2, [-3.891216313559976, 4.618896208293719], 10.574860084093084], [2, [3.8912163249888247, 4.61890340071124], 10.574859942561078], [2, [-3.8912163249888243, -4.61890340071124], 10.574859942561078], [2, [3.8904146668026374, 2.12371549336557], 6.780895796973704], [1, [2.8955007323524, 2.1153347395749944], 5.368137766059821], [2, [-3.8908457485634322, 2.123717604373255], 6.780881794961382], [1, [-2.8955167124444046, 2.1153722003532778], 5.368126101340144], [2, [-9.670680971166487e-06, 2.1237718506842045], 2.882740439691963], [1, [-1.823660966711792, 2.025772010046434], 4.143671215588631], [1, [1.823663036769313, 2.025776579221444], 4.143653023818876], [2, [-3.689900768517792, 0.7193731995611062], 4.457024491684946], [2, [-3.6917838920831243, -0.7191545279166517], 4.455707477843329], [2, [3.6932561603398875, -0.7194503774208124], 4.454194028069076], [2, [3.6946713440969754, 0.7193798992183029], 4.453081328425045], [1, [-1.6715687659733205, -1.42971361127615], 2.8512770913445404], [1, [1.672440706136473, -1.4279136889578588], 2.8512743695012084], [1, [-1.6724400442223633, 1.427913368455655], 2.851275766084379], [1, [1.6724395385277457, 1.4279131237981433], 2.851276832883224], [2, [0.001387170488448319, -4.619192723780078], 6.676747024787521], [2, [0.0013871689755709034, 4.619193545284238], 6.676747035667138], [2, [1.8202283459643656, 0.6933050417150102], 1.5769558935585661], [2, [-1.8220462423748451, 0.6924729999702597], 1.5770327316182953], [2, [1.8203832727790068, -0.6940723607162055], 1.5736364410140427], [2, [-1.8221940494983508, -0.6932179427917324], 1.5737470913361358], [2, [-3.8909778266932755, 1.441256447375489], 5.346114345949628], [2, [-3.890977808927737, -1.4412563898068647], 5.346114347792774], [2, [3.8621551760042148, -3.897119400901853], 9.011574363430075], [2, [-3.862250467699129, 3.897576052676707], 9.01101369899972], [2, [-3.8622522894889806, -3.897581405611595], 9.011006937604783], [2, [3.8622523335713574, 3.8975797988139367], 9.011008722243016], [1, [-2.8718484635934716, -2.102236267312612], 5.381022889509071], [3, [2.8799753062771885, -2.1057232092623486], 5.375804642692042]], "nr_of_basins": 65, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0922381069698417e-162, 5.0918104731011085e-163], "f_opt_dim_5": 0.542859768710711, "x_opt_dim_5": [0.9713271183496172, 4.896695495437404e-10, -3.38319077716359e-10, -5.120588653812893e-10, 1.9767984420366404e-10]}
{"id": "dae475f4-9274-49b6-9cfc-7445bd0c89db", "fitness": 1.0, "name": "landscape_centered_quadratic_cosine", "description": "A fully separable landscape with dimension-specific centered quadratic wells plus cosine modulation. Each dimension i has a unique center c_i within [-4, 4], creating independent 1D subproblems. The per-dimension function is g_i(x_i) = (x_i - c_i)^2 + a_i*(1 - cos(b_i*(x_i - c_i))), with a_i and b_i varying per dimension. The global optimum is at x = c, with f(x) = 0, ensuring clear separability and tunable ruggedness across dimensions.", "code": "import numpy as np\n\nclass landscape_centered_quadratic_cosine:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension centers c_i spaced within [-4, 4]\n        if self.dim == 1:\n            self.centers = np.array([0.0], dtype=float)\n        else:\n            self.centers = -4.0 + 8.0 * (np.arange(self.dim, dtype=float) / (self.dim - 1))\n\n        # Deterministic per-dimension modulation amplitudes a_i (ridge strength)\n        # Linearly increasing with dimension index for diversity\n        self.amplitudes = 0.2 + 1.4 * (np.arange(self.dim, dtype=float) / max(self.dim - 1, 1))\n\n        # Deterministic per-dimension frequencies b_i for the cosine term\n        self.freqs = 0.5 + 2.0 * (np.arange(self.dim, dtype=float) / max(self.dim - 1, 1))  # range ~[0.5, 2.5]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        dx = x - self.centers\n        quad = dx**2\n        cos_term = self.amplitudes * (1.0 - np.cos(self.freqs * dx))\n        return float(np.sum(quad + cos_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_centered_quadratic_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["20cf8e06-8149-471a-8c6c-7bbd9337a091"], "operator": null, "metadata": {"ela_features_2D": [0.9062907529849784, 0.3266537200226741, 0.5176659145336462, 0.5284227811549528, 1.020862961843048, 0.9062723141462877, 0.9989384713036351, 1.0156871953062088, 0.9989685424967945, 0.5263458577759561, -0.3834541795360679, 1.6, 0.719935485824194, 0.7216964052196674, 0.5976911557783514, 0.3369292339994989, -0.1079032814152741, 0.15453380546656667, 0.2233686120197463, 0.3236305797881777, 0.5017406098957198, 0.15292806923904856, 0.22043529288143157, 0.32086753739183027, 0.4964612996298915, -0.4423842620225784, -0.40637178047706585, -0.35391238405351444, -0.26071662675162377, -0.43525177148894845, -0.40057582747365716, -0.3489812201546985, -0.25875025794766715, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5240307006719699, 0.5240158203217793, 0.6057729439030377, 0.6535648712739548, 0.6957511843190824, 0.1651651651651651, 0.30670983142622327, -0.33933933933933924, 0.35421686746987946], "score_Separable_2D": 1.0, "ela_features": [0.8302057029938632, 0.37388535703800546, 0.01172378142382283, 0.3797864199802376, 39.74944098824749, 0.8316601468829916, 0.9984811826125076, 1.0430130600410323, 0.998559223237778, 0.4409148831497437, -0.19681961789177665, 1.0, 0.8963579304257892, 0.8699815132197968, 0.6560116789982859, 0.18425162440614348, -0.30636075518621314, 0.4621123777087906, 0.5541540811902924, 0.6343794159909524, 0.757415674941457, 0.4599619631570122, 0.5509189161502102, 0.6309231979328489, 0.7547287955460723, -0.4730814614097585, -0.39212947705104495, -0.32156978781138135, -0.21335731126248061, -0.4773019994027921, -0.39690982558248855, -0.3262008407847385, -0.21677868372075831, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21251238448030038, 0.21249876439236867, 0.254458782157574, 0.3200503968455278, 0.8123127935872964, -0.04304304304304305, 0.16277154398594265, -0.6116116116116114, 0.4915064102564103], "score_Separable_5D": 1.0, "ela_features_10D": [0.7958229824113499, 0.3906241424290509, 0.022550227093932416, 0.2451271478620675, 11.19314014739217, 0.7961380619524746, 0.9982464862748236, 1.052154801579499, 0.9983618683622657, 0.33396051303244134, -0.007385820684707944, 1.6, 0.9818700537133165, 0.933781654360945, 0.7071309439108159, 0.106777705185536, -0.42805317850105806, 0.6598733993644711, 0.7251741545323594, 0.7798895048367621, 0.8567821823806394, 0.6601586129925554, 0.7272117602822458, 0.7814108796300268, 0.8584964492362888, -0.43135539469505674, -0.34853959508706767, -0.2791482534964702, -0.18163125615408166, -0.4321286348593105, -0.34686643120218247, -0.27794863907635603, -0.17992898144180378, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11037810500790832, 0.11037287346316949, 0.12285969049197228, 0.17207863854970454, 0.8377404492753001, -0.27127127127127126, 0.08988619188951405, -0.8158158158158155, 0.5373098478783027], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[63, [-3.999995898833726, 2.0366667452615657], 5.1431691316491905], [37, [-4.00000000000011, 4.00000000000011], 2.4259050557356555e-26]], "nr_of_basins": 2, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 7.822714703056513e-168, "x_opt_dim_5": [-4.0, -2.0, -2.796911636619311e-84, 2.0, 4.0]}
{"id": "6c6745c5-7fb8-47a1-a806-0765b400b79f", "fitness": 1.0, "name": "landscape_separable_mixed_adv", "description": "A strictly separable, additive multimodal landscape where each dimension uses an independent 1D profile combining a quadratic base, cosine micro-wells, and sine-squared ripples. Each dimension has deterministic parameters to ensure diverse yet decoupled subproblems. The global optimum is at the origin with f(x) = 0, and the separable structure enables straightforward subproblem partitioning across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_mixed_adv:\n    \"\"\"\n    A strictly separable, additive multimodal benchmark with per-dimension\n    independent 1D profiles:\n\n        g_i(t) = w_i * t^2 + a_i * (1 - cos(b_i * t)) + c_i * sin^2(d_i * t)\n\n    Global objective: f(x) = sum_i g_i(x_i), with f(0) = 0 and separable subproblems\n    across dimensions. The parameters w_i, a_i, b_i, c_i, d_i are deterministic\n    per-dimension to ensure variety while preserving additivity.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Quadratic base weight per dimension (positive, increasing variety)\n        self.w = np.array([0.30 + 0.05 * (i % 18) for i in range(self.dim)], dtype=float)\n\n        # Amplitude for cosine micro-well term (nonnegative contribution)\n        self.a = np.array([0.10 + 0.04 * ((i * 3) % 20) for i in range(self.dim)], dtype=float)\n\n        # Frequency multiplier for the cosine term\n        self.b = np.array([0.5 + 0.25 * (i % 5) for i in range(self.dim)], dtype=float)\n\n        # Amplitude for sine-squared ripple\n        self.c = np.array([0.15 + 0.05 * (i % 7) for i in range(self.dim)], dtype=float)\n\n        # Frequency multiplier for the sine-squared term\n        self.d = np.array([0.8 + 0.2 * ((i * 2) % 6) for i in range(self.dim)], dtype=float)\n\n    def _one_dimensional(self, t, i):\n        \"\"\"\n        1D subproblem for dimension i with its specific parameters.\n        \"\"\"\n        t = float(t)\n        w = float(self.w[i])\n        a = float(self.a[i])\n        b = float(self.b[i])\n        c = float(self.c[i])\n        d = float(self.d[i])\n\n        # g_i(t) = w_i * t^2 + a_i * (1 - cos(b_i * t)) + c_i * sin^2(d_i * t)\n        return w * t ** 2 + a * (1.0 - np.cos(b * t)) + c * (np.sin(d * t)) ** 2\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape on a 1D array x of length dim.\n        Global minimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dim {self.dim}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            total += self._one_dimensional(x[i], i)\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_mixed_adv scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["01497983-debe-4be8-85fb-1346c2d339aa"], "operator": null, "metadata": {"ela_features_2D": [-0.0016579165940576069, 0.35711715859918786, 0.013633989280689674, 0.03110842568410834, 2.901072333665857, 0.0063626758109407875, 0.998987063041714, 1.2138354053012388, 0.9989862476405355, 0.41333918112745954, -0.5571078027000691, 1.8, 0.7277699966182507, 0.7260141485467327, 0.5768258678317487, 0.33557701464259776, -0.19472224026902057, 0.15221186797174935, 0.22625731953576173, 0.3171808862336783, 0.48606464488042633, 0.1527587064231322, 0.2257330106254126, 0.31998481008537905, 0.488628818486491, -0.44335748634591354, -0.40463576253083045, -0.35708551628054613, -0.26876622159311314, -0.43503892717159526, -0.3975777808765465, -0.34917237652665534, -0.262577197736363, 1.0, 1.0, 1.0, 1.0, 0.5250345143996844, 0.5249065066669198, 0.40311128563313153, 0.360345064198441, 0.7271512946485643, 0.3893893893893893, 0.535399231658791, -0.09109109109109108, 0.37670682730923694], "score_Separable_2D": 1.0, "ela_features": [-0.0008498219906980964, 0.40776617611856836, 0.004304065122209155, 0.021669466655560153, 9.408612400376054, 0.002811841499780887, 0.9927608613505082, 1.5641392791707973, 0.9927364351088857, 0.2512688149674931, -0.18085150923802926, 1.4, 0.9129098441722052, 0.8760749373645034, 0.6476597399663223, 0.18123711174385293, -0.47285715692215147, 0.4551140615817711, 0.5352207285544903, 0.6056232501181097, 0.7194122278604511, 0.45145859273853767, 0.537010610282095, 0.6084083027250264, 0.7230609970831507, -0.47925949408565793, -0.40880119198352727, -0.3468782124281174, -0.2467935682679788, -0.4848681567449794, -0.4092489170003543, -0.3461400640858148, -0.2447912738117924, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21728770159562644, 0.21729338769498346, 0.20366187726498386, 0.18318087355546897, 0.8235569761341189, 0.07707707707707703, 0.24363062208462916, -0.4074074074074073, 0.5064102564102564], "score_Separable_5D": 1.0, "ela_features_10D": [-0.001841167321379933, 0.44387977726724887, 0.000677684708374504, 0.0157164642035342, 83.46312254049658, 0.0010749745445006065, 0.996286410334665, 2.390794296139609, 0.9962801009213129, 0.20061451161597219, -0.08841071568870422, 1.4, 1.0058608132395688, 0.9369070804023785, 0.7038507148259623, 0.10531575814657967, -0.603783075565999, 0.6317400211065954, 0.692255188967209, 0.7414925447976339, 0.8173569478226306, 0.6342208237416835, 0.694720209282949, 0.7446927475332444, 0.8208134503432458, -0.4670826979336473, -0.3903283845827767, -0.3278782908151786, -0.2316556800570762, -0.46522113192873027, -0.38827560577643866, -0.32471749223985996, -0.22790220319364365, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10983338112098207, 0.10984106178380378, 0.10666165165524408, 0.10019417219607987, 0.8569646230009902, -0.10310310310310307, 0.14174848405749343, -0.6396396396396394, 0.588951160928743], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.1893826529363263e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.8130172504942217e-163, 1.699548417315558e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.6736305279713226e-162, -8.271442367532154e-163, -2.154234049093655e-162, 7.707255707882228e-163, -2.0544106140566806e-162]}
{"id": "89f234ae-836e-4ff7-8587-5908111ca772", "fitness": 1.0, "name": "landscape_separable_quad_cosine_dimvar", "description": "A novel separable landscape with independent per-dimension 1D profiles. Each dimension has its own quadratic weight and cosine modulation, yielding a smooth, multi-modal, yet fully separable function whose global minimum is at the origin. The problem can be partitioned into independent subproblems across dimensions, enabling exact subproblem decomposition and scalable optimization. Per-dimension parameters are deterministically derived from the dimension index to ensure reproducible, diverse landscapes.", "code": "import numpy as np\n\nclass landscape_separable_quad_cosine_dimvar:\n    \"\"\"\n    A fully separable benchmark: f(x) = sum_i [ w_i * x_i^2 + a_i * (1 - cos(b_i * x_i)) ]\n    - Global minimum at x = 0 with f(0) = 0\n    - Each dimension i has its own deterministic parameters:\n        w_i in [0.1, 1.0] (quadratic weight)\n        a_i in [0.25, 0.9] (cosine modulation amplitude)\n        b_i based on distinct primes (frequency)\n    - The function is strictly separable: no cross-dimension coupling.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        # Deterministic per-dimension frequencies derived from primes\n        base_primes = np.array([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53], dtype=float)\n        if self.dim <= len(base_primes):\n            primes = base_primes[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / len(base_primes)))\n            primes = np.tile(base_primes, reps)[:self.dim]\n\n        idx = np.arange(self.dim, dtype=float)\n\n        # Per-dimension quadratic weights w_i\n        # Spread smoothly from 0.1 to 1.0 across dimensions\n        if self.dim == 1:\n            self.weight = np.array([0.25], dtype=float)\n        else:\n            self.weight = 0.1 + 0.9 * (idx / (self.dim - 1))\n\n        # Per-dimension cosine amplitudes a_i\n        # Spread smoothly from 0.25 to 0.9 across dimensions\n        if self.dim == 1:\n            self.amp_per_dim = np.array([0.5], dtype=float)\n        else:\n            self.amp_per_dim = 0.25 + 0.65 * (idx / (self.dim - 1))\n\n        # Per-dimension cosine frequencies b_i (using distinct primes for diversity)\n        self.freq = 0.8 * primes  # scale primes to keep frequencies reasonable\n\n        # Ensure arrays are numpy arrays of correct dtype\n        self.weight = np.asarray(self.weight, dtype=float)\n        self.amp_per_dim = np.asarray(self.amp_per_dim, dtype=float)\n        self.freq = np.asarray(self.freq, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        # Per-dimension contribution: w_i * x_i^2 + a_i * (1 - cos(b_i * x_i))\n        quad = self.weight * (x ** 2)\n        periodic = self.amp_per_dim * (1.0 - np.cos(self.freq * x))\n        return float(np.sum(quad + periodic))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_quad_cosine_dimvar scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b1373a9b-e536-4791-9160-054e9936b565"], "operator": null, "metadata": {"ela_features_2D": [-0.003201062816321709, 0.38074865603713476, 0.004044994220388199, 0.022295850458090214, 6.535001641822703, -0.0037792077549830827, 0.9927698586746769, 11.076680534559532, 0.9927350028614225, 0.6015387361469396, -0.967918782591014, 2.0, 0.6752170360843253, 0.7107298830901757, 0.5510063502330146, 0.34283328539864, -0.18478783462500414, 0.19115206393495007, 0.3554268902365444, 0.504788909908504, 0.6278014905779369, 0.18794031421728646, 0.3166142041593396, 0.4484829651149916, 0.5680921054469332, -0.423356887255666, -0.3373748030822886, -0.2591979322899635, -0.194808213421057, -0.4173541983708919, -0.351216850047591, -0.28343134192269914, -0.22195535019032003, 1.0, 1.0, 1.0, 1.0, 0.5088625690206685, 0.508831375934532, 0.34858776665940805, 0.3441686927390871, 0.7032695315468841, 0.5095095095095094, 0.5631290384059634, -0.0830830830830831, 0.3791164658634538], "score_Separable_2D": 1.0, "ela_features": [-0.0005896730266730987, 0.4047652810301394, 0.0035932102253567835, 0.025612713628068558, 20.87676877626194, 0.0032858398946978397, 0.9912852302151041, 10.896020915553834, 0.9912450159561315, 0.32364633536061244, -0.32273279198683, 1.2, 0.87714672350169, 0.8680279833685406, 0.6435896360701642, 0.18540924047158994, -0.4725545689021951, 0.517921868548905, 0.5863020029344772, 0.6532281949024042, 0.7574665979539711, 0.49284733740031744, 0.5661419862347539, 0.6369576403437647, 0.7511707752244617, -0.4241275969260393, -0.3639648228578258, -0.3050847786107476, -0.21337796743467718, -0.4488237198023667, -0.3839458570098633, -0.32127853719005317, -0.22020671495691496, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21789228495778518, 0.21792246926201794, 0.2018996018886272, 0.1840121967587371, 0.8187985073863935, 0.17717717717717713, 0.2588661440266268, -0.3353353353353352, 0.5068910256410256], "score_Separable_5D": 1.0, "ela_features_10D": [-0.0007732291955556469, 0.44255241117200816, 0.0021783112366902833, 0.019560586629225954, 18.47249546702427, 0.0025357548667126915, 0.9913026232434108, 11.071681677091503, 0.9913236658615997, 0.23746756060769983, -0.20032815144517874, 1.2, 0.9971987867286541, 0.9350975480563539, 0.7004892576396144, 0.10733510472565011, -0.5954158242822263, 0.6603062966653186, 0.7138605497933603, 0.7590557467396588, 0.8289392695446901, 0.6557114746882643, 0.7130924557839788, 0.7591911467773502, 0.8302117486315723, -0.4308002755881232, -0.36288245183116147, -0.3055658927062931, -0.2169396243342018, -0.4377213093348399, -0.3647673285395191, -0.306159119797308, -0.21586535784758515, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10969413886986194, 0.10969474401604914, 0.10626376195876261, 0.10057632938384656, 0.8569101691887969, -0.0870870870870871, 0.1408519076178695, -0.6076076076076073, 0.5844675740592474], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 7.924937759443837e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.60253529342698e-162, -1.5126662325311644e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.1169481277757066e-162, -2.659685627395913e-163, -1.5531227147469986e-162, 4.076677161179998e-163, 2.3050436439559372e-163]}
{"id": "33f23dc5-2a16-413f-bda1-701176dc9680", "fitness": 1.0, "name": "landscape_quartic_ripple_centered", "description": "A completely different separable landscape based on per-dimension centered quartic wells with an offset cosine ripple. Each dimension has its own center within [-5,5], a quartic term to create a smooth but non-quadratic basin, and a cosine-based micro-well centered at that same dimension-specific center. The global minimum is at x equal to the per-dimension centers, with f(x) = 0. The problem remains fully separable across dimensions.", "code": "import numpy as np\n\nclass landscape_quartic_ripple_centered:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters derived deterministically from dimension index\n        self.center = np.zeros(self.dim, dtype=float)  # dimension-specific center within [-5, 5]\n        self.a = np.zeros(self.dim, dtype=float)       # amplitude for the cosine ripple\n        self.b = np.zeros(self.dim, dtype=float)       # frequency multiplier for the ripple\n        self.w = np.zeros(self.dim, dtype=float)       # quartic coefficient per dimension\n\n        for i in range(self.dim):\n            # Distribute centers evenly in (-5, 5)\n            t = (i + 1) / float(self.dim + 1)  # in (0, 1)\n            self.center[i] = -5.0 + 10.0 * t\n\n            # Dimension-specific parameters (deterministic, reproducible)\n            self.a[i] = 0.2 + 0.8 * t       # ripple amplitude in [0.2, 1.0]\n            self.b[i] = 1.0 + 4.0 * t       # ripple frequency in [1.0, 5.0]\n            self.w[i] = 0.05 + 0.15 * t     # quartic weight in [0.05, 0.20]\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape == (self.dim,):\n            diff = x - self.center\n            # Per-dimension landscape: w_i*(x_i - c_i)^4 + a_i*(1 - cos(b_i*(x_i - c_i)))\n            term1 = self.w * (diff ** 4)\n            term2 = self.a * (1.0 - np.cos(self.b * diff))\n            return float(np.sum(term1 + term2))\n        else:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_quartic_ripple_centered scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["efaec5ff-3031-49e3-9df3-08da7134383d"], "operator": null, "metadata": {"ela_features_2D": [0.5380793326183475, 0.2323218862939665, 0.2750195364429309, 0.4133283208019898, 1.5091175130223835, 0.5387005092434255, 0.9153884144707186, 1.4685661544837199, 0.9895868971721763, 1.5009588231197326, 1.8248471084043398, 1.6, 0.6858263048345988, 0.7126879185527236, 0.5397042700032104, 0.3433139820322249, -0.14323172820160576, 0.16959348739103808, 0.27318627369332155, 0.332488963767, 0.5007456403376503, 0.1585478316199397, 0.2769712131543975, 0.33068078539479656, 0.5012082224901804, -0.4345872567309598, -0.38037056030616306, -0.3493363520519418, -0.26128172591386145, -0.4322741084497038, -0.3714284477273029, -0.34384275055123453, -0.2562426844623621, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.522246565395047, 0.522172803736803, 0.5388399049929751, 0.5863200101276836, 0.5901357469962867, 0.5295295295295294, 0.06463977316827717, -0.5955955955955954, 0.368273092369478], "score_Separable_2D": 1.0, "ela_features": [0.6527940055414592, 0.38276603384666236, 0.011447392389689327, 0.47686928908360127, 58.64930785422895, 0.6543917938188991, 0.9497996834039462, 5.98893529822089, 0.9968999693324101, 1.1675278844021766, 0.8652917124485846, 1.2, 0.8903108412239306, 0.8692880059591104, 0.6505788007949451, 0.18500830702722232, -0.3163993659474709, 0.4552725431701544, 0.5420226891882147, 0.6298655844242577, 0.7580465881238068, 0.45212680024963925, 0.5418769387910414, 0.6287403505489877, 0.7556664301902652, -0.47919583251347675, -0.4028810509846664, -0.32560562651589614, -0.2128442822853441, -0.4845705150537932, -0.40518982144232146, -0.32836214014538034, -0.21609856903279018, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21451396706532808, 0.21452981879596048, 0.2431586014790489, 0.29966780207133636, 0.75863309490204, 0.22122122122122115, 0.13301829277073474, -0.5835835835835834, 0.5078525641025642], "score_Separable_5D": 1.0, "ela_features_10D": [0.673048417306266, 0.47633136285918143, 0.00852835496244873, 0.37619639722767545, 1023.3683596695009, 0.6744218565440356, 0.9588583119279107, 8.572782573857467, 0.9978856608017583, 0.9094621417317332, 0.6078270489221325, 1.8, 0.9478637881219838, 0.9284842444400724, 0.6823539133963249, 0.11108938006308537, -0.41848968682676924, 0.6782771211022759, 0.7405103704379389, 0.7938381872981658, 0.8644327214632167, 0.6771944678268471, 0.7422396551310443, 0.7945488952496931, 0.8651905777513333, -0.4080309406132345, -0.3291023532260272, -0.2614681178618331, -0.17193565249960802, -0.4105329676884472, -0.32781145345202567, -0.26128674470310476, -0.1714466950132601, 0.9, 0.9, 0.8181818181818181, 0.8727272727272727, 0.11006209117745698, 0.11005814845879, 0.12292918938996711, 0.165804198421107, 0.8250581167477933, -0.10310310310310308, 0.0852154794007948, -0.7917917917917915, 0.556605284227382], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[27, [-1.6666666666666665, 3.15488888888897], 0.9722680323504622], [15, [-1.6666666666666665, 1.666666666666667], 9.723461371658034e-62], [58, [-1.6666666666666665, 0.17844444444444527], 0.9722680323504624]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.666666666666667, 1.666666666666666], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.3333333333333335, -1.666666666666667, -1.5902603155731262e-81, 1.666666666666666, 3.333333333333334]}
{"id": "3b796718-058d-4662-97e6-17c579b2d899", "fitness": 1.0, "name": "landscape_separable_nonlinear_sine_ripple", "description": "A completely different fully separable landscape using a non-quadratic per-dimension base with a cubic-like |x|^p term and a sine-squared ripple, ensuring a unique global minimum at the origin and easy separability across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_nonlinear_sine_ripple:\n    \"\"\"\n    Fully separable landscape with per-dimension non-quadratic base + sinusoidal ripple.\n    Each dimension i contributes:\n        g_i(x_i) = w_i * |x_i|^p + A_i * sin^2(s_i * x_i)\n    Global minimum is at x = 0 with f(x) = 0. Parameters are deterministically derived\n    from the dimension index to preserve diversity while maintaining additivity.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        idx = np.arange(self.dim)\n\n        # Normalized position across dimensions for deterministic shaping\n        if self.dim > 1:\n            t = idx / float(self.dim - 1)\n        else:\n            t = np.zeros(self.dim)\n\n        # Per-dimension weight for the |x|^p term: in [0.25, 0.75], increasing with dimension\n        self.w = 0.25 + 0.50 * t  # shape (dim,)\n\n        # Per-dimension ripple amplitude for the sine^2 term: in [0.05, 0.25]\n        self.A = 0.05 + 0.20 * t  # shape (dim,)\n\n        # Per-dimension frequency factor for the sine term\n        # Ensures diverse but deterministic frequencies\n        self.s = 0.7 + 0.3 * (idx + 1)  # shape (dim,)\n\n        # Exponent for the non-quadratic base\n        self.p = 3\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        # Per-dimension components\n        term1 = self.w * (np.abs(x) ** self.p)\n        term2 = self.A * (np.sin(self.s * x) ** 2)\n\n        return float(np.sum(term1 + term2))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_nonlinear_sine_ripple scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94ba0fec-a981-48e9-8d7f-6bfa30d421bf"], "operator": null, "metadata": {"ela_features_2D": [-0.001118207389207937, 0.28723143379566796, 0.008708741714719368, 0.03864686976865232, 4.527782794889814, 0.003950379129829318, 0.9720257907706247, 2.951859434139837, 0.9720311363946671, 0.9355154878198165, -0.09773090549561614, 1.2, 0.7218242994988708, 0.721520053473623, 0.5641444656111715, 0.33969074322782644, -0.2044343512222449, 0.15991241125185193, 0.23623125373912224, 0.32981509912323914, 0.5115806272286745, 0.15691565359329773, 0.2326883424233989, 0.32335497618341685, 0.5053641465212578, -0.4396488890785507, -0.39970922611967274, -0.3507338209338955, -0.25561165630260135, -0.43334102251491025, -0.39437982947036493, -0.3477824414948594, -0.2542297726908792, 1.0, 1.0, 1.0, 1.0, 0.5114906539941824, 0.511443947184001, 0.3823641673280653, 0.3544361783731953, 0.6378794260579769, 0.6216216216216214, 0.43277798906845355, -0.10710710710710707, 0.3618473895582329], "score_Separable_2D": 1.0, "ela_features": [-0.0011019621014662028, 0.32349930082957223, 0.004403446658957466, 0.024738952367928335, 6.224723392677451, -0.0005810552633773725, 0.9714928929316928, 2.987671339362315, 0.9717840183356335, 0.5348600331270941, -0.008583508661866546, 1.4, 0.9082840937970109, 0.8721277642105445, 0.6388224772631701, 0.18513070406402762, -0.4837162091659805, 0.44102552232231834, 0.5265199374354814, 0.6082823815492466, 0.7311473927230592, 0.4433646343799441, 0.5253189470682431, 0.6064233121075352, 0.7310604495309976, -0.49168477469294086, -0.4164832322062882, -0.3445626713808325, -0.23648869909315984, -0.49232608520665744, -0.4198440540521893, -0.3481100284460899, -0.2378713084044235, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21813575065446736, 0.2181267049274111, 0.2026106514611846, 0.1829628395378306, 0.8215037627639334, 0.22522522522522515, 0.2453396814220971, -0.3433433433433432, 0.5147435897435897], "score_Separable_5D": 1.0, "ela_features_10D": [0.0002135369087149952, 0.3767328320630781, 0.00041281255359901844, 0.02062407631512144, 67.37088918231858, 0.007072023469564481, 0.9714995408106933, 2.9963693188913707, 0.9719416487048491, 0.3702965174463059, -0.013024295602760106, 2.0, 1.0136480790659892, 0.936659371586966, 0.7065394966566838, 0.10669945979973328, -0.5964411445710696, 0.6302206458688163, 0.689827426067741, 0.7418516393112525, 0.8188031827018, 0.6317744657347032, 0.6915283575510381, 0.7442752756509737, 0.8218553225060468, -0.468963501322035, -0.39336885682257955, -0.3273904761388906, -0.22979842926926214, -0.4682821997061974, -0.39229162725018474, -0.32521224398454185, -0.22655135676263655, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10920191413310795, 0.10920473526985071, 0.10622879897841989, 0.10030071139953582, 0.8579363691505282, -0.0950950950950951, 0.13439573413916994, -0.6396396396396394, 0.5976781425140112], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 9.342111489179499e-08]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.754123868584348e-162, 5.3258117996036134e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [3.205134936172817e-162, -1.9717166362458678e-162, 2.5667247865177107e-162, 5.783836222908788e-163, -1.2163663940511069e-162]}
{"id": "744f259a-3622-4c7d-9d2f-909e52217cf4", "fitness": 1.0, "name": "landscape_separable_attractor_ripple_v2", "description": "A novel fully separable additive landscape with per-dimension attraction to 1 and dimension-specific ripple. Each dimension contributes an independent 1D profile, enabling exact subproblem partitioning; the global optimum is at x = [1, ..., 1] with f(x) = 0. Deterministic, dimension-dependent parameters yield diverse yet decoupled subproblems, improving separability for efficient optimization.", "code": "import numpy as np\n\nclass landscape_separable_attractor_ripple_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Deterministic per-dimension base bowl centered at x_i = 1\n        # Slightly increasing weight across dimensions to encourage diverse but decoupled subproblems\n        self.w = 1.0 + 0.25 * (np.arange(self.dim) / max(self.dim - 1, 1))  # [1.0, ~1.25]\n\n        # Deterministic per-dimension ripple amplitude, increasing with dimension index\n        self.A = 0.25 + 0.25 * (np.arange(self.dim) / max(self.dim - 1, 1))  # [0.25, ~0.5]\n\n        # Per-dimension ripple frequency (distinct for each dimension)\n        self.k = np.arange(1, self.dim + 1)  # (1, 2, ..., dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        # Separable per-dimension function:\n        # g_i(x_i) = w_i * (x_i - 1)^2 + A_i * sin^2(pi * k_i * (x_i - 1))\n        quad_term = self.w * (x - 1.0) ** 2\n        ripple_term = self.A * np.sin(np.pi * self.k * (x - 1.0)) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_attractor_ripple_v2 scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94ba0fec-a981-48e9-8d7f-6bfa30d421bf"], "operator": null, "metadata": {"ela_features_2D": [0.3657773971343077, 0.5858422375554, 0.2708115893527644, 0.33289195396959037, 1.2325547980490785, 0.36901246381053177, 0.9998259110076322, 1.2483283834188283, 0.9998267247218638, 0.7334834081984112, -0.0717812327392382, 1.2, 0.6983225084190625, 0.713963004681753, 0.5487060191609702, 0.34305538601629376, -0.16343989471619336, 0.1493640395447773, 0.2201905743340181, 0.3078813001367653, 0.48597124209546144, 0.15201947360470264, 0.22371015256149313, 0.30931993696171045, 0.48636749240708266, -0.4451550969879928, -0.4080865446722326, -0.36219536649735595, -0.2689969577534284, -0.4355993359762242, -0.3987528345445475, -0.35477201623015053, -0.2638268167015094, 1.0, 1.0, 0.8666666666666666, 1.0, 0.5095988377798286, 0.5095804462552372, 0.4931850571204751, 0.5316276871505796, 0.7240318335337801, 0.3213213213213212, 0.40068682245850074, -0.22722722722722716, 0.3839357429718876], "score_Separable_2D": 1.0, "ela_features": [0.3819826464582145, 0.764498810361942, 0.14459177114486815, 0.1803370300540988, 1.2470196302071437, 0.3831021800088553, 0.99983512889466, 1.2488291277906989, 0.9998341818667982, 0.5109021166186365, 0.03444799811410189, 1.6, 0.9107665484270298, 0.8734661985805492, 0.6426119420514869, 0.1820498924936708, -0.39680824520541513, 0.4429636110083046, 0.5284722656254355, 0.5990510665737023, 0.7204318481608414, 0.44778829603148784, 0.5311032794635194, 0.602390533622209, 0.7244782451674725, -0.4900109780068663, -0.41479041159120345, -0.35270337483119735, -0.24592834652995452, -0.48820197860824893, -0.41454405427782526, -0.35151893356862063, -0.24358363754576945, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2156374169593797, 0.21559308191165205, 0.21804198672094074, 0.2691757478583542, 0.8245018818213324, 0.041041041041041, 0.20020060931781458, -0.4714714714714713, 0.5227564102564102], "score_Separable_5D": 1.0, "ela_features_10D": [0.3801064500784302, 0.9331799532094862, 0.08852711910566444, 0.1185003990847188, 1.3384044078734727, 0.3840395163503264, 0.9998370032417746, 1.2495436735803385, 0.9998378112141817, 0.3484444623595201, 0.026117258068627257, 1.4, 1.0178628157162581, 0.9376965375147497, 0.7173279753605712, 0.10537388311173397, -0.5229524140459815, 0.6121605242198938, 0.6811804960832881, 0.7376598093360507, 0.8211643731614139, 0.6153752329439726, 0.6854305430833001, 0.7414135173113217, 0.8251813329902797, -0.4918936448081698, -0.4043562068799404, -0.33272377288618615, -0.22681550389632438, -0.4891389299523251, -0.40004761641451453, -0.3288518552623677, -0.22232152882838108, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11093314914589336, 0.11093944839297627, 0.1130925787860821, 0.14789886505526467, 0.8520995706314632, -0.1751751751751751, 0.11429263197343893, -0.7117117117117115, 0.5720576461168936], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [0.9997777777778631, 0.5555555555555554], 0.305402640696833], [19, [1.239973842289642, 1.8988036684293788], 1.36085695401548], [22, [1.0002443266293508, 1.4692753862076495], 0.2936779595023054], [50, [0.9996857833138166, 0.06711111004159659], 1.171610019034246]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0, 1.0], "f_opt_dim_5": 0.07296344200813991, "x_opt_dim_5": [0.9999999996898601, 0.9999999997057839, 0.9999999998724354, 0.7542323335175579, 0.9999999998910016]}
{"id": "ff17ab9e-50bd-4d34-b894-8d59690d1bd1", "fitness": 1.0, "name": "landscape_centered_wells", "description": "A novel separable landscape with per-dimension quadratic wells centered at deterministic centers m_i and dimension-specific cosine modulation. Each dimension contributes an independent 1D profile f_i(x_i) = w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i*x_i)), with m_i chosen so that cos(b_i*m_i) = 1, ensuring a global minimum of 0 at x_i = m_i. The overall function is the sum of independent 1D subproblems, making it fully separable and suitable for subproblem optimization.", "code": "import numpy as np\n\nclass landscape_centered_wells:\n    \"\"\"\n    A strictly separable, additive landscape where each dimension has:\n      - a quadratic well centered at m_i\n      - a dimension-specific cosine modulation to introduce local features\n    The centers m_i are deterministically placed in [-5, 5], and for each i a cosine\n    term is constructed so that cos(b_i * m_i) = 1, yielding f_i(m_i) = 0.\n    The global optimum is at x = m (vector of centers) with f(x) = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i in [-5, 5]\n        self.m = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = i / float(max(1, self.dim - 1))\n            self.m[i] = -5.0 + 10.0 * t  # linearly spread from -5 to 5\n\n        # Quadratic weights w_i (positive)\n        self.w = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # deterministic pattern across dimensions\n            self.w[i] = 0.4 + 0.25 * ((i % 6) / 5.0)  # in [0.4, ~0.65]\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.A[i] = 0.6 + 1.0 * ((i % 5) / 5.0)  # in [0.6, 1.6)\n\n        # Cosine frequencies b_i tuned so that b_i * m_i is a multiple of 2\u03c0\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            mi = self.m[i]\n            if abs(mi) < 1e-8:\n                # For zero center, any frequency works; pick a moderate one\n                self.b[i] = 2.0 * np.pi\n            else:\n                # Choose frequency so that b_i * m_i = 2\u03c0 * N_i with N_i = (i%5)+1\n                N_i = (i % 5) + 1\n                self.b[i] = (2.0 * np.pi * N_i) / max(abs(mi), 0.5)  # keep frequencies reasonable\n\n        # Ensure numpy arrays for convenient vectorized operations\n        self.m = np.asarray(self.m)\n        self.w = np.asarray(self.w)\n        self.A = np.asarray(self.A)\n        self.b = np.asarray(self.b)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        # Per-dimension: f_i(x_i) = w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i * x_i))\n        diff = x - self.m\n        quad_term = self.w * (diff ** 2)\n        cos_term = self.A * (1.0 - np.cos(self.b * x))\n\n        return float(np.sum(quad_term + cos_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_centered_wells scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["22934d04-7374-46c8-8fff-44cbaa88c42a"], "operator": null, "metadata": {"ela_features_2D": [0.9382078562441357, 0.4000829575825586, 0.49363296122372063, 0.5601552007286607, 1.1351952654481972, 0.9384037012028811, 0.9984738357613411, 1.1514325913810737, 0.9984762905928448, 0.44222690878069304, -0.45394214602798444, 2.0, 0.6928852773613122, 0.7147773980159198, 0.5498108686973262, 0.33702014699506433, -0.10166647916380908, 0.19351754694219123, 0.2643458547997396, 0.34796070990395317, 0.5261240336698372, 0.18104142204217494, 0.26065149319038794, 0.3451478767662822, 0.5168536107931749, -0.42181329817386964, -0.38477244102477903, -0.34104084354668246, -0.24785849855218572, -0.4207086112023445, -0.37981934723163996, -0.3364272095030498, -0.2482297290373939, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5134940285698895, 0.5134669790399435, 0.6044936957885265, 0.6555376188106882, 0.7049791278764749, 0.11311311311311308, 0.2762824175044242, -0.3913913913913913, 0.3602409638554217], "score_Separable_2D": 1.0, "ela_features": [0.8834953940915312, 0.47859276800005884, 0.005425156737673758, 0.4493635650237203, 109.93076620076667, 0.8839541493103585, 0.9955048359030096, 1.5533501075265514, 0.995494752905555, 0.3515320884430807, -0.35983347177431746, 1.4, 0.8639914439072005, 0.86482152177749, 0.6383675448304864, 0.18725976033357963, -0.2927596828861151, 0.4695780144663112, 0.5724075257835871, 0.6520651793446263, 0.7738196284255616, 0.4585163089753815, 0.5632963796994357, 0.6469499768915693, 0.7689552703071706, -0.4666871493479025, -0.37621242691181384, -0.30612652812533847, -0.19900143104876553, -0.4791597599283267, -0.38644007349792464, -0.31241231315893164, -0.2044483240810008, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21353925952892028, 0.21353293458814832, 0.2580869088777014, 0.3255182360719136, 0.8095423374942271, -0.05905905905905908, 0.15394567725905833, -0.6076076076076073, 0.48605769230769236], "score_Separable_5D": 1.0, "ela_features_10D": [0.8405836535849271, 0.44550911007218186, 0.0337921309657461, 0.29260001607924957, 8.672376251907247, 0.8413580088385032, 0.9941290194376405, 1.6600413369587492, 0.9941187670206281, 0.28834408470717743, -0.12319185126559953, 1.2, 0.9548576404865562, 0.9313491453498722, 0.6969799344793816, 0.10758952030578717, -0.41899571694655274, 0.687378913130474, 0.7507439912688394, 0.8012327313136464, 0.8715230406378925, 0.6893017842067609, 0.7511527793915901, 0.8024964436092044, 0.8727731660728377, -0.3965357961067847, -0.3161624978722756, -0.25212125062165247, -0.16296306801986024, -0.3951706614347349, -0.3165044301816219, -0.2512011982602428, -0.16181660611285156, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10968059965720764, 0.10968116367290197, 0.1246309080197526, 0.17443496370647155, 0.8428397359020872, -0.2832832832832832, 0.09425553187075476, -0.8198198198198196, 0.5378702962369897], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [-5.0, 5.0], 0.0], [88, [-5.0, 2.9577777777777587], 2.350392785204148]], "nr_of_basins": 2, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 0.5872311815456552, "x_opt_dim_5": [-4.999999992988385, -2.500000000209836, -1.2081452924080554e-09, 2.499999999072168, 4.021312589620285]}
{"id": "e8defcbd-c9e5-4059-8135-0024fdb8cf81", "fitness": 1.0, "name": "landscape_separable_centered_cosine_well", "description": "A fully separable additive landscape where each dimension has a unique center and a per-dimension cosine modulation around that center. The global optimum is at x = c (dimension-specific centers) with f(x) = 0, and each dimension contributes independently via a quadratic well plus a cosine-based modulation to introduce ruggedness while preserving separability.", "code": "import numpy as np\n\nclass landscape_separable_centered_cosine_well:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n        \n        # Dimension-specific centers c_i (optima) spread across the domain [-4, 4]\n        if self.dim == 1:\n            self.c = np.array([0.0])\n            self.w = np.array([1.0])\n            self.a = np.array([0.20])\n            self.b = np.array([0.75])\n        else:\n            self.c = -4.0 + 8.0 * (np.arange(self.dim) / (self.dim - 1))  # centers in [-4, 4]\n            # Per-dimension quadratic weight (slightly varying to encourage separability)\n            self.w = 1.0 + 0.25 * (np.arange(self.dim) / (self.dim - 1))  # in [1.0, ~1.25]\n            # Per-dimension cosine modulation amplitude\n            self.a = 0.15 + 0.15 * (np.arange(self.dim) / (self.dim - 1))  # in [0.15, ~0.3]\n            # Per-dimension modulation frequency\n            self.b = 0.5 + 0.5 * (np.arange(self.dim) / (self.dim - 1))  # in [0.5, 1.0]\n\n        # Ensure shapes are numpy arrays for consistent broadcasting\n        self.c = np.asarray(self.c, dtype=float)\n        self.w = np.asarray(self.w, dtype=float)\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        \n        delta = x - self.c  # per-dimension displacement from its center\n        quad_term = self.w * (delta ** 2)\n        ripple_term = self.a * (1.0 - np.cos(self.b * delta))\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_centered_cosine_well scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["94ba0fec-a981-48e9-8d7f-6bfa30d421bf"], "operator": null, "metadata": {"ela_features_2D": [0.906935171342019, 0.3755227756112037, 0.45822712527170006, 0.5767435907410895, 1.2586219079992924, 0.9069084670862952, 0.999973407095062, 1.2484702485002788, 0.9999868937369489, 0.5789446328448654, -0.31137476463399116, 1.6, 0.7266960635479072, 0.716674468531856, 0.5612485785053974, 0.34582437805008065, -0.10847843380641795, 0.12770234247490353, 0.21937494127270965, 0.3194323874293822, 0.50648154220457, 0.13099101535963406, 0.22281794610103814, 0.3208272972440086, 0.5024308667492989, -0.45632059254014357, -0.40836788819000286, -0.35602533594233765, -0.2581730346134828, -0.4463558385471793, -0.3992016414618913, -0.34886038557120047, -0.25558060637340774, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5115153720130877, 0.511511222064889, 0.6055579343384416, 0.6537589815111168, 0.6746135700552408, 0.1411411411411411, 0.30812407451930796, -0.3993993993993993, 0.34257028112449794], "score_Separable_2D": 1.0, "ela_features": [0.8255190564666408, 0.4112260033389076, 0.005025124011155577, 0.39947391171055163, 247.17316164606592, 0.8260514983747731, 0.9999588783543161, 1.2484112694809373, 0.9999856632260993, 0.4528095319097769, -0.18714950737221675, 1.0, 0.8966257028476143, 0.8744466732788461, 0.6641666769217084, 0.1786303808575689, -0.30163733112220076, 0.4733205380179662, 0.5695214980936047, 0.6493301269827141, 0.7698071232457551, 0.4767582036565594, 0.5690874098645808, 0.6485086000365906, 0.7683458718218534, -0.4632501357400483, -0.378634795053331, -0.30843752197762503, -0.20247026681295982, -0.4626471737417683, -0.38101237661466414, -0.3107867097633717, -0.20482746527435314, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21437898343413964, 0.21440980818466504, 0.24811269703665398, 0.3171223090060195, 0.8049547532987027, -0.055055055055055056, 0.15239971521103518, -0.5915915915915914, 0.4865384615384615], "score_Separable_5D": 1.0, "ela_features_10D": [0.7978349329159855, 0.46074088796902063, 0.026303720089407612, 0.26987766105857103, 10.292840969190994, 0.7986264195833218, 0.9999573504575388, 1.2481990229714652, 0.9999816124877723, 0.3154318092853057, -0.09809294657833005, 1.0, 0.979506899786422, 0.93418116199838, 0.7101146721423524, 0.10518354714830185, -0.42840194555432565, 0.6592285771553354, 0.7282616474988871, 0.783732356998622, 0.8586139661578167, 0.6616108347980953, 0.7311024348236674, 0.7856218348611413, 0.860141524329535, -0.4321869895335171, -0.34463570760852724, -0.2742840124164595, -0.17931454080153367, -0.4303569259623826, -0.34198022988025734, -0.272643289943742, -0.17787021628165314, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11015178028693899, 0.11015170967504287, 0.12339364437744882, 0.17242192065276327, 0.8393260929602239, -0.2672672672672672, 0.08973811573527377, -0.8078078078078075, 0.5415532425940752], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 2.7291431877026124e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 1.3519433067060354e-177, "x_opt_dim_5": [-4.0, -2.0, 3.46659398219448e-89, 2.0, 4.0]}
{"id": "409e51c5-4ed9-4633-9dfa-6264d5d5ac66", "fitness": 1.0, "name": "landscape_separable_centered_cosine_well_improved", "description": "A novel fully separable additive landscape with per-dimension centers and cosine-based ruggedness. Each dimension contributes an independent 1D subproblem with a quadratic well centered at a dimension-specific optimum plus a cosine modulation to introduce nonlinearity, while preserving separability. The global optimum is at x = c with f(x) = 0. Centers are spread across [-4, 4] using a slight nonlinear spacing to enhance diversity between subproblems, and per-dimension scaling and modulation parameters are varied to boost independence among dimensions.", "code": "import numpy as np\n\nclass landscape_separable_centered_cosine_well_improved:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        if self.dim == 1:\n            self.c = np.array([0.0])\n            self.w = np.array([1.0])\n            self.a = np.array([0.15])\n            self.b = np.array([0.75])\n        else:\n            # Center positions spread across [-4, 4] with a slight nonlinear spacing to decorrelate dimensions\n            r = np.arange(self.dim) / (self.dim - 1)\n            self.c = -4.0 + 8.0 * (np.power(r, 1.1))  # centers in [-4, 4]\n            # Per-dimension quadratic weight (slightly different across dimensions)\n            self.w = 0.9 + 0.2 * r  # in [0.9, 1.1]\n            # Per-dimension cosine modulation amplitude\n            self.a = 0.14 + 0.32 * r  # in [0.14, ~0.46]\n            # Per-dimension modulation frequency\n            self.b = 0.6 + 0.6 * r  # in [0.6, ~1.2]\n\n        # Ensure numpy arrays\n        self.c = np.asarray(self.c, dtype=float)\n        self.w = np.asarray(self.w, dtype=float)\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}\")\n        delta = x - self.c\n        quad_term = self.w * (delta ** 2)\n        ripple_term = self.a * (1.0 - np.cos(self.b * delta))\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_centered_cosine_well_improved scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e8defcbd-c9e5-4059-8135-0024fdb8cf81"], "operator": null, "metadata": {"ela_features_2D": [0.9052313719751981, 0.3736276620597748, 0.4654243087480725, 0.5751219236649223, 1.2356618840344775, 0.9052451506383216, 0.9999200381790887, 1.2353895994251887, 0.9999442096985725, 0.5557434926163373, -0.3358629201222347, 1.4, 0.7140066864789548, 0.723133912085163, 0.5697022773885686, 0.33677382202905654, -0.10489507353364096, 0.16029307577223895, 0.24297623648299066, 0.33436218879454604, 0.5204567279879914, 0.16432741454293182, 0.24434251783032207, 0.336819558509562, 0.5144946731218905, -0.4393947232574836, -0.3961329521669632, -0.3483190980648911, -0.25094213401178533, -0.42925066031799053, -0.3881534877994956, -0.3406616026263463, -0.24940744048807445, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5173705527176825, 0.5172233581615036, 0.5931173226458021, 0.6443285575076575, 0.6995964153754878, 0.1411411411411411, 0.3124820062435695, -0.36736736736736725, 0.37269076305220883], "score_Separable_2D": 1.0, "ela_features": [0.8330687782350144, 0.3801936385868212, 0.021178569307655538, 0.40869119091720335, 20.54993464982781, 0.8338172468185263, 0.9998767418643718, 1.2333053903449855, 0.9999313303515647, 0.41701106102211527, -0.2424273776321165, 1.4, 0.8903935641308095, 0.8702851563162872, 0.6365011534333658, 0.18588363716311238, -0.30080552133150384, 0.45257551700809506, 0.5472932714136955, 0.6310880576347373, 0.7557690103768594, 0.4563138288430292, 0.5440567206537309, 0.6285406200492913, 0.7533024748132104, -0.48158328259862426, -0.39825828392563456, -0.32454155741541885, -0.214855046537399, -0.480877300926389, -0.40327664936661645, -0.3285521130724711, -0.21819930436904772, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21585315101284497, 0.21588395851957226, 0.2549573479234482, 0.3201665845567941, 0.8060190188052048, -0.05105105105105105, 0.15651629874909198, -0.5675675675675673, 0.48173076923076924], "score_Separable_5D": 1.0, "ela_features_10D": [0.8012017820352589, 0.3935972027283659, 0.013179263799635906, 0.2593789535352898, 22.197057826149216, 0.8021703319765618, 0.9998561208417198, 1.2363046294560411, 0.9999102038880217, 0.31931447642808214, -0.07231572391672633, 1.6, 0.9794404754701637, 0.9326407909652474, 0.7004426900759697, 0.10760610579479883, -0.42648039678441857, 0.6647793003472506, 0.726417930169657, 0.7824076065805536, 0.8595244308348097, 0.6673065313406805, 0.728215718559135, 0.7837894363811753, 0.8606579858254436, -0.4251713965138473, -0.346992555271101, -0.275979136678782, -0.1781695494600899, -0.4231644304199914, -0.3456911182718777, -0.27500517477510295, -0.17723364816008239, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10952373568367135, 0.10951599392939766, 0.12237213878404105, 0.17289801072475175, 0.8373086758378815, -0.2792792792792792, 0.09140373502898509, -0.8158158158158155, 0.544035228182546], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 2.4259050557356555e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.0, -2.2588988734077518, -0.2678680338527708, 1.8298499471784408, 4.0]}
{"id": "fdf5d4ea-1804-4106-9c10-adc7dc93359b", "fitness": 1.0, "name": "landscape_separable_attractor_ripple_improved_more_separable", "description": "A fully separable, purely quadratic landscape with per-dimension optima spread across [-5, 5], achieved by removing the ripple component to maximize separability. Each dimension is independent, enabling exact subproblem decomposition while preserving a unique global minimum at x = c.", "code": "import numpy as np\n\nclass landscape_separable_attractor_ripple_improved_more_separable:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Centers per dimension distributed across the domain [-5, 5]\n        if self.dim > 1:\n            self.c = -5.0 + (np.arange(self.dim) / (self.dim - 1)) * 10.0  # c_i in [-5, 5]\n        else:\n            self.c = np.array([0.0], dtype=float)\n        \n        # Per-dimension quadratic weights, increasing slightly with dimension index\n        self.w = 1.0 + 0.25 * np.linspace(0, 1, self.dim)  # in [1.0, 1.25]\n        \n        # Per-dimension ripple amplitudes are intentionally set to zero to maximize separability\n        self.A = np.zeros(self.dim, dtype=float)  # No ripple component\n        \n        # Per-dimension ripple frequencies (positive integers) kept for interface compatibility\n        self.k = np.arange(1, self.dim + 1)  # (1, 2, ..., dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        delta = x - self.c\n        # Purely separable quadratic term plus a zero ripple term\n        quad_term = self.w * (delta) ** 2\n        ripple_term = self.A * np.sin(2.0 * np.pi * self.k * delta) ** 2  # zeros due to A == 0\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_attractor_ripple_improved_more_separable scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c7f2a9bb-4f01-43d6-a65a-cf2fbaf19be9"], "operator": null, "metadata": {"ela_features_2D": [0.9374609111347674, 0.4120772658796074, 0.46883157114240526, 0.5906070712027663, 1.2600579763605668, 0.9373995984710776, 1.0, 1.248845680262192, 1.0, 0.4653826958388828, -0.4241234524817292, 1.6, 0.7063401091296018, 0.7061219988859951, 0.5707410063142969, 0.35253363258023934, -0.10428376299257884, 0.14819435754641944, 0.22696632545554518, 0.3120559458330584, 0.5145963127561178, 0.1411252226335776, 0.2181763966274377, 0.307101461790822, 0.505029974060099, -0.44563830072761074, -0.40442822241382165, -0.35991227225138267, -0.2539533765715202, -0.44148518236369705, -0.4018510078185827, -0.3561417928391331, -0.25443174003721286, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5194023115539681, 0.5193983902274258, 0.6050751834820908, 0.6546559500803061, 0.6884201524429523, 0.11311311311311308, 0.3238275880672577, -0.39539539539539525, 0.3357429718875502], "score_Separable_2D": 1.0, "ela_features": [0.8828668201324147, 0.4408219256782272, 0.00620733819779891, 0.4283577130142488, 108.99764090648144, 0.8832273955862672, 1.0, 1.2492275613117543, 1.0, 0.36606841350001523, -0.2697037559423934, 1.2, 0.8667807212799856, 0.8649463857165752, 0.6409224086515624, 0.18579197726901805, -0.2931991402876409, 0.47773991983298353, 0.5763983785275532, 0.6593992248109689, 0.7730120642753954, 0.4760713393039454, 0.5660487549564448, 0.6518384425690412, 0.7678855427669122, -0.4594579161864775, -0.3726605482354093, -0.29964331679871037, -0.19969316811264318, -0.4635588216481036, -0.383943885596714, -0.3080464433547744, -0.20537227818538278, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21500466513678015, 0.21498885666136242, 0.25097897099118904, 0.31969327967633954, 0.8060931973046394, -0.07507507507507509, 0.15943213846612841, -0.6076076076076073, 0.48173076923076924], "score_Separable_5D": 1.0, "ela_features_10D": [0.8574779329523394, 0.4557995501750344, 0.02567307340798864, 0.27620964121426983, 10.887620665135755, 0.8585313843144673, 1.0, 1.2497211486654323, 1.0, 0.2511768483977427, -0.13607035763763156, 1.4, 0.963317408513068, 0.9317101577140765, 0.7077367177818299, 0.10737875944597679, -0.4131498521058014, 0.6707945152601202, 0.7345471496273058, 0.7955898538376133, 0.8701049309121929, 0.6702946421053961, 0.7347343114450133, 0.7955834088502952, 0.8708907259287821, -0.41749999804168053, -0.33664910775716284, -0.2592337225042835, -0.16473335697919866, -0.419252848925914, -0.3373128996635072, -0.25993562150102595, -0.16417513949851759, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10921564535483386, 0.10922597765190815, 0.12308499634973498, 0.1751958981960861, 0.8318507112754924, -0.30730730730730726, 0.0898452232749998, -0.8358358358358355, 0.5305044035228181], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 4.507150478011496e-168, "x_opt_dim_5": [-5.0, -2.5, 2.0015883643883082e-84, 2.5, 5.0]}
{"id": "871598bc-c4c9-47d9-94cd-8327cfc5c4c1", "fitness": 1.0, "name": "landscape_separable_rugged_sine_parabola", "description": "A novel separable landscape with per-dimension quadratic basins offset from dimension-specific centers, modulated by a multiplicative sine term to introduce ruggedness. Each dimension is independent, ensuring perfect separability; the global minimum lies at x = a with f(x) = 0.", "code": "import numpy as np\n\nclass landscape_separable_rugged_sine_parabola:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters\n        self.a = np.zeros(self.dim)  # centers where each 1D landscape attains its minimum\n        self.w = np.zeros(self.dim)  # quadratic weights\n        self.s = np.zeros(self.dim)  # modulation amplitude for ruggedness (0 <= s_i <= 1)\n        self.t = np.zeros(self.dim)  # modulation frequency\n        \n        for i in range(self.dim):\n            # Centers spread across [-4, 4] for variety while staying well within bounds\n            self.a[i] = -4.0 + (8.0 * i) / float(max(1, self.dim - 1))\n            \n            # Quadratic weight grows modestly with dimension to create varying basins\n            self.w[i] = 0.2 + (1.0 * i) / float(max(1, self.dim - 1))  # ~0.2 .. ~1.2\n            \n            # Ruggedness amplitude, stays within [0.3, 0.9] to keep nonnegativity\n            self.s[i] = 0.3 + 0.6 * (i / float(max(1, self.dim - 1)))\n            \n            # Distinct frequencies per dimension to diversify local features\n            self.t[i] = 2.0 * np.pi * (1.0 + i / float(max(1, self.dim - 1)))\n    \n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        # Per-dimension rugged parabola with separable subproblems\n        d = x - self.a\n        # f_i(d) = w_i * d^2 * (1 + s_i * sin(t_i * d))\n        # This stays nonnegative because 0 <= 1 + s_i * sin(t_i * d) <= 1 + s_i <= 1.9 (for s_i <= 0.9)\n        # and d^2 >= 0, with f_i(0) = 0 ensuring the global minimum at x = a.\n        term = self.w * (d ** 2) * (1.0 + self.s * np.sin(self.t * d))\n        return float(np.sum(term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_rugged_sine_parabola scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e1d70b0a-5276-49bd-8503-e1bbcc6ca8bf"], "operator": null, "metadata": {"ela_features_2D": [0.5153670944660533, 0.4170964139736785, 0.08311916602046789, 0.5418805209722171, 6.786422229974839, 0.5151892651039155, 0.5809327379600635, 13.667456210331096, 0.5823912587053905, 1.6541906792755892, 2.10025264997589, 1.0, 0.38349560320672427, 0.5725419720253323, 0.3099826341144545, 0.4256986135339675, -0.33730532516518863, 0.17344917641839, 0.24410628485547928, 0.3653882388887513, 0.6352828666978874, 0.18036014458131402, 0.23772835027307115, 0.3487242913706733, 0.6113730609545542, -0.43224157244428785, -0.3953084077057274, -0.33188141679849836, -0.19073202185839264, -0.42032691045329357, -0.3909369052269256, -0.33403118624008804, -0.19932127409291506, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.53407761894127, 0.5340744415115347, 0.5371899757049214, 0.5745751406602534, 0.7234782157952481, 1.5265265265265269, 0.517402604876058, 0.2932932932932932, 0.6325301204819278], "score_Separable_2D": 1.0, "ela_features": [0.5006277277586783, 0.43952298376993815, 0.006316094658894976, 0.4030582323951898, 85.1385330151738, 0.5015604777852636, 0.5990127602877753, 69.55515008957467, 0.6025305444899324, 1.3689379525471632, 1.5836752385843282, 1.2, 0.6847354120834426, 0.8193941940665169, 0.4746599108735768, 0.22630780828189895, -0.3935774934118736, 0.5154666130206709, 0.611269826510856, 0.7059506058125238, 0.8376815644299931, 0.5160139304061938, 0.6068103646740719, 0.699952197740456, 0.833569690522047, -0.4261724694264094, -0.34190964327368906, -0.2586327918488692, -0.14276789427701567, -0.4279443712391382, -0.3476659237037493, -0.2653093464084594, -0.14716185934557055, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21594119501740278, 0.21592479705791284, 0.23017645749707277, 0.2844390550317509, 0.8121774198172413, 0.5255255255255254, 0.18379013911178507, -0.35935935935935925, 0.6163461538461539], "score_Separable_5D": 1.0, "ela_features_10D": [0.500860803495909, 0.5195149480333286, 0.01232901275952981, 0.2919959980318715, 25.46465790836209, 0.5024842936949048, 0.6141082144542064, 11.54249775334645, 0.6178755970509682, 1.0112620519994981, 0.9044301537155489, 1.8, 0.8332216341348273, 0.907988014667855, 0.585887052931404, 0.13079843025416163, -0.4480525265414748, 0.719091129884271, 0.7799692192280678, 0.8362669324117762, 0.9025945773777515, 0.7173814024686601, 0.7786122746444175, 0.8349928869894313, 0.9024338683314422, -0.3562503283423932, -0.2790449713603976, -0.20764755037283628, -0.1235301144058237, -0.35934683859314454, -0.2814941345647069, -0.20980662607829634, -0.12405466928993017, 0.9, 0.9, 0.8727272727272727, 0.909090909090909, 0.10912370413225961, 0.10912694975688611, 0.11472148233547011, 0.15503810027704973, 0.8450444923175567, 0.017017017017016987, 0.11276209322335093, -0.6836836836836835, 0.6207365892714172], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-0.5555555555555554, 3.8888888888888893], 2.6179912233445055], [1, [0.5555555555555554, 3.8888888888888893], 3.726422913221235], [1, [1.666666666666667, 3.8888888888888893], 4.755363989038856], [1, [-0.5555555555555554, 2.8757777777777678], 2.7680374478337733], [1, [0.5555955930205467, 2.877777376987959], 3.8764643487741877], [1, [1.666718185197869, 2.8777771141278956], 4.905408897470376], [1, [-0.555517133536919, 4.872000369096951], 2.708033560347557], [1, [0.5555748714428362, 4.872000093278064], 3.8164580071824528], [1, [1.666691862608822, 4.872000158715187], 4.84539927807096], [1, [3.7348888888889062, 3.8888888888888893], 8.393842878582735], [1, [3.7149812392647132, 2.8777980537267394], 8.570991370395188], [1, [3.7163630790748106, 1.875351091905265], 8.957151355657007], [1, [2.7317554501268764, 4.872000126045886], 6.453989438251656], [1, [2.7317070675779482, 3.9753904319878224], 6.36269079072129], [1, [1.666666666666667, -1.6246666666666665], 8.550404710863411], [1, [-2.3266666666666307, 3.8888888888888893], 0.4128083691431525], [1, [-2.328665905807488, 2.875832939881283], 0.5628545610257123], [1, [-2.3286653995586746, 4.873928818357281], 0.502854520540752], [2, [1.6924030139640482, -2.625348306254865], 9.930295509981427], [1, [3.7333864384008346, 4.84862223761828], 8.521027347766013], [2, [-0.44013420954762844, 1.8762390425850617], 2.797052180891078], [3, [-4.00000000000011, 3.8888888888888893], 0.0016840447746520406], [3, [-4.00000000000011, 2.8757777777777678], 0.15173026926391964], [3, [-4.00000000000011, 4.874000000000014], 0.09173025743278812], [1, [4.73598277073244, 1.8763960939061946], 11.24409598147114], [4, [-4.00000000000011, -1.6246666666666665], 3.796724766599208], [4, [-3.9460953343216247, -0.599570501709509], 3.6960756635125507], [1, [4.735995736148147, -2.623832424090273], 15.97230121932062], [1, [3.662914666247873, -0.6218219386151617], 11.316974845773132], [1, [4.685351310342043, -0.6227312964230961], 13.502976499334043], [1, [2.722527465854639, -0.623760660090452], 8.935528491571391], [1, [3.604032785247966, -2.6227429695290523], 14.736954483290106], [2, [0.5011537461921378, -1.6237993656637033], 7.842406750070946], [1, [4.7153633133099415, 2.8771235393167913], 10.893345425212967], [1, [3.6740677681516685, 0.37683235232606604], 10.218400118405114], [1, [4.673940412762228, 0.3781635788857995], 12.624286777706288], [1, [2.730291681765792, 2.8763894292631], 6.514074568173694], [4, [-3.9965090840491655, 1.8762095079294814], 0.5418234396716095], [1, [2.7301198017511883, -1.624778168207187], 10.15911406726719], [1, [4.731674332099977, -1.6245746930142078], 14.500979113772097], [5, [-4.00000000000011, 0.41955555555555524], 3.6524022047320424], [1, [3.6796919107354165, -1.6237549503734858], 12.39595571754548], [2, [-0.2823091156304964, -2.6247071134590603], 7.21873078726047], [1, [1.642605942403966, -0.6235084389900665], 7.445393071914738], [1, [4.698039300798305, 4.417121961555569], 10.878198402864593], [1, [4.728877440182284, 4.874895991396605], 10.799118581015268], [1, [2.730162416853143, 1.8767223409428917], 6.904533122088605], [2, [0.4750424975205265, -0.6213054087731943], 6.780479336819468], [10, [2.72989576169858, -4.004711340268753], 79.15830604689856], [10, [1.7541186157128317, -5.013618969467652], 87.18687789418155], [4, [-3.9747646838828667, -2.624171654529129], 5.268258823257849], [3, [1.6095815459668963, 0.3813320602038301], 6.709944080147411], [1, [1.6666105422396895, 1.8829205916806628], 5.315726278174956]], "nr_of_basins": 53, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 2.5110496154028714e-174, "x_opt_dim_5": [-4.0, -2.0, -1.89399412255947e-87, 2.0, 4.0]}
{"id": "565589e3-9566-41ef-b4a7-30fda7a89545", "fitness": 1.0, "name": "landscape_separable_centered_quartic_cosine_mixture", "description": "A novel fully separable landscape using per-dimension centered quartic wells with a cosine-based modulation that is always nonnegative. Each dimension contributes independently with a minimum at its center c_i, ensuring an overall global minimum of 0 at x = c.", "code": "import numpy as np\n\nclass landscape_separable_centered_quartic_cosine_mixture:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Dimension-dependent optima c_i spread across [-5, 5]\n        self.c = -5.0 + (10.0 * np.arange(self.dim) / max(self.dim - 1, 1))\n        \n        # Per-dimension quartic weight (adds a non-quadratic basin, varying with dim)\n        self.q = 0.08 + 0.12 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [0.08, ~0.2]\n        \n        # Per-dimension cosine modulation amplitude (nonnegative modulation)\n        self.r = 0.10 + 0.25 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [0.10, ~0.35]\n        \n        # Per-dimension cosine modulation frequency\n        self.s = 1.0 + 0.5 * (np.arange(self.dim) / max(self.dim - 1, 1))  # in [1.0, ~1.5]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        # z_i = x_i - c_i\n        diff = x - self.c\n        z2 = diff ** 2\n        z4 = diff ** 4\n        # cos modulation term: 1 - cos(s_i * z_i) is nonnegative for all z_i\n        cos_term = 1.0 - np.cos(self.s * diff)\n        # Per-dimension contribution: z^2 + q_i*z^4 + r_i*(1 - cos(s_i*z))\n        contrib = z2 + self.q * z4 + self.r * cos_term\n        return float(np.sum(contrib))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_centered_quartic_cosine_mixture scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1dffbfe8-2f30-46f3-8049-4d5df3643909"], "operator": null, "metadata": {"ela_features_2D": [0.7661451615301473, 0.40354005869119625, 0.26029144477682714, 0.6154669524479055, 2.3706835390776284, 0.7662089925295515, 0.9826982088086812, 2.3715617205319477, 0.9997270966979379, 1.1405975440546006, 0.5297431292959696, 1.2, 0.722123732975539, 0.7202341318298411, 0.5722734251948378, 0.33852438858825884, -0.12491590969773463, 0.16543702786797118, 0.22756880015027853, 0.3205610003929912, 0.4983574483815604, 0.1659895861509489, 0.22706185096407538, 0.31575592691083804, 0.4963836009771244, -0.43662121713685587, -0.40411501553644413, -0.35546451594319595, -0.262443960923084, -0.4283549860387388, -0.39698499744443844, -0.35143352165041664, -0.2586678713035787, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5157306801117275, 0.5157277255406953, 0.5866474504433337, 0.6316815376441326, 0.5913040398795107, 0.40540540540540526, 0.19526285385928632, -0.4794794794794794, 0.3393574297188755], "score_Separable_2D": 1.0, "ela_features": [0.7540853266496758, 0.4013293421099443, 0.009874410204300275, 0.5122933068429877, 545.5411590049123, 0.7545843084413241, 0.9796947571137931, 8.92352692135226, 0.9994033973489216, 1.0564079325258764, 0.5765535149045411, 1.2, 0.8716233811655825, 0.867082472936113, 0.6437450325676588, 0.1838777418347962, -0.2990494000964739, 0.45971769463600587, 0.5645404586589698, 0.6480093435603218, 0.7698531614846248, 0.4560911315274372, 0.5585821893513131, 0.6361668033073915, 0.764639018013668, -0.4752166946619221, -0.38301688810272355, -0.30959958260962717, -0.20242859144250555, -0.4808727221737897, -0.3902557241199573, -0.3216621474352017, -0.20807711439505683, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21698666493426275, 0.2169942376849653, 0.25167558859529293, 0.3112724164507144, 0.7637327913901368, 0.1451451451451451, 0.11119805721410406, -0.6396396396396394, 0.4926282051282052], "score_Separable_5D": 1.0, "ela_features_10D": [0.7398943201455435, 0.49704335919848647, 0.01284849411365983, 0.3989007769917233, 44.491383812870396, 0.7402904098798151, 0.976830196241757, 9.143226714042164, 0.9991577207197156, 0.775049931555812, 0.2678613067035265, 1.0, 0.958657168527244, 0.9296700992975218, 0.6887162281596598, 0.11007060529851982, -0.4132993934380986, 0.6821381947215485, 0.7490957737753453, 0.7995415290624799, 0.8688082360758156, 0.6814692389496413, 0.7491011857489113, 0.7996102417938424, 0.8693448612000374, -0.40314327310278575, -0.31822089536381765, -0.2542406504300013, -0.16638988082874753, -0.4050587686136472, -0.3190541490866878, -0.2548237560504163, -0.16614655489551775, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.1096049234753782, 0.10960174683780877, 0.1271792608396713, 0.17000386949040314, 0.8288331849508991, -0.11911911911911907, 0.08750874181940842, -0.7837837837837835, 0.5518014411529223], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 1.045805270807565e-166, "x_opt_dim_5": [-5.0, -2.5, 1.0226462099903196e-83, 2.5, 5.0]}
{"id": "dd2bcf49-4505-4acc-86cf-c1b1aea2f5aa", "fitness": 1.0, "name": "landscape_separable_quartic_cosine", "description": "A novel separable landscape with per-dimension quartic and quadratic wells around deterministic centers, augmented by a cosine-based modulation to introduce ruggedness while preserving separability. The global minimum is at x = c with f(x) = 0, and each dimension forms an independent 1D subproblem.", "code": "import numpy as np\n\nclass landscape_separable_quartic_cosine:\n    \"\"\"\n    A novel separable, additive landscape where each dimension has:\n      - a quartic well centered at c_i\n      - a quadratic term around the same center\n      - a cosine modulation to introduce ruggedness\n    Centers c_i are deterministically placed in [-5, 5], and for each i a cosine term\n    ensures f_i(c_i) = 0. The global optimum is at x = c with f(x) = 0.\n    The function is fully separable: f(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers c_i in [-5, 5]\n        self.c = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = i / float(max(1, self.dim - 1))\n            self.c[i] = -5.0 + 10.0 * t  # linearly spread from -5 to 5\n\n        # Quartic weights a_i (positive, varying per-dimension)\n        self.a = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.a[i] = 0.04 + 0.06 * ((i % 6) / 5.0)  # in [0.04, ~0.10]\n\n        # Quadratic weights b_i (positive, varying per-dimension)\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.b[i] = 0.5 + 0.3 * ((i % 4) / 3.0)  # in [0.5, ~0.8]\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.A[i] = 0.2 + 0.3 * ((i % 5) / 4.0)  # in [0.2, ~0.5]\n\n        # Cosine frequencies omega_i chosen per-dimension\n        self.omega = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.omega[i] = 0.4 + 0.6 * ((i % 6) / 5.0)  # in [0.4, ~1.0]\n\n        # Ensure numpy arrays for convenient vectorized operations\n        self.c = np.asarray(self.c)\n        self.a = np.asarray(self.a)\n        self.b = np.asarray(self.b)\n        self.A = np.asarray(self.A)\n        self.omega = np.asarray(self.omega)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        # Per-dimension: f_i(x_i) = a_i*(x_i - c_i)^4 + b_i*(x_i - c_i)^2 + A_i*(1 - cos(omega_i*(x_i - c_i)))\n        diff = x - self.c\n        quartic_term = self.a * (diff ** 4)\n        quadratic_term = self.b * (diff ** 2)\n        cos_term = self.A * (1.0 - np.cos(self.omega * diff))\n\n        return float(np.sum(quartic_term + quadratic_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_quartic_cosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.7729317271128661, 0.29537482734030146, 0.4015166990849872, 0.5134163345852077, 1.2795699539251761, 0.7754446196597848, 0.9840809833533788, 1.2953752825203622, 0.9997376680747718, 0.9556559277135317, 0.3728981469583167, 1.4, 0.6988549816127156, 0.7128483587765542, 0.5667183012475823, 0.3416830536238658, -0.1268195764523085, 0.1510758521391776, 0.23517977437757018, 0.33802041472516253, 0.5104403096208664, 0.1509895556893969, 0.23327528362163727, 0.3387954476145077, 0.5081577910078934, -0.44432773292671934, -0.40030599406386946, -0.3464779925158906, -0.25623142939222154, -0.4364767504071101, -0.3941702880604209, -0.33992008880637015, -0.25284682813219994, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5167361623899189, 0.5167249568498292, 0.5722183435202943, 0.625010626232796, 0.6150657989434709, 0.3213213213213212, 0.289439749064616, -0.4594594594594593, 0.3610441767068273], "score_Separable_2D": 1.0, "ela_features": [0.7488223337806241, 0.4152392196517818, 0.00464018454803041, 0.500562965628831, 131.7314860517143, 0.7499364773277662, 0.9795987322364985, 7.379270777433858, 0.9994048244540691, 0.9526780588215729, 0.3384565013213504, 1.4, 0.8862075541850103, 0.870906446733744, 0.6509729891274117, 0.1811655365879224, -0.3048650538583426, 0.47293993921402355, 0.5720012435538724, 0.6552429667390254, 0.7744432812548343, 0.46731956476790587, 0.5646913598036752, 0.6488665631896131, 0.7700506658571296, -0.4636008404848323, -0.3764663479996818, -0.3032465665122167, -0.19839847086177448, -0.47085022847658786, -0.38477900015340355, -0.3103744844657931, -0.20325636689718546, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21464467938284412, 0.21462364868834896, 0.2499308385806179, 0.310226908992131, 0.7703748153722304, 0.1371371371371371, 0.12019445264372548, -0.6196196196196194, 0.4907051282051282], "score_Separable_5D": 1.0, "ela_features_10D": [0.7449261576999777, 0.3915736612314662, 0.015861064390873043, 0.3595322875776084, 26.852357821459048, 0.7454200693335687, 0.977291645505991, 6.3492339665716875, 0.998965904915371, 0.6846203615300248, 0.1789298764016885, 1.0, 0.9550799041742455, 0.9305839732912222, 0.6922675315764211, 0.10940453847492293, -0.418460734114763, 0.6721863132478086, 0.7435099792988392, 0.7940926839403823, 0.8688431272261387, 0.6730481646246609, 0.7437720004500749, 0.7948892560322045, 0.8691954944501719, -0.41575422501509635, -0.32529673731755787, -0.26114383993677603, -0.16634126132143406, -0.4157751954394893, -0.3258376601295111, -0.26083181056431826, -0.1663400200319492, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11001731931361025, 0.11001230728967107, 0.12581370266572028, 0.17101725885107047, 0.8322902099485725, -0.1511511511511511, 0.09132725173349712, -0.7757757757757756, 0.5566853482786229], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 9.192090044345605e-169, "x_opt_dim_5": [-5.0, -2.5, 1.1459300679451608e-84, 2.5, 5.0]}
{"id": "04184247-b859-445c-90c2-1baf2b461303", "fitness": 1.0, "name": "landscape_centered_wells_separable_adv", "description": "A novel, fully separable benchmark with per-dimension quadratic wells centered at deterministic centers and phase-anchored cosine modulation to induce ruggedness while preserving subproblem separability. Each dimension is independent, enabling exact block-wise optimization.", "code": "import numpy as np\n\nclass landscape_centered_wells_separable_adv:\n    \"\"\"\n    A novel separable, additive landscape with:\n      - per-dimension quadratic well centered at deterministic m_i in [-5, 5]\n      - per-dimension cosine modulation anchored at (x_i - m_i) to preserve a zero minimum at m_i\n    The global optimum is at x = m with f(x) = 0. The function is strictly decomposable into\n    independent 1D subproblems, enabling straightforward block-wise optimization.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i spread linearly in [-5, 5]\n        self.m = np.zeros(self.dim, dtype=float)\n        if self.dim == 1:\n            self.m[0] = 0.0  # center at 0 for 1D case\n        else:\n            for i in range(self.dim):\n                t = i / float(self.dim - 1)\n                self.m[i] = -5.0 + 10.0 * t\n\n        # Quadratic weights w_i in [0.2, 0.8], increasing slightly with i\n        self.w = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.w[i] = 0.2 + 0.6 * (i / float(max(1, self.dim - 1)))\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # deterministic pattern across dimensions\n            pattern = (i % 4) / 4.0  # 0.0, 0.25, 0.5, 0.75\n            self.A[i] = 0.4 + 1.0 * pattern  # range [0.4, 1.4)\n\n        # Per-dimension frequencies for the cosine term\n        # Use phase anchored at the center: cos(b_i*(x_i - m_i))\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # Choose frequency to yield diverse local ruggedness while keeping values moderate\n            base = (i % 4) + 1\n            self.b[i] = 2.0 * np.pi * base / max(1.0, self.dim)\n\n        # Ensure arrays are numpy arrays\n        self.m = np.asarray(self.m)\n        self.w = np.asarray(self.w)\n        self.A = np.asarray(self.A)\n        self.b = np.asarray(self.b)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        # Per-dimension: f_i(x_i) = w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i*(x_i - m_i)))\n        diff = x - self.m\n        quad_term = self.w * (diff ** 2)\n        cos_term = self.A * (1.0 - np.cos(self.b * diff))\n\n        return float(np.sum(quad_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_centered_wells_separable_adv scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.9382724661169368, 0.6534495266982192, 0.21153602098390975, 0.8213560410174493, 3.893914044994053, 0.9382318336312329, 0.9995203536900528, 4.049252932568633, 0.9995187007753243, 0.5969607485950508, -0.7603826211808461, 1.6, 0.6269038341639815, 0.7055453935788514, 0.5298132486168756, 0.33976258268426157, -0.09982145184726529, 0.20446655330862124, 0.26273433731808915, 0.3458241247191678, 0.554465416093733, 0.20023212429171036, 0.24684473642101362, 0.327392978118904, 0.5184668868854447, -0.41638446969172727, -0.3858749151007278, -0.34238990118686274, -0.2331899345225103, -0.4113971575439187, -0.3874212298303379, -0.3459825750670319, -0.2476918268873623, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5121619766602038, 0.5120841784188539, 0.6346401737467471, 0.6605749270200043, 0.6954297033755925, 0.22922922922922914, 0.25918996168214026, -0.37137137137137133, 0.3714859437751004], "score_Separable_2D": 1.0, "ela_features": [0.8916558212780131, 0.6442585270280055, 0.00636041591688114, 0.5832988892702906, 228.0301103501443, 0.8918077812269342, 0.9981086820170997, 4.145307296793981, 0.998101394806669, 0.44415831458244676, -0.5458797964489075, 1.0, 0.8636925091019615, 0.8672523553881915, 0.6394945399064975, 0.18504765238007412, -0.278026771100339, 0.4999893743214793, 0.5920599535426886, 0.6749796134285146, 0.7967694131730582, 0.49844683907142573, 0.5846709974254465, 0.6676704306379619, 0.7902494347528178, -0.43982120620380993, -0.35883216820899955, -0.2858958397424183, -0.1787663509988831, -0.443497581766799, -0.36725102883547145, -0.29386183438240526, -0.18547166964937972, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21693577324189595, 0.21695130663892986, 0.26551441327623887, 0.32495172980982034, 0.7999257753225555, -0.02702702702702704, 0.1518906547621035, -0.5915915915915914, 0.4793269230769231], "score_Separable_5D": 1.0, "ela_features_10D": [0.8684113497563344, 0.6950174904336573, 0.025815609158406045, 0.38977182558841716, 15.403329306865405, 0.868522508294317, 0.9978283758186425, 4.80659091404438, 0.9979340726313634, 0.3578116022237014, -0.22503034208391703, 1.0, 0.9483994690416757, 0.9297000386615852, 0.7010158073227019, 0.10935239078377879, -0.4038710621479735, 0.6934054033311339, 0.7542164953800017, 0.8002872479241558, 0.8728738839236243, 0.696766795789776, 0.7545198709396009, 0.8003773045189571, 0.8729597193961889, -0.38877023458306387, -0.311660639314563, -0.2532415589165378, -0.1611990831398225, -0.38543543289468574, -0.31202639807557014, -0.25373775402411064, -0.16147790665588274, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10987337109798231, 0.10986714784172488, 0.12808748311918106, 0.1758038095206303, 0.835070449038902, -0.25525525525525516, 0.09563200253878985, -0.7997997997997995, 0.5379503602882305], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [-5.0, 5.0], 0.0], [2, [-5.0, 4.06088888888887], 0.752534843159804], [16, [-4.998223371091964, 3.1306962491834622], 3.00256554894198], [8, [-3.19541221340067, 4.0624855183673585], 1.4769480530446821], [8, [-3.1953333333332044, 5.0], 0.7243455056185663], [64, [-3.1957815241578706, 3.1307288373048334], 3.7269053163600034]], "nr_of_basins": 6, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 2.7635834073200395e-170, "x_opt_dim_5": [-5.0, -2.5, 2.3509927296017058e-85, 2.5, 5.0]}
{"id": "a116cef5-757e-4632-912c-64b89c422c43", "fitness": 1.0, "name": "landscape_quartic_cosine_separable", "description": "A novel separable landscape using per-dimension quartic wells centered at deterministically chosen centers with a cosine modulation. Each dimension contributes an independent 1D subproblem f_i(x_i) = w_i*(x_i - m_i)^4 + A_i*(1 - cos(b_i*(x_i - m_i))). The global minimum is at x = m with f(x) = 0, ensuring perfect separability and independent subproblems.", "code": "import numpy as np\n\nclass landscape_quartic_cosine_separable:\n    \"\"\"\n    A novel separable landscape with per-dimension quartic wells centered at deterministic centers m_i,\n    plus a cosine modulation to introduce ruggedness while preserving separability.\n    For each dimension i:\n      f_i(x_i) = w_i*(x_i - m_i)^4 + A_i*(1 - cos(b_i*(x_i - m_i)))\n    The global minimum occurs at x = m with f(x) = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i in [-5, 5], phase-shifted relative to a simple grid\n        self.m = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = (i + 0.5) / float(self.dim)\n            # Use a sinusoidal offset to place centers in [-5,5] in a non-uniform but deterministic way\n            self.m[i] = -5.0 + 10.0 * (0.5 + 0.5 * np.sin(2.0 * np.pi * t))\n\n        # Per-dimension quartic weights w_i (positive, small to keep values manageable)\n        self.w = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # Deterministic pattern across dimensions\n            self.w[i] = 0.001 + 0.009 * ((i % 7) / 6.0)  # range ~[0.001, 0.01]\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.A[i] = 0.2 + 1.3 * ((i % 5) / 4.0)  # range ~[0.2, 1.5]\n\n        # Cosine frequencies b_i tuned to vary per-dimension modulation\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # Use a few distinct frequencies across dimensions\n            self.b[i] = 2.0 * np.pi * ((i % 6) + 1) / max(self.dim, 6)\n\n        # Ensure numpy arrays for vectorized operations\n        self.m = np.asarray(self.m)\n        self.w = np.asarray(self.w)\n        self.A = np.asarray(self.A)\n        self.b = np.asarray(self.b)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape on a 1D numpy array x of length dim.\n        Returns a scalar value f(x) = sum_i [ w_i*(x_i - m_i)^4 + A_i*(1 - cos(b_i*(x_i - m_i))) ].\n        The global minimum is at x = m with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        diff = x - self.m\n        quad_term = self.w * (diff ** 4)\n        cos_term = self.A * (1.0 - np.cos(self.b * diff))\n\n        return float(np.sum(quad_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_quartic_cosine_separable scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.7511210484182684, 0.05391051343579285, 0.24779452374403999, 0.6043865310409056, 2.4380387553402327, 0.7515004636044926, 0.9754102195644292, 2.41249926111995, 0.9974330632049518, 1.1639421034486723, 0.6204483823482931, 1.4, 0.5507714273605442, 0.6947539475075953, 0.4662735267135287, 0.3459630928573619, -0.11948968194187493, 0.35721769651783336, 0.41198621155143156, 0.4644112135170621, 0.5181669627325005, 0.42203558819118464, 0.45060479530254655, 0.48447244480602736, 0.5060147031751013, -0.336501704084727, -0.3078306832355787, -0.2803862089763223, -0.2522475490295323, -0.29726861214569905, -0.2826239199493384, -0.26521857139358224, -0.2541352814070034, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5123378433295992, 0.5122843445323713, 0.5749073404865449, 0.6234629641963445, 0.6546887782803524, 0.4494494494494493, 0.15473918409419796, -0.4874874874874873, 0.36265060240963853], "score_Separable_2D": 1.0, "ela_features": [0.721326407567979, 0.04815830805799812, 0.004549259211447493, 0.4763072525900124, 275.2575501714675, 0.7222993917837861, 0.9618989699822791, 13.67553204538151, 0.9901291759887059, 0.9978560649730468, 0.5158019591589296, 1.0, 0.7924101358455464, 0.8543370600058646, 0.5663658438603583, 0.19733368097903875, -0.2959427083897162, 0.5966020413968749, 0.6487384096332244, 0.69770646001478, 0.782499270930035, 0.5831361907399059, 0.6356137643120879, 0.686847939617853, 0.7737608633884544, -0.354829982305588, -0.30897523788106673, -0.26589964685033773, -0.19131507097210274, -0.36862328760586627, -0.3222197201405218, -0.2769076297338381, -0.2000536508773131, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21715209494565962, 0.21717078430450693, 0.2543727700893398, 0.3113144252354135, 0.79019471233035, 0.16916916916916913, 0.1323887464031089, -0.5875875875875873, 0.5248397435897436], "score_Separable_5D": 1.0, "ela_features_10D": [0.7110799995887703, 0.28600009461311104, 0.012173350779184813, 0.3615643301684949, 42.219833111175646, 0.7114634161082524, 0.9605534470712153, 24.965391929762838, 0.9917046788133721, 0.7999347541894191, 0.3653820412413394, 1.2, 0.9246604942141954, 0.9271102907444216, 0.6707253913057107, 0.11220149726286732, -0.41673207659777745, 0.7194757329281681, 0.7594508968170668, 0.8054532008690394, 0.8746880661360779, 0.7170180601202226, 0.759531088089808, 0.8050199889386309, 0.8749232264196202, -0.3557792233070796, -0.3050796669844164, -0.2467370537818821, -0.15892937960017947, -0.35989686830673084, -0.3058268795914395, -0.24797524107314467, -0.15907395183374184, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11025656258600076, 0.11025614054685873, 0.12336746334897315, 0.16750486701751377, 0.8326209209268528, -0.11511511511511507, 0.09694268591776868, -0.7677677677677676, 0.5612489991993594], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [5.0, -5.0], 0.0], [80, [5.0, -2.1057777777778517], 0.18824625167171338]], "nr_of_basins": 2, "f_opt_dim_2": 0.0, "x_opt_dim_2": [5.0, -5.0], "f_opt_dim_5": 0.042197817202766004, "x_opt_dim_5": [2.9389262674113104, 4.755282578842269, -2.2721773627724812e-09, -3.2588585022692835, -1.7400993796822937]}
{"id": "b28569bc-a6e7-47d0-9776-0695b2577c22", "fitness": 1.0, "name": "landscape_separable_centered_quartic_cosine_dx", "description": "A novel separable landscape with per-dimension centered quartic wells and a dx-based cosine modulation, guaranteeing a global minimum at deterministic centers m_i. Each dimension is independent, making it fully separable and suitable for subproblem optimization.", "code": "import numpy as np\n\nclass landscape_separable_centered_quartic_cosine_dx:\n    \"\"\"\n    A strictly separable additive landscape where each dimension has:\n      - a centered quartic well around m_i\n      - a quadratic term around the center\n      - a dx-dependent cosine modulation to introduce ruggedness while preserving separability\n    The centers m_i are deterministically placed in [-5, 5], and the cosine term uses\n    (x_i - m_i) as its argument, ensuring f_i(m_i) = 0. The global minimum is at x = m with f(x) = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i in [-5, 5]\n        self.m = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = i / float(max(1, self.dim - 1))\n            self.m[i] = -5.0 + 10.0 * t  # linearly spread from -5 to 5\n\n        # Quadratic weights w_i (positive, increasing with i for variety)\n        self.w = 0.25 + 0.75 * (np.arange(self.dim) / max(1, self.dim - 1))  # in [0.25, 1.0]\n\n        # Quartic coefficients a_i (positive, small so the landscape is smooth but with higher-order well)\n        self.a = 0.01 + 0.09 * (np.arange(self.dim) / max(1, self.dim - 1))**2  # in [0.01, ~0.1]\n\n        # Cosine modulation amplitudes c_i (positive)\n        self.c = 0.2 + 0.6 * (np.arange(self.dim) / max(1, self.dim - 1))  # in [0.2, ~0.8]\n\n        # Cosine frequencies d_i chosen to vary per dimension (dx = x_i - m_i)\n        # Use a few distinct frequencies to create diverse local features\n        self.d = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            N = (i % 3) + 1  # 1, 2, or 3\n            self.d[i] = (2.0 * np.pi * N) / 5.0  # roughly 2\u03c0/5, 4\u03c0/5, 6\u03c0/5\n\n        # Ensure numpy arrays for vectorized operations\n        self.m = np.asarray(self.m)\n        self.w = np.asarray(self.w)\n        self.a = np.asarray(self.a)\n        self.c = np.asarray(self.c)\n        self.d = np.asarray(self.d)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        dx = x - self.m\n        # Per-dimension components:\n        # f_i(dx) = w_i * dx^2 + a_i * dx^4 + c_i * (1 - cos(d_i * dx))\n        quad_term = self.w * (dx ** 2)\n        quartic_term = self.a * (dx ** 4)\n        cos_term = self.c * (1.0 - np.cos(self.d * dx))\n\n        return float(np.sum(quad_term + quartic_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_centered_quartic_cosine_dx scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.7750110959915976, 0.5571403302843166, 0.09264455838471024, 0.7620570540008431, 8.445689802840382, 0.7750448182090932, 0.9834461271433922, 9.593959662719055, 0.9997544912741485, 1.286583918885995, 0.5753941968460615, 1.0, 0.6855202688585819, 0.7139798273949729, 0.5633145993861135, 0.3396313363873353, -0.10751973657214371, 0.15179795618224978, 0.25128597032887806, 0.3556964898087511, 0.5402726284390836, 0.14259652195595554, 0.23630579522745965, 0.3421327955275707, 0.5181286288226828, -0.4436671379020713, -0.3916283265025669, -0.3370141667113661, -0.2404691428290489, -0.44040699510402537, -0.3922736195009801, -0.33790770705816564, -0.24751103889458514, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5161778003855068, 0.5160584310480228, 0.6040152245368471, 0.6295143851342545, 0.5853187956389264, 0.4734734734734733, 0.09234833205937464, -0.5995995995995994, 0.35622489959839354], "score_Separable_2D": 1.0, "ela_features": [0.7694032636802832, 0.5907669585438289, 0.012706838817172144, 0.6925078587328867, 136.31952959390918, 0.7693230816148718, 0.9824059750238895, 14.043994395457739, 0.9996204598247189, 1.2129884366569983, 0.49215958360743695, 1.2, 0.8707758862163286, 0.8667347314708198, 0.6481105676088308, 0.18509470348819484, -0.27185063896285494, 0.47978582099878614, 0.5737667071545516, 0.6649030408648788, 0.7865440902088608, 0.46943056040566544, 0.5671414021312344, 0.6558881038792671, 0.7794389610115504, -0.4576624146619017, -0.374978747384369, -0.29479928721113036, -0.18778807365640024, -0.469418661730749, -0.38295522208798793, -0.30443506620461463, -0.1951327223941708, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21260387937088474, 0.2125894854447617, 0.2757166145654224, 0.3129514273906173, 0.734378647997327, 0.26126126126126115, 0.0789632723751769, -0.6996996996996995, 0.4831730769230769], "score_Separable_5D": 1.0, "ela_features_10D": [0.7611135963521154, 0.617397139561007, 0.0063268365046292045, 0.47570446927904825, 85.27889874615546, 0.7623472025087497, 0.9806015634898951, 15.295431324089162, 0.9995276019954209, 0.9686976972721867, 0.38620396823300257, 1.2, 0.9361540649102207, 0.9276332875761915, 0.6923768597641125, 0.11042976154247792, -0.38153306057953973, 0.6923216836052237, 0.7538338743494883, 0.8064862516783518, 0.8820159970412231, 0.692673592119177, 0.7542778757162717, 0.807083602214594, 0.8822913678663031, -0.39022930334857614, -0.31221302570777154, -0.24543373480450223, -0.14963913571652987, -0.39082322081663035, -0.31248037115397775, -0.24532762198403288, -0.149687086494576, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.1106790605599925, 0.11067968853400192, 0.12991796033879335, 0.17157473599924528, 0.7945670697448447, -0.08308308308308307, 0.06669032935679617, -0.8038038038038036, 0.5395516413130504], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 2.323661159529015e-175, "x_opt_dim_5": [-5.0, -2.5, -6.097423927566808e-88, 2.5, 5.0]}
{"id": "b0505853-5ef2-490d-8c8b-72fbd042ea57", "fitness": 1.0, "name": "landscape_separable_centered_quadratic_sine_ripple", "description": "A novel separable benchmark where each dimension has its own centered quadratic well around a distinct per-dimension center, combined with a per-dimension sinusoidal ripple. The global minimum is at x = c with f(x) = 0, and dimensions are completely decoupled, enabling independent subproblem optimization.", "code": "import numpy as np\n\nclass landscape_separable_centered_quadratic_sine_ripple:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension centers distributed evenly across [-4, 4]\n        if self.dim == 1:\n            self.c = np.array([0.0])\n        else:\n            self.c = -4.0 + 8.0 * (np.arange(self.dim) / (self.dim - 1))\n        # Quadratic well weights (slightly increasing across dimensions)\n        self.w = 0.4 + 0.6 * (np.arange(self.dim) / max(self.dim - 1, 1))  # [0.4, ..., 1.0]\n        # Ripple amplitudes per dimension\n        self.A = 0.05 + 0.35 * (np.arange(self.dim) / max(self.dim - 1, 1))  # [0.05, ..., 0.40]\n        # Ripple frequencies per dimension (distinct across dims)\n        self.B = 1.0 + 0.25 * np.arange(self.dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        diff = x - self.c\n        quad_term = self.w * (diff ** 2)\n        ripple_term = self.A * np.sin(self.B * diff) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_centered_quadratic_sine_ripple scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["744f259a-3622-4c7d-9d2f-909e52217cf4"], "operator": null, "metadata": {"ela_features_2D": [0.9037412207748989, 0.5349178623452759, 0.30002277423174567, 0.7377402927621943, 2.462104982645264, 0.9045165840741387, 0.9999707703473323, 2.5099708052648935, 0.9999713217311939, 0.6790468576667686, -0.48020401535156687, 1.0, 0.709784216027932, 0.7130974370773484, 0.5486506397543025, 0.34565007948518056, -0.1043574803660832, 0.16228835605072034, 0.22339805875581456, 0.32796703177234526, 0.5262069757996363, 0.16303991505144982, 0.22361069185575005, 0.32011502464712543, 0.516575816014656, -0.43798789348559525, -0.4060404998463774, -0.35136541150152906, -0.24771423584529528, -0.4293240892589581, -0.3982712957933232, -0.34875777139919634, -0.24796587825127955, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5241797392806725, 0.5241316209112091, 0.6137453508972998, 0.6496984814343975, 0.6528696220666267, 0.20120120120120114, 0.2718382758982526, -0.38738738738738726, 0.34899598393574294], "score_Separable_2D": 1.0, "ela_features": [0.8378223654511624, 0.557417755729429, 0.0047578188668123845, 0.5304855267453115, 140.28403659909495, 0.8385341474688792, 0.999955405557351, 2.5072692285262392, 0.9999554117904179, 0.5088283743011822, -0.340799449479232, 1.0, 0.8821632980936333, 0.8690833982779587, 0.6374696491035928, 0.18398767990872886, -0.2922522459825885, 0.45376234302005497, 0.5448436475592825, 0.6302983381727071, 0.7638679191372191, 0.45271806216585747, 0.5438350228943126, 0.6276341688794276, 0.7601252404653681, -0.4804658024135004, -0.4003518704726871, -0.3251859822434076, -0.20769955747108976, -0.48399867656644463, -0.40342173982753005, -0.3293095125731945, -0.2121376270796011, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21553582810821764, 0.21552522834878157, 0.2596049203306861, 0.31899203876444393, 0.8069885504222061, -0.015015015015015024, 0.15782523802490955, -0.5915915915915914, 0.4875], "score_Separable_5D": 1.0, "ela_features_10D": [0.8013326484942669, 0.6018550136531495, 0.02105160987131271, 0.3426702342200107, 16.38320352757287, 0.8024663010314574, 0.9999480257285978, 2.5012166027805427, 0.9999481283977601, 0.349929284849296, -0.1729584603310263, 1.4, 0.9863286423608446, 0.9323351100010828, 0.7099802920611822, 0.1083759398037735, -0.41713816328764536, 0.6590064092043358, 0.7294056839020625, 0.7867682080078963, 0.8628955719559286, 0.6607662427567744, 0.7303186531417746, 0.7883441117501115, 0.8644106510339202, -0.43245759984406745, -0.34317574632318304, -0.2704267991329317, -0.17387980022894212, -0.4313110811107129, -0.3428822561906295, -0.26910655360176905, -0.1723920940290816, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11014088138061137, 0.11014079135938923, 0.12508780907926922, 0.17292346264673963, 0.8392672111749917, -0.2552552552552552, 0.09741356082914152, -0.7957957957957955, 0.5424339471577262], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 2.5168764953257426e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 1.1675635731717501e-175, "x_opt_dim_5": [-4.0, -2.0, 3.111154690490267e-88, 2.0, 4.0]}
{"id": "4accdff8-45ae-4680-949c-8472db8424c2", "fitness": 1.0, "name": "landscape_separable_attractor_ripple_improved_v2", "description": "A strictly separable, fully additive landscape with per-dimension optima distributed in [-5,5]. Each dimension has an independent 1D landscape consisting of a quadratic basin centered at c_i plus a dimension-specific sine-squared ripple to inject ruggedness. The global minimum is at x = c with f(x) = 0, and the problem remains perfectly separable to favor subproblem decomposition.", "code": "import numpy as np\n\nclass landscape_separable_attractor_ripple_improved_v2:\n    \"\"\"\n    A refined, fully separable benchmark with dimension-specific optima.\n    Each dimension i has:\n      g_i(x_i) = w_i * (x_i - c_i)^2 + A_i * sin^2(2 * pi * k_i * (x_i - c_i))\n    The total f(x) = sum_i g_i(x_i) with a global minimum at x = c and f(x) = 0.\n    - c_i are spread across [-5, 5] deterministically\n    - w_i, A_i and k_i introduce dimension-wise variation but no coupling\n    - The landscape is strictly separable, enabling exact subproblem decomposition.\n    \"\"\"\n    def __init__(self, dim=5, seed=None):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be at least 1\")\n\n        # Deterministic centers distributed across [-5, 5]\n        if self.dim > 1:\n            self.c = -5.0 + (np.arange(self.dim) / (self.dim - 1)) * 10.0  # c_i in [-5, 5]\n        else:\n            self.c = np.array([0.0], dtype=float)\n\n        # Per-dimension quadratic weights (slightly increasing with dimension)\n        self.w = 1.0 + 0.25 * np.linspace(0, 1, self.dim)  # in [1.0, 1.25]\n\n        # Per-dimension ripple amplitudes\n        self.A = 0.25 * (1.0 + 0.5 * np.linspace(0, 1, self.dim))  # in [0.25, ~0.375]\n\n        # Per-dimension ripple frequencies\n        self.k = np.arange(1, self.dim + 1, dtype=float)  # (1, 2, ..., dim)\n\n        # Optional: store seed for potential future randomness without affecting current separability\n        self._seed = seed\n        self._rng = np.random.default_rng(seed)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        delta = x - self.c\n        # g_i(x_i) = w_i * (x_i - c_i)^2 + A_i * sin^2(2 * pi * k_i * (x_i - c_i))\n        quad_term = self.w * (delta ** 2)\n        ripple_term = self.A * np.sin(2.0 * np.pi * self.k * delta) ** 2\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_attractor_ripple_improved_v2 scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c7f2a9bb-4f01-43d6-a65a-cf2fbaf19be9"], "operator": null, "metadata": {"ela_features_2D": [0.9381468356128713, 0.4120706497264699, 0.4688013969396877, 0.5876271259616027, 1.2534006225141792, 0.9385950598728263, 0.9999885984526162, 1.2484341719550573, 0.9999885365955908, 0.4105852036169312, -0.5751445566093103, 2.0, 0.705875174194745, 0.7126758004108749, 0.5681945623288314, 0.3447534640798195, -0.10116318554352303, 0.14859932221807706, 0.23533832616975534, 0.3186679589715298, 0.5050389977628407, 0.1474748808809078, 0.23149901320194086, 0.31283901865931785, 0.4954070417594367, -0.4456238069208194, -0.40022568896688576, -0.35660848077091456, -0.25906128743243206, -0.43821750974497037, -0.39504111418775256, -0.3532245940121937, -0.2593776223362743, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5222275034315771, 0.5222174116705733, 0.6092677104805424, 0.6582111007112231, 0.7093132836191007, 0.10910910910910906, 0.25282982526215714, -0.41941941941941935, 0.3654618473895582], "score_Separable_2D": 1.0, "ela_features": [0.8801592436415548, 0.413101481296127, 0.0046275113732435254, 0.4058704402751925, 215.0567419408827, 0.8811107521591157, 0.9999788913631849, 1.251328511147064, 0.9999788861002964, 0.3708411004082707, -0.22225779592192801, 1.4, 0.8804009770331167, 0.8708156878731319, 0.6491002551422079, 0.1824912696427859, -0.29471580065297154, 0.4815022505072271, 0.5762480929811901, 0.6526118902156776, 0.7768632690794001, 0.47291678069117643, 0.5686689255491336, 0.6462128674146175, 0.7723023260702819, -0.45602587325765825, -0.37269657361829733, -0.3055346701356504, -0.19625237666617681, -0.4659183183739447, -0.3812779809972115, -0.31273794915066955, -0.20127666447429932, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21883635730652323, 0.2188385603243826, 0.25152909010111346, 0.3232748775658368, 0.8040592745105715, -0.10310310310310308, 0.13738128399315838, -0.6156156156156154, 0.47451923076923075], "score_Separable_5D": 1.0, "ela_features_10D": [0.8601311874232407, 0.44632396096973076, 0.024681451907633795, 0.27754015843723145, 11.493492848734828, 0.8607782268600183, 0.9999754936272378, 1.249674384031425, 0.999975546796717, 0.2957915017062158, -0.11770691754412965, 1.6, 0.9656946491766887, 0.9319456060640366, 0.705166438800262, 0.10656208555697713, -0.4119934305586096, 0.6849904266182949, 0.744523000010049, 0.7989654221137448, 0.871849311871604, 0.685512892344075, 0.7445106371846666, 0.7996768793205187, 0.8725650625181725, -0.39953771386632314, -0.3240300691703917, -0.25497896192508107, -0.16253796440254925, -0.3999806928451247, -0.32494418031914896, -0.25478132318875774, -0.16207838716205095, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10972638696818879, 0.10972368527835415, 0.12392418710770967, 0.1757664524350853, 0.8331925923145616, -0.2992992992992992, 0.08570033774866581, -0.8478478478478475, 0.5373899119295437], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 0.0], [1, [-5.0, 4.020888888888875], 1.2235745046021578], [14, [-4.548888888888817, 5.0], 0.22635812227600993], [14, [-4.54889909564434, 4.021700865851686], 1.4498973967027344], [8, [-5.0, 3.2946666666665245], 3.741450124167752], [62, [-4.548858695992655, 3.294921418713959], 3.9678057195321905]], "nr_of_basins": 6, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 0.11424218585985269, "x_opt_dim_5": [-5.000000000557169, -2.2558617145714766, -0.1649938212552269, 2.375680043407659, 4.999999999968927]}
{"id": "4848d6bd-d449-4996-b6e3-36d9ba456997", "fitness": 1.0, "name": "landscape_centered_wells_enhanced", "description": "A deterministic, fully separable landscape with per-dimension quadratic wells centered at m_i and dimension-specific cosine modulation. Each dimension contributes independently via f_i(x_i) = w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i*x_i)), with m_i chosen so cos(b_i*m_i) = 1, ensuring a global minimum of 0 at x = m. The global objective is the sum over dimensions, preserving perfect separability and enabling subproblem division into independent 1D problems.", "code": "import numpy as np\n\nclass landscape_centered_wells_enhanced:\n    \"\"\"\n    Enhanced separable landscape with per-dimension quadratic wells centered at\n    deterministic centers m_i and a dimension-specific cosine modulation.\n    Each dimension contributes independently:\n        f_i(x_i) = w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i*x_i))\n    The per-dimension centers m_i are fixed to guarantee cos(b_i*m_i) = 1,\n    yielding a global minimum f(x)=0 at x = m.\n    The global objective is the sum over dimensions, preserving perfect separability.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i in [-5, 5]\n        self.m = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = i / float(max(1, self.dim - 1))\n            self.m[i] = -5.0 + 10.0 * t\n\n        # Quadratic weights w_i (positive) chosen to span a reasonable scale\n        self.w = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # keeps a smooth increase with i but within [0.4, 0.75]\n            self.w[i] = 0.4 + 0.35 * (i / max(1, self.dim - 1))\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.A[i] = 0.6 + 1.0 * ((i % 4) / 4.0)  # in [0.6, 1.6)\n\n        # Per-dimension frequencies b_i chosen to keep the target cos alignment\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            mi = self.m[i]\n            if abs(mi) < 1e-8:\n                self.b[i] = 2.0 * np.pi\n            else:\n                N_i = (i % 6) + 1  # 1..6\n                # Choose frequency so that b_i * m_i = 2\u03c0 * N_i\n                self.b[i] = (2.0 * np.pi * N_i) / max(abs(mi), 0.5)\n\n        # Ensure arrays are numpy arrays for vectorized ops\n        self.m = np.asarray(self.m, dtype=float)\n        self.w = np.asarray(self.w, dtype=float)\n        self.A = np.asarray(self.A, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        diff = x - self.m\n        quad_term = self.w * (diff ** 2)\n        cos_term = self.A * (1.0 - np.cos(self.b * x))\n\n        return float(np.sum(quad_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_centered_wells_enhanced scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.9377363229277895, 0.5234669021339091, 0.37133657454189517, 0.6944549843258228, 1.870712936289009, 0.9377117245274187, 0.9991637004354466, 1.9209536282527577, 0.9991666795871904, 0.5285904208881076, -0.517706959236861, 1.0, 0.6732910092641387, 0.7124518857206981, 0.5416379957777107, 0.339721247128554, -0.10184310910075176, 0.17590692954904458, 0.262248310046873, 0.35182241050300556, 0.5306095690941224, 0.18269960757978154, 0.2542221749321952, 0.3368513797083771, 0.5163908229256032, -0.43112857997918097, -0.38596258006394635, -0.33910454941454604, -0.24556899172279661, -0.4197049479990854, -0.3830220677466898, -0.3406387928694192, -0.24842286281301088, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5126582555403656, 0.5126397385284285, 0.6080936632655369, 0.6513647546322959, 0.6993503540247089, 0.1411411411411411, 0.23382356632065054, -0.4194194194194193, 0.3477911646586346], "score_Separable_2D": 1.0, "ela_features": [0.8836537683887707, 0.4929883713729911, 0.003442069122461503, 0.4627676961333848, 1752.5867260664613, 0.8847529967142129, 0.9973965532995385, 1.9454142901254763, 0.9974050374840318, 0.4414502188453122, -0.23439673548605428, 1.2, 0.8765762207296788, 0.8661915386965255, 0.6396880238546379, 0.1863063788006616, -0.2911720628667355, 0.4889709699626856, 0.5804031997536759, 0.655963958970491, 0.7754277447246744, 0.4846646387998364, 0.5760042960260462, 0.6502640046598682, 0.7718357292876349, -0.44946941207026897, -0.36905271241380955, -0.3025945708093084, -0.1975205546683091, -0.4552463834832842, -0.37456144106976963, -0.3089610512331715, -0.20156195133232996, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2161081685367781, 0.21612524389256554, 0.2594649869838256, 0.32923745557969447, 0.8073255932437368, -0.0790790790790791, 0.15472753145585252, -0.6436436436436435, 0.4866987179487179], "score_Separable_5D": 1.0, "ela_features_10D": [0.8581725354338744, 0.5589536249500837, 0.0238545377123102, 0.3244687559018242, 14.005238793441787, 0.8588083061239832, 0.9967232639887185, 1.929804265283391, 0.9967201396581877, 0.3023686571208879, -0.18832197590897443, 1.4, 0.9607552033312509, 0.9313174526271624, 0.7019186090727239, 0.1071504224036475, -0.40914444806024575, 0.6868945358570137, 0.7525078953171092, 0.8010327005912103, 0.8734165978257021, 0.6861052571666363, 0.752896228401964, 0.8018223450696149, 0.8741783544344403, -0.3971037377553806, -0.3138889863164164, -0.25234604493134316, -0.160543041505463, -0.3991525256994183, -0.3142230054572946, -0.2520070276997328, -0.1599972958589866, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11164175940956804, 0.11163987430466298, 0.1249960630103198, 0.17534686772955252, 0.839759431300747, -0.2832832832832833, 0.08992531480911266, -0.8318318318318315, 0.5389111289031224], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 3.256768012026039e-167, "x_opt_dim_5": [-5.0, -2.5, -7.525918129199213e-84, 2.5, 5.0]}
{"id": "ea788814-eb9a-43a4-8288-ec773769062f", "fitness": 1.0, "name": "landscape_centered_wells_separable_v2", "description": "A novel fully separable benchmark with per-dimension quadratic wells and cosine modulation, designed to maximize true separability for subproblem optimization. Each dimension has its own independent 1D landscape centered at a deterministic m_i, ensuring a global optimum at x = m with f(x) = 0. Parameters are chosen to provide varied ruggedness across dimensions while preserving additivity.", "code": "import numpy as np\n\nclass landscape_centered_wells_separable_v2:\n    \"\"\"\n    A strictly separable, additive landscape with per-dimension:\n      - quadratic well centered at deterministic m_i\n      - dimension-specific cosine modulation to introduce ruggedness\n    The centers m_i are deterministically placed in [-5, 5], and for each i a cosine\n    term is constructed so that cos(b_i * m_i) = 1, yielding f_i(m_i) = 0.\n    The global optimum is at x = m (vector of centers) with f(x) = 0.\n    This version emphasizes improved separability by ensuring fully independent 1D subproblems\n    with smoothly varying per-dimension parameters.\n    \"\"\"\n    def __init__(self, dim=5, seed=None):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers m_i in [-5, 5]\n        self.m = np.linspace(-5.0, 5.0, self.dim)\n\n        # Quadratic weights w_i (positive), increasing with dimension to vary subproblem difficulty\n        self.w = 0.15 + 0.75 * (np.arange(self.dim) / max(self.dim - 1, 1))\n\n        # Cosine modulation amplitudes A_i (positive)\n        self.A = 0.3 + 1.7 * (np.arange(self.dim) / max(self.dim - 1, 1))\n\n        # Cosine frequencies b_i tuned so that cos(b_i * m_i) = 1\n        self.b = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            mi = self.m[i]\n            if abs(mi) < 1e-8:\n                # For zero center, pick a reasonable frequency\n                self.b[i] = 2.0 * np.pi\n            else:\n                # Choose frequency so that b_i * m_i = 2\u03c0 * N_i (N_i >= 1)\n                N_i = (i % 5) + 1\n                self.b[i] = (2.0 * np.pi * N_i) / max(abs(mi), 0.5)\n\n        # Store as numpy arrays for fast vectorized operations\n        self.m = np.asarray(self.m)\n        self.w = np.asarray(self.w)\n        self.A = np.asarray(self.A)\n        self.b = np.asarray(self.b)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        x: 1D numpy array of length dim\n        Returns a scalar value f(x) = sum_i [ w_i*(x_i - m_i)^2 + A_i*(1 - cos(b_i * x_i)) ]\n        Global minimum is 0 at x = m.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        diff = x - self.m\n        quad_term = self.w * (diff ** 2)\n        cos_term = self.A * (1.0 - np.cos(self.b * x))\n\n        return float(np.sum(quad_term + cos_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_centered_wells_separable_v2 scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.9368216910447373, 0.7367992835967755, 0.1512428535365415, 0.8896417708968782, 5.892162978673294, 0.9367994892847532, 0.997251630147499, 6.380828960375033, 0.9972480785043508, 0.5994963230017296, -0.8725761788811897, 2.4, 0.6124943038788191, 0.6939479197497259, 0.5086800918929015, 0.3509089493743422, -0.09665456302250373, 0.27594360599455114, 0.3905702830745213, 0.4242216844630474, 0.5888931629422487, 0.25333096170502695, 0.3451401991334903, 0.3796642528671813, 0.5388131485421013, -0.3788239689474456, -0.31887959922885767, -0.30126808728489, -0.21511651043834332, -0.3838490041627094, -0.3366931821697913, -0.31894670594891783, -0.23716171744647277, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5087835854820237, 0.5087795158355971, 0.6434645524788207, 0.6577221553883394, 0.6708012335196416, 0.26126126126126115, 0.2358655975527872, -0.3313313313313312, 0.3606425702811245], "score_Separable_2D": 1.0, "ela_features": [0.8906396539618691, 0.6693647914864801, 0.008189890400839988, 0.6020473341307155, 139.20525705354183, 0.8907247453432567, 0.9953696934578504, 6.356624612299536, 0.9953547544565741, 0.50128771707279, -0.5042969059521769, 1.0, 0.8553505104264458, 0.863466216751123, 0.6277113784682201, 0.18804363235796653, -0.2779634110620501, 0.5127313321237554, 0.6004434311173752, 0.6843781450748261, 0.7999970900724286, 0.5098220857127108, 0.5933795601458345, 0.6761853330430976, 0.7937338713242228, -0.42866304730832894, -0.35149886103600714, -0.2776587050532712, -0.17594701987874134, -0.433459439273154, -0.3595651407241185, -0.28634180611749216, -0.18239883258135153, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21587398714103484, 0.21587441575721766, 0.2619761090166766, 0.3213774814786282, 0.8044081797329993, 0.0010010010010009852, 0.15044872920784688, -0.5995995995995994, 0.4918269230769231], "score_Separable_5D": 1.0, "ela_features_10D": [0.873064886596992, 0.7550985490541697, 0.02135428847282369, 0.41209520125269555, 20.16150152508321, 0.8737899424273307, 0.9946041181823982, 6.12201235286254, 0.99459257025425, 0.3679228265978604, -0.3013889658610648, 1.2, 0.9505930296859431, 0.9274810476322772, 0.6907547456320575, 0.11241716821186087, -0.3962372645339959, 0.7049524761947376, 0.765723931605432, 0.810842432817271, 0.8774942108976289, 0.7070898288266935, 0.7649349523314808, 0.8110529422492625, 0.8777905187952957, -0.3742269131891285, -0.2971465068258924, -0.23991996111127026, -0.1553815573847463, -0.37255354428004017, -0.29897947452463836, -0.24032176405049865, -0.15543845350058816, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10951845019323166, 0.10950939641349997, 0.12983936769928636, 0.17644291636584175, 0.8283555432078705, -0.2432432432432432, 0.09381325409777105, -0.8038038038038036, 0.532345876701361], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [-5.0, 5.0], 0.0], [80, [-5.0, 2.8497777777777706], 4.885401592269281]], "nr_of_basins": 2, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 0.8799075368629713, "x_opt_dim_5": [-4.999999999455284, -2.5000000015894193, -1.5965860266625676e-09, 2.4999999992453894, 4.022360990968399]}
{"id": "fd3998d1-ca91-42df-b7fc-663f8597e19a", "fitness": 1.0, "name": "landscape_separable_centered_cosine_well_v2", "description": "A refined fully separable additive landscape where each dimension has its own center and a mild, dimension-dependent cosine modulation around that center. The global optimum remains at x = c with f(x) = 0. Each dimension contributes independently via a quadratic well centered at c_i plus a per-dimension cosine-based modulation to introduce ruggedness while preserving separability, with dimension-specific parameters chosen to encourage stable separability and straightforward subproblem decomposition.", "code": "import numpy as np\n\nclass landscape_separable_centered_cosine_well_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n        \n        if self.dim == 1:\n            self.c = np.array([0.0], dtype=float)\n            self.w = np.array([1.0], dtype=float)\n            self.a = np.array([0.25], dtype=float)\n            self.b = np.array([0.75], dtype=float)\n        else:\n            # Centers spread uniformly across [-4, 4]\n            self.c = -4.0 + 8.0 * (np.arange(self.dim) / (self.dim - 1))\n            # Slightly varying quadratic weights to encourage separability\n            self.w = 1.0 + 0.20 * (np.arange(self.dim) / (self.dim - 1))  # [1.0, ~1.2]\n            # Per-dimension cosine modulation amplitude (ruggedness)\n            self.a = 0.15 + 0.20 * (np.arange(self.dim) / (self.dim - 1))  # [0.15, ~0.35]\n            # Per-dimension modulation frequency\n            self.b = 0.4 + 0.6 * (np.arange(self.dim) / (self.dim - 1))  # [0.4, ~1.0]\n\n        self.c = np.asarray(self.c, dtype=float)\n        self.w = np.asarray(self.w, dtype=float)\n        self.a = np.asarray(self.a, dtype=float)\n        self.b = np.asarray(self.b, dtype=float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n        \n        delta = x - self.c  # per-dimension displacement from its center\n        quad_term = self.w * (delta ** 2)\n        ripple_term = self.a * (1.0 - np.cos(self.b * delta))\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_centered_cosine_well_v2 scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e8defcbd-c9e5-4059-8135-0024fdb8cf81"], "operator": null, "metadata": {"ela_features_2D": [0.9110338605045225, 0.3676904450025951, 0.47654733352015743, 0.5738260885584356, 1.2037948037148825, 0.9111884927636374, 0.9999637578049928, 1.1924664739396704, 0.999981770151112, 0.563530014098826, -0.4162894855875723, 1.0, 0.7284415718845502, 0.7184251976803838, 0.5937120589924949, 0.34204148364541176, -0.10480005044633785, 0.14191374371812526, 0.23334779668881586, 0.3081670782747203, 0.4954329338633747, 0.14254207802809876, 0.23127183814257607, 0.309173764122143, 0.4870845607565141, -0.44902504044302755, -0.4011803154899048, -0.36202775825093003, -0.26403480720717454, -0.44061358102771875, -0.3950230240988196, -0.3549918333884644, -0.26357780198646186, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5208131213579431, 0.5207986315384121, 0.6144849403868617, 0.6592309932020787, 0.6826583806263697, 0.1531531531531531, 0.26606429349897887, -0.4274274274274273, 0.3642570281124498], "score_Separable_2D": 1.0, "ela_features": [0.8257269356319366, 0.41477490863014366, 0.006688405843571535, 0.40818043624760814, 103.09651532812896, 0.8269738179540317, 0.9999475778153203, 1.188906159019183, 0.9999813217080892, 0.3933810986037407, -0.2484109958351559, 1.2, 0.8872893156111179, 0.8673511678394421, 0.6378567168717736, 0.18771270699183493, -0.30568611879352015, 0.4542206832146071, 0.5530655632500869, 0.6368412702237278, 0.7604337844861291, 0.45698968466770185, 0.5514649894148791, 0.6327603843669852, 0.7578542060238407, -0.4801605133898498, -0.3931990184809373, -0.31949701702007455, -0.2107633004491049, -0.4802107800555205, -0.39665932542552296, -0.3247688426106537, -0.21413971954435068, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21639884228220696, 0.21638578617195173, 0.2493222116705621, 0.31558128081741693, 0.8113902237077133, -0.055055055055055056, 0.16538447619868982, -0.5915915915915914, 0.4913461538461538], "score_Separable_5D": 1.0, "ela_features_10D": [0.7950094667814569, 0.45089446138019806, 0.023385028430867597, 0.27388201131473755, 12.001921898492418, 0.7967524751949057, 0.9999486044281152, 1.191051937859965, 0.9999770972552042, 0.3280039820995869, -0.11313917147636285, 1.0, 0.9911760121401146, 0.9348513440054683, 0.7096097386939204, 0.10628502349149416, -0.42639143135675567, 0.6651347816059486, 0.7282931799909982, 0.782916669912103, 0.856505653485289, 0.6659843413062069, 0.7307674442180716, 0.7850236582409441, 0.8582576978531142, -0.42465826495538134, -0.344563959866821, -0.2752933376279737, -0.1819716893798679, -0.42468546710609945, -0.3423163981228509, -0.2733319498601549, -0.18021812454372976, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11132692965690957, 0.11132325224453028, 0.12478767653061036, 0.17236935747495735, 0.8385523803140906, -0.25125125125125114, 0.10096912048215057, -0.7917917917917916, 0.5393915132105684], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, 4.00000000000011], 2.668495561309221e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 4.4619715938934424e-176, "x_opt_dim_5": [-4.0, -2.0, 2.0140352064029074e-88, 2.0, 4.0]}
{"id": "0933ee7b-1f73-4308-a2c5-ddbf0fd26f6d", "fitness": 1.0, "name": "landscape_separable_hypercosine", "description": "A completely different separable landscape using a non-quadratic, non-polynomial 1D basin per dimension. Each dimension has a hyperbolic-basin component (cosh-based) plus an independent oscillatory ripple, both centered at a per-dimension optima a_i. The global optimum is at x = a, with f(x) = 0, and the problem remains fully separable across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_hypercosine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self.a = np.zeros(self.dim, dtype=float)      # per-dimension optima\n        self.omega = np.zeros(self.dim, dtype=float)  # per-dimension ripple frequency\n        self.alpha = np.zeros(self.dim, dtype=float)  # hyperbolic-basin weight\n        self.beta = np.zeros(self.dim, dtype=float)   # cosine ripple weight\n\n        for i in range(self.dim):\n            # Distribute optima across [-5, 5] deterministically\n            if self.dim == 1:\n                self.a[i] = 0.0\n            else:\n                self.a[i] = -5.0 + 10.0 * i / float(self.dim - 1)\n\n            # Distinct, dimension-dependent frequencies\n            self.omega[i] = 2.0 * np.pi * (1.0 + i / 3.0)\n\n            # Dimension-specific weights for the two components\n            denom = float(max(1, self.dim - 1))\n            self.alpha[i] = 0.15 + 0.25 * (i / denom)  # 0.15 .. ~0.40\n            self.beta[i]  = 0.15 + 0.70 * (i / denom)  # 0.15 .. ~0.85\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n        \n        z = x - self.a\n        # Per-dimension landscape:\n        # f_i(z) = alpha_i * (cosh(z) - 1) + beta_i * (1 - cos(omega_i * z))\n        term1 = self.alpha * (np.cosh(z) - 1.0)\n        term2 = self.beta * (1.0 - np.cos(self.omega * z))\n        return float(np.sum(term1 + term2))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_hypercosine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e1d70b0a-5276-49bd-8503-e1bbcc6ca8bf"], "operator": null, "metadata": {"ela_features_2D": [0.46729005461410356, 0.2587038764514838, 0.17050228082215302, 0.4362518653712531, 2.596672917459184, 0.4688686768379604, 0.8132399540048988, 2.780711046837696, 0.9554556489815245, 2.181500642231182, 4.562756890447129, 2.0, 0.6739066069667474, 0.7041704418979912, 0.5518807852270642, 0.34838804188007166, -0.1425374289625267, 0.19908885439920354, 0.2487919740225477, 0.3325968713588857, 0.520016417144189, 0.20570367463017175, 0.24161697493902068, 0.3320756338019573, 0.5212573069418858, -0.418726788433532, -0.3927415291227622, -0.348928038670556, -0.25094053199787314, -0.40722516692224764, -0.3888015829139556, -0.342416975767462, -0.2454357152761935, 1.0, 1.0, 0.6666666666666666, 0.9333333333333332, 0.526936927257142, 0.5269209417687041, 0.5094772937997052, 0.5543187355695839, 0.5525522407657977, 0.7857857857857855, 0.007596526216385296, -0.8918918918918918, 0.38032128514056224], "score_Separable_2D": 1.0, "ela_features": [0.4725866554419018, 0.2552037615782263, 0.005783922829928205, 0.40165543364783307, 104.9580663364168, 0.47509232135973056, 0.8174191240939794, 76.64163076726965, 0.9547122705793768, 2.1667319090149664, 4.612096119326899, 2.2, 0.8563450390021456, 0.8620723210107701, 0.624322914687029, 0.18969452366440837, -0.2958719685975194, 0.4911058433670708, 0.5905922380810809, 0.6665875549632816, 0.7846073627384623, 0.4935698342126228, 0.5854673987847592, 0.660839817920363, 0.7782241754452464, -0.44772736694483867, -0.360196749319282, -0.2933351196069576, -0.1895018954780438, -0.44810752606739257, -0.36678751067076104, -0.3000925903430984, -0.19622787401016478, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21507756267772354, 0.21510310125436866, 0.2266210803289102, 0.28025870877011194, 0.6680537228853672, 0.39739739739739727, 0.0539792110816267, -0.8678678678678675, 0.5054487179487179], "score_Separable_5D": 1.0, "ela_features_10D": [0.4814390984959026, 0.2909197316185551, 0.0019975714278132766, 0.3584174633431204, 249.03665738442882, 0.4847937372935987, 0.8175922470577104, 127.72723492622933, 0.9560589811769453, 1.9652675203268846, 3.967753175524204, 2.6, 0.9388151735748327, 0.9266628948226827, 0.683389076506456, 0.11246942299559348, -0.36436775720533116, 0.692959600701202, 0.7539197902516863, 0.7999469778604492, 0.8720777291628004, 0.6940058148303061, 0.7535468160211225, 0.7993523404984082, 0.8717845436334898, -0.38941165645127895, -0.3120973130843093, -0.2537220153250241, -0.1622401405872101, -0.38915329879201555, -0.31343078293879306, -0.2551765179332312, -0.16305916304175666, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11016561945228709, 0.11016332899919226, 0.11705321009019869, 0.1544927024235221, 0.7695607796146853, 0.07307307307307302, 0.05402158799620412, -0.8438438438438436, 0.5694155324259408], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 0.0], [1, [-5.0, 4.254888888888849], 0.11698423999151522], [1, [-4.028953167074519, 4.256635965287804], 0.19594489149670108], [1, [-4.028888888888874, 5.0], 0.07892971985502485], [2, [-4.998806905764946, 2.0661538809991353], 3.4978330769222445], [4, [-3.092439981098616, 4.265087640616965], 0.5107286617976635], [1, [-5.0, 2.781777777777778], 1.4898996197547498], [1, [-4.028889062747831, 2.781777777774], 1.5688293396912174], [7, [-3.0877777777777435, 5.0], 0.3909307623992283], [24, [-4.026699427609379, 1.4324795058177624], 7.584575971185752], [37, [-3.08993204103044, 2.068012902873727], 3.8888572000316524], [20, [-3.087784662598322, 2.781812576004089], 1.8808323831240816]], "nr_of_basins": 12, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0000000004160805, 5.000000000822101], "f_opt_dim_5": 0.49898204391939577, "x_opt_dim_5": [-4.028811356378936, -2.499999999708196, -1.1924896993177327, 2.9983558141079882, 4.144966087245342]}
{"id": "464fd6b6-95af-4685-949b-40c0ab93dcec", "fitness": 1.0, "name": "landscape_separable_rugged_quadratic_sine", "description": "A completely different separable landscape using per-dimension rugged quadratic wells. Each dimension has a shifted optimum m_i and a per-dimension multiplicative modulation that increases ruggedness without destroying separability. The global minimum is at x = m, with f(x) = 0, and the problem remains fully separable across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_rugged_quadratic_sine:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim < 1:\n            raise ValueError(\"dim must be >= 1\")\n\n        if self.dim == 1:\n            # 1D parameters\n            self.m = np.array([0.0], dtype=float)       # global optimum per dimension\n            self.w = np.array([0.35], dtype=float)      # quadratic weight\n            self.a = np.array([0.6], dtype=float)       # modulation amplitude\n            self.b = np.array([1.2], dtype=float)       # modulation frequency\n        else:\n            # Deterministic per-dimension optima spanning [-4, 4]\n            self.m = -4.0 + 8.0 * (np.arange(self.dim) / (self.dim - 1))\n            self.m = self.m.astype(float)\n\n            # Quadratic weights growing across dimensions\n            self.w = 0.15 + 0.85 * (np.arange(self.dim) / (self.dim - 1))\n            self.w = self.w.astype(float)\n\n            # Ruggedness modulation amplitudes per dimension\n            self.a = 0.10 + 0.60 * (np.arange(self.dim) / (self.dim - 1))\n            self.a = self.a.astype(float)\n\n            # Frequencies per dimension for the sine-based modulation\n            self.b = 0.5 + 1.5 * (np.arange(self.dim) / (self.dim - 1))\n            self.b = self.b.astype(float)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input x must have shape (dim,)\")\n        \n        diff = x - self.m\n        quad = self.w * (diff**2)\n        rug = 1.0 + self.a * (np.sin(self.b * diff)**2)\n        return float(np.sum(quad * rug))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_rugged_quadratic_sine scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["a02e65c9-65fb-462f-8693-42a50b6c1968"], "operator": null, "metadata": {"ela_features_2D": [0.8380587288294332, 0.6224287446568446, 0.0985941401975611, 0.8062439616782701, 8.186577827985884, 0.8384174109588474, 0.9458784459955393, 8.233971269927986, 0.9484811855695409, 1.0415394840026306, 0.19250889763623819, 2.0, 0.5072301593493033, 0.6522708274792139, 0.4095953028469709, 0.3743541120661472, -0.1328430915552105, 0.15474902944303043, 0.24722003754741123, 0.33363797040622656, 0.5779662312535431, 0.14951177778222297, 0.22942688257089724, 0.3179632950442345, 0.5304609689411802, -0.44251549915181165, -0.39410421013710784, -0.34886656217299594, -0.22095320759713197, -0.43755171223480505, -0.3964391236787532, -0.3508945880131534, -0.24157001073956294, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5211799834217634, 0.5211642207880264, 0.617831103022621, 0.64134151516223, 0.6944883903710273, 0.8138138138138136, 0.10442357404208377, -0.28328328328328317, 0.4393574297188755], "score_Separable_2D": 1.0, "ela_features": [0.796128256646562, 0.6114384101727285, 0.008039067682133375, 0.556128002539878, 154.29695362111556, 0.7970976651134165, 0.9501843128712046, 9.773553083115706, 0.9529053520895626, 0.8427134596438993, 0.15345841351837003, 1.0, 0.8417002445528814, 0.8560826259385065, 0.6136403974165325, 0.19478588735652855, -0.3036291007215336, 0.44793521824867966, 0.5689729124667802, 0.6580280536359366, 0.7877773672983854, 0.4405900410436482, 0.5598003875356501, 0.6483803118473244, 0.7818237758953973, -0.4855623414860169, -0.3791087869277235, -0.3007792519785767, -0.18665894574580305, -0.4944209115838917, -0.3890730557278585, -0.3107780329722563, -0.19283323145731573, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2170812422333152, 0.21710950052727082, 0.26133722826495304, 0.31999274992455284, 0.7977140668733659, 0.26126126126126115, 0.13140653493500215, -0.5715715715715713, 0.5208333333333333], "score_Separable_5D": 1.0, "ela_features_10D": [0.7722858420144801, 0.6653630295665002, 0.016864963069988734, 0.3743560075413491, 25.307378546357818, 0.7732071002694638, 0.9537107707564907, 10.79783994156492, 0.9564130974458811, 0.5994692844647805, 0.08228384839203037, 1.4, 0.9540542246063023, 0.9287381321215685, 0.6828093793870053, 0.11207942808411109, -0.41292564103974466, 0.6898725150515701, 0.7516894709633484, 0.80424749996924, 0.8729340678300825, 0.6911367601662042, 0.7524459673885376, 0.8051661977721836, 0.8733121478838166, -0.3933222658954331, -0.314923275221666, -0.24826600506004085, -0.1611532936617468, -0.39276793074083166, -0.31480527172833217, -0.24776316933474543, -0.16110424223017966, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.1102332907808768, 0.1102372756845604, 0.12331648193662062, 0.17083577937778013, 0.8364035238510251, -0.1751751751751751, 0.09418249425756015, -0.7877877877877875, 0.5570856685348279], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[10, [-3.9998428639189587, 0.9875558125582327], 9.489291478977217], [10, [-4.00000000000011, -5.0], 112.97777060093692], [10, [-4.00000000000011, -0.5555555555555554], 22.13610499315796], [20, [-4.00000000000011, -2.224666666666642], 39.11629889021565], [10, [-4.00000000000011, -3.806888888888898], 61.3248581384905], [40, [-4.00000000000011, 4.00000000000011], 1.394895407048002e-26]], "nr_of_basins": 6, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, 4.0], "f_opt_dim_5": 7.488637926456674e-176, "x_opt_dim_5": [-4.0, -2.0, 3.608838889860301e-88, 2.0, 4.0]}
{"id": "79b71623-6808-4828-994d-05f97e1e506c", "fitness": 1.0, "name": "landscape_separable_quartic_sine_ripple", "description": "A completely different separable landscape where each dimension has a deterministic center and combines a quartic well with a sine-squared ripple around that center. This creates a rugged yet separable landscape with an exact global minimum at x = c and f(x) = 0, while keeping subproblems independent per dimension.", "code": "import numpy as np\n\nclass landscape_separable_quartic_sine_ripple:\n    \"\"\"\n    A fully separable additive landscape where each dimension has:\n      - a quartic well centered at c_i (deterministic center in [-5, 5])\n      - a dimension-specific sine-squared ripple to add ruggedness around the center\n    The global optimum is at x = c with f(x) = 0. The landscape is fully separable,\n    enabling independent optimization per dimension.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Deterministic per-dimension centers c_i in [-5, 5], spread linearly\n        self.c = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            t = i / float(max(1, self.dim - 1))\n            self.c[i] = -5.0 + 10.0 * t\n\n        # Quartic well weights w_i (positive)\n        # Spread across dimensions for variety while staying moderate\n        self.w = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.w[i] = 0.25 + 0.35 * ((i % 7) / 6.0)  # in [0.25, ~0.60]\n\n        # Sine-squared ripple amplitudes A_i (positive)\n        self.A = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.A[i] = 0.4 + 0.6 * ((i % 5) / 4.0)  # in [0.4, 1.0]\n\n        # Ripple periods p_i (positive)\n        # Provides variety in ripple frequency across dimensions\n        self.p = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            self.p[i] = 2.0 + (i % 3)  # periods in {2, 3, 4}\n\n        # Ensure numpy arrays for convenient vectorized operations\n        self.c = np.asarray(self.c)\n        self.w = np.asarray(self.w)\n        self.A = np.asarray(self.A)\n        self.p = np.asarray(self.p)\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.shape[0]))\n\n        # Per-dimension: f_i(x_i) = w_i*(x_i - c_i)^4 + A_i*(sin(pi*(x_i - c_i)/p_i))^2\n        dx = x - self.c\n        quad_term = self.w * (dx ** 4)\n        ripple_term = self.A * (np.sin(np.pi * dx / self.p) ** 2)\n\n        return float(np.sum(quad_term + ripple_term))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_quartic_sine_ripple scored on:Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ff17ab9e-50bd-4d34-b894-8d59690d1bd1"], "operator": null, "metadata": {"ela_features_2D": [0.7373107909132256, 0.27770062467308737, 0.4069705207739676, 0.5043696145479251, 1.2405623864884778, 0.7374867614919252, 0.9798371614677805, 1.2480444632516852, 0.9996881971417583, 1.0216315712640163, 0.49426529441851424, 1.2, 0.7049427149393303, 0.7145454351423886, 0.5640030293261276, 0.3425583728445648, -0.13445543747041883, 0.15557639850452917, 0.22523552035963196, 0.3137797947702138, 0.5119192899473755, 0.15647517054091822, 0.2211775452904159, 0.31148971794617164, 0.5126073596171417, -0.4417245346375577, -0.40528816176925486, -0.3589704599662188, -0.25531874973434354, -0.4325923377178496, -0.3994273698267829, -0.35311038409275464, -0.24995009271141416, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5157289424272243, 0.5157103122226763, 0.5613558089837802, 0.6127990051874214, 0.5897075749981981, 0.36936936936936926, 0.2826920939899733, -0.3993993993993993, 0.3333333333333333], "score_Separable_2D": 1.0, "ela_features": [0.729431911159222, 0.4076857658463592, 0.008394709925317264, 0.5274031178220709, 348.77840925648155, 0.7316443141745521, 0.9753917707200987, 10.326006780456128, 0.999268876888382, 0.9533424919000015, 0.31468375310505675, 1.2, 0.8675993843499052, 0.865137216774629, 0.6384798799784994, 0.18613086782224794, -0.3036338253813337, 0.4709081786696837, 0.5719323747672923, 0.6498647023446387, 0.7773956773208395, 0.4645163721638569, 0.5649252500340155, 0.6432321541528235, 0.7704823385912147, -0.4654631595231355, -0.3765863018337475, -0.30802473906620964, -0.19583078347250465, -0.47364065768107944, -0.384824670110508, -0.31555558715874327, -0.2030015417916109, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21575174021286347, 0.21573567792723397, 0.25178938125488126, 0.3055065738832939, 0.7539839938686641, 0.1731731731731731, 0.1251096931990504, -0.5595595595595594, 0.4810897435897436], "score_Separable_5D": 1.0, "ela_features_10D": [0.706400504169635, 0.34453440591882706, 0.019884807182418363, 0.330468519431334, 18.233896865672683, 0.707870910784716, 0.9697727482642774, 5.608390161737996, 0.9983200470363428, 0.6671348295948965, 0.17056050407091972, 1.4, 0.9661364054810001, 0.9315777084931665, 0.7023799603782148, 0.10853989954815046, -0.4343802174218162, 0.6660999160102772, 0.7362533362970043, 0.7891099725645829, 0.863784430865907, 0.6637716832983699, 0.7371522627373108, 0.7899417326315448, 0.864405974478226, -0.4234738143304198, -0.33450092325649583, -0.26746453513242757, -0.17275734379204036, -0.42752522270690896, -0.3342203129485345, -0.26709621762518637, -0.1724119378217679, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11014853093874259, 0.11014417308027244, 0.1219009276061912, 0.16699271785619954, 0.8342985936078687, -0.13913913913913908, 0.09381325409777105, -0.7637637637637635, 0.5560448358686949], "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-5.0, 5.0], 0.0]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.0, 5.0], "f_opt_dim_5": 1.8087746790895775e-176, "x_opt_dim_5": [-5.0, -2.5, 2.0466959655720837e-88, 2.5, 5.0]}
