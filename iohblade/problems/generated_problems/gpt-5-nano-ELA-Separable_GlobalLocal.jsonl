{"id": "640051b4-c98c-47c2-b212-383d2da40840", "fitness": 0.6621932759007905, "name": "landscape", "description": "A separable benchmark landscape with per-dimension quadratic base and nonnegative oscillatory bumps (sin^2 terms) to create multiple local minima while preserving a global minimum at the origin. The complexity is tunable per dimension via dimension-specific amplitudes and frequencies, yielding a clear global minimum but numerous nearby local minima for testing search robustness.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Deterministic, dimension-specific parameters to ensure reproducible landscapes\n        # Per-dimension amplitude of the oscillatory term (nonnegative)\n        self.a = 0.6 + 0.25 * np.arange(dim)\n        # Per-dimension frequency of the oscillatory term\n        self.k = 1.0 + 0.25 * np.arange(dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n        # Separable per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        # Global minimum at x = 0 with f = 0; local minima arise from the sin^2 term.\n        per_dim = x**2 + self.a * np.sin(self.k * x)**2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.002555942498027175, 0.3552526744478726, 0.010808721646006061, 0.02560861394345264, 3.1697049535993935, -0.004017963961290327, 0.9988109399902507, 1.005809584314886, 0.9988090626118238, 0.49591726935555336, -0.3056030948842201, 2.0, 0.7115989404492243, 0.7173726187964223, 0.5544630141438465, 0.34225207368147403, -0.20088509254580042, 0.13657330532913417, 0.2140632577029006, 0.3091742234271907, 0.49418074124420075, 0.13929877206240548, 0.2137507304625988, 0.3086340586460438, 0.49335252829197473, -0.45169200075746846, -0.4111529899119207, -0.361392926916973, -0.2646099838723547, -0.4421967401447162, -0.4039513688263437, -0.35519363683880345, -0.2602903784502363, 1.0, 1.0, 1.0, 1.0, 0.5109677131568287, 0.5109474354561454, 0.396527460923483, 0.3487654736888123, 0.7078607851829735, 0.39339339339339324, 0.4919371077093733, -0.08308308308308306, 0.355421686746988], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9727391600608826, "ela_features": [-0.001340803292805437, 0.410298920347807, 0.0032476506225272888, 0.020085405310616842, 8.370901901874333, 0.0043826183735571345, 0.9971414858028002, 1.0232806262503071, 0.9971248955255729, 0.2856154429925276, -0.21064360247768538, 1.4, 0.9036084087823077, 0.875158261776326, 0.6434892093307436, 0.18048648886230298, -0.4809570772185099, 0.4390368750401719, 0.5206125585853639, 0.5925523050847941, 0.7133585865043995, 0.4411992704773386, 0.5225625564638439, 0.5966462914720734, 0.7176723417107974, -0.4933671642053937, -0.4216202571374518, -0.35834893895542586, -0.25209979300849367, -0.493896668774369, -0.4219822301300473, -0.3565042295031294, -0.2495336965892307, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21473466467462762, 0.2147121716710199, 0.20067979642005468, 0.18102985143086506, 0.8266618690739687, 0.10110110110110107, 0.2542885812326692, -0.38338338338338324, 0.5166666666666667], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00018718582578003407, "ela_features_10D": [-0.0003768189902131569, 0.46284523297297075, 0.0003055286823676899, 0.021069765938355, 329.94547208577694, 0.001054618298489185, 0.9920219378166634, 1.0323368214256465, 0.9920037120947276, 0.20098789919346466, -0.14755156969158553, 1.8, 1.0226557663640128, 0.9393947277529439, 0.7202677307266867, 0.10388810098420545, -0.6046764337978936, 0.6267057905162454, 0.6830401124514138, 0.732696810626009, 0.8090238600214743, 0.630564993481912, 0.6873613108274059, 0.7375887092373542, 0.81374458555139, -0.4734447258295356, -0.4019967276394076, -0.33901756152659285, -0.24221288966736254, -0.4697522254352031, -0.397533375477781, -0.33366680210370464, -0.23683177023647048, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1083349381596346, 0.10833117121710707, 0.1053561364390461, 0.09952225562017612, 0.8597292547123689, -0.11911911911911907, 0.13600431925575615, -0.6356356356356354, 0.5932746196957567], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00023330951808020473}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 7.759258911343016e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-8.184940061781241e-163, -5.3571661190912855e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.512398863871661e-163, -1.8349402147467516e-163, -5.4110392703141765e-164, -6.431663493502257e-163, -6.879488114380218e-163]}
{"id": "6207de7a-adce-4711-b3d9-4d355c2fb011", "fitness": 0.617137654471056, "name": "landscape", "description": "A separable multi-well landscape built from the minimum of several 1D parabolas per dimension. Each dimension has multiple local wells (centers mu_j) with additive offsets c_j, creating local minima. The global minimum is at x_i = mu_0 for all dimensions (here mu_0 = 0 with c_0 = 0), giving a global optimum value of 0. Other wells yield higher local minima (c_j > 0). The overall function is F(x) = sum_i min_j [(x_i - mu_j)^2 + c_j], making the problem separable across dimensions.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        self.dim = int(dim)\n\n        # Define a fixed set of 1D wells (mu_j, c_j) for a single dimension.\n        # mu_j: centers of parabolic wells\n        # c_j : additive offset (local depth). c_0 = 0 ensures global minimum at mu_0.\n        fixed_mu = np.array([0.0, -4.0, 4.0, -2.0, 2.0], dtype=float)\n        fixed_c  = np.array([0.0, 0.75, 0.85, 0.50, 0.60], dtype=float)\n\n        # Tile wells if more dimensions are requested\n        if self.dim <= fixed_mu.size:\n            self.mu = fixed_mu[:self.dim]\n            self.c  = fixed_c[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / fixed_mu.size))\n            mu_tile = np.tile(fixed_mu, reps)[:self.dim]\n            c_tile  = np.tile(fixed_c,  reps)[:self.dim]\n            self.mu = mu_tile\n            self.c  = c_tile\n\n        # Ensure numpy arrays for fast vectorized evaluation\n        self.mu = self.mu.astype(float)\n        self.c  = self.c.astype(float)\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape: F(x) = sum_i min_j [ (x_i - mu_j)^2 + c_j ]\n        - x: 1D numpy array of length self.dim\n        - domain: each x_i in [-5, 5] (as per specification)\n        - Global minimum: at x_i = mu_0 for all i, with value 0 (since c_0 = 0)\n        - Other wells give local minima with higher values (c_j > 0).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        # Compute per-dimension: g_i(x_i) = min_j [ (x_i - mu_j)^2 + c_j ]\n        # Vectorized: compute (x_i - mu_j)^2 + c_j for all i, j, then take min over j.\n        # x[:, None] has shape (dim, 1); mu[None, :] has shape (1, L)\n        diff = (x[:, None] - self.mu[None, :])**2 + self.c[None, :]\n        gi = np.min(diff, axis=1)\n        return float(np.sum(gi))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.002,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.5796610435352967, -0.15406071214692707, 0.36713304631303934, 0.3806154674935246, 1.0369008455164022, 0.5808186997845437, 0.8967437900731433, 1.0375989600680486, 0.9823502485962361, 1.170903395081638, 0.8416832422024164, 2.0, 0.4028447308383593, 0.6791352413496866, 0.3314147746680562, 0.3463612304073499, -0.15309943428100564, 0.3091424445110194, 0.5824625195410956, 0.6362087278642388, 0.7120915651606274, 0.2657932524112119, 0.698465498243594, 0.7248261808594283, 0.7721834860271215, -0.3615442711852844, -0.2184954487645845, -0.19037039054822674, -0.150659863525642, -0.37727497839042917, -0.15494092102232707, -0.14140179203870623, -0.117069533970273, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.518599177328451, 0.5185901464813634, 0.5411280214435648, 0.5910793865961331, 0.7045926425977271, 0.37337337337337323, 0.28637441868760155, -0.3153153153153152, 0.3746987951807229], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.6975427865982056, "ela_features": [0.006409917407173715, 0.48096035994044073, 0.008317682966422173, 0.03546426758300225, 7.178287324654612, 0.004575282790122914, 0.37025176683230104, 1.2072150924825327, 0.36742024755670305, -0.1310906901625481, -0.03255827786868384, 1.4, 0.667771897688354, 0.8176111426875334, 0.4614667875604105, 0.22737624801959527, -0.6029101494805484, 0.6295085144344021, 0.6976285903034972, 0.7519910639193006, 0.833879959628266, 0.6212305738058479, 0.6902957242748032, 0.7445378123393807, 0.8282643649731789, -0.32595676107832544, -0.2660229448571038, -0.21819644287248904, -0.14615109995407466, -0.335044476370985, -0.2739453855818479, -0.22596802363339394, -0.151909776191704, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21350392388728195, 0.2134771676779151, 0.20166693837016675, 0.18615315381134803, 0.8624384415098951, 0.4454454454454453, 0.3957536127149169, -0.19119119119119116, 0.6493589743589744], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.003447022521868348, "ela_features_10D": [0.009477508766923392, 0.4609140657745616, 0.002554115098692836, 0.027988945968580214, 21.976845008926453, 0.011343654603394126, 0.359118060435964, 1.2292503179405483, 0.3591033571358327, -0.04985049027510951, -0.0033287558777174374, 2.0, 0.830417223464399, 0.9092452102350158, 0.5756022259758317, 0.12960343423327597, -0.6289622058481356, 0.7629193699285064, 0.8043257181138983, 0.8374454860768121, 0.8850031368549214, 0.7605598645382982, 0.8030386231441302, 0.8372189634140115, 0.8852920442258471, -0.30069238198731274, -0.24817616271010237, -0.20616975540281995, -0.14585244557736146, -0.30453086205996044, -0.2505044314183755, -0.20703125046532808, -0.14589197447374325, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11002491430307759, 0.11002059608740977, 0.10768819032642889, 0.10398672678413297, 0.8660795667832171, -0.01901901901901903, 0.1484529263378182, -0.6036036036036034, 0.6428342674139312], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0018361177062615752}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-4.00000000000011, -4.00000000000011], 1.5], [21, [-4.00000000000011, 0.00044444444444512003], 0.7500001975308642], [21, [0.00044444444444512003, -4.00000000000011], 0.7500001975308642], [49, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0162337101856229e-162, -1.2108274972452988e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.414235986733205e-162, -9.076939856454842e-163, -7.020869037803807e-163, -2.690148809314411e-163, 1.1343244926004757e-162]}
{"id": "85a9a836-e812-4d32-9e29-227eabe42c69", "fitness": 0.6658609674486797, "name": "landscape", "description": "A novel separable landscape built from a 1D oscillatory-quadratic base per dimension. Each dimension uses g(t) = t^2 + A*(1 - cos(\u03c9 t)) with t in [-5,5]. The global minimum is at t=0 (per dimension), so the global optimum is at x=0 with f(x)=0. The cosine term introduces multiple local minima, creating a challenging but separable landscape across dimensions. GlobalLocal is computed as the ratio of the strongest non-global local minimum to the mean landscape value over the domain, providing a scalar difficulty descriptor of local minima contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5, A=2.0, omega=3.0, grid_points=4001):\n        \"\"\"\n        dim: number of dimensions\n        A: amplitude of the oscillatory term in the 1D per-dimension function\n        omega: frequency of the oscillatory term\n        grid_points: resolution used to estimate the GlobalLocal metric (per-dimension)\n        \"\"\"\n        self.dim = dim\n        self.A = A\n        self.omega = omega\n        self.grid_points = int(grid_points)\n        # GlobalLocal descriptor for the landscape, computed once at init\n        self.GlobalLocal = self._compute_global_local_metric()\n\n    def _g(self, t):\n        # 1D landscape component: g(t) = t^2 + A*(1 - cos(omega * t))\n        return t**2 + self.A * (1.0 - np.cos(self.omega * t))\n\n    def _compute_global_local_metric(self):\n        \"\"\"\n        Estimate a GlobalLocal metric for the 1D component by scanning the domain [-5,5].\n        Global minimum is at t=0 with value 0.\n        Local minima are identified (excluding t=0), and the strongest local minimum value\n        is compared to the mean value of g over the domain.\n        GlobalLocal = max_local_min / mean_g\n        \"\"\"\n        t = np.linspace(-5.0, 5.0, self.grid_points)\n        y = self._g(t)\n\n        # Identify local minima: points where y[i] <= y[i-1] and y[i] <= y[i+1]\n        if y.size < 3:\n            return 0.0\n        interior = y[1:-1]\n        left = y[:-2]\n        right = y[2:]\n        is_local_min = (interior <= left) & (interior <= right)\n\n        # Corresponding t-values for local minima (excluding the global minimum near t=0)\n        t_candidates = t[1:-1][is_local_min]\n        minima_values = interior[is_local_min]\n\n        # Exclude the global minimum at t ~ 0 (t=0 is often present in the grid)\n        if t_candidates.size > 0:\n            step = t[1] - t[0]\n            non_global_mask = (np.abs(t_candidates) > step * 0.5)  # exclude near-zero points\n            minima_values = minima_values[non_global_mask]\n        else:\n            minima_values = np.array([])\n\n        max_local_min = float(np.max(minima_values)) if minima_values.size > 0 else 0.0\n\n        mean_g = float(np.mean(y))\n        if mean_g <= 0.0:\n            return 0.0\n        return max_local_min / mean_g\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the separable landscape: f(x) = sum_i g(x_i)\n        Where each g is the 1D component defined above.\n        x must be a 1D numpy array of length 'dim' with values in [-5, 5].\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}.\")\n        # Clip to domain to ensure evaluation is within bounds\n        x = np.clip(x, -5.0, 5.0)\n        # Compute per-dimension g(x_i) and sum\n        g_vals = self._g(x)\n        return float(np.sum(g_vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0016316911175858983, 0.3596844648300207, 0.01325899185105742, 0.028276822577544013, 2.8237188826067894, -0.0008126919847514236, 0.9653008982083934, 1.008815551228895, 0.9653138922536337, 0.45482004959846256, -0.26157539358793896, 2.2, 0.5645920648118581, 0.6895818654315273, 0.48445425457655916, 0.3503559278621935, -0.23060885191730582, 0.22669103433666762, 0.32212718886852937, 0.3796730006786465, 0.5003895349267111, 0.2223519844934863, 0.3217571173388405, 0.3838897806258662, 0.5015089773942397, -0.404675014775992, -0.3547310666145314, -0.3246072486255419, -0.26143624484143413, -0.399878982365686, -0.3487740638944076, -0.31679112530404147, -0.2563000455432496, 1.0, 1.0, 1.0, 1.0, 0.5200844636343908, 0.5200798563734707, 0.4241788172954516, 0.35435027390521406, 0.729281527584881, 0.5135135135135134, 0.5447020683078139, -0.06306306306306309, 0.38714859437751004], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9945996999740601, "ela_features": [-0.0013172577274455533, 0.39740152544722507, 0.0042655437198055165, 0.019213725939400052, 5.308391953535569, 0.006895878863269145, 0.9657625639813888, 1.0264130754436276, 0.9656515343936801, 0.29554467160402037, -0.11289924917695773, 1.4, 0.8863039645310581, 0.8639291074085866, 0.624705700283258, 0.19229091548278995, -0.4682331452545183, 0.475498734517696, 0.5425848115165149, 0.6131585121739709, 0.7251816483575553, 0.47190644468220677, 0.5430170381109803, 0.6151199680274062, 0.728146507616247, -0.4613378258066043, -0.40232993288682295, -0.34025592026916895, -0.24172372583085844, -0.4669403501662587, -0.4040618094453884, -0.3403120848595268, -0.24037476806544006, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2168918641801854, 0.21688206596194162, 0.20316262267226098, 0.18159732520725755, 0.8392819037764617, 0.1611611611611611, 0.24959806701287784, -0.37537537537537524, 0.5344551282051283], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00026139934197999537, "ela_features_10D": [-0.0008640999428170427, 0.42032564761637453, 0.0007206757026828516, 0.018114280005581147, 74.53768153911997, 0.004587864351289328, 0.9656180315555172, 1.0395820395619189, 0.9654778329085307, 0.2031900693025841, -0.09223656019614168, 1.4, 1.009613445664212, 0.937018042787207, 0.7044058889424183, 0.10574195661432458, -0.6120637829096414, 0.6301525829927035, 0.6865211707771771, 0.7358584443570036, 0.8110021423316741, 0.6338961483816243, 0.6887808303350271, 0.7400747306102249, 0.8153821228265761, -0.46904520867539307, -0.3975580678156188, -0.33498773720313346, -0.23968961847787634, -0.4654884981471533, -0.395704639280786, -0.33048534238022287, -0.23473509017833716, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10962465221501234, 0.10963108432932826, 0.10668146137877507, 0.10000733703644882, 0.8549953189237236, -0.11911911911911907, 0.12992871768732028, -0.6436436436436435, 0.5903923138510809], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0003047053760383278}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950616757018855e-06], [8, [0.00044444444444512003, -1.869777777777863], 3.93322324364782], [8, [-1.869777777777863, 0.00044444444444512003], 3.93322324364782], [16, [-1.869777777777863, -1.869777777777863], 7.866442536678883], [16, [1.869777777777864, -1.869777777777863], 7.866442536678884], [16, [-1.869777777777863, 1.869777777777864], 7.866442536678884], [8, [1.8700000000003303, 0.00044444444444512003], 3.9332226518931415], [8, [0.00044444444444512003, 1.8700000000003303], 3.9332226518931415], [16, [1.869777777777864, 1.869777777777864], 7.866442536678885]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.2449225067104494e-162, -7.893588909892723e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2406596612081419e-162, -1.8571877810375463e-163, 1.3504302242322532e-162, 1.533396014829915e-162, 1.0753374298078266e-162]}
{"id": "81aefca4-3c83-4278-815f-8eb7e8531587", "fitness": 0.6432368720221954, "name": "landscape", "description": "A separable, Rastrigin-inspired benchmark with tunable global-local contrast. Each dimension contributes a 1D landscape g(u) = A + u^2 - A*cos(2\u03c0u). The full function is f(x) = sum_i g(x_i) = A*dim + sum_i [x_i^2 - A*cos(2\u03c0x_i)]. The global minimum occurs at x = 0 (f = 0). The cos term creates many local minima across each dimension, producing clear global-local peaks and a strong contrast that scales with A and dim. This makes the landscape suitable for benchmarking exploration vs exploitation, while remaining fully separable and bounded to [-5, 5] per dimension.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5, A=10.0):\n        \"\"\"\n        Initialize a separable, cosine-perturbed quadratic landscape.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - A: float, amplitude of the cosine term controlling local minima count/height\n        \"\"\"\n        self.dim = int(dim)\n        self.A = float(A)\n\n        # Global minimum per-dimension value (for this standard Rastringin-like form, it's 0 at x=0)\n        self.global_min_per_dim = 0.0\n\n        # Local minima per-dimension (approximately the lowest non-global minima, e.g., near x ~ 1)\n        # For the 1D case f_i(1) = A + 1 - A*cos(2\u03c0*1) = A + 1 - A = 1\n        # The smallest non-global-local value is thus 1 per dimension when using this form.\n        self.local_min_per_dim = 1.0\n\n        # Global-local contrast metric (per-dimension difference, scaled by dim)\n        self.global_local_contrast = self.local_min_per_dim - self.global_min_per_dim  # equals 1.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape function at point x.\n\n        The function is:\n            f(x) = A*dim + sum_i [ x_i^2 - A * cos(2\u03c0 x_i) ]\n\n        Domain: x_i in [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar value of the landscape at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds (optional; ensures evaluation respects problem bounds)\n        x = np.clip(x, -5.0, 5.0)\n\n        return self.A * self.dim + np.sum(x**2 - self.A * np.cos(2 * np.pi * x))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.001626366942364843, 0.4567754871829736, 0.013200920794220819, 0.027694542892055373, 2.6906920124083187, -0.0007408418050836474, 0.5006533944517901, 1.0170739919806169, 0.4988087513666999, 0.095837417707345, -0.40618987178591776, 1.0, 0.35393914361186557, 0.5572780522436924, 0.3481866599342441, 0.43015880960787234, -0.492063578182656, 0.404215033200758, 0.4821729960161744, 0.5762141874415934, 0.6689826183834654, 0.40139895111590873, 0.47726139599066303, 0.5757199760609563, 0.6516194587578026, -0.3118951547771488, -0.271082243197261, -0.22184586922980792, -0.17328494958915117, -0.307955947039617, -0.26892965193786483, -0.21826688401186675, -0.17922741208854448, 1.0, 1.0, 1.0, 1.0, 0.5072443407937404, 0.5072112010424429, 0.4177516038011542, 0.35122383171092697, 0.8306057500096736, 1.0300300300300296, 2.220754753513928, 0.6136136136136134, 0.5397590361445783], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8538320660591125, "ela_features": [-0.0009520848509416479, 0.4696767111567094, 0.001513623082836571, 0.02523271132616678, 74.58760828111942, 0.006293362641114531, 0.5109945799160405, 1.1259606866333494, 0.5113468184170233, 0.027540161986810856, -0.2288362616370141, 1.0, 0.6902953823860785, 0.8225252793311417, 0.46635338081925426, 0.22522140186768275, -0.5871167260333345, 0.6390793581305743, 0.6929466193629376, 0.7338603797840799, 0.8074584638075614, 0.6327668466370977, 0.6836696992487531, 0.7278035067932183, 0.8036707261756252, -0.317417780234333, -0.2700435941915626, -0.23406142692413479, -0.16933464371725518, -0.32471206671193537, -0.27970297740385675, -0.24068127933190575, -0.1735995380546506, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21686583762586337, 0.21688567418399352, 0.2038262981589663, 0.18236820341216542, 0.8751538787736667, 0.4774774774774773, 0.3787721517320243, -0.19119119119119116, 0.6237179487179487], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.004350725095719099, "ela_features_10D": [-0.0008641247978355526, 0.45697279042592454, 0.001434214359568629, 0.018270032392687843, 21.78555115697486, 0.000682005276541675, 0.5169556408743408, 1.2337735736866304, 0.516037033615534, 0.12730193249533536, -0.0840518015159164, 1.0, 0.8578327633317298, 0.9149029094011306, 0.5797386721023449, 0.12727031750691312, -0.6230655357290593, 0.7628420119271369, 0.792440071142367, 0.8239063165607176, 0.8691450416289254, 0.7611384369141769, 0.7924814581278823, 0.8245272768140792, 0.8701524403307476, -0.3007836831501072, -0.2632445215928217, -0.2233369395547183, -0.16596111849365774, -0.3037328481935927, -0.26387500281205706, -0.2231277728442252, -0.16511122389851884, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10971804089179729, 0.10971702580145495, 0.10686153622039211, 0.10074814849395368, 0.869595520327265, 0.013013013013012983, 0.1632582190152286, -0.5635635635635634, 0.643955164131305], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0012384409783408046}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-3.888888888888889, -3.888888888888889], 34.92602471786735], [1, [3.8888888888888893, -3.888888888888889], 34.92602471786736], [1, [-2.7777777777777777, -2.7777777777777777], 31.959135212093543], [1, [2.7777777777777786, -2.7777777777777777], 31.95913521209348], [1, [-2.7777777777777777, 2.7777777777777786], 31.95913521209348], [1, [2.7777777777777786, 2.7777777777777786], 31.95913521209341], [1, [-3.888888888888889, 3.8888888888888893], 34.92602471786736], [1, [3.8888888888888893, 3.8888888888888893], 34.926024717867364], [1, [4.973953208581327, -4.974000042104592], 49.74764620390462], [1, [-4.974000042103818, 4.973953209008633], 49.747646203781294], [1, [-4.973953208026169, -4.974000042105585], 49.74764620406486], [1, [4.975345032752111, 4.973964855925408], 49.74763296774867], [2, [-1.000641598888815, -0.9946001680011068], 1.996349402834987], [1, [0.9448665939801723, -2.6130750026131437], 25.89551532617113], [1, [-2.6130762932575324, 0.9448673478577677], 25.89545452472477], [1, [2.611998133455709, 0.9465529437276284], 25.90158631933732], [1, [-4.9267534972366835, 3.934193492252561], 41.63393309343034], [1, [-3.93419344993701, 4.926752547097713], 41.633950981803906], [1, [4.9267535786253, 3.9341935389002702], 41.633930813521175], [1, [3.9356534979574853, 4.925386974259838], 41.633952010876165], [1, [3.935652828727382, -4.925386787748474], 41.63396674187557], [1, [4.926755070792207, -3.934195022537292], 41.63387809502309], [1, [-3.934194070150736, -4.926754494869439], 41.63390504120814], [1, [-4.925386781873466, -3.9356523616072114], 41.63397471969691], [1, [2.8882883362535727, -4.86266643983025], 37.8491702620021], [1, [-2.8897712824045887, -4.861326739566219], 37.84906269847967], [1, [-4.861323954703317, -2.8897674187343], 37.84930219443531], [1, [2.889768485878179, 4.861325183121878], 37.849218430917574], [1, [-4.862664859607076, 2.8882832647748597], 37.84940677838037], [1, [-2.8882841980381717, 4.862665984077474], 37.84933156564648], [1, [4.861322764558108, 2.88976559065839], 37.849410622727646], [1, [4.862665515735331, -2.888283210746921], 37.84938371878021], [1, [0.945373904972488, 2.6100108041184824], 25.99384818166125], [1, [2.6099412406297384, -0.9453311961751175], 25.997093259989008], [1, [-0.9453298545949497, 2.609938966174245], 25.997198291626574], [1, [3.8211235390151224, 2.8457745059301547], 32.71684013325314], [1, [2.8457774691750077, 3.821126638481932], 32.71655158652972], [1, [3.8266727784353285, -2.8400124002320615], 32.716868550177104], [1, [2.847234319351604, -3.819756483579566], 32.71695233973148], [1, [-2.845776420505906, 3.8211254486702386], 32.71665825611126], [1, [-3.818402789329972, 2.8487066923867648], 32.71663648384226], [1, [-2.8414399833553996, -3.8252720726166216], 32.71691794844017], [1, [-3.819756277702427, -2.8472341528273017], 32.71697010195877], [1, [-0.9385634615769416, -2.6258727637317154], 25.544135447477846], [1, [-2.6224411568160386, -0.938832626684052], 25.671926045621774], [1, [0.8925990828403277, 0.8481563363497032], 7.924164180751365], [1, [1.8624510763113262, 1.0022054378605643], 7.981957128029299], [1, [1.862205700243982, -0.9912603606213317], 7.985072030070365], [3, [1.9906047458766953, 1.9726468545878482], 8.018586282844426], [1, [-0.9364787325596498, 0.8237665326987884], 7.870819089429588], [1, [0.9970786455610019, 1.8623311388212194], 7.977718626378982], [1, [-0.9910614408504781, 1.8623537247268387], 7.9788421889651495], [1, [-1.8623151840462788, 1.0032299703169183], 7.991101459080591], [1, [-1.8620852854058156, -0.9896946661148998], 7.993168498944021], [1, [0.8227161199893931, -0.934596290064024], 7.971307136211367], [1, [-4.777171230476823, 1.9333916338453943], 35.723486532551334], [1, [1.9333907629154763, -4.777171425317848], 35.72349520150683], [1, [-4.7793140884375145, -1.9336216320388722], 35.606466272138], [1, [-1.9346713934464927, 4.774784100630263], 35.82124493371782], [1, [4.7784578768826975, -1.931889667038031], 35.68912398592693], [1, [4.777686250296036, 1.9337333886187427], 35.68914318266583], [1, [1.9337318079500945, 4.777682694240431], 35.689363319732855], [1, [-1.9322693117556224, -4.7796451926530965], 35.61870421141556], [1, [1.8279182517861914, 3.75878505447135], 32.21554231802786], [1, [3.762908886716101, 1.823560193579233], 32.2155400261421], [1, [-3.760152743311928, 1.8264588341615484], 32.21583350008759], [1, [-1.826460355032266, 3.760154239851064], 32.215671728728594], [1, [1.822113287447765, -3.764289738881613], 32.21577054757219], [1, [3.760152954756336, -1.8264591626820856], 32.21580472677011], [1, [-3.7587844923013485, -1.8279177341090367], 32.21560017355472], [1, [-1.829378221464403, -3.7574181880512114], 32.21562140709875], [3, [-1.9902621452748377, 1.971104040853263], 8.029472068681807], [1, [0.9939724200193522, -1.8612505299376443], 8.02482130838369], [3, [-1.9700934372612355, -1.989246604024242], 8.037216159364272], [1, [4.724381063781814, 0.9612467329896635], 35.141499317851085], [1, [4.726269679144942, -0.9603176074869904], 35.05456143527227], [1, [0.962060063003541, 4.725675845658626], 35.06275145641282], [1, [0.9616813445454074, -4.725126066343242], 35.096605307736645], [1, [-4.725102703720418, 0.9616744850613491], 35.097924118361874], [1, [-0.9612292090589967, 4.726531376113678], 35.02854983607845], [1, [-0.9607042305483356, -4.7277327926600305], 34.972199108496255], [1, [-4.7364121873225615, -0.9375224144810856], 34.925925191231045], [3, [1.9711745508113774, -1.9882643968530858], 8.029464327085522], [1, [0.844662804705538, -3.7145051379302134], 31.11947162505661], [1, [3.7567798446251293, -0.802094833930107], 31.11581064968757], [1, [-0.8076932528411449, -3.7510377175871574], 31.11134669573635], [1, [-3.714577740560771, -0.8447028474695741], 31.113545915985085], [1, [3.7540690460369928, 0.8051051523240076], 31.091996075391478], [1, [0.8449432572256951, 3.7147401397314437], 31.092702526620798], [1, [-3.7540912563005753, 0.805103805542241], 31.090845210793084], [1, [-0.8449505431640557, 3.7147464528645733], 31.091996055410196]], "nr_of_basins": 91, "f_opt_dim_2": 0.9949590570932898, "x_opt_dim_2": [0.9949586384543628, 6.214314603977733e-11], "f_opt_dim_5": 4.974790247647377, "x_opt_dim_5": [0.9949586386345514, -1.424064891558378e-09, -1.9899122324238019, 1.2558858743206782e-09, 3.02643360844506e-09]}
{"id": "624b3ddf-1c3e-4f6d-a5cb-0fd523eca099", "fitness": 0.6648322427645326, "name": "landscape", "description": "A separable rugged landscape with per-dimension non-convex wells created by a quadratic term modulated by a sine wave. The global minimum is at x = 0 for every dimension, while the sinusoidal modulation introduces multiple local basins within the domain [-5, 5], producing a clear global-local minima contrast. The problem is separable, making it easy to partition into subproblems.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Parameters controlling ruggedness and scale\n        self.a = 0.6  # amplitude of the sine modulation (kept < 1 to keep positive basins)\n        self.b = 3.0  # frequency of the modulation\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n        # Separable 1D landscape: g(x) = x^2 * (1 + a * sin(b * x))\n        gx = (x ** 2) * (1.0 + self.a * np.sin(self.b * x))\n        return float(np.sum(gx))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.004,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.025645400090767923, 0.16635864377001913, 0.0688350523590685, 0.08636438121189154, 1.2676839379282583, 0.029343354530873157, 0.7033896325586442, 1.0355117835804653, 0.7836892420653665, 0.9980950474438263, 0.7191618438142243, 1.6, 0.42319258732995013, 0.6423272567063203, 0.33598685768469394, 0.3716846772647906, -0.2586825636917641, 0.14885031922518308, 0.2389873806827943, 0.32453500200427776, 0.5232221244773179, 0.14954389630250794, 0.23595404465143743, 0.32241931000376217, 0.516214784608657, -0.44539625376734177, -0.3982273996334547, -0.3534604537650444, -0.24948582518897622, -0.4370725777590766, -0.3926687072860785, -0.3482144978397487, -0.24861376416384276, 1.0, 1.0, 1.0, 1.0, 0.5209773725658264, 0.5209645667890095, 0.43409220270461296, 0.3869045011317611, 0.7299654657529983, 0.7497497497497496, 0.49751431435451127, 0.021021021021021005, 0.43654618473895584], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9413847327232361, "ela_features": [0.021991609655733546, 0.22660339497203857, 0.01923320391574976, 0.05923247244186286, 3.790728819230739, 0.02613851930383886, 0.7087649996655844, 1.106196681662407, 0.7831646476316674, 0.6103433246853547, 0.15431080447978635, 1.4, 0.7744833616634448, 0.8417955557532922, 0.5435723449586198, 0.20717494166412248, -0.5116897976641247, 0.480830248680508, 0.5715023598625855, 0.6514415616110453, 0.760616832368765, 0.48541519701747937, 0.5662323082195205, 0.6483755069072034, 0.7579140546177605, -0.45677623460921507, -0.3770017520838267, -0.30666745070722473, -0.2106143833343058, -0.45515708784732284, -0.3836756357091612, -0.31101368710689303, -0.21412914063104482, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21639310996896866, 0.2164270967212225, 0.20263848130079834, 0.19300011712044043, 0.8553569508962419, 0.36536536536536524, 0.32271191923842646, -0.26726726726726724, 0.5991987179487179], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.04375904053449631, "ela_features_10D": [0.02871067427653722, 0.2363661536482058, 0.014712837285583338, 0.044415384575848316, 3.812829329481409, 0.03288207249625141, 0.7021985871833569, 1.1604114978007376, 0.7758310607874512, 0.48379932135086945, 0.22671645365735166, 1.2, 0.9422961418081272, 0.9264092470587114, 0.645402801932627, 0.11592575601521504, -0.5908460388667344, 0.6630342470256326, 0.7228620529182452, 0.7715854037107308, 0.8395155306732314, 0.6617979281702944, 0.7235996312398296, 0.7721069184556864, 0.8409419341136957, -0.4273506221342787, -0.3514755807817311, -0.2896829134113197, -0.2035316205048118, -0.43003271220920575, -0.3514520200952431, -0.2897729294591169, -0.2022468904974526, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10915126714520211, 0.10914602944779814, 0.10642552844860206, 0.1085739968021084, 0.8629721780294715, -0.031031031031031032, 0.14261012743533613, -0.6076076076076073, 0.6247397918334668], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.003849683329463005}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], 69.50863520471351], [4, [-4.680888888888802, -4.680888888888802], 17.64589089939856], [3, [5.0, -0.00044444444444512003], 34.7543177997296], [3, [-0.00044444444444512003, 5.0], 34.7543177997296], [6, [-0.00044444444444512003, -4.680888888888802], 8.82294564707212], [6, [-4.680888888888802, -0.00044444444444512003], 8.82294564707212], [9, [-0.00044444444444512003, -0.00044444444444512003], 3.9474567910718954e-07], [2, [5.0019351486180605, 1.3486876001559978], 35.6758853025408], [2, [1.3666803717685676, 5.0014261229822505], 35.6760301120453], [4, [1.4586666666666668, -4.680888888888802], 9.745580158329638], [4, [-4.680888888888802, 1.4586666666666668], 9.745580158329638], [6, [1.4586666666666668, -0.00044444444444512003], 0.9226349060031984], [6, [-0.00044444444444512003, 1.4586666666666668], 0.9226349060031984], [4, [1.4550418753280718, 1.3925569810511353], 1.8607855613428375], [2, [-4.672891244549774, 5.000165585895857], 43.577191803337044], [2, [3.6228016249535075, -4.675546431802337], 14.137796694753257], [2, [-4.675546401092696, 3.622802992986518], 14.137796626181476], [5, [3.6233805449905576, 0.002086120349826], 5.313446204400883], [5, [0.0021150701737812187, 3.6233868247739887], 5.313446179895215], [3, [-2.5542516144744862, -2.519757862732809], 5.384946413655529], [2, [-4.668160018678127, -2.555993070852276], 11.512469139188578], [2, [-2.5567441132853443, -4.671766817866232], 11.508087088652099], [2, [-2.557232933491646, 1.4255401098996796], 3.6075960349477563], [2, [-2.5574721450455224, 0.0013754750509927557], 2.6807756012699726], [2, [1.4273674827420044, -2.5572884916091767], 3.607159593754393], [2, [0.0013755401404534186, -2.557472602278682], 2.6807755879863793], [1, [5.000482919864393, -2.5337839414478376], 37.43480289837377], [2, [5.000166279749159, -4.672891238983715], 43.57717772095942], [1, [-2.5357826420321716, 5.000409704819018], 37.43482257562781], [1, [3.6064865874325616, -2.5561365875988864], 8.004253895707436], [1, [-2.556131216306026, 3.6064898900435933], 8.004250488128859], [1, [5.000402812029123, 3.6128913859944247], 40.063533965829095], [1, [3.624400656441767, 3.6196774338933744], 10.627446567023181], [1, [3.6128913153482944, 5.000347319552899], 40.06466197710909]], "nr_of_basins": 34, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.9784517655508257e-163, 1.3827646277210266e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.4131186299074e-163, 1.5503808531019264e-162, 1.7882166177039282e-163, 3.304218351893382e-163, -8.582179186135388e-163]}
{"id": "1b3c4ddb-5b10-4e7e-9302-c275d1a65228", "fitness": 0.6638243788232406, "name": "landscape", "description": "A separable, non-convex benchmark with a global minimum at the origin and periodic ripples per dimension to create local minima; The per-dimension function g(t) = t^2 + gamma*(1 - cos(k*t)) introduces nonlinearity while preserving separability. The global optimum is at x = 0 with f(x) = 0, while local minima arise from the cosine ripple, providing a controllable GlobalLocal contrast through gamma and k.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Hyperparameters controlling the local minima landscape\n        # gamma controls the amplitude of the periodic perturbation\n        # k controls the frequency (how many ripples per unit length)\n        self.gamma = 5.0\n        self.k = 2.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimensionality.\")\n        # Per-dimension landscape: g(t) = t^2 + gamma * (1 - cos(k * t))\n        g = x**2 + self.gamma * (1.0 - np.cos(self.k * x))\n        return float(np.sum(g))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.002,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.002108969946451822, 0.40204478178831016, 0.007540321166197921, 0.0243169030263825, 11.829768442024537, -0.003680484736152101, 0.8560997208999606, 1.0283732104693286, 0.8560952438995095, 0.5927528979673676, 0.005450771015976308, 1.6, 0.4598533834364881, 0.6636135211417635, 0.4041380848830797, 0.36148325009877796, -0.2526167324809945, 0.1386443109793764, 0.31988739973278146, 0.4694479387304292, 0.5730643449756186, 0.1427037896663915, 0.27717912968113084, 0.4766199058612262, 0.5749830537159102, -0.45067415307431197, -0.35584271616835295, -0.2775884218418391, -0.2233768867703204, -0.4401300909599974, -0.3710633574075965, -0.26869330569569877, -0.21819401194555854, 1.0, 1.0, 1.0, 1.0, 0.5136828240009933, 0.5136666601972761, 0.42095477615242977, 0.35180598768097165, 0.7345675841333501, 0.5015015015015013, 0.6465679088517544, -0.003003003003003022, 0.40562248995983935], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9776057600975037, "ela_features": [-0.0009634406052628552, 0.3919241299597044, 0.0036138821419551687, 0.017318521795291735, 7.686061010296591, 0.005032356807602989, 0.849936135537062, 1.0574337457027276, 0.8494030303742269, 0.40664854223091706, 0.13977937156917264, 1.4, 0.8003704850520217, 0.8547274731894443, 0.5527745498168241, 0.19898076321130886, -0.5209963124890612, 0.5390593790144906, 0.5967831537129721, 0.6567924834250327, 0.7453662652339822, 0.5357613197895505, 0.5941788972319578, 0.6521500982184791, 0.7455162324314284, -0.4054414332262682, -0.35466655414221454, -0.3018829738600748, -0.22397366558444493, -0.41047105862328126, -0.35881398272702886, -0.30755732656688284, -0.225004712547397, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21525692683280231, 0.21527370994378833, 0.20323050271557896, 0.18236011787988354, 0.8521642120082816, 0.23323323323323314, 0.28281017427822286, -0.30730730730730726, 0.5740384615384615], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.002866509836167097, "ela_features_10D": [-0.0001284606099638763, 0.45452903273074863, 0.0019246485015939007, 0.020800884383289982, 13.194512690600499, 0.00699419171329938, 0.8469639501149342, 1.0671050036551835, 0.8464303101349504, 0.2449412219172858, -0.05266560434395044, 1.6, 0.9673351857952971, 0.9326041501160365, 0.6549683803976916, 0.11197531324567778, -0.6156244071268914, 0.6700805590128522, 0.719401032516674, 0.763093926504611, 0.829256593116986, 0.6701555618101033, 0.7210637448096687, 0.7649175505209417, 0.8321951704102144, -0.4184487584638563, -0.3558936411440797, -0.3004762820179826, -0.21655990883798615, -0.4195050536698159, -0.3547585149637931, -0.2989836950863811, -0.21341858763488367, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1103757194589868, 0.11036885301387785, 0.1071645948107739, 0.10098176855303184, 0.8622452646813841, -0.039039039039039054, 0.14756181345460326, -0.6036036036036034, 0.611128903122498], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.002474003005772829}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-2.839777777777771, -2.839777777777771], 17.89586894889168], [12, [0.00044444444444512003, -2.839777777777771], 8.947936647285214], [12, [-2.839777777777771, 0.00044444444444512003], 8.947936647285214], [16, [0.00044444444444512003, 0.00044444444444512003], 4.34567875191444e-06], [9, [2.8397777777777717, -2.839777777777771], 17.89586894889168], [9, [-2.839777777777771, 2.8397777777777717], 17.89586894889168], [12, [2.8397777777777717, 0.00044444444444512003], 8.947936647285214], [12, [0.00044444444444512003, 2.8397777777777717], 8.947936647285214], [9, [2.8397777777777717, 2.8397777777777717], 17.89586894889168]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0354277134555143e-162, 1.2270019452210025e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.6497592562579994e-163, 3.631131642403249e-163, -1.3656778822020674e-162, -9.124504535261107e-163, -7.983197936059305e-163]}
{"id": "560e4325-4788-4a2a-8f95-9e38a29946fe", "fitness": 0.5582804257671038, "name": "landscape", "description": "A separable, multimodal landscape built from per-dimension \"min-of-quadratics\" wells. Each dimension has multiple local minima (at predefined wells) with the global minimum at x = 0. The local-minima depth contrast is controlled by a contrast parameter, creating a measurable global-local peak distinction while keeping the problem separable and bounded to [-5, 5].", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: the span of wells along each axis: wells lie in [-L, L]\n        contrast: scales the depth of non-global wells (GlobalLocal control)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n\n        # Build well positions per dimension\n        s = np.linspace(-self.L, self.L, self.wells)  # initial well positions\n        idx_zero = int(np.argmin(np.abs(s)))\n        s[idx_zero] = 0.0  # ensure a well exactly at 0 for the global minimum\n\n        # Sort wells by distance to zero so that depths can be assigned monotonically\n        order = np.argsort(np.abs(s))\n        self.s = s[order]\n\n        # Depths: 0 for the closest well to zero, increasing with distance from zero\n        depths = np.arange(self.wells, dtype=float) * self.contrast\n        self.d = depths[order]\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_j)^2 + d_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        total = 0.0\n        for i in range(d):\n            t = x[i]\n            vals = (t - self.s) ** 2 + self.d\n            total += float(np.min(vals))\n        return total", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.013,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.9862412081978824, -0.09580908056414474, 0.549144569222807, 0.5543890225364294, 1.009546259249881, 0.9863751741261787, 0.9906752596343068, 1.0788677981133732, 0.9946436993840108, 0.06719049640538426, -0.6622386967051967, 1.0, 0.7040898933205334, 0.7183583455503834, 0.5382040281314038, 0.34013509727017577, -0.101837867243514, 0.14161097491262037, 0.22102387249058258, 0.3215979416494294, 0.5331177529327432, 0.14605604122576327, 0.21942159652874924, 0.3183570281211937, 0.5183887621795048, -0.4493907917140749, -0.40781553216240063, -0.3551597461660408, -0.24442556241244953, -0.4390411086690764, -0.4013170626248015, -0.3504412082485801, -0.24759771716470205, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5188555787619346, 0.5188263370291997, 0.6108895556715817, 0.6609396790212142, 0.7514507677143862, 0.11711711711711707, 0.3291128262354678, -0.3433433433433432, 0.38473895582329315], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.33387771248817444, "ela_features": [0.9860900389267568, -0.17126873122547598, 0.2603588084919247, 0.2647783197675882, 1.0170712826941444, 0.9861233633975853, 0.99070191733871, 1.2019576053385819, 0.994495209466676, 0.04054615059969205, -0.2946939013944457, 1.0, 0.8409436030051805, 0.8624337642559554, 0.6257711064762784, 0.18843595521909756, -0.26533787975231393, 0.5215666408674859, 0.6370339107262566, 0.7247860488767364, 0.839384306742091, 0.5166266262578084, 0.6236091728311395, 0.715786822423928, 0.8330458858530339, -0.4208773782623575, -0.3193029894697137, -0.24210531414275702, -0.14129247609770193, -0.42749301116857696, -0.33287944962829535, -0.2513593916098634, -0.14765322519146398, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21448662092350973, 0.21450279291037008, 0.2547885671940241, 0.33401896966421896, 0.8065721753244585, -0.23923923923923915, 0.13277548752551843, -0.6956956956956954, 0.4645833333333333], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0030989646911621094, "ela_features_10D": [0.9862059321180873, -0.3139303329707631, 0.16161900519742087, 0.16495418377664525, 1.0206166033401964, 0.98634664820352, 0.9906811112577028, 1.2800253192933007, 0.9947865138640306, 0.052795468069834685, -0.12219959108100742, 1.2, 0.8777097884813185, 0.9192482861486415, 0.678248866680821, 0.11558081926289931, -0.37805533626910337, 0.7736296226207604, 0.8190529360061779, 0.8602800678254698, 0.918664456562519, 0.7722878017906704, 0.8200462372202162, 0.8603586912531448, 0.9185658194380322, -0.2870533162950212, -0.22945313596492176, -0.17717382394417996, -0.1031391374292459, -0.2894769365280051, -0.22876404291902191, -0.1775161562020399, -0.10352227287621255, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11060058544412746, 0.11059504375892877, 0.12535378763130844, 0.18215917677525267, 0.8286272848897355, -0.4074074074074073, 0.08039352927316418, -0.9039039039039037, 0.5128102481985588], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.012705877423286438}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, -4.00000000000011], 2.4259050557356555e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, -4.0], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.0, -4.0, -4.0, -4.0, -4.0]}
{"id": "4dce3fa0-fa4d-4a1a-85eb-9a1b4b079107", "fitness": 0.6673470108071342, "name": "SeparableRuggedLandscape", "description": "A novel separable rugged landscape where each dimension has its own sinusoidally modulated quadratic base, with per-dimension parameters, preserving a global minimum at the origin while creating diverse local basins. The function remains fully separable, enabling easy decomposition into subproblems.", "code": "import numpy as np\n\nclass SeparableRuggedLandscape:\n    \"\"\"\n    A separable rugged landscape with per-dimension non-convex wells created by a quadratic term\n    modulated by a sine wave. Each dimension has its own amplitude and frequency, preserving a\n    global minimum at x_i = 0 for all dimensions. The per-dimension parameters can be tuned to\n    adjust local minima depth and spacing, while the problem remains fully separable.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=None, a_bounds=(0.4, 0.9), b_bounds=(0.5, 3.5)):\n        \"\"\"\n        Initialize a separable rugged landscape.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - seed: int or None, random seed for reproducibility\n        - a_bounds: tuple (a_min, a_max), bounds for per-dimension sine modulation amplitude\n        - b_bounds: tuple (b_min, b_max), bounds for per-dimension sine modulation frequency\n        \"\"\"\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n        # per-dimension parameters\n        self.a = rng.uniform(a_bounds[0], a_bounds[1], size=self.dim)  # amplitude of sine modulation\n        self.b = rng.uniform(b_bounds[0], b_bounds[1], size=self.dim)  # frequency of modulation\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        The per-dimension function is:\n            g_i(x_i) = x_i^2 * (1 + a_i * sin(b_i * x_i))\n\n        The global function is F(x) = sum_i g_i(x_i).\n        Global minimum is at x = 0 with F(0) = 0.\n\n        Parameters:\n        - x: array-like, shape (dim,), real-valued input within [-5, 5] per dimension\n\n        Returns:\n        - float, objective value\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n\n        gx = (x ** 2) * (1.0 + self.a * np.sin(self.b * x))\n        return float(np.sum(gx))", "configspace": "", "generation": 1, "feedback": "The optimization landscape SeparableRuggedLandscape scored on:Separable 1.000, GlobalLocal 0.004,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["624b3ddf-1c3e-4f6d-a5cb-0fd523eca099"], "operator": null, "metadata": {"ela_features_2D": [0.0418424923856016, 0.1380420424329941, 0.0794306310596982, 0.11834327363146986, 1.5708767516423516, 0.04419222990375458, 0.6405117483358117, 1.054559049529439, 0.7178077195035684, 1.0066634245715016, 0.7022971261427793, 1.8, 0.3701260610119822, 0.612242747803619, 0.35918005415054494, 0.38472185996609004, -0.303797749849659, 0.15718647568531802, 0.26403298127595026, 0.35542805665367355, 0.5662122892721292, 0.1495252337618169, 0.2564656245041772, 0.3468253303893787, 0.5442031527234591, -0.44080831148288324, -0.38491674792298475, -0.3371040425802015, -0.22687100464028784, -0.4365640469619116, -0.38164940937614517, -0.33523754711790327, -0.23394848115318667, 1.0, 1.0, 1.0, 1.0, 0.5195305137598032, 0.5195154621740142, 0.43208685513977957, 0.4051187896592376, 0.7323478601856785, 0.8778778778778775, 0.7160381926989914, 0.1611611611611611, 0.46787148594377503], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9598109126091003, "ela_features": [0.06782708794840109, 0.37734827242660385, 0.018090815623802572, 0.11872122643165098, 9.556375581683882, 0.06909030301821406, 0.7204765246651739, 1.109569970318283, 0.7846669834390814, 0.5875454664335349, 0.11706875447081914, 1.6, 0.7688896515899428, 0.8396613114382125, 0.535018618289721, 0.2110411318149461, -0.5012439906546425, 0.48868786828750677, 0.5943234878619396, 0.6615500375223196, 0.7593161710984144, 0.4821333319919171, 0.5873230641087612, 0.6557535183813993, 0.7571772769332636, -0.4497311317154204, -0.35681534637759577, -0.2976891573256988, -0.21169757584728247, -0.45769777812859325, -0.3647229591312128, -0.3042521053156304, -0.21461130333245465, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21380150785758145, 0.21379256446219244, 0.2027627764448005, 0.21352485463358611, 0.8463913324102819, 0.35735735735735724, 0.3013977843292195, -0.2792792792792792, 0.5860576923076923], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.040531955659389496, "ela_features_10D": [0.05855809749080596, 0.3272793646788196, 0.0026491694261734536, 0.08587371373793744, 66.41640450310015, 0.06586245946217031, 0.8004135875030695, 1.1129075960864974, 0.8621202101514893, 0.37317645472182887, 0.04408339300383668, 1.6, 0.9736186596302951, 0.9313515777683499, 0.6736952580327964, 0.11127575870739133, -0.5862133253205364, 0.6441622279547371, 0.708157943217081, 0.7542061289417834, 0.8276912985593216, 0.6450656066261387, 0.7100885668990912, 0.7560014058412465, 0.8300657792609509, -0.4513030524965568, -0.3701394494894669, -0.31173732202265897, -0.21853671188887347, -0.45132534183927675, -0.3686482286461526, -0.3102666220505757, -0.21608617175187717, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10831193033332025, 0.10831787699003144, 0.10583683069627352, 0.11351683767360383, 0.8587379310713432, -0.07907907907907909, 0.13714420005756553, -0.6356356356356354, 0.6058446757405924], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0037391965743154287}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, -5.0], 22.877655988919265], [6, [-3.822888888888896, 4.024888888888874], 8.694913179172996], [6, [-3.822888888888896, -2.8517777777777695], 6.154698897873969], [6, [2.24666666666664, 4.024888888888874], 6.3988471393246655], [6, [2.24666666666664, -2.8517777777777695], 3.858632858025639], [3, [-0.00044444444444512003, -5.0], 10.69942163078152], [3, [5.0, -0.00044444444444512003], 12.1782347529009], [6, [-0.00044444444444512003, 4.024888888888874], 5.145768971351364], [6, [-0.00044444444444512003, -2.8517777777777695], 2.6055546900523385], [9, [-3.822888888888896, -0.00044444444444512003], 3.549144602584784], [9, [2.24666666666664, -0.00044444444444512003], 1.2530785627364542], [9, [-0.00044444444444512003, -0.00044444444444512003], 3.9476315340185744e-07], [2, [5.001090502210348, 1.588677531747563], 13.08822736422527], [6, [-3.822888888888896, 1.658666666666667], 4.4600569122859755], [6, [2.24666666666664, 1.658666666666667], 2.1639908724376458], [6, [-0.00044444444444512003, 1.658666666666667], 0.9109127044643447], [3, [2.196675550208029, -5.000835830062942], 11.951918599464067], [3, [-3.806891588047771, -5.000252183711422], 14.248467169690946], [2, [5.0002253140427735, 4.01289177889019], 17.32394433776677], [2, [5.00041455353061, -2.829782790623055], 14.783642383846303]], "nr_of_basins": 20, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.2367350504930856e-162, 1.155962656078446e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [9.584749920621507e-163, 7.938365419333513e-163, -7.793761515167859e-163, 1.0915233703063281e-162, -1.083797041887696e-162]}
{"id": "c028813c-50c5-4335-855b-58a7ad3860da", "fitness": 0.6621779410464418, "name": "landscape_sep_bumpy", "description": "A fully separable benchmark landscape with per-dimension quadratic base plus dimension-specific nonnegative sin^2 bumps. The per-dimension parameters (amplitude and frequency) are chosen deterministically to create a clear global minimum at the origin while producing varied local minima across dimensions, enhancing separability and making subproblems distinct.", "code": "import numpy as np\n\nclass landscape_sep_bumpy:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + a_i * sin^2(k_i * x_i) ]\n    - Separable: no cross-dimension interactions; f(x) is a sum of independent per-dimension functions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent,\n      yielding varied local minima across dimensions while preserving separability.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Deterministic, increasing per-dimension amplitude for richer local structure\n        # and increasing per-dimension frequency to create more local features.\n        # Ensure nonnegative amplitudes.\n        self.a = 0.4 + 0.18 * np.arange(self.dim)\n        self.k = 0.9 + 0.28 * np.arange(self.dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_sep_bumpy scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["640051b4-c98c-47c2-b212-383d2da40840"], "operator": null, "metadata": {"ela_features_2D": [-0.0018394218093202408, 0.3606218453559932, 0.009239426756391585, 0.030380127646019113, 15.745185449722133, -0.00085550145619262, 0.9994949310815082, 1.0045938499433495, 0.999493068480256, 0.44345187565063504, -0.4599690974065568, 2.0, 0.7165113274087546, 0.7182342815746539, 0.5569530574962378, 0.3419253459819641, -0.19586771844471754, 0.16138317840244715, 0.23139243952379407, 0.3033556641872345, 0.48324718467416455, 0.16261892581504628, 0.2385968069331617, 0.3062491585367749, 0.48681971123331974, -0.4385825401461362, -0.4019703083401354, -0.36433433015303507, -0.2702539593306033, -0.4298207126378452, -0.39082654169221426, -0.35609944872580546, -0.2634124598387809, 1.0, 1.0, 1.0, 1.0, 0.5167309765734807, 0.5166997545288018, 0.4032293584230945, 0.3509963512288347, 0.7268437149727741, 0.3893893893893893, 0.4652440492572403, -0.11111111111111108, 0.3951807228915663], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9727391600608826, "ela_features": [-0.0002944949765024907, 0.3966294157162324, 0.006985184021983953, 0.022745123273242025, 20.724366177781203, 0.005443405604497542, 0.9985806768127313, 1.0158775200410695, 0.9985802976086198, 0.2909544525629951, -0.10347199609835833, 1.0, 0.896681650030461, 0.8723827055545463, 0.6328229066610328, 0.18256523954263087, -0.4755203946395343, 0.44129177949753584, 0.5264637340077943, 0.6018833706465443, 0.7200148023388775, 0.44177126769843794, 0.52970726408173, 0.6048426431424467, 0.7241969633124423, -0.4915663587521347, -0.41663146226956693, -0.35027564854418325, -0.24633993274142324, -0.49398063576407375, -0.41616855477439146, -0.3496813340965427, -0.2440643956833858, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21932083263777966, 0.21936593205886487, 0.20511375188238903, 0.1837453107171728, 0.8255236246012562, 0.10910910910910906, 0.2455410478253215, -0.38338338338338335, 0.5209935897435897], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00017484399722889066, "ela_features_10D": [-0.0005489180917328084, 0.42408755543028526, 0.0008780776013005854, 0.020067827526267734, 24.261918542179906, 0.00638534830787234, 0.9960329303153165, 1.0216727436418427, 0.996051475230885, 0.19349848634584155, -0.08331529651738726, 1.2, 1.0243507400194993, 0.9386447220850315, 0.7157031919092727, 0.10557646578774708, -0.6080496724893776, 0.622721672620389, 0.680907069501764, 0.7312628610550883, 0.8093649088591693, 0.6274704761709604, 0.6859819675802096, 0.7355581688655178, 0.8138130437316262, -0.4785245968241906, -0.4047245156289315, -0.3408552205793415, -0.2417938361104405, -0.4737889661952022, -0.39937269969981004, -0.3363209138159514, -0.23679523609044276, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1096603108406704, 0.10967287886329857, 0.10670193712840212, 0.10028021053336371, 0.8542949995309812, -0.1271271271271271, 0.13588049691927817, -0.6436436436436435, 0.588470776621297], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00015364222053904086}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 6.18586056037325e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-6.896806849624634e-163, 1.2992316801241674e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.890398089982574e-163, 9.813978833090998e-163, -9.492877341098032e-163, 8.101296190470992e-163, -5.980912596655672e-163]}
{"id": "8f17f21f-4486-4814-a0fb-8836c74361fc", "fitness": 0.6577867261488185, "name": "landscape_cosine", "description": "A completely different, separable cosine-modulated quadratic landscape. Each dimension has its own frequency and amplitude for a per-dimension f_i(t) = t^2 + A_i*(1 - cos(K_i*t)), yielding multiple local minima while guaranteeing a global minimum at the origin. The landscape remains separable across dimensions and is tunable via per-dimension parameters to adjust GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_cosine:\n    \"\"\"\n    A separable landscape with a quadratic base per dimension plus a cosine modulation.\n    Per-dimension parameters (A_i, K_i) are chosen to create multiple local minima\n    while preserving a global minimum at x = 0 (f(x) = 0).\n    \n    f(x) = sum_i [ x_i^2 + A_i * (1 - cos(K_i * x_i)) ]\n    Domain per dimension: [-5, 5]\n    \"\"\"\n    def __init__(self, dim, seed=None):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Define candidate ranges for per-dimension parameters\n        # Frequencies (modulation) and amplitudes (depth of modulation)\n        freq_candidates = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=float)\n        amp_candidates  = np.array([0.25, 0.5, 0.75, 1.0, 1.25], dtype=float)\n\n        # Sample per-dimension frequencies and amplitudes\n        self.K = rng.choice(freq_candidates, size=self.dim, replace=True).astype(float)\n        self.A = rng.choice(amp_candidates, size=self.dim, replace=True).astype(float)\n\n        # Ensure numpy arrays for fast evaluation\n        self.K = self.K.astype(float)\n        self.A = self.A.astype(float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n        - x must be a 1D array of length self.dim\n        - Returns a scalar objective value (minimization)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        # Per-dimension contribution: t^2 + A*(1 - cos(K*t))\n        # Vectorized over dimensions\n        contrib = x**2 + self.A * (1.0 - np.cos(self.K * x))\n        return float(np.sum(contrib))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_cosine scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6207de7a-adce-4711-b3d9-4d355c2fb011"], "operator": null, "metadata": {"ela_features_2D": [-0.0026864307292420618, 0.3868525982626865, 0.011318783873602228, 0.022469684149715247, 2.1293739569482013, -0.003832788969455869, 0.9901992136113764, 1.0177201152109714, 0.990167196919941, 0.41716792241549616, -0.4585964706594849, 1.6, 0.6247010106038917, 0.6992218519327825, 0.4896789599084771, 0.34615727615092845, -0.19928831449314796, 0.20382747079724178, 0.27327020691894166, 0.330463143983395, 0.5046123996513299, 0.1991452261524383, 0.2739236672073343, 0.32968761011916836, 0.5046677866738863, -0.4164433099676693, -0.38012510869388033, -0.3502078058451654, -0.2591136289371002, -0.411455027946665, -0.37304954145170677, -0.34439292128306315, -0.25447981737927383, 1.0, 1.0, 1.0, 1.0, 0.515757967683996, 0.5156811445508406, 0.4008751491932426, 0.35030254566391866, 0.7351057918255879, 0.4614614614614613, 0.6437281253880146, -0.07507507507507505, 0.3859437751004016], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9462426900863647, "ela_features": [-0.0021144482852848865, 0.3888475630274639, 0.0026608947536128245, 0.01806660931245028, 65.37269769343148, 0.0031164536047253444, 0.9981696340405369, 1.0079447485344122, 0.9981706157798106, 0.24940371477756326, -0.18251345454167361, 1.2, 0.9128478419696439, 0.8761989768470576, 0.6435492383130323, 0.1808185993929524, -0.47323519668133385, 0.43785854737135416, 0.513917820413297, 0.5880707212485937, 0.7116820863698768, 0.4444207195511935, 0.5188882725887451, 0.5923707555883029, 0.7158556743211306, -0.4944785829745163, -0.42757471406557696, -0.36234742170242223, -0.25361441954481023, -0.49115714699898233, -0.42532515229295287, -0.36036204265184535, -0.25119665646809997, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2182283275473776, 0.2182398050483963, 0.20442446670909087, 0.1825327954650568, 0.8186382678778312, 0.10910910910910906, 0.24491750079113978, -0.3993993993993993, 0.5048076923076923], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0002610919764265418, "ela_features_10D": [-0.0013180580883873638, 0.4411668705591067, 0.0006756170900754898, 0.015322029685472322, 62.653660551940256, 0.0014611329488983583, 0.9964794439534719, 1.0540523417295675, 0.996456071891075, 0.22603494062554005, -0.06200312003759558, 1.2, 1.0192529059239768, 0.9383008821098177, 0.7142260650792004, 0.10539295693393494, -0.604266411705966, 0.6256288140573114, 0.6842264680027595, 0.7331264005244824, 0.8085945625355638, 0.6296923656039789, 0.6892184748343133, 0.7375917212328524, 0.8135843031048786, -0.47479643835128754, -0.4004798240033556, -0.33846269540246154, -0.24275029218158198, -0.47084921178900957, -0.3951614360697282, -0.333654826908806, -0.2370299953036658, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11079254544838821, 0.11079138302990543, 0.10768175778614146, 0.10083564441189607, 0.8558665465919695, -0.11911911911911907, 0.12638039648879001, -0.6516516516516514, 0.589911929543635], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00021657483011949807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 8.888888612487717e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.4946101406335349e-162, 5.9759136879976574e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.743681922719959e-163, 1.3246346126711665e-162, -1.0159377887456395e-162, 2.5371723341155337e-163, 5.38329252466006e-163]}
{"id": "74f350b7-9f81-4da0-b5a5-ca0cc0b0479d", "fitness": 0.6620909876437509, "name": "landscape_separable_osc_quad", "description": "A highly separable, per-dimension oscillatory-quadratic landscape with dimension-specific parameters drawn from a seed. Each dimension contributes g_i(t) = t^2 + A_i*(1 - cos(omega_i t)) independently, ensuring full separability. The global optimum is at the origin with f=0. Local minima arise from the cosine term within each dimension, and the overall GlobalLocal descriptor is the average, across dimensions, of the strongest non-global local minima relative to the per-dimension mean landscape value, reflecting separable difficulty.", "code": "import numpy as np\n\nclass landscape_separable_osc_quad:\n    \"\"\"\n    A separable optimization landscape where each dimension contributes\n    an independent 1D component:\n        g_i(t) = t^2 + A_i * (1 - cos(omega_i * t))\n    The global minimum is at x = 0 with f(x) = 0. Per-dimension A_i and\n    omega_i introduce heterogeneity while preserving separability.\n    A per-dimension GlobalLocal metric is computed and averaged across\n    dimensions to yield a single scalar descriptor of local-minima contrast.\n    \"\"\"\n\n    def __init__(self, dim=5, A=2.0, omega=3.0, seed=0, grid_points=4001):\n        \"\"\"\n        dim: number of dimensions\n        A: base amplitude of the oscillatory term (scaled per-dim)\n        omega: base frequency of the oscillatory term (scaled per-dim)\n        seed: RNG seed for deterministic per-dimension variation\n        grid_points: resolution used to estimate the GlobalLocal metric (per-dimension)\n        \"\"\"\n        self.dim = int(dim)\n        self.A_base = float(A)\n        self.omega_base = float(omega)\n        self.grid_points = int(grid_points)\n        self._rng = np.random.RandomState(int(seed))\n\n        # Per-dimension independent parameters to enhance separability\n        # Slight, deterministic heterogeneity across dimensions\n        delta_A = self._rng.uniform(-0.25, 0.25, size=self.dim)\n        delta_omega = self._rng.uniform(-0.25, 0.25, size=self.dim)\n\n        self.A_i = self.A_base * (1.0 + delta_A)        # per-dimension A_i\n        self.omega_i = self.omega_base * (1.0 + delta_omega)  # per-dimension omega_i\n\n        # GlobalLocal descriptor computed once at initialization\n        self.GlobalLocal = self._compute_global_local_metric()\n\n    def _g_per_dim(self, t, idx):\n        \"\"\"\n        1D component for dimension idx evaluated over t.\n        g_i(t) = t^2 + A_i * (1 - cos(omega_i * t))\n        \"\"\"\n        return t**2 + self.A_i[idx] * (1.0 - np.cos(self.omega_i[idx] * t))\n\n    def _compute_global_local_metric(self):\n        \"\"\"\n        Estimate a GlobalLocal metric for the multi-dimensional separable landscape.\n        For each dimension i, compute the 1D curve g_i(t) over t in [-5,5],\n        identify local minima (excluding the global minimum near t=0),\n        and compute:\n            GL_i = max_local_min_i / mean(g_i)\n        The final GlobalLocal is the average of GL_i across dimensions.\n        \"\"\"\n        t = np.linspace(-5.0, 5.0, self.grid_points)\n        step = t[1] - t[0] if t.size > 1 else 1.0\n\n        gl_values = []\n\n        for i in range(self.dim):\n            y = self._g_per_dim(t, i)\n\n            # Identify local minima: interior point <= neighbors\n            if y.size < 3:\n                gl_values.append(0.0)\n                continue\n\n            interior = y[1:-1]\n            left = y[:-2]\n            right = y[2:]\n            is_local_min = (interior <= left) & (interior <= right)\n\n            t_candidates = t[1:-1][is_local_min]\n            minima_values = interior[is_local_min]\n\n            # Exclude the global minimum near t=0\n            if t_candidates.size > 0:\n                non_global_mask = np.abs(t_candidates) > step * 0.5\n                minima_values = minima_values[non_global_mask]\n            else:\n                minima_values = np.array([])\n\n            max_local_min = float(minima_values.max()) if minima_values.size > 0 else 0.0\n\n            mean_g = float(np.mean(y))\n            gl_i = (max_local_min / mean_g) if mean_g > 0.0 else 0.0\n            gl_values.append(gl_i)\n\n        # If for any reason there are no valid GL values, default to 0\n        if len(gl_values) == 0:\n            return 0.0\n        return float(np.mean(gl_values))\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the separable landscape: f(x) = sum_i g_i(x_i)\n        Where each g_i is the 1D component defined above.\n        x must be a 1D numpy array of length 'dim' with values in [-5, 5].\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}.\")\n\n        # Clip to domain to ensure evaluation is within bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        # Vectorized computation: g_i(x_i) = x_i^2 + A_i*(1 - cos(omega_i * x_i))\n        g_vals = x**2 + self.A_i * (1.0 - np.cos(self.omega_i * x))\n        return float(np.sum(g_vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_osc_quad scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["85a9a836-e812-4d32-9e29-227eabe42c69"], "operator": null, "metadata": {"ela_features_2D": [-0.002595434418228404, 0.38299973252140385, 0.011102323551059718, 0.020075115494026366, 11.524720245524499, 0.002467389021100308, 0.9627492812890377, 1.024975300939209, 0.9626874067620366, 0.44249312721999823, -0.3456645139103361, 2.6, 0.5801136171949902, 0.6844253111327884, 0.45640289360378816, 0.35369507989622634, -0.22092894995202128, 0.20692293800670508, 0.3428116021874187, 0.37128632484104135, 0.48841720573175496, 0.1984996378646506, 0.3586044366122845, 0.38154446165922123, 0.4903810875735899, -0.41463095529544186, -0.34357875576237423, -0.32869283023318746, -0.2674538910502257, -0.41058296665828786, -0.32854168720625804, -0.31679503578210966, -0.2610306108499295, 1.0, 1.0, 1.0, 1.0, 0.518060188700335, 0.5180082132874585, 0.41539009432847945, 0.3523322836807447, 0.7355138253514917, 0.5295295295295294, 0.5531618755839464, -0.06306306306306307, 0.4028112449799196], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9720073342323303, "ela_features": [0.0006873950533557327, 0.40649837845751424, 0.004961479567686495, 0.025309962916956086, 9.240086976198892, 0.00133051896286438, 0.9631986334694451, 1.0736390858266724, 0.9631851330226568, 0.25177077015005955, -0.21612416351032246, 2.0, 0.8793441372401407, 0.867499552992063, 0.6174714209995867, 0.18870813569204017, -0.47577592616534065, 0.46227849988551756, 0.5423689254811037, 0.6100788815187729, 0.7223627183798134, 0.460355381893812, 0.5445689424315137, 0.6120761583901559, 0.7263506198583165, -0.47304947616701903, -0.4025841516302604, -0.34302083268804634, -0.24424332865050763, -0.47716902143707723, -0.40268474086395845, -0.3429992546807515, -0.24195960875265216, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21263558940622707, 0.21264419498929082, 0.19931421188388834, 0.17953289137905093, 0.8339318752883781, 0.1611611611611611, 0.2665163392674064, -0.36736736736736725, 0.526923076923077], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00030571946990676224, "ela_features_10D": [-0.0012008504659440922, 0.4360841190270304, 0.0011405383449977408, 0.01632090340316289, 22.737177318397663, 0.004968019741089602, 0.965168156185307, 1.0727354255075254, 0.9651464486600414, 0.17171600707206372, -0.09944740477284411, 1.8, 1.0106670563524247, 0.9383049696187923, 0.7069060345979403, 0.10446823558690484, -0.6123084223460978, 0.6182314689147357, 0.6808719583824207, 0.7328964510581953, 0.8098981990296317, 0.6224046971449765, 0.6831539035156615, 0.7366880356743712, 0.8140721463163928, -0.4841453514612478, -0.4047070404230011, -0.3387315100259153, -0.2410804239968804, -0.48008231348517505, -0.40284396772782605, -0.33478004707090836, -0.23639208246259596, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11123328144148095, 0.11122447034921219, 0.10819790568353879, 0.10114476848995398, 0.8611151349565501, -0.11111111111111108, 0.13852955492946112, -0.6436436436436435, 0.5987990392313851], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00023287216026801616}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 4.4666124262413465e-06], [8, [0.00044444444444512003, -1.859777777777863], 3.8193959558529778], [16, [-1.8045224451312243, -1.8597734930414942], 7.423731750471171], [8, [-1.803777777777863, 0.00044444444444512003], 3.6043411536877845], [16, [-1.803777777777863, 1.859777777777864], 7.423732642928336], [8, [0.00044444444444512003, 1.859777777777864], 3.8193959558529773], [16, [1.8037777777778639, -1.859777777777863], 7.423732642928336], [16, [1.8037777777778639, 1.859777777777864], 7.423732642928336], [8, [1.8040000000003302, 0.00044444444444512003], 3.604339794487503]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.3691704436548677e-162, 4.777106897883868e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.3491370030004357e-162, 9.478496966245082e-163, 6.138863697247659e-163, 5.036587287207208e-163, 1.5034661421874827e-162]}
{"id": "5472a768-0c98-49ea-9d5a-2ac15730bdee", "fitness": 0.5500004629187364, "name": "landscape_separable_enhanced", "description": "A fully separable, multi-frequency per-dimension benchmark landscape. Each dimension contributes a quadratic term plus a sum of cosine-based wells with independent frequencies and amplitudes. The global minimum is at the origin (f(0)=0). The multi-component per-dimension structure increases local minima density while preserving separability, enabling easy subproblem decomposition and tunable global-local contrast across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_enhanced:\n    \"\"\"\n    A fully separable landscape: f(x) = sum_i g_i(x_i)\n    where each g_i(t) = a_i * t^2 + sum_{k=1..m} A_{i,k} * (1 - cos(2*pi*f_{i,k} * t)).\n    - Per-dimension quadratic term ensures a global minimum at t=0 (g_i(0) = 0).\n    - Each dimension has multiple cosine modulations (multi-frequency) to create many local minima without cross-dimension coupling.\n    - All per-dimension terms are independent, preserving separability and enabling easy subproblem partitioning.\n    - Domain is [-5, 5] per dimension (as required).\n    \"\"\"\n    def __init__(self, dim=5, seed=0, comps_per_dim=2):\n        self.dim = int(dim)\n        self.comps = int(comps_per_dim)\n\n        rng = np.random.default_rng(seed)\n\n        # Base quadratic curvature per dimension (slightly varying)\n        self.a = 0.25 + 0.05 * (np.arange(self.dim) % 5)\n\n        # Frequencies per dimension per component (multi-frequency per-dim)\n        freq_set = [1, 2, 3, 4]  # small fixed set for variety\n        # Shape: (dim, comps)\n        self.freqs = np.zeros((self.dim, self.comps), dtype=float)\n        for i in range(self.dim):\n            for j in range(self.comps):\n                self.freqs[i, j] = freq_set[(i + j) % len(freq_set)]\n\n        # Amplitudes per dimension per component\n        # Randomized but deterministic given seed to preserve reproducibility\n        self.amps = 0.2 + rng.random((self.dim, self.comps)) * 0.8  # range ~[0.2, 1.0]\n\n        # Optional: clamp to keep numerical stability within typical landscape bounds\n        self.amps = np.clip(self.amps, 0.0, 2.0)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at a point x \u2208 R^dim.\n        x must be a 1D array-like of length dim.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}\".format(self.dim))\n\n        # Quadratic term per-dimension\n        term_quad = self.a * (x ** 2)  # shape (dim,)\n\n        # Multi-frequency cosine modulations per dimension\n        # t = 2*pi * freq_{i,k} * x_i\n        t = 2.0 * np.pi * self.freqs * x[:, None]  # shape (dim, comps)\n        cos_t = np.cos(t)  # shape (dim, comps)\n\n        # Sum over components per-dimension\n        term_cos = np.sum(self.amps * (1.0 - cos_t), axis=1)  # shape (dim,)\n\n        # Total per-dimension term\n        per_dim = term_quad + term_cos  # shape (dim,)\n\n        # Global objective\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["131d9d82-3ecb-4af5-9206-d9599d625aa9"], "operator": null, "metadata": {"ela_features_2D": [-0.0029079869565534987, 0.3932478777450401, 0.00987505055176898, 0.01891946025125138, 2.310475654645394, -0.0024475138449719046, 0.9552123914821722, 1.2092972217712021, 0.9550222296540969, 0.4013768675135522, -0.4155443931778211, 1.8, 0.4861274081999172, 0.6243886176342615, 0.3766563129057844, 0.39825864315580406, -0.23062650036795654, 0.2953639147537497, 0.367361977888051, 0.38523142072854055, 0.509691504613814, 0.2980442719714388, 0.3668133979612257, 0.378321700037287, 0.5044649396670995, -0.3688295462097474, -0.33113866219524646, -0.3217767090497612, -0.25663294662035313, -0.36081136912049094, -0.32545291082940137, -0.31953430605771477, -0.2546996809410035, 1.0, 1.0, 1.0, 1.0, 0.5170423249628301, 0.5170271258775943, 0.408688096943764, 0.34980878199374554, 0.8393457522730948, 0.7897897897897896, 0.8901644875961343, 0.1691691691691691, 0.529718875502008], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.29896607995033264, "ela_features": [-0.0014039557954692362, 0.4437422330815662, 0.0032570492040935816, 0.021331628652790577, 9.352004228635497, 0.0014716188646712424, 0.9379578216641203, 1.7960666533507144, 0.9381618468558791, 0.25767239534696057, -0.2527259431025766, 1.2, 0.8618824435521966, 0.8605130449898739, 0.5944183682116413, 0.19569768396918735, -0.4890965775385352, 0.49104442585056846, 0.5643427528012432, 0.6218887492613177, 0.7287380329891319, 0.4869671215846356, 0.5608006808460316, 0.6205700544433792, 0.7300517601989449, -0.4476277219736799, -0.3831618416024489, -0.3325509308615828, -0.23857665812354883, -0.4533842185239362, -0.38813728049708135, -0.33532064118089194, -0.2385683947294094, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21523801388271618, 0.21527781915106767, 0.20105636599638038, 0.17980663265040156, 0.8435974506471787, 0.20120120120120114, 0.28925342845912844, -0.3473473473473473, 0.5475961538461538], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0007319921860471368, "ela_features_10D": [-0.0002645327322373436, 0.46608526752691565, 0.0005869207723144752, 0.019271275943042725, 131.4956145362658, 0.004359259585643404, 0.9428936747188702, 1.8185551067057744, 0.9429488348111681, 0.21375685011071463, -0.07783302348860906, 1.2, 1.007458106885439, 0.9378098419430451, 0.7107315714420366, 0.10508651764792545, -0.6070249692393219, 0.6417910436141877, 0.6995217400336757, 0.7453349696973509, 0.816990780670911, 0.6443496699746561, 0.7011900699826832, 0.7479248791225478, 0.8206328818822856, -0.45426443515637915, -0.38105329918546527, -0.3229552026960851, -0.2320844980341838, -0.4521771483198789, -0.3799089710876113, -0.32049079516635065, -0.22804907500923915, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11069191390742317, 0.11068902646710281, 0.1077645229115561, 0.1009641367487909, 0.8608100677436099, -0.11911911911911907, 0.13371412282144343, -0.6396396396396394, 0.5954363490792635], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0003047053760383278}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-3.888888888888889, -0.5555555555555554], 4.7573789019279635], [1, [-2.7777777777777777, -0.5555555555555554], 3.788833086952371], [1, [2.7777777777777786, -0.5555555555555554], 3.7888330869523656], [1, [3.8888888888888893, -0.5555555555555554], 4.757378901927964], [1, [-3.888888888888889, 0.5555555555555554], 4.7573789019279635], [1, [-2.7777777777777777, 0.5555555555555554], 3.788833086952371], [1, [2.7777777777777786, 0.5555555555555554], 3.7888330869523656], [1, [3.8888888888888893, 0.5555555555555554], 4.757378901927964], [1, [-0.48955637168799454, -3.888960199883591], 6.530043912132046], [1, [0.4895563872945987, -3.888960773113064], 6.530041599556871], [1, [4.97200000415506, -4.971995919631374], 13.676136333406607], [1, [-0.4915562894130588, -0.5556097301941518], 1.9477028716609919], [1, [0.4915563154270566, -0.5556106818523682], 1.9477016635146966], [1, [4.972000003642487, -1.602663445624837], 7.292718144495679], [1, [-0.4915562590448565, 0.5556085976360915], 1.94770430940997], [1, [0.49155625327878777, 0.5556083798502706], 1.9477045858760602], [1, [4.972000006457438, 1.6026620733293226], 7.2927181209105], [1, [-4.97400004209487, 4.971953213980617], 13.676127930385423], [1, [-0.48955643643510244, 3.8889644376417616], 6.530026822965496], [1, [0.48955641123371646, 3.8889639076352314], 6.5300289628068775], [1, [-4.97200000570273, -4.9719952318059315], 13.676136367321948], [1, [-3.889277923952928, -2.347781980170577], 6.260471771216054], [1, [-4.97011914299462, -1.6025343113853576], 7.293053732095427], [1, [-4.972000003553066, 1.60266355649206], 7.292718146391081], [1, [-3.888981297447998, 1.5966676307109982], 5.366570413379626], [1, [3.889057108557356, 1.5946691161286963], 5.366559861313987], [1, [4.973294664608327, 4.971961860827117], 13.676090087418515], [1, [4.952079240830814, -2.5701787096871134], 8.5679407497451], [1, [-4.953298269606932, -2.5709326525956726], 8.56572885113063], [1, [1.4806004045296763, -2.576408363207528], 4.305862318116129], [1, [1.4786667692638287, -0.5555845186882381], 2.441089713592738], [1, [-1.478666771635792, -0.5555846017983496], 2.4410896081480042], [1, [-1.4786667783449083, 0.5555850685680835], 2.441089016263497], [1, [1.478666795701116, 0.5555866184931906], 2.4410870511173215], [1, [-4.972000002448673, 2.579774794566036], 8.548203967056077], [1, [4.972000004683707, 2.5797736188146945], 8.548203963172774], [1, [1.480666666707327, -4.971996110390363], 9.433726549950372], [1, [-1.4806666667018336, 4.971996383340058], 9.433726536451552], [1, [1.478805305971906, 1.592727994704801], 3.0518733839725494], [1, [-1.4792258624847805, -1.5943431429381913], 3.051390763145903], [1, [-1.4806955560865092, -2.3525326621337186], 3.94598031875149], [1, [-1.4766671331737071, 3.8889508962795336], 7.023388107651774], [1, [1.4766671461299785, 3.888952899852048], 7.023380031622851], [1, [1.4746686785256, -3.889028581081574], 7.0233870317374425], [1, [-1.4766671245174194, -3.8889493679325207], 7.023394267903738], [1, [1.4803212878697583, 4.970306054884569], 9.433947095787927], [1, [-1.480321288892509, -4.970306032825002], 9.43394710061103], [1, [1.478805873251845, -1.592636192706465], 3.0519021881859834], [1, [-1.479223751501919, 1.5942515139974536], 3.0514152782879402], [1, [0.49296996195829895, -2.5783435405497057], 3.8124127435448187], [1, [0.4926528457390673, 2.578345261942924], 3.8124202252754738], [1, [-0.4940527924908766, -2.35166215806285], 3.4525919140505446], [1, [-0.49328305206409256, 2.551446640284804], 3.8145595185872034], [1, [0.4910451889015534, 1.6011310456407006], 2.557038166382842], [1, [-0.4910451778141153, -1.6011314733261353], 2.557038150357556], [1, [0.48817208883149993, -1.5976997723811095], 2.5577986600164166], [1, [-0.48817203874554566, 1.5977005552987924], 2.5577985452423215], [1, [-3.9399589948002482, -4.919197955350893], 11.616206329276714], [1, [-3.939960542889097, 4.919198337182746], 11.616199941031388], [1, [3.93849768822934, -4.920565361017206], 11.61620720171912], [1, [3.9399572285998388, 4.919198026431315], 11.616211819712289], [1, [2.970201795826262, -4.3051997107791715], 8.248213137607696], [1, [-2.970204546342707, -4.305202058159299], 8.24820658474225], [1, [-2.97018577511555, 4.305185905029736], 8.248251498914007], [1, [2.9702056009684767, 4.305203417272315], 8.248203466528167], [1, [3.889278362142616, -2.34778194942547], 6.260469126436751], [1, [3.889340726716893, 2.3477819250943077], 6.260091621740266], [1, [-3.889314196993462, 2.347781980914406], 6.260252183094237], [1, [2.981596267398243, -3.339686124456272], 5.918587676729214], [1, [-2.981480122514861, 3.3396640501226913], 5.918617505719649], [1, [-2.981399985600488, -3.339645417937114], 5.9186393743711205], [1, [2.9814919509835778, 3.3397021442676973], 5.918608745095188], [1, [-3.968117831339428, -3.3316123102100006], 7.667113550344099], [1, [3.9679514755570766, -3.3314800354917606], 7.6673554849196215], [1, [-3.967268923779247, 3.3312598494051526], 7.66817072474505], [1, [3.9687509938280687, 3.333018748375576], 7.665702755406003], [1, [4.949377203983722, 0.5831660572545455], 6.672900300352331], [1, [-4.949389824118884, 0.5831783031682412], 6.672860816105225], [1, [-4.94938889858051, -0.5831779572782578], 6.672863082432391], [1, [4.949387012731151, -0.5831760183850598], 6.672869105889009], [1, [-2.868346853937552, 1.9904908320453736], 3.93033479623774], [1, [1.4786551135922283, 2.5639299872642587], 4.307005840699137], [1, [-3.8890564607239617, -1.5946690723881138], 5.366563799531416], [1, [2.8518529740693355, 1.600633387168573], 3.9303264717724034], [1, [-2.851849896628486, 1.6026530490616655], 3.9303062665969843], [1, [2.868336199984056, 1.9884909213421593], 3.9303747484064235], [1, [-0.4934366393620727, 4.971457599284502], 8.94037148799086], [1, [0.4934366620591427, -4.971455889181062], 8.940371665115801], [1, [-0.49089179905212693, -4.969784289374095], 8.940806697902879], [1, [0.4908918271640736, 4.969784431328853], 8.940806656914154], [1, [3.8890571537094396, -1.5946690597734892], 5.366559602020237], [1, [2.851317247415764, -1.5947632244822332], 3.935087578018654], [1, [-2.8519732361581527, -1.594630680420027], 3.9304272307209476], [1, [2.867640329836298, -1.9882133291522766], 3.9353174959334316], [1, [-1.82466704441125, 1.9927189381518182], 3.0770178796044467], [1, [-4.956492157496551, -3.8927529652069306], 11.262117276886574], [1, [4.9564922522057, 3.8927511589612847], 11.262124608607673], [1, [4.956493113433343, -3.8927552906340908], 11.262106283254372], [1, [-4.9564926623058785, 3.89275217200487], 11.26211982856773], [1, [-2.8683658261402796, -1.9864935692826007], 3.930573489471301]], "nr_of_basins": 100, "f_opt_dim_2": 0.41041563594729985, "x_opt_dim_2": [-6.550957516507132e-10, 0.6161006705742883], "f_opt_dim_5": 0.8251608920826283, "x_opt_dim_5": [-6.553744120686266e-11, -3.5884023474750926e-10, -0.7232752332293974, -1.6498305398377858e-10, 4.670341749558006e-10]}
{"id": "998f0d7b-7655-439d-81d5-d06b23489c39", "fitness": 0.5544872508423092, "name": "landscape", "description": "A separable multi-well landscape with per-dimension wells (min of several 1D parabolas) enhanced with an explicit GlobalLocal difficulty metric. The GlobalLocal score is computed as the ratio between the strongest non-global local minimum (largest well depth among non-global wells) and the average landscape value over the domain, estimated via Monte Carlo sampling. This yields a robust, scalar measure of how prominent local minima are relative to the overall landscape, aiding robust benchmarking of optimization algorithms.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        self.dim = int(dim)\n\n        # Define a fixed set of 1D wells (mu_j, c_j) for a single dimension.\n        # mu_j: centers of parabolic wells\n        # c_j : additive offset (local depth). c_0 = 0 ensures global minimum at mu_0.\n        fixed_mu = np.array([0.0, -4.0, 4.0, -2.0, 2.0], dtype=float)\n        fixed_c  = np.array([0.0, 0.75, 0.85, 0.50, 0.60], dtype=float)\n\n        # Tile wells if more dimensions are requested\n        if self.dim <= fixed_mu.size:\n            self.mu = fixed_mu[:self.dim]\n            self.c  = fixed_c[:self.dim]\n        else:\n            reps = int(np.ceil(self.dim / fixed_mu.size))\n            mu_tile = np.tile(fixed_mu, reps)[:self.dim]\n            c_tile  = np.tile(fixed_c,  reps)[:self.dim]\n            self.mu = mu_tile\n            self.c  = c_tile\n\n        # Ensure numpy arrays for fast vectorized evaluation\n        self.mu = self.mu.astype(float)\n        self.c  = self.c.astype(float)\n\n        # GlobalLocal descriptor (improved, robust): ratio of strongest non-global local minimum\n        # to the mean landscape value over the domain [-5,5], estimated by sampling.\n        self.GlobalLocal = self._compute_global_local()\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape: F(x) = sum_i min_j [ (x_i - mu_j)^2 + c_j ]\n        - x: 1D numpy array of length self.dim\n        - domain: each x_i in [-5, 5] (as per specification)\n        - Global minimum: at x_i = mu_0 for all i, with value 0 (since c_0 = 0)\n        - Other wells give local minima with higher values (c_j > 0).\n        - GlobalLocal score is available as self.GlobalLocal.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        # Compute per-dimension: g_i(x_i) = min_j [ (x_i - mu_j)^2 + c_j ]\n        # Vectorized: compute (x_i - mu_j)^2 + c_j for all i, j, then take min over j.\n        # x[:, None] has shape (dim, 1); mu[None, :] has shape (1, L)\n        diff = (x[:, None] - self.mu[None, :])**2 + self.c[None, :]\n        gi = np.min(diff, axis=1)\n        return float(np.sum(gi))\n\n    def _mean_f_over_domain(self, samples=2000):\n        \"\"\"\n        Estimate the mean value of f(x) over the domain [-5,5]^dim by random sampling.\n        \"\"\"\n        rng = np.random.default_rng()\n        X = rng.uniform(-5.0, 5.0, size=(samples, self.dim))  # (samples, dim)\n\n        # Compute f(X) for all samples in a vectorized way\n        # For each sample, per-dimension g_i = min_j ((x_i - mu_j)^2 + c_j)\n        mu = self.mu  # (L,)\n        c  = self.c   # (L,)\n        # differences shape: (samples, dim, L)\n        diffs = (X[:, :, None] - mu[None, None, :])**2 + c[None, None, :]\n        gi = np.min(diffs, axis=2)  # (samples, dim)\n        f_vals = gi.sum(axis=1)      # (samples,)\n        mean_f = f_vals.mean()\n        return float(mean_f)\n\n    def _compute_global_local(self, samples_for_mean=2000):\n        \"\"\"\n        Compute the GlobalLocal score as:\n            GL = (max_j>0 c_j) / mean_f_over_domain\n        where mean_f_over_domain is estimated by random sampling over [-5,5]^dim.\n        This yields a robust scalar describing local minima contrast relative to the average landscape.\n        \"\"\"\n        if self.c.size <= 1:\n            return 0.0\n        # Strongest non-global local minimum value (largest c_j among j>0)\n        max_non_global_c = float(np.max(self.c[1:]))\n        # Mean landscape value over the domain\n        mean_f = self._mean_f_over_domain(samples=samples_for_mean)\n        if mean_f <= 0.0:\n            return float('inf')\n        return float(max_non_global_c / mean_f)\n", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.002,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6207de7a-adce-4711-b3d9-4d355c2fb011"], "operator": null, "metadata": {"ela_features_2D": [0.5645069495677785, -0.14583741273680545, 0.367373671753899, 0.3763856043783475, 1.0243038732728658, 0.5647533194700044, 0.8958278062912441, 1.0280400668399532, 0.9828002593049877, 1.1575624749255184, 0.6987234295978054, 1.8, 0.4211469216296937, 0.679052680956264, 0.3292464236424652, 0.3516245711737344, -0.15131845391038495, 0.1280104704082883, 0.4859450126253971, 0.6245381853709836, 0.7080911729720256, 0.12782207466825474, 0.5389191558566614, 0.731724241855272, 0.7632753318311616, -0.4561541429428549, -0.2689142175737561, -0.19641187128276566, -0.15270383261725912, -0.44798445520062513, -0.2368665957114627, -0.13779972753459185, -0.1215943046546593, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5197476813946313, 0.519737754303484, 0.551200751972122, 0.5957300622613477, 0.6944973683851101, 0.3893893893893893, 0.31111624209121047, -0.24724724724724717, 0.37991967871485943], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.3226642608642578, "ela_features": [0.011653681352906297, 0.4391124482435659, 0.01250311526591962, 0.04164742909560355, 3.82891687014844, 0.010894751707178175, 0.3552740918790907, 1.2582042879069228, 0.35113890038828915, -0.05703734060116814, -0.022386280657608015, 1.4, 0.6745104618435247, 0.8139633236557409, 0.46896368068657984, 0.23059904876196463, -0.6052309444885468, 0.6222020546138424, 0.6876818220351801, 0.7434732379648382, 0.8334366666341767, 0.6110881015989005, 0.678855189039777, 0.7371860399358503, 0.8272234220715369, -0.33235422037079987, -0.27474932802397034, -0.2256692495651061, -0.14652649138205368, -0.3439127791051198, -0.2839837221936313, -0.23240281326351148, -0.15278139643216987, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21596669151771594, 0.2159377998924128, 0.20484449082997447, 0.18846733344868555, 0.8671567915629534, 0.4374374374374373, 0.37862321156460194, -0.20720720720720714, 0.6538461538461539], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0024271830916404724, "ela_features_10D": [0.008553852575570531, 0.4403274409232371, 0.0015214643555772802, 0.02728827038865713, 147.03338805296298, 0.009865342213023843, 0.36309349051070383, 1.3336652243584666, 0.364972283171258, -0.05167105355273639, -0.03250749880848556, 1.8, 0.8289027808117801, 0.9109931781722775, 0.5785907134577988, 0.1277803117247736, -0.627096285477782, 0.760012645816611, 0.8032769430353552, 0.8348011315954038, 0.8830995615252958, 0.7589462403106632, 0.8020064526521372, 0.8339757115568223, 0.8831861048188863, -0.30435128462124206, -0.249483145946562, -0.20950386778980476, -0.14825200755454881, -0.30650547332324085, -0.251749232141311, -0.21109873775044247, -0.1485268415426781, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10922234644228168, 0.10921723623271602, 0.10676720558831347, 0.1025232815093307, 0.8656036728494069, -0.007007007007007024, 0.15176338979328785, -0.5835835835835834, 0.6424339471577262], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0018320610979571939}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-4.00000000000011, -4.00000000000011], 1.5], [21, [-4.00000000000011, 0.00044444444444512003], 0.7500001975308642], [21, [0.00044444444444512003, -4.00000000000011], 0.7500001975308642], [49, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.83159561920409e-163, -4.0529948953110215e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [7.603600062318989e-163, 2.1149998013792687e-164, -3.7852898850834846e-163, 7.817590407432401e-163, -5.610995284985306e-163]}
{"id": "6cc27429-cd3e-43b1-9e09-ead2dfad539d", "fitness": 0.5672538268457478, "name": "landscape_improved", "description": "A separable, multimodal landscape with per-dimension min-of-quadratics wells, global minimum at the origin, and an enhanced GlobalLocal score computed by sampling the mean 1D landscape to quantify local minima contrast relative to typical landscape level.", "code": "import numpy as np\n\nclass landscape_improved:\n    \"\"\"\n    Separable, multimodal landscape built from per-dimension \"min-of-quadratics\" wells.\n    Global minimum is at x = 0 (f = 0). Each dimension has multiple wells at positions\n    s_j and corresponding depths d_j, with depths increasing with distance from zero.\n    A GlobalLocal indicator is computed to quantify the contrast between the global minimum\n    and the non-global local minima relative to a rough estimate of the mean landscape level.\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, grid_samples=101):\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.grid_samples = int(max(11, grid_samples))\n\n        # Build well positions per dimension\n        s = np.linspace(-self.L, self.L, self.wells)  # well centers\n        idx_zero = int(np.argmin(np.abs(s)))\n        s[idx_zero] = 0.0  # ensure a well at 0 for global minimum\n\n        # Sort wells by distance to zero so depths align with proximity to zero\n        order = np.argsort(np.abs(s))\n        self.s = s[order]\n\n        # Depths: 0 for the closest well to zero, increasing with distance from zero\n        depths = (np.arange(self.wells, dtype=float) * self.contrast)\n        self.d = depths[order]\n\n        # Compute a GlobalLocal descriptor: ratio of deepest non-global local minimum\n        # to a rough mean of the 1D landscape over the domain\n        self.global_local = self._compute_global_local_score()\n\n    def _compute_global_local_score(self):\n        # Estimate a mean value of the 1D landscape by sampling across the domain\n        xs = np.linspace(-self.L, self.L, max(11, self.grid_samples))\n        vals = []\n        for x in xs:\n            vals.append(float(np.min((x - self.s) ** 2 + self.d)))\n        mean_1d = float(np.mean(vals))\n        d_max = float(self.d.max())\n        if mean_1d > 0:\n            return d_max / mean_1d\n        else:\n            return float('inf')\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_j)^2 + d_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        total = 0.0\n        for i in range(d):\n            t = x[i]\n            vals = (t - self.s) ** 2 + self.d\n            total += float(np.min(vals))\n        return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_improved scored on:Separable 1.000, GlobalLocal 0.013,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["560e4325-4788-4a2a-8f95-9e38a29946fe"], "operator": null, "metadata": {"ela_features_2D": [0.9864867037678884, -0.09516295670801025, 0.5453361512507656, 0.548959292797144, 1.0066267120341514, 0.9865439610720855, 0.990839881931754, 1.0467050461328715, 0.9948411276033514, 0.0831552259147117, -0.6445928963621974, 1.0, 0.7101970151607273, 0.7170359041284744, 0.56458224134676, 0.3404626745783419, -0.10016222381259195, 0.14409643017671797, 0.22528246922342693, 0.3218699488319937, 0.5321418902484035, 0.1528931730589775, 0.22742712212488728, 0.3202136563054294, 0.5158578777207286, -0.44771227354818227, -0.4052388230479396, -0.35470993723699845, -0.2447241891774067, -0.43501375412306464, -0.3967313264620095, -0.34907372025395655, -0.24859758147230776, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5097425560289277, 0.509699952249483, 0.6226286289465457, 0.6702225942404358, 0.7401403270023926, 0.11311311311311308, 0.3680727239206595, -0.33933933933933924, 0.36827309236947786], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.3866935670375824, "ela_features": [0.9857116061607591, -0.2054532435728797, 0.27159713565356725, 0.27619533717457084, 1.0169571645660103, 0.9858019346166221, 0.9903199294152181, 1.1985433272836954, 0.9945267192645713, 0.05416521579641102, -0.3029474332869125, 1.0, 0.8461110732476179, 0.8634052641126931, 0.6227633798353012, 0.18983008920430594, -0.26803778118552063, 0.5319230896343866, 0.6461982012575678, 0.7350061367585106, 0.8338884428015577, 0.5237273345403672, 0.6369468505422013, 0.7247160953195707, 0.828261565891134, -0.4117212124943307, -0.31120517585101937, -0.2330884555032474, -0.14611146878392717, -0.421040773783551, -0.32095341983924575, -0.24336027448729478, -0.15182200427382275, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2176572165842232, 0.21767940459003848, 0.24831165426434, 0.3263419674155192, 0.8158969262928, -0.2152152152152152, 0.15032745546184595, -0.6636636636636635, 0.47724358974358977], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0034028824884444475, "ela_features_10D": [0.9863331469629838, -0.3116082700856907, 0.15757294475467037, 0.1606643635188844, 1.0196974494406732, 0.986358674027092, 0.9908546651353982, 1.32411918851388, 0.9946879208857073, 0.07823744329139659, -0.12124837422237426, 1.4, 0.8743317026556559, 0.9185793066172427, 0.6650142924867476, 0.1171267702215489, -0.38114081353445284, 0.7746178707050506, 0.8221550293749071, 0.8692183793819293, 0.9210739163389896, 0.7754385893675111, 0.8225867537834441, 0.8695565710614737, 0.9212714801477933, -0.28584063337900345, -0.2255509596231448, -0.16586319913491235, -0.1000979922681271, -0.2855432335929359, -0.22558887577457867, -0.16586469630302894, -0.10010744997024697, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10957734314312764, 0.10957680609622808, 0.12388564012364567, 0.18186333566484592, 0.8276521888270905, -0.41141141141141124, 0.07706701694885101, -0.9239239239239238, 0.511929543634908], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.01342651154845953}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-4.00000000000011, -4.00000000000011], 2.4259050557356555e-26]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0, -4.0], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.0, -4.0, -4.0, -4.0, -4.0]}
{"id": "da48755a-794b-4668-805c-2997118694e6", "fitness": 0.5078084308770485, "name": "landscape_separable_wellfields", "description": "A novel separable landscape where each dimension contributes an independent 1D min-of-parabolas well, with dimension-specific curvature scaling. This preserves a global minimum at the origin while varying local minima depths per dimension, making the problem highly separable and decomposable into independent 1D subproblems for efficient solving by modular metaheuristics.", "code": "import numpy as np\n\nclass landscape_separable_wellfields:\n    \"\"\"\n    Separable landscape: F(x) = sum_i g_i(x_i)\n    where g_i(t) = min_j [ a[i, j] * (t - mu_j)^2 + c_j ].\n    - mu_j, c_j define a fixed set of 1D wells (parabolas) per dimension.\n    - a[i, j] is a per-dimension per-well curvature factor, making\n      the landscape still strictly separable but with dimension-specific\n      well depths/curvatures.\n    - Global minimum is at t = mu_0 (here mu_0 = 0) with c_0 = 0, giving f(0) = 0.\n    - Domain per dimension: [-5.0, 5.0].\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n\n        # Fixed wells for a single dimension: (mu_j, c_j)\n        # mu_0 = 0, c_0 = 0 ensures global minimum at x_i = 0\n        fixed_mu = np.array([0.0, -4.0, 4.0, -2.0, 2.0], dtype=float)\n        fixed_c  = np.array([0.0, 0.75, 0.85, 0.50, 0.60], dtype=float)\n\n        # Tile wells to the requested dimension\n        if self.dim <= fixed_mu.size:\n            self.mu = fixed_mu[:self.dim].astype(float)\n            self.c  = fixed_c[:self.dim].astype(float)\n        else:\n            reps = int(np.ceil(self.dim / fixed_mu.size))\n            mu_tile = np.tile(fixed_mu, reps)[:self.dim]\n            c_tile  = np.tile(fixed_c,  reps)[:self.dim]\n            self.mu = mu_tile.astype(float)\n            self.c  = c_tile.astype(float)\n\n        # Per-dimension per-well curvature a[i, j]\n        # Deterministic, so results are reproducible\n        L = self.mu.size  # number of wells per dimension\n        j = np.arange(L)\n        # Create a (dim, L) matrix of curvature factors with deterministic variation\n        # a[i, j] = 1.0 + 0.3 * cos( (i+1) * (j+1) * pi/4 )\n        self.A = np.zeros((self.dim, L), dtype=float)\n        for i in range(self.dim):\n            self.A[i, :] = 1.0 + 0.3 * np.cos((i + 1) * (j + 1) * np.pi / 4.0)\n\n        # Ensure shapes are float arrays\n        self.mu = self.mu.astype(float)\n        self.c  = self.c.astype(float)\n        self.A  = self.A.astype(float)\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape: F(x) = sum_i min_j [ a_i_j * (x_i - mu_j)^2 + c_j ]\n        - x: 1D numpy array of length self.dim\n        - domain: each x_i in [-5, 5] (as per specification)\n        - Global minimum: at x_i = mu_0 = 0 for all i, with value 0\n        - Each dimension contributes independently via its own set of wells\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        # Compute per-dimension g_i(x_i) = min_j [ a[i, j] * (x_i - mu_j)^2 + c_j ]\n        # Shapes:\n        # x[:, None] -> (dim, 1)\n        # mu[None, :] -> (1, L)\n        # (x_i - mu_j)^2 -> (dim, L)\n        diff = (x[:, None] - self.mu[None, :]) ** 2        # (dim, L)\n        val = self.A * diff + self.c[None, :]              # (dim, L)\n        gi = np.min(val, axis=1)                            # (dim,)\n        return float(np.sum(gi))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_wellfields scored on:Separable 1.000, GlobalLocal 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6207de7a-adce-4711-b3d9-4d355c2fb011"], "operator": null, "metadata": {"ela_features_2D": [0.5890619290231596, -0.16501904367579243, 0.34896807767961036, 0.4204127522671999, 1.2036293609794384, 0.5885733315505752, 0.9019073649043656, 1.20506613819245, 0.9854617206896853, 1.1342169725330518, 0.6584372223699393, 1.8, 0.4125691532773194, 0.6815806249392267, 0.35812505202307116, 0.3477184636117913, -0.15251785880403007, 0.3399160242401595, 0.5918738932187845, 0.6466779154232128, 0.7049425143826613, 0.2890357216442783, 0.7105882765891407, 0.739898582813273, 0.7574842387504124, -0.34546519026517397, -0.2135915434934717, -0.1849110233342641, -0.15441997967913976, -0.3663251417144236, -0.14909860503267053, -0.13400248154581043, -0.12494979519106728, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.512834078125, 0.5128214646747511, 0.5366351334884458, 0.5872063777841047, 0.6895398804726044, 0.39739739739739727, 0.3328357028933284, -0.2752752752752752, 0.3666666666666667], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.04176417738199234, "ela_features": [0.027000316363816345, 0.4256219684791865, 0.013524303598865686, 0.057154569574926, 12.01094367521939, 0.026207828122748154, 0.4349654035061533, 1.4562776931175294, 0.4378427297106132, -0.04076684000285713, 0.028440968129596112, 2.0, 0.6838825684312118, 0.8183743772792148, 0.467845259780259, 0.2282093293413808, -0.5831797206165643, 0.6075628448894183, 0.6886307559573316, 0.7353627473796267, 0.8191013204025103, 0.5923548272159471, 0.6807673498958151, 0.7287202852519905, 0.8131996162028902, -0.34516054862306744, -0.273860953609252, -0.2327587652485586, -0.15910902895462675, -0.36036555273841997, -0.28221194646226194, -0.23982077342205227, -0.1651409636031847, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21756755454734078, 0.2175946590924632, 0.20746505098437398, 0.19832851910613752, 0.8631515424484274, 0.39339339339339324, 0.3452353998538063, -0.24324324324324315, 0.6283653846153847], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0038479669019579887, "ela_features_10D": [0.02232949921930829, 0.3967376856809486, 0.0051721713573989105, 0.04323044242633005, 10.943921810028433, 0.020452276885482613, 0.4441988141509244, 1.2972841841792484, 0.4443003962386068, -0.020127743749774597, 0.006371294611161727, 1.2, 0.8594120950085916, 0.9127629509282963, 0.5925323316320722, 0.12672526700330103, -0.6195777152073203, 0.7336429345592469, 0.7730258048952946, 0.8132980937258945, 0.8693604636407933, 0.7320616116723886, 0.7721438802085311, 0.8127066551547776, 0.8698321111584459, -0.3377830572439774, -0.2878396887328726, -0.23676803288377699, -0.16567169292800302, -0.34060972533291983, -0.28965758436478894, -0.23809285530855004, -0.16547295386645255, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10997851727329247, 0.10997837808373431, 0.10738566107535794, 0.10738071873833496, 0.868160834835819, 0.009009009009008983, 0.14336875315708117, -0.5875875875875873, 0.6356285028022418], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0012384409783408046}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-4.00000000000011, -4.00000000000011], 1.5], [21, [-4.00000000000011, 0.00044444444444512003], 0.7500001975308642], [49, [0.00044444444444512003, 0.00044444444444512003], 4.369643524667041e-07], [21, [0.00044444444444512003, -4.00000000000011], 0.7500002394334883]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.0175978858794106e-163, -6.7329305954256e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-9.52275161541289e-163, -9.266439771001118e-163, 9.499482573274787e-163, -7.114882535457371e-163, -3.476786723810236e-163]}
{"id": "de571ef2-7f92-4f0e-9844-a80acda6e5a3", "fitness": 0.6447121491510188, "name": "landscape_cosine_wells", "description": "A completely different separable benchmark landscape using per-dimension quadratic base plus cosine-based wells. Each dimension adds a nonnegative modulation  a_i*(1 - cos(n_i x_i)) on top of x_i^2, creating multiple local minima while preserving a unique global minimum at the origin. Parameters are deterministic and dimension-specific to keep the landscape reproducible and tunable.", "code": "import numpy as np\n\nclass landscape_cosine_wells:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Deterministic, per-dimension modulation amplitudes (nonnegative)\n        self.a = 0.25 + 0.15 * np.arange(dim)\n        # Deterministic, per-dimension cosine frequencies\n        self.n = 1.0 + 0.5 * np.arange(dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n        # Separable per-dimension function: f_i(t) = t^2 + a_i*(1 - cos(n_i * t))\n        per_dim = x**2 + self.a * (1.0 - np.cos(self.n * x))\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_cosine_wells scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["640051b4-c98c-47c2-b212-383d2da40840"], "operator": null, "metadata": {"ela_features_2D": [-0.0014327143303761725, 0.3732183620613985, 0.007054143309942149, 0.03146883123812906, 6.576745182721635, -0.0013413083717909613, 0.9991442424412422, 1.0298048000692088, 0.9991412008916049, 0.3737785482435313, -0.453673816866562, 1.6, 0.7137684251093905, 0.7091572465187695, 0.5613007466158518, 0.3487922233210655, -0.20512629655174391, 0.11971362434654846, 0.21670074861911043, 0.32540521606865075, 0.5057584164501222, 0.12044139993427305, 0.21447072970650827, 0.3226992096456948, 0.5065119335355794, -0.4611666050746962, -0.4103603162052069, -0.35341086756925516, -0.25892723251328853, -0.45342081826920355, -0.40495121661582667, -0.3491521917161111, -0.25440257623770457, 1.0, 1.0, 1.0, 1.0, 0.5135830090036471, 0.5134476654310036, 0.4025009155921855, 0.3532264127763848, 0.7032228441642412, 0.39739739739739727, 0.5325588610946405, -0.06706706706706704, 0.36385542168674695], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8678290843963623, "ela_features": [0.00014678946326629472, 0.3953164803928386, 0.002520371721038249, 0.03104721186940875, 47.61313265995672, 0.00843844512824692, 0.9969553040309285, 1.0276087968694483, 0.9969442799073226, 0.28668171610590015, -0.1467293775104297, 1.2, 0.9115994468519395, 0.8725875677777678, 0.6516444901350686, 0.18413593105925957, -0.46784250978357916, 0.44938546825868936, 0.5320433074293718, 0.6011068680375307, 0.71333736772092, 0.45146266056462403, 0.5351445607635775, 0.605078701193995, 0.7193092884944108, -0.4843788224888275, -0.41166392957977543, -0.35090817068577057, -0.2521788517093803, -0.48498538540470637, -0.41099483500565837, -0.34916468229556413, -0.2481710224776652, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21701975172932722, 0.21704449834873488, 0.20367644642871924, 0.1837136659953467, 0.8201998842336117, 0.09309309309309305, 0.2455505476517769, -0.41141141141141124, 0.5052884615384615], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0002438786468701437, "ela_features_10D": [-0.0014974301817717085, 0.41712324576480697, 0.0013876684517342822, 0.015390451784321638, 128.00000686365993, 0.006346737118718226, 0.9909502851870593, 1.0415801105119864, 0.9909403491134539, 0.20304754355915416, -0.057220214090228, 1.4, 1.0196607243811076, 0.9378413820674805, 0.715237756130632, 0.10541076923569212, -0.609486707945743, 0.6174158839064315, 0.6791348675352197, 0.7291240469226417, 0.8072681313643235, 0.6202319553353893, 0.6839498485624418, 0.733982119541498, 0.81215061518324, -0.4851898682810322, -0.40691878014911137, -0.34352288268136777, -0.24442111511527936, -0.48282063389324065, -0.4018141169043636, -0.33820471702425525, -0.23882406311897744, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10921321471248424, 0.1092137404146865, 0.10626362343871854, 0.09992514574135443, 0.8562288784963759, -0.13113113113113112, 0.1332506359220136, -0.6556556556556554, 0.5871897518014412], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00019993186288047582}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 5.086419716068831e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.4093662748859196e-162, -9.668652324771476e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.989866254538715e-163, 8.345862560583839e-164, 2.7650650710189455e-163, -1.4605304263740458e-162, 9.140981937750476e-163]}
{"id": "81a8ca1f-74f8-4507-a2e7-fc0661a0f855", "fitness": 0.6663156965514645, "name": "landscape_enhanced", "description": "A novel separable landscape built from a 1D oscillatory-quadratic base per dimension with an improved GlobalLocal metric. GlobalLocal aggregates per-dimension local minima using an L2-norm approach (robust to dimensionality) and normalizes by the mean landscape value, providing a more representative contrast between global and local peaks in multi-dimensional space.", "code": "import numpy as np\n\nclass landscape_enhanced:\n    \n    def __init__(self, dim=5, A=2.0, omega=3.0, grid_points=4001):\n        \"\"\"\n        dim: number of dimensions\n        A: amplitude of the oscillatory term in the 1D per-dimension function\n        omega: frequency of the oscillatory term\n        grid_points: resolution used to estimate the GlobalLocal metric (per-dimension)\n        \"\"\"\n        self.dim = int(dim)\n        self.A = float(A)\n        self.omega = float(omega)\n        self.grid_points = int(grid_points)\n        # GlobalLocal descriptor for the landscape, computed once at init\n        self.GlobalLocal = self._compute_global_local_metric()\n\n    def _g(self, t):\n        # 1D landscape component: g(t) = t^2 + A*(1 - cos(omega * t))\n        return t**2 + self.A * (1.0 - np.cos(self.omega * t))\n\n    def _compute_global_local_metric(self):\n        \"\"\"\n        Estimate a GlobalLocal metric for the 1D component by scanning the domain [-5,5].\n        Global minimum is at t=0 with value 0.\n        Local minima are identified (excluding t=0), and the strongest local minimum value\n        is compared to the mean value of g over the domain.\n        For multi-dimensional spaces, we aggregate per-dimension local minima via L2-norm\n        and normalize by sqrt(dim) * mean_g to obtain a robust GlobalLocal descriptor.\n        GlobalLocal = sqrt(sum_i(max_local_min_i^2)) / (sqrt(dim) * mean_g)\n        \"\"\"\n        t = np.linspace(-5.0, 5.0, self.grid_points)\n        y = self._g(t)\n\n        # Identify local minima: points where y[i] <= y[i-1] and y[i] <= y[i+1]\n        if y.size < 3:\n            return 0.0\n        interior = y[1:-1]\n        left = y[:-2]\n        right = y[2:]\n        is_local_min = (interior <= left) & (interior <= right)\n\n        # Corresponding t-values for local minima (excluding the global minimum near t=0)\n        t_candidates = t[1:-1][is_local_min]\n        minima_values = interior[is_local_min]\n\n        # Exclude the global minimum at t ~ 0 (t=0 is often present in the grid)\n        if t_candidates.size > 0:\n            step = t[1] - t[0]\n            non_global_mask = (np.abs(t_candidates) > step * 0.5)  # exclude near-zero points\n            minima_values = minima_values[non_global_mask]\n        else:\n            minima_values = np.array([])\n\n        # Strongest local minimum value per dimension (1D)\n        max_local_min_per_dim = float(np.max(minima_values)) if minima_values.size > 0 else 0.0\n\n        mean_g = float(np.mean(y))\n        if mean_g <= 0.0:\n            return 0.0\n\n        # GlobalLocal in multi-dim: aggregate across dims via L2-norm and normalize\n        # Since all dims share the same (A, omega), per-dim maxima are identical.\n        # GlobalLocal = sqrt(sum_i(max_local_min_i^2)) / (sqrt(dim) * mean_g)\n        # => = max_local_min_per_dim / (sqrt(dim) * mean_g) for identical dims\n        return max_local_min_per_dim / (np.sqrt(self.dim) * mean_g)\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the separable landscape: f(x) = sum_i g(x_i)\n        Where each g is the 1D component defined above.\n        x must be a 1D numpy array of length 'dim' with values in [-5, 5].\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}.\")\n        # Clip to domain to ensure evaluation is within bounds\n        x = np.clip(x, -5.0, 5.0)\n        # Compute per-dimension g(x_i) and sum\n        g_vals = self._g(x)\n        return float(np.sum(g_vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["85a9a836-e812-4d32-9e29-227eabe42c69"], "operator": null, "metadata": {"ela_features_2D": [-0.0024907301079335033, 0.3863791134916442, 0.007236530189783846, 0.02236324008354685, 44.2422154067487, -0.0004849773097894694, 0.9640803806353189, 1.0092435942167721, 0.9639671872653148, 0.40278760706098293, -0.39187593662584835, 2.0, 0.601659404982242, 0.6962697042347281, 0.5094067620415444, 0.34842863395053325, -0.22323508983860343, 0.17069855533703562, 0.31288741401226655, 0.3767421300183719, 0.4993439006861452, 0.16690720599953596, 0.31319621800672276, 0.38254030609019346, 0.5005087395237791, -0.433924774457746, -0.35952971021294705, -0.32612289990738236, -0.26197280486024477, -0.42880879587391896, -0.35350743975859633, -0.31780602103899314, -0.25709040982660397, 1.0, 1.0, 1.0, 1.0, 0.513456762727267, 0.5134531715032145, 0.4152726533299618, 0.3486924321382953, 0.7467703617242869, 0.5175175175175173, 0.5256577028533684, -0.05905905905905908, 0.39558232931726905], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9972724318504333, "ela_features": [-0.0019047668570737696, 0.387905577131043, 0.0019480461938244779, 0.017815637248786632, 18.19739612306153, -0.0015198744796332208, 0.9650772126520867, 1.0224836960102504, 0.9651356911075577, 0.2518631681024417, -0.071080763499201, 1.8, 0.8848086338501245, 0.8657657665934646, 0.6204955863475174, 0.19093299637410052, -0.4846531738901289, 0.4477353218275414, 0.5335204553568456, 0.6098948036022847, 0.7235917113890092, 0.4524766373153721, 0.5343755169695752, 0.6102613442052535, 0.7258718601998868, -0.48586466150599755, -0.4103944459144758, -0.34320168996391703, -0.24317455444867084, -0.4844249005281105, -0.41196349925812104, -0.3448203520944821, -0.242532964373858, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21305507630605125, 0.21305736909205888, 0.2009602634536633, 0.17851763224476222, 0.8391838808417328, 0.13313313313313307, 0.2590973755673213, -0.39539539539539525, 0.5416666666666667], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00031704208231531084, "ela_features_10D": [-0.00043756107488701623, 0.4442813238232457, 0.0016474164578594748, 0.018723454620812402, 196.8425054539265, 0.00317968320600559, 0.9654012240139046, 1.0283013020106486, 0.9652569671417934, 0.17853790423803093, -0.1032942710937486, 1.2, 1.0081887331555799, 0.9377655468349027, 0.7004786273019509, 0.10537019662959646, -0.6090963655568297, 0.6341106828960766, 0.6891390885289812, 0.7380732753298984, 0.8111301579076917, 0.6354337516608277, 0.692648125271145, 0.7420504308971296, 0.8154869881290834, -0.4640535660332529, -0.3942619253538188, -0.33219908629538775, -0.2395421664394432, -0.4636312354159031, -0.3908704389921075, -0.3280433846992338, -0.2346523966130271, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11061608830548879, 0.11061013779696369, 0.10773399883847048, 0.1007403604673158, 0.8577160230266477, -0.11911911911911906, 0.12745894870756627, -0.6636636636636635, 0.5879103282626101], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0003047053760383278}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950616757018855e-06], [8, [0.00044444444444512003, -1.869777777777863], 3.93322324364782], [8, [-1.869777777777863, 0.00044444444444512003], 3.93322324364782], [16, [-1.869777777777863, -1.869777777777863], 7.866442536678883], [16, [1.869777777777864, -1.869777777777863], 7.866442536678884], [16, [-1.869777777777863, 1.869777777777864], 7.866442536678884], [8, [1.8700000000003303, 0.00044444444444512003], 3.9332226518931415], [8, [0.00044444444444512003, 1.8700000000003303], 3.9332226518931415], [16, [1.869777777777864, 1.869777777777864], 7.866442536678885]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1096180439343525e-162, -2.0747634945401696e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.3446747601596641e-162, 1.9049612445138056e-163, -9.021032686135685e-163, 6.768888200743074e-163, -1.2065233137562885e-162]}
{"id": "7e6a5eb2-361b-4fc6-b44f-29b7407ca080", "fitness": 0.6644387703029982, "name": "landscape_min_of_quadratics_wells", "description": "A completely different separable benchmark where each dimension\u2019s landscape is the minimum over several localized quadratic wells (centers mu_j) with nonzero depths c_j, plus a global well at zero. The per-dimension f_i(t) = min_j [(t - mu_{i,j})^2 + c_{i,j}]. The global minimum is at x=0 with f=0, while other wells yield local minima with positive depth, producing a clear global-local contrast. The landscape is fully separable and bounded to [-5,5].", "code": "import numpy as np\n\nclass landscape_min_of_quadratics_wells:\n    \"\"\"\n    A completely different, separable landscape.\n    Each dimension has several localized quadratic wells:\n      f_i(t) = min_j [ (t - mu_{i,j})^2 + c_{i,j} ]\n    where j=0 is the global well at mu=0, c=0 (global minimum at x=0).\n    Other wells (j>=1) create non-global local minima.\n    The overall objective is F(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5, n_wells=4, seed=123):\n        self.dim = int(dim)\n        self.n_wells = max(2, min(int(n_wells), 6))  # ensure a reasonable number of wells\n        self.seed = seed\n        rng = np.random.RandomState(seed)\n\n        # Prepare per-dimension centers mu[i, j] and depths c[i, j]\n        # Shape: (dim, n_wells)\n        self.mu = np.zeros((self.dim, self.n_wells), dtype=float)\n        self.c = np.zeros((self.dim, self.n_wells), dtype=float)\n\n        for i in range(self.dim):\n            # j = 0 is the global well at 0 with zero depth\n            self.mu[i, 0] = 0.0\n            self.c[i, 0] = 0.0\n            for j in range(1, self.n_wells):\n                # Place non-global wells at alternating sides with a small dimension-dependent spread\n                sign = -1 if ((i + j) % 2 == 0) else 1\n                self.mu[i, j] = sign * (0.8 * j + 0.2 * (i % 3))\n                # Clamp to domain [-5, 5]\n                if self.mu[i, j] > 5.0:\n                    self.mu[i, j] = 5.0\n                if self.mu[i, j] < -5.0:\n                    self.mu[i, j] = -5.0\n                # Depth of the j-th local well (positive)\n                self.c[i, j] = 0.15 * j + 0.04 * (i)\n\n        # Optional small jitter to avoid perfectly symmetric arrangement (preserves 0-centered global minimum)\n        if self.seed is not None:\n            jitter = rng.uniform(-0.04, 0.04, size=(self.dim, self.n_wells))\n            # Do not jitter the global well to keep 0 as a guaranteed global minimum\n            self.mu[:, 1:self.n_wells] += jitter[:, 1:self.n_wells]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n        total = 0.0\n        for i in range(self.dim):\n            t = x[i]\n            # Compute min_j ( (t - mu[i, j])^2 + c[i, j] ) across wells\n            diffs = t - self.mu[i, :self.n_wells]\n            vals = diffs**2 + self.c[i, :self.n_wells]\n            total += float(np.min(vals))\n        return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_min_of_quadratics_wells scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["640051b4-c98c-47c2-b212-383d2da40840"], "operator": null, "metadata": {"ela_features_2D": [0.09400592991766236, 0.2281025985962184, 0.13489569237527294, 0.1547226671098767, 1.153848810828221, 0.09562744451943601, 0.9069410046422334, 1.1647513932628604, 0.9256946848553598, 1.1207026481971964, 0.876351246859614, 1.6, 0.5773215973971186, 0.698727162718481, 0.47009047555905886, 0.3444847791760407, -0.20260709928258774, 0.17912713146098164, 0.2900903276621768, 0.393811648978483, 0.5323763503537109, 0.17761538679903788, 0.2920883663887068, 0.3876938961726338, 0.525755420815286, -0.42948963995900835, -0.3714310653376435, -0.317159126325282, -0.2446654578382541, -0.42230926706023253, -0.3635378752665274, -0.31442394321441103, -0.24352629241656093, 1.0, 1.0, 1.0, 1.0, 0.5235270063089519, 0.5235153600478212, 0.45081641580472187, 0.442173924896548, 0.7011004775996991, 0.5335335335335334, 0.4109998461733501, -0.18718718718718716, 0.40763052208835343], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9850601553916931, "ela_features": [0.1033333604430878, 0.3205776632206402, 0.06331249931934936, 0.11139429361674677, 1.7755815269240256, 0.10791942421122588, 0.9048190653590916, 1.4549242862834801, 0.9278841153848019, 0.7328420206290709, 0.3885192794318589, 1.6, 0.8758180164835163, 0.865834871762465, 0.6092864958449249, 0.19208915123258466, -0.47306298392275903, 0.5040549864692709, 0.5653767901410278, 0.6199683090935559, 0.7311995756331189, 0.5049733976175071, 0.5628388391700485, 0.6196773807927947, 0.7344618026063999, -0.43623342838053175, -0.3822942165481198, -0.33427526407406843, -0.23643667683794276, -0.43764756859200116, -0.3864884588287156, -0.33623747177119956, -0.23475858711741307, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2176432882752819, 0.21765036713391517, 0.20724669569008047, 0.22080987024495252, 0.8315679175794088, 0.25325325325325315, 0.2659931307744541, -0.3353353353353353, 0.553525641025641], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0012861326104030013, "ela_features_10D": [0.109137656178275, 0.3320083181238435, 0.038624444249233836, 0.0712870247715797, 1.850415038074966, 0.11517383766743798, 0.9058697565397955, 1.4762799841323897, 0.9295927117735522, 0.48925384369209085, 0.15283885667913574, 1.8, 1.0005308237732575, 0.9377923488406262, 0.6903840522437835, 0.10591830044341363, -0.5774909041166031, 0.6302559928215363, 0.685832866902268, 0.7400317182925917, 0.81863537582405, 0.6318685510480269, 0.6882492321516614, 0.7426773805123055, 0.8213423272779956, -0.46885137500201035, -0.3983769698071974, -0.32965066955148636, -0.2299780212455133, -0.46800549808106917, -0.3963279307605313, -0.3271340878455827, -0.22712751624593772, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11006577254164743, 0.11006009417732883, 0.10772487626012803, 0.12203852673546356, 0.8625333433546313, -0.06706706706706708, 0.12987214700495925, -0.6356356356356354, 0.6018414731785428], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0002863338158931583}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [-0.2619561338170279, -0.11498406262878662], 0.08184235070298537], [4, [0.7826666666666662, 0.00044444444444512003], 0.15000024792219266], [6, [0.7826666666666662, 1.8386666666666671], 0.4900000926342365], [3, [-0.04716529816442965, -0.9619631273212153], 0.19417717614532973], [12, [-1.6219681763884792, -2.5853685438288716], 0.7900000375250957], [4, [-1.622244422691547, -1.0058652387969866], 0.49000023602270076], [8, [-1.620814621850188, -0.0031343072516661183], 0.30001089979412376], [3, [2.271845271766235, -0.8948463185306901], 0.6698815234096738], [6, [2.404000000000286, 0.00044444444444512003], 0.4500002085940177], [9, [2.4035481427716574, -2.575157401861916], 0.9401014378337821], [6, [0.7069423167760013, -2.5313411405769317], 0.648670468918994], [8, [-0.25779021954707027, 1.6300856867408495], 0.4498761250942224], [12, [2.40475379426046, 1.8379264544098426], 0.790000706582743], [3, [-0.20161325418468024, -2.3465372554065564], 0.5876143117144028], [14, [-1.6226666666666665, 1.8386666666666671], 0.6400007061141666]], "nr_of_basins": 15, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.073619109066969e-163, -9.744832013063366e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.4679093268299098e-163, 9.02160468659547e-163, -1.289469120049129e-162, 4.585705613373296e-163, 1.3169431968690839e-163]}
{"id": "7e96f668-95d2-4719-b32c-e3d800bec321", "fitness": 0.6646093549206853, "name": "landscape_separable_minquad_wells", "description": "A strictly separable per-dimension landscape built from per-dimension min-of-quadratics wells with randomized centers, guaranteeing a global minimum at the origin. Each dimension has its own set of local wells; depths increase with distance from zero to create controllable GlobalLocal contrast. The function remains additive across dimensions, enabling straightforward partitioning into subproblems and easy exploitation by separable optimizers. The difficulty can be tuned via the number of wells, spread range, and depth contrast.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells:\n    \"\"\"\n    A strictly separable benchmark:\n    - Each dimension i has its own set of 'wells' (centers) s_i_j in [-L, L].\n    - The per-dimension contribution is: min_j [(x_i - s_i_j)^2 + d_i_j]\n    - Global minimum is at x = 0 with f(x) = 0.\n    - Depths d_i_j are assigned so that wells farther from zero are deeper (controlled by 'contrast').\n    - The implementation is fully separable: f(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: the span of wells along each axis; wells lie in [-L, L]\n        contrast: scales the depth of non-global wells (GlobalLocal control)\n        seed: random seed for reproducibility (optional)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.rng = np.random.default_rng(seed)\n\n        # Build per-dimension well centers with a guaranteed global well at 0\n        s_per_dim = []\n        for i in range(self.dim):\n            # Randomly draw wells in [-L, L], then sort\n            s = self.rng.uniform(-self.L, self.L, size=self.wells)\n            s.sort()\n            # Ensure a well exactly at 0 for the global minimum\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n            s_per_dim.append(s)\n\n        S = np.stack(s_per_dim, axis=0)  # shape: (dim, wells)\n\n        # For each dimension, order wells by distance to zero and assign depths accordingly\n        order = np.argsort(np.abs(S), axis=1)  # shape: (dim, wells)\n        s_sorted = np.zeros_like(S)\n        d_sorted = np.zeros_like(S)\n\n        depths = np.arange(self.wells, dtype=float) * self.contrast  # 0, contrast, ..., (wells-1)*contrast\n        for i in range(self.dim):\n            o = order[i]\n            s_sorted[i, :] = S[i, o]\n            d_sorted[i, :] = depths[o]\n\n        self.s = s_sorted  # per-dimension wells positions\n        self.d = d_sorted  # per-dimension depths aligned with wells\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        # Vectorized computation:\n        # t has shape (d, 1); s and d have shape (dim, wells)\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_minquad_wells scored on:Separable 1.000, GlobalLocal 0.030,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["560e4325-4788-4a2a-8f95-9e38a29946fe"], "operator": null, "metadata": {"ela_features_2D": [0.8363913921983581, -0.14193581150419984, 0.3656911173429834, 0.5746595609941807, 1.5749529970810943, 0.837042037068225, 0.977476333414074, 1.5286877598060635, 0.9884394847957602, 0.6437814349198108, -0.11317063774226757, 1.8, 0.6893100707061688, 0.7114234364605794, 0.5358407473873452, 0.3437559262684347, -0.12575247857533353, 0.16480682509118863, 0.28474194851650847, 0.3517108909795993, 0.5123647490769324, 0.16587527918682093, 0.28992567128716834, 0.3536167984623796, 0.5125690209643994, -0.4369327242470855, -0.3741867643607128, -0.3391565839442564, -0.25510976157016957, -0.42855300873200636, -0.36482014727002987, -0.3321101719463727, -0.25043857534779085, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5200064927873145, 0.5199566522591862, 0.5688749304901752, 0.6270180973929209, 0.7274911623616626, 0.3173173173173172, 0.34916560076832825, -0.2872872872872872, 0.36746987951807225], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9362338781356812, "ela_features": [0.9141091734433141, -0.16240194285847967, 0.2191357669846436, 0.2946427150784907, 1.3446178326478746, 0.914131182066015, 0.9577934708629577, 4.645499798189453, 0.9639965798464338, 0.13690375774779415, -0.3070276827815054, 1.0, 0.8479403179698313, 0.8636764663164431, 0.6089176498075011, 0.1900858828897828, -0.2897549121819595, 0.5330810303548349, 0.6307216326050415, 0.7048935878301559, 0.8175228701290556, 0.5246564694921994, 0.6213252523677437, 0.697250546831212, 0.8119772608414765, -0.4107805980603173, -0.3248794674793253, -0.2596252409462214, -0.16053741843589717, -0.4205766743345484, -0.33505139104045634, -0.2678714560471983, -0.16635632221462782, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21196762608192882, 0.21196578251371548, 0.25118317150356734, 0.3283489046839164, 0.8250457535579689, -0.0790790790790791, 0.15760817333944416, -0.6076076076076073, 0.5099358974358974], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.021642765030264854, "ela_features_10D": [0.7888405345471248, -0.26100868432501967, 0.10858447225946169, 0.17195217171090232, 1.5865258165580376, 0.7896968372447009, 0.90578552494558, 94.08707259428438, 0.9595492581852796, 0.06097872002700795, -0.09285694962269657, 1.4, 0.9086493037624891, 0.9238220974666387, 0.6703579879214155, 0.11385375399416757, -0.42508720755961865, 0.7133242932911799, 0.7797562902436913, 0.8312587970208657, 0.8984491201698726, 0.7128426829979452, 0.781791041651859, 0.8325234415743333, 0.8989005105707735, -0.36357423011625417, -0.2793223991114272, -0.2140048845460562, -0.12879090259475312, -0.3651452784830279, -0.27747250085945474, -0.2129623092512917, -0.12855646317117664, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.109695339367157, 0.10970007451016159, 0.12290220042780058, 0.17369201865698444, 0.8507041624890735, -0.2672672672672672, 0.09497441656806731, -0.8158158158158155, 0.5588470776621296], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.02977948635816574}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [-0.012811916269395476, -3.6681402089411113], 3.000164161496611], [3, [-2.7777777777777777, -3.6677777777776797], 1.0000891457825216], [6, [-3.8900000000001222, -3.6677777777776797], 1.1949272203259644e-07], [3, [-0.0012929943181948333, 2.8440093820787693], 10.000119030205903], [3, [1.3186666707634869, -1.501608953921805], 5.000000339688321], [3, [1.3186666747697835, -3.667852876110717], 4.000000356352784], [6, [-1.4115555555555561, 2.854888888889003], 9.000000282951063], [6, [-3.8900000000001222, 2.854888888889003], 7.000000066520821], [5, [1.3183702415735816, 2.854954622395322], 11.000000772301423], [8, [-0.006564259860992196, -1.5069247535965937], 4.000070357308485], [7, [-1.427424418331298, -1.5113001226351515], 3.0003273901588], [6, [-1.43709645451737, -3.68322685871008], 2.0008570247838575], [9, [2.3497777777778257, -1.5015555555555562], 6.000000408827941], [9, [2.350000000000292, -3.6677777777776797], 5.000000215088814], [8, [2.350635197720157, 2.8548704737227366], 12.000000056111269], [4, [-2.7777777777777777, -1.5015555555555562], 2.000089112376026], [8, [-3.8900000000001222, -1.5015555555555562], 1.0000000860862264], [3, [-2.7741022485617868, 2.8479480289336236], 8.000080750078205]], "nr_of_basins": 18, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.6550913696704557, -3.03359424638281], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.476972313985077, -2.5708923869786355, -0.9108222123827856, -3.84048473476153, -3.2092916102007214]}
{"id": "0e080937-ac3d-4df5-b8b9-4d08b6fceb50", "fitness": 0.6641213418770349, "name": "landscape", "description": "A separable multi-well landscape where each dimension is the minimum of several shifted quadratic wells. The global minimum is at the origin, while other wells create local minima with controllable depth. The problem remains separable and bounded on [-5, 5] per dimension, suitable for testing exploration vs exploitation.", "code": "import numpy as np\n\nclass landscape:\n    \"\"\"\n    Separable, multi-well landscape.\n    Each dimension takes the minimum over several shifted quadratic wells:\n        g_i(u) = min_j [ (u - mu_j)^2 + c_j ]\n    The full objective is f(x) = sum_i g_i(x_i).\n    This preserves a global minimum at x = 0 (since (0 - mu_0)^2 + c_0 = 0\n    with mu_0 = 0, c_0 = 0) and introduces additional local minima at other wells.\n    \"\"\"\n    def __init__(self, dim=5, wells=None):\n        \"\"\"\n        Initialize the separable multi-well landscape.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - wells: list of (mu, c) pairs to define per-dimension wells.\n                 If None, a default set of wells is used:\n                   [(0.0, 0.0), (0.8, 0.5), (-0.8, 0.5), (1.6, 0.9), (-1.6, 0.9)]\n                 The global minimum is at mu=0, c=0.\n        \"\"\"\n        self.dim = int(dim)\n\n        if wells is None:\n            self.wells = [\n                (0.0, 0.0),    # global minimum\n                (0.8, 0.5),\n                (-0.8, 0.5),\n                (1.6, 0.9),\n                (-1.6, 0.9)\n            ]\n        else:\n            # Normalize input wells\n            self.wells = [ (float(mu), float(c)) for mu, c in wells ]\n\n        self.num_wells = len(self.wells)\n\n        self.global_min_per_dim = 0.0  # by construction (mu=0, c=0)\n        # Exclude the global minimum well when computing the strongest local minimum\n        non_global_cs = [c for (mu, c) in self.wells if not (mu == 0.0 and c == 0.0)]\n        if len(non_global_cs) > 0:\n            self.local_min_per_dim = min(non_global_cs)\n        else:\n            self.local_min_per_dim = 0.0\n\n        self.global_local_contrast = self.local_min_per_dim - self.global_min_per_dim\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i min_j [ (x_i - mu_j)^2 + c_j ]\n\n        Domain: x_i in [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar value of the landscape at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds (optional; ensures evaluation respects problem bounds)\n        x = np.clip(x, -5.0, 5.0)\n\n        # Compute per-dimension minimum over wells\n        total = 0.0\n        for xi in x:\n            per_dim_vals = np.array([ (xi - mu)**2 + c for (mu, c) in self.wells ])\n            total += float(per_dim_vals.min())\n\n        return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["81aefca4-3c83-4278-815f-8eb7e8531587"], "operator": null, "metadata": {"ela_features_2D": [-0.0027301479343846856, 0.27764375308696315, 0.008605832589445318, 0.022238824726867012, 72.25991405461515, -0.002780317786273834, 0.9707818955902109, 1.0095225842057303, 0.9709740876399644, 0.7943378340531815, 0.0307108839405406, 1.6, 0.6966411487157627, 0.7156673380582881, 0.5533208888877166, 0.3411837918353882, -0.21057310422179806, 0.12683283407762755, 0.21476136577794963, 0.3075989466205932, 0.48485515089002984, 0.12935727825127877, 0.21623958236948188, 0.3068932617725002, 0.4840612328357089, -0.4565767696856257, -0.4105965213360154, -0.3620505928962854, -0.26936416961733733, -0.4466559084570575, -0.4020778029413579, -0.3555621793395197, -0.2646707802164906, 1.0, 1.0, 1.0, 1.0, 0.5184163357630035, 0.5184125528649026, 0.4065295947637808, 0.3527901778686059, 0.687964406182073, 0.5255255255255253, 0.3634550018946558, -0.1191191191191191, 0.37228915662650597], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9840779304504395, "ela_features": [0.000293297731207498, 0.36318979018860553, 0.0024448893148687916, 0.02885907836814542, 25.823191373579625, 0.004744121336803975, 0.9705516175649608, 1.0212749699445276, 0.9706650531278587, 0.43941537466561986, -0.16704339226339462, 1.2, 0.9141102741823689, 0.8715464076283572, 0.6329470896453608, 0.18777364430249566, -0.4857590882341767, 0.4396825966808048, 0.5263164248363278, 0.5992207565443974, 0.7196232438545277, 0.4430648169682194, 0.5265434592237602, 0.6030112871679385, 0.7234581440500599, -0.4928955696949518, -0.41668557555117614, -0.35255399996749653, -0.24663967398875278, -0.4923595596764, -0.41855581544163795, -0.35095423437030193, -0.2444757180400555, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21513083652824244, 0.21511301639064695, 0.19920108896853836, 0.18197754011024186, 0.8345999145877077, 0.21721721721721715, 0.29223396624682463, -0.3233233233233232, 0.5360576923076923], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00032580277184024453, "ela_features_10D": [-0.0008123792538206942, 0.4019506437280467, 0.0013900311422666643, 0.018694605379438012, 51.99597789916551, 0.007939580228887123, 0.9703107233061248, 1.0360572306020834, 0.9706658342481704, 0.33816318659807854, -0.03512783098540506, 1.4, 1.0221348060031614, 0.9387582532096982, 0.710853939823769, 0.10541537749176692, -0.6054378775383474, 0.6188306697052299, 0.679091604306472, 0.7285167533778983, 0.8079535437412444, 0.6214968797521866, 0.6824063746109515, 0.7327036615302588, 0.8122161227424858, -0.483381933669955, -0.40696148445891095, -0.34428289075352314, -0.243544826079912, -0.48117877951756666, -0.40374567943670686, -0.3398047470419972, -0.2387234001184106, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11065480516587485, 0.11066030766775632, 0.10744189462605039, 0.10099956977626756, 0.8583216541407783, -0.08308308308308308, 0.13491324313048375, -0.6316316316316314, 0.6064851881505204], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00032431803992949426}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [8, [0.00044444444444512003, -1.6006666666666665], 0.9000006419753087], [8, [-1.6006666666666665, 0.00044444444444512003], 0.9000006419753087], [16, [-1.6008405417074432, -1.5995862132930254], 1.8000008777298009], [8, [1.600666666666667, 0.00044444444444512003], 0.9000006419753087], [8, [0.00044444444444512003, 1.600666666666667], 0.9000006419753087], [16, [1.60029310268872, -1.6004844529952316], 1.8000003206038908], [16, [-1.6004925968175217, 1.600354775278899], 1.8000003685171233], [16, [1.599631687614285, 1.599926516030432], 1.8000001410539073]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [9.703085523655392e-163, -1.4687001674234245e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.419247471800984e-162, 1.336668348877427e-162, 2.1424016762493762e-163, 3.662641774875053e-163, 4.992573660481343e-164]}
{"id": "90791ae8-917a-45be-9001-b75647864f34", "fitness": 0.6263627847462582, "name": "landscape", "description": "A fully separable, block-aware Rastringin-like landscape with per-dimension amplitude and frequency. The per-dimension subproblems are independent and can be partitioned into contiguous blocks (subproblems) to reflect scalable, decomposable optimization tasks. The global minimum is at the origin, while local minima density is controlled by per-dimension frequencies, enabling tunable GlobalLocal contrast without coupling between dimensions.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim):\n        \"\"\"\n        Initialize a fully separable, cosine-modulated quadratic landscape.\n\n        Parameters:\n        - dim: int, number of dimensions\n        \"\"\"\n        self.dim = int(dim)\n\n        # Base per-dimension amplitude (kept constant here, but can be varied per-dimension if desired)\n        self.A_base = 10.0\n        self.A_arr = np.full(self.dim, self.A_base, dtype=float)\n\n        # Per-dimension frequencies (deterministically generated for reproducibility)\n        self.w_arr = self._generate_w(self.dim)\n\n        # Block structure (for explicit separability scaffolding): partition dims into\n        # contiguous blocks of size block_size. The function remains sum of independent\n        # 1D landscapes, but the block view helps reasoning about subproblems.\n        self.block_size = 2 if self.dim >= 2 else 1\n        self.blocks = self._generate_blocks(self.dim, self.block_size)\n\n        # Global minimum per-dimension value is 0 at x_i = 0, so f(0) = 0\n        # This is preserved by the chosen per-dimension form below.\n\n    def _generate_w(self, dim):\n        # Deterministic pseudo-random sequence for reproducible frequencies\n        seed = 1234567\n        w = np.empty(dim, dtype=float)\n        for i in range(dim):\n            seed = (1103515245 * seed + 12345) % (2**31)\n            # Map to a range that yields interesting local minima (0.3 to 1.0 roughly)\n            w[i] = 0.3 + (seed % 1000) / 1000.0 * 0.7\n        return w\n\n    def _generate_blocks(self, dim, block_size):\n        blocks = []\n        i = 0\n        while i < dim:\n            end = min(dim, i + block_size)\n            blocks.append(slice(i, end))  # contiguous block [i:end]\n            i = end\n        return blocks\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        The function is:\n            f(x) = sum_i [ A_i + x_i^2 - A_i * cos(2\u03c0 * w_i * x_i) ]\n\n        Domain: x_i \u2208 [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - float: landscape value at x\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds (optional; ensures evaluation respects problem bounds)\n        x = np.clip(x, -5.0, 5.0)\n\n        # Vectorized per-dimension contribution\n        contrib = self.A_arr + x**2 - self.A_arr * np.cos(2 * np.pi * self.w_arr * x)\n\n        # Optional explicit block-wise accumulation (for clarity; results identical to a sum)\n        # total = 0.0\n        # for sl in self.blocks:\n        #     total += np.sum(contrib[sl])\n        # return float(total)\n\n        return float(np.sum(contrib))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:Separable 1.000, GlobalLocal 0.005,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["81aefca4-3c83-4278-815f-8eb7e8531587"], "operator": null, "metadata": {"ela_features_2D": [-0.0025384202377531475, 0.4567454746793248, 0.0049689114005151535, 0.020897122082672536, 5.851635542349674, -0.004432445093686921, 0.5095274200581563, 1.0345074019743277, 0.509034574549252, 0.16521438091834445, -0.23607128343502595, 1.4, 0.35448184794793175, 0.5782089952528127, 0.33465368751709273, 0.4085896593687769, -0.48299554902212216, 0.4280624393639867, 0.4950620608166674, 0.6117709347824736, 0.6901535901727307, 0.4262873072753079, 0.4883140451609971, 0.5960354605171598, 0.6809051480794344, -0.29930205543024535, -0.26423492567380935, -0.20316280064469994, -0.16214146832115792, -0.2952060286066577, -0.26328787268048515, -0.20785788222514068, -0.16418854832992463, 1.0, 1.0, 1.0, 1.0, 0.5192059741855418, 0.5192030779906974, 0.431433596099728, 0.3528270884430783, 0.8291921499157164, 0.9779779779779776, 2.1533830259843674, 0.5575575575575573, 0.5277108433734939], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.7512006163597107, "ela_features": [-0.0013425236496548143, 0.443183920092631, 0.0035726778708281637, 0.02143247575891675, 8.337381673833127, 0.0015798094963306753, 0.5529361993519395, 1.2297473050238228, 0.5509872964621382, 0.1590267756664115, -0.057585912824482575, 1.4, 0.7097827190455256, 0.8263547070412087, 0.4685109812258631, 0.22317731049566167, -0.5829557192441469, 0.6232356759041631, 0.697184318142807, 0.7366494413157957, 0.8022895607834528, 0.6174448794478341, 0.6937624877901063, 0.7327319450391744, 0.7992316365576858, -0.3314485138110266, -0.2663910772675761, -0.2316736525625358, -0.17392750443543786, -0.33835509157938465, -0.2708499382645634, -0.2363820095052233, -0.1775645858082926, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21215956512027687, 0.21216441084118842, 0.1998448472796554, 0.17822903005737487, 0.865807705819259, 0.4254254254254253, 0.37363428564541057, -0.19119119119119116, 0.632051282051282], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0018689282005652785, "ela_features_10D": [0.0002555929375381627, 0.44745228723996544, 0.0009905264451843994, 0.021771073980998996, 36.00850346421865, 0.000587724449451521, 0.5697542411005102, 1.4132754143705848, 0.5680974776361947, 0.12999686354111012, -0.06945906831201745, 2.0, 0.8751422142304076, 0.9176914098997063, 0.5797512612023672, 0.12568443300063067, -0.6266119979341511, 0.7635473957779816, 0.792279500377816, 0.8167784616232702, 0.8639266996871873, 0.7622674187199785, 0.7923572558126027, 0.8174993932786618, 0.8648584195603959, -0.29987194852500887, -0.2634340085104623, -0.232363940294985, -0.17256989967045616, -0.3022394160677376, -0.2639876754754681, -0.2320221186113657, -0.17181190483605585, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11041756229083129, 0.11041816836562539, 0.10778825221944421, 0.1008708056649877, 0.87143779239569, -0.011011011011011013, 0.14737557889174802, -0.5955955955955954, 0.6366693354683747], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.005107163917273283}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 5.606454104700731e-05], [2, [-4.988000000000001, 0.00044444444444512003], 25.07598252440529], [2, [-3.676952196044487, 2.2253364898955725], 19.6023325206923], [2, [-3.6757256286328954, -2.2251891283610665], 19.621368045729376], [3, [2.4847391551905544, 3.291703475464225], 17.948391651022092], [1, [3.740386546529333, -2.228757246566492], 19.10640260590761], [2, [4.986751128943898, -0.0006078163076276236], 25.076037241825823], [1, [4.962839201417317, 1.1131501601936111], 26.400638413905895], [1, [4.91348768792855, 2.2237973108652462], 30.7326724488493], [1, [4.772200249363953, 3.3238499864791393], 41.19174188181855], [1, [3.7409782567988907, 2.228345487699755], 19.106484043721764], [1, [4.9735023927812865, -1.1137805354979953], 26.350214388079333], [1, [4.9180361051407715, -2.225659138067226], 30.654136767543626], [1, [-4.9866627270988095, 1.1146381879313245], 26.326247349853457], [1, [-4.925147905694853, 2.225099268626524], 30.545039598505706], [1, [-4.894543596236343, 4.453869827044746], 46.09663717333406], [2, [1.2466666666666666, 0.00044444444444512003], 1.567323808364101], [2, [2.49377777777781, 0.00044444444444512003], 6.269136331536803], [2, [0.00044444444444512003, 1.1146666666666665], 1.2502772603363148], [2, [0.00044444444444512003, 2.229777777777839], 5.001074090974404], [2, [0.00044444444444512003, 3.3428888888889494], 11.252330363357686], [2, [0.00044444444444512003, 4.45800000000006], 20.00381062430943], [1, [1.2420529392000683, 1.0621929737988394], 3.2490260826083563], [1, [1.2419514392056907, 2.179800269122066], 6.9500153854754085], [1, [-1.2465373807524989, 2.225290350126995], 6.570683789230516], [1, [-1.242065499721156, 1.1145001148116553], 2.8205112494996403], [1, [-4.986662361748643, -1.1146394154566384], 26.32624743784971], [1, [-4.925144036833924, -2.2251119174800853], 30.545080082482578], [2, [0.0005373040133029675, -4.458000039241892], 20.003822102621005], [2, [0.00044444444444512003, -1.114666666666666], 1.2502772603363148], [2, [0.00023007152877666987, -3.343699056666832], 11.252196294010437], [1, [1.2322369361863033, -1.1139259877641445], 2.84471465060283], [2, [-0.006545024471542806, -2.223386792608451], 5.011675910623536], [1, [2.4876334289949464, -4.405060278940975], 26.708969961711542], [1, [1.24789906780325, -4.458078256221867], 21.571182185854408], [1, [2.4934819299387923, 4.456965354494643], 26.273163212032202], [1, [-2.4889350093370517, 4.4036361692996975], 26.730172090850886], [1, [-1.2462164545188583, 4.458259737110957], 21.57112138703354], [1, [-2.4876693999128703, -4.405047420697404], 26.709119506296126], [1, [-1.2478952095880884, -4.458076236205222], 21.571181374056593], [2, [-1.216731659248324, 0.024525922110419204], 1.7763085634607574], [1, [-1.2233842971590085, -1.1137404783251046], 2.8871686082463555], [2, [-2.4879268155594545, 0.004149550078747122], 6.276190681069616], [1, [1.2469304350035317, 4.45802963013106], 21.571067254023546], [2, [3.729694447997848, 1.1055539911841938], 15.383518473157535], [1, [-4.920579466280184, -3.339749917163563], 36.865363586634246], [1, [-4.920162703799231, 3.3400957270850498], 36.871492800041636], [1, [4.915839410051968, -3.3407547659737515], 36.94089834406998], [1, [-4.954832264122885, -4.456992496703728], 45.20966056182297], [2, [-2.4816650481296665, 2.2285350163992845], 11.288678351820748], [1, [4.929692659226827, 4.456339186167367], 45.48144131650017], [2, [2.4648926716490753, -2.228194162833074], 11.374533701807955], [2, [-2.4641983002226158, -2.2280659815676738], 11.379618423914028], [1, [3.658795141107466, -0.03159186168851259], 15.069254388904122], [1, [3.7306640336082313, -1.1153193472797738], 15.368180456046842], [1, [3.7257738501315716, 4.451330362671433], 34.144238360274116], [1, [3.713072225669657, -4.445707264990041], 34.2278497817277], [1, [-3.7115392369461624, 4.445011758145351], 34.2413185122311], [1, [-3.700969423984698, -4.439963957726129], 34.35498141055276], [2, [2.4795467105728464, -3.336128472942129], 17.55589118355661], [2, [-3.739897029692143, -0.0006599354103353119], 14.105514995932513], [1, [1.2211007125269326, -2.2165806848853453], 6.676847039428239], [1, [-1.2208110190154693, -2.2165835136582213], 6.678717453000383], [1, [2.442659833933578, 2.1502109010380592], 12.5481658141212], [1, [4.9630520987679265, -4.456938674792203], 45.15284040651658], [2, [-2.4773389378250945, -3.338875951495411], 17.558997378104884], [1, [3.7266429572410433, -3.3394713256704183], 25.38489358911955], [2, [-2.478046460724285, 3.3376234845117336], 17.55830517432451], [1, [3.680837595241067, 3.3232748647960393], 25.859061238768405], [1, [-3.684865340862389, 3.3257781837933655], 25.788128574038566], [1, [-3.6746007577394058, -3.321099619055986], 25.967550333931765]], "nr_of_basins": 71, "f_opt_dim_2": 0.0, "x_opt_dim_2": [6.546342856471384e-10, 1.7593722045997613e-09], "f_opt_dim_5": 3.220830269370623, "x_opt_dim_5": [-3.202378106862807e-10, 1.114598411296981, -1.788975486390564e-09, 3.3716593437051404e-09, -1.3967415433394708]}
{"id": "70f8d894-0dc9-4f59-baaa-428f0b601be5", "fitness": 0.5909927746591469, "name": "landscape_glocal_rastrigin", "description": "A separable Rastringin-inspired benchmark with an explicit GlobalLocal difficulty descriptor computed from a grid search of the 1D landscape. The global minimum is at the origin; local minima arise from the cosine perturbation. The GlobalLocal score is derived from the strongest non-global local minimum relative to the mean 1D landscape value, averaged across dimensions, providing a robust measure of local-minima contrast.", "code": "import numpy as np\n\nclass landscape_glocal_rastrigin:\n    \"\"\"\n    Novel separable Rastringin-like landscape with an explicit GlobalLocal\n    difficulty descriptor. Each dimension contributes:\n        g(u) = A + u^2 - A * cos(2*pi*u)\n    The global minimum is at u = 0 with g(0) = 0, and local minima arise from\n    the cosine modulation. The overall objective is:\n        f(x) = sum_i g(x_i) = A*dim + sum_i [ x_i^2 - A*cos(2*pi*x_i) ]\n    Domain: x_i in [-5, 5].\n    GlobalLocal is computed as an average over dimensions of the per-dimension\n    contrast: (min_non_global - global_min) / mean(g) for a single dimension.\n    \"\"\"\n\n    def __init__(self, dim=5, A=10.0, grid_points=1001):\n        \"\"\"\n        Initialize the landscape and compute a GlobalLocal descriptor.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - A: float, amplitude of the cosine perturbation\n        - grid_points: int, resolution for 1D grid to estimate local minima\n        \"\"\"\n        self.dim = int(dim)\n        self.A = float(A)\n        self.grid_points = int(grid_points)\n\n        # Build a 1D grid over [-5, 5] to estimate local minima for GlobalLocal\n        t = np.linspace(-5.0, 5.0, self.grid_points)\n        g = self.A + t**2 - self.A * np.cos(2.0 * np.pi * t)\n\n        # Mean value of the 1D landscape\n        mean_f1d = float(np.mean(g))\n\n        # Global minimum location (approximately at t=0)\n        min_idx = int(np.argmin(g))\n        min_val_global = float(g[min_idx])  # should be 0.0 for the exact formula\n\n        # Find local minima indices (excluding the global minimum index)\n        local_min_vals = []\n        for i in range(1, self.grid_points - 1):\n            if g[i] <= g[i - 1] and g[i] <= g[i + 1]:\n                if i != min_idx:\n                    local_min_vals.append(float(g[i]))\n\n        if len(local_min_vals) == 0:\n            # Fallback: take the smallest non-global value if no local minima found on grid\n            non_global_vals = [val for idx, val in enumerate(g) if idx != min_idx]\n            min_non_global = float(min(non_global_vals)) if non_global_vals else min_val_global\n        else:\n            min_non_global = float(min(local_min_vals))\n\n        # Per-dimension contrast: (deepest non-global min - global min) / mean_1d\n        # Since global_min == 0, this reduces to min_non_global / mean_f1d\n        per_dim_contrast = min_non_global / (mean_f1d if mean_f1d != 0 else 1.0)\n\n        # Store descriptors (same value across all dimensions for this separable case)\n        self.mean_f1d = mean_f1d\n        self.min_non_global_min = min_non_global\n        self.per_dim_contrast = per_dim_contrast\n        self.per_dim_contrasts = np.full(self.dim, per_dim_contrast)\n\n        # GlobalLocal descriptor: average across dimensions\n        self.GlobalLocal = float(np.mean(self.per_dim_contrasts))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        The function is:\n            f(x) = A*dim + sum_i [ x_i^2 - A * cos(2\u03c0 x_i) ]\n\n        Bounds: -5 <= x_i <= 5 for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar: landscape value at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce domain bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        return self.A * self.dim + np.sum(x**2 - self.A * np.cos(2.0 * np.pi * x))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_glocal_rastrigin scored on:Separable 1.000, GlobalLocal 0.009,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["81aefca4-3c83-4278-815f-8eb7e8531587"], "operator": null, "metadata": {"ela_features_2D": [-0.002909162147566713, 0.46693710706243363, 0.00637147171598359, 0.017294168240230043, 25.994164052677057, -0.004087560303887639, 0.5215515279721255, 1.0373839366519686, 0.5211879915932387, 0.08516856198386775, -0.47767657721364654, 1.0, 0.35480346771089466, 0.5669433004072992, 0.34332507772499754, 0.42109094716734596, -0.4913351996643505, 0.4626545707767008, 0.5165317734283755, 0.5846229875832913, 0.6709213544119514, 0.48305410235975116, 0.513712714587861, 0.5814220932878784, 0.6549887591710662, -0.28127039969373824, -0.2530731833545344, -0.21742868784919459, -0.172258445465478, -0.26575547292581214, -0.24997411515908602, -0.21519229687469704, -0.1773797754154453, 1.0, 1.0, 1.0, 1.0, 0.5102798893710462, 0.5102568069509461, 0.4185524772594015, 0.34674116725719156, 0.8415196332006835, 1.0420420420420418, 2.695310778661114, 0.6256256256256254, 0.5618473895582329], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.5335426330566406, "ela_features": [-0.0010812310726649565, 0.48024805886760963, 0.0016197974816443959, 0.02292957366085575, 34.82969126434388, -0.00019275889570413707, 0.5167871336156246, 1.153807795624575, 0.5172725405159395, 0.0947185556532139, -0.15301302891172516, 1.2, 0.6923902816773337, 0.8239531674258155, 0.46537604609111244, 0.22339398497223123, -0.5899454234647437, 0.6589590530576867, 0.6909851503622642, 0.7335224501698316, 0.8062340159428556, 0.6579413402657147, 0.687618141829917, 0.7278760649261252, 0.8029596434255957, -0.30002416428908424, -0.27185088826411563, -0.23442777204729204, -0.17046034323763198, -0.3025240815083534, -0.27627804963563163, -0.24066732756168968, -0.17426038416993556, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21407085007910923, 0.21407016029735754, 0.20056617828417944, 0.18049665433277204, 0.866292253582464, 0.4854854854854853, 0.414456301187845, -0.16716716716716712, 0.63125], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.003424190916121006, "ela_features_10D": [0.000606025367577634, 0.4652731512398498, 0.001204935628261258, 0.020308824716232476, 51.50272346048969, 0.005562264457174471, 0.5260212160471502, 1.2218487175197583, 0.529323067241155, 0.06419356792504352, -0.07741579750385386, 1.0, 0.8740319008991675, 0.9186061933254113, 0.5984808097461055, 0.12298560448034061, -0.6277086250920945, 0.7466619356574672, 0.77975417565901, 0.8137384049567679, 0.8669228398217275, 0.7453770491664231, 0.7776748242194707, 0.8133483746411544, 0.867323590725799, -0.321298692979511, -0.279329087604629, -0.23622718673231743, -0.1687761036280353, -0.3237981420777321, -0.2827252967930061, -0.23735825717621997, -0.16872068104654883, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1097105408698329, 0.1096996837064796, 0.10686949189062925, 0.10082625655154179, 0.866444797488154, 0.001001001001000985, 0.1589171126152617, -0.5755755755755754, 0.6308246597277822], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00898982398211956}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-3.888888888888889, -3.888888888888889], 34.92602471786735], [1, [3.8888888888888893, -3.888888888888889], 34.92602471786736], [1, [-2.7777777777777777, -2.7777777777777777], 31.959135212093543], [1, [2.7777777777777786, -2.7777777777777777], 31.95913521209348], [1, [-2.7777777777777777, 2.7777777777777786], 31.95913521209348], [1, [2.7777777777777786, 2.7777777777777786], 31.95913521209341], [1, [-3.888888888888889, 3.8888888888888893], 34.92602471786736], [1, [3.8888888888888893, 3.8888888888888893], 34.926024717867364], [1, [4.973953208371979, -4.9740000421049615], 49.747646203965054], [1, [-4.974000042104627, 4.973953208563026], 49.74764620390991], [1, [-4.9720043003212755, -4.9738675151260665], 49.74899200001539], [1, [4.973964855749533, 4.975345032821132], 49.7476329678164], [2, [-1.0006414257374363, -0.9945999474583413], 1.9963490438198264], [1, [0.9466301259074136, -2.6121314977546204], 25.89540752782178], [1, [-2.612129012717352, 0.9466287328005136], 25.895521841743125], [1, [2.612945340130765, 0.9447915250556138], 25.901609191216014], [1, [-4.926754647598123, -3.9341945542913246], 41.63389387126427], [1, [-3.9341933273799867, -4.926752938419411], 41.63394604683675], [1, [4.926752988679142, -3.934192504978326], 41.6339594305645], [1, [3.9341927768708054, -4.926753079354938], 41.63395306880568], [1, [-3.9327713459490483, 4.928159798184254], 41.633977155674344], [1, [-4.926752564989701, 3.9341915855388314], 41.63398305717381], [1, [3.935653847272111, 4.925387752768542], 41.63393169465255], [1, [4.925387591834177, 3.9356536779401665], 41.63393753045032], [1, [4.860793534812513, 2.8884876812210227], 37.91388082313689], [1, [4.862665434507672, -2.8882862199695554], 37.84928210517749], [1, [2.8897716488168865, 4.861327012279252], 37.84903965592847], [1, [-2.888284288635231, -4.862664418417365], 37.84938792420085], [1, [-4.862665110348173, 2.8882848919871598], 37.84934063114757], [1, [-2.8882849374405017, 4.86266559932461], 37.84932046369773], [1, [2.8882837731862914, -4.862665369394768], 37.84936971179448], [1, [-4.86266559501983, -2.888283881958434], 37.84935735122048], [1, [0.9453740519756776, 2.6100111076589183], 25.993834777810136], [1, [-0.9470868126006323, 2.6089831972765136], 25.997052758545692], [1, [3.8197562295282825, 2.847234070490405], 32.716976243395024], [1, [2.844320636954956, 3.822496915961453], 32.71694666129109], [1, [2.8414396816222336, -3.825271783451589], 32.716946110434904], [1, [3.8224959250431323, -2.844319652955029], 32.71704068453676], [1, [-2.845773544493377, 3.821122514476696], 32.71693468084747], [1, [-3.8211226813715196, 2.845773724549011], 32.716918198593085], [1, [-2.8457729000718324, -3.8211218304606875], 32.716997921029964], [1, [-3.822496843628468, -2.8443205702723593], 32.71695328569761], [1, [-0.9385636164667523, -2.6258729903958615], 25.544123138991722], [1, [0.8217705149457564, -0.9363583494251967], 7.982781894008982], [1, [2.6099399548716606, -0.9453304343698625], 25.997152700485934], [1, [0.8922678407229531, 0.8481387987128658], 7.937461845495445], [1, [-2.622438696077042, -0.9388311845935259], 25.672051959571373], [1, [1.8626522894507551, 1.006168214734331], 7.987603688275106], [1, [1.861977256372636, -0.991291383689492], 7.995114390655065], [1, [-0.9350319069499635, 0.8227989827250419], 7.956686621851526], [3, [1.9906055697181038, 1.9726463347515226], 8.0185900439809], [3, [-1.990267385864134, 1.971032317089926], 8.030004767294653], [1, [0.9990781379441774, 1.862308740180556], 7.98118087991379], [1, [-0.9910704779368973, 1.8622992348686411], 7.981231112234758], [1, [-1.862547434030445, 1.0052178828225964], 7.988173226572963], [1, [-1.8620234763629653, -0.9916693745851062], 7.992551127961455], [1, [4.774263264639723, -1.934322872736692], 35.856020652331], [1, [-4.777170126481746, 1.9333899052956651], 35.723581797398595], [1, [-4.779316853671293, -1.9336234861052388], 35.60628187932846], [1, [4.775489317985116, 1.9328226490364617], 35.82404165948867], [1, [-1.9337355631078168, 4.77768532179966], 35.68914492248504], [1, [1.933734840717328, 4.777685135781994], 35.68917021930699], [1, [1.9337339832259546, -4.777687442090195], 35.68906800802158], [1, [-1.934118986498354, -4.778880460620521], 35.618422770663045], [1, [-1.8279194939417287, -3.7587863710532656], 32.21540528053039], [1, [-3.7587860270446507, -1.8279193895010408], 32.21542968570868], [1, [3.76290954325861, -1.8235608995970038], 32.215466719997714], [1, [1.8308436050510335, -3.7560570162903146], 32.21555320070331], [1, [1.8293752395757354, 3.7574151869553583], 32.215940838993504], [1, [3.767066606083772, 1.819234310346513], 32.21591885720214], [1, [-1.8279195351516182, 3.7587863529203007], 32.21540414733607], [1, [-3.758787954286002, 1.8279211984856156], 32.21522956997325], [1, [0.9979419803415467, -1.8613785509415866], 8.020714910194602], [3, [-1.9700945856244643, -1.9892463765246742], 8.037207265694716], [1, [4.726302455968955, -0.9611484125236833], 35.04168216509869], [1, [-0.9622093804805366, 4.725679070429342], 35.06065791378455], [1, [-4.72616190619687, 0.9601139891332405], 35.063012648458624], [1, [-0.9621607730209546, -4.726399256893246], 35.023351706080255], [1, [0.9617736774716074, -4.725227564547394], 35.090060505012275], [1, [0.9617059288767199, 4.725173032406045], 35.09381316687203], [1, [4.726180814328862, 0.9601721955876213], 35.061222077014804], [1, [-4.736458267932589, -0.9375450996355067], 34.9229742440369], [3, [1.9711785126516277, -1.9882613471814825], 8.029437101269828], [1, [0.8077003319633864, -3.7509963147083467], 31.113233006463197], [1, [3.7145356523481294, -0.844707249866559], 31.115590784123736], [1, [3.7539234694055597, 0.804880880894262], 31.11294450493141], [1, [0.8447147075524308, 3.71456197366615], 31.113797937002772], [1, [-3.751236370610629, 0.80792656720342], 31.08702948081279], [1, [-0.8434748440737373, 3.716171114240907], 31.089621289077144], [1, [-0.7982512672875496, -3.76130305731009], 31.089523473519307], [1, [-3.714718348871175, -0.8449408307156532], 31.0939983377479]], "nr_of_basins": 91, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.5106999942834532e-09, -4.95801121698962e-10], "f_opt_dim_5": 7.086963344552899, "x_opt_dim_5": [-0.0044098778859901, 0.9078919142832984, 0.055581010428298015, -1.0696505575022799, 0.10046524659075093]}
{"id": "b3c62445-e900-4803-9d11-48eb2b60c760", "fitness": 0.6212291359164132, "name": "landscape_separable_rastrigin", "description": "A strictly separable Rastringin-inspired benchmark with per-dimension amplitude and frequency variation. Each dimension contributes an independent f_i(x_i) = A_i + x_i^2 - A_i*cos(2\u03c0*w_i*x_i). The global objective is the sum over dimensions, preserving a global minimum at the origin and enabling easy problem partitioning into subproblems by dimension.", "code": "import numpy as np\n\nclass landscape_separable_rastrigin:\n    def __init__(self, dim=5, A_base=10.0, seed=None, variability=0.6, freq_min=0.5, freq_max=2.0):\n        \"\"\"\n        Initialize a strictly separable Rastringin-inspired landscape.\n\n        Each dimension i contributes:\n            f_i(x_i) = A_i + x_i^2 - A_i * cos(2\u03c0 * w_i * x_i)\n\n        with A_i sampled around A_base and w_i sampled in [freq_min, freq_max].\n        The full objective is F(x) = sum_i f_i(x_i).\n\n        Global minimum is at x = 0 with F(0) = 0.\n        Domain is [-5, 5] per dimension.\n        \"\"\"\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Per-dimension amplitudes and frequencies, providing strong separability\n        self.A = A_base * (1.0 + rng.uniform(-variability, variability, size=self.dim))\n        self.w = rng.uniform(freq_min, freq_max, size=self.dim)\n\n        self.lower, self.upper = -5.0, 5.0\n\n        # Optional descriptor: a lightweight separability score proxy (not used by callers)\n        # The problem is strictly separable by construction.\n        self.separable = True\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        f(x) = sum_i [ A_i + x_i^2 - A_i * cos(2\u03c0 * w_i * x_i) ]\n        Domain: x_i \u2208 [-5, 5] for all i.\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, self.lower, self.upper)\n\n        # Per-dimension contributions, vectorized\n        return float(np.sum(self.A + x**2 - self.A * np.cos(2 * np.pi * self.w * x)))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_separable_rastrigin scored on:Separable 1.000, GlobalLocal 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["81aefca4-3c83-4278-815f-8eb7e8531587"], "operator": null, "metadata": {"ela_features_2D": [-0.0029543739192145592, 0.4528282807198039, 0.00615155123480945, 0.0164569711427281, 5.8873362933818525, 0.00030010774117206207, 0.5112752445058883, 1.0773040815877475, 0.5095839307052303, 0.16494852773879465, -0.44550009648123723, 1.0, 0.36709884037743723, 0.573076939992309, 0.32776399539498924, 0.4231487247461362, -0.4761302000327793, 0.42078198086509727, 0.49579467414232087, 0.5671560808563745, 0.6764631967317414, 0.4231441063275135, 0.49783217510848354, 0.5556395526522622, 0.6694270531907642, -0.3028654283007949, -0.2636417858753276, -0.2263301099996906, -0.1691722829807724, -0.29590987226394844, -0.25755744616498044, -0.22790663287575966, -0.16954602338327487, 1.0, 1.0, 1.0, 1.0, 0.521851292425004, 0.5218440224278826, 0.42871053891452904, 0.34981376263449737, 0.8417958150196858, 0.9899899899899897, 2.3321764254885458, 0.5935935935935934, 0.5449799196787148], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.7239854335784912, "ela_features": [-0.00017085276774806424, 0.45339359987417893, 0.0015551844457586698, 0.02504137263072332, 31.957935553702622, -0.00018631622268932, 0.5139064895484495, 1.1700500131095861, 0.514031974457182, 0.15981949576219967, -0.15594401558767865, 1.2, 0.6878096574062873, 0.8218176587107701, 0.4363966880504765, 0.22713299130099035, -0.5927075625219194, 0.6732355342316071, 0.7152351254632757, 0.758407485442613, 0.8148693813449459, 0.6704242057865194, 0.7111178983819655, 0.7541635965011694, 0.8127409372047916, -0.2874303920887161, -0.2504855030733796, -0.2125106682916881, -0.16284668944399142, -0.29141700786379177, -0.25543496080028627, -0.21737375339724405, -0.16558084630563463, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21477246928964408, 0.21476996534687126, 0.20290408032598534, 0.18269937350888538, 0.8717770344003501, 0.4774774774774773, 0.384870025406021, -0.1791791791791791, 0.6360576923076924], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.002150940941646695, "ela_features_10D": [-0.00041930298597674386, 0.4757774015560581, 0.0009262038393244567, 0.01814002215714882, 21.784460090960227, 0.001057048095794988, 0.4968113843802634, 1.2984129427291287, 0.49760273484680473, 0.09046726864102747, -0.0631968526853444, 1.0, 0.8675661528416876, 0.9150910230988348, 0.5772786207389521, 0.1279297626420694, -0.6324615840216425, 0.7535758659434587, 0.7908991009798532, 0.8197366170531865, 0.8674962575933172, 0.7549119236259237, 0.7911595513184129, 0.8195962655979759, 0.8682053642181176, -0.31252779401929187, -0.26519226984315475, -0.22861839079377919, -0.16804733256542786, -0.3116296475255413, -0.2655406612999659, -0.22938159911736816, -0.1675751573079831, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10927699933657287, 0.10927394441237233, 0.1063727160155203, 0.1000064779795021, 0.8689901518814456, 0.013013013013012987, 0.16520290532788523, -0.5635635635635634, 0.6486789431545236], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0012384409783408046}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [4.950001275001065, -4.821881448049252], 48.050103473886196], [1, [4.954000869020305, -2.4117010104552215], 30.548331440890962], [1, [4.95378470786207, -1.6066010484930828], 27.30948029715295], [1, [4.95378470774204, 1.6066011303107], 27.30948024027957], [2, [0.00044444444444512003, 4.82200000000002], 23.324310676120312], [1, [-4.917822384214613, -4.820358037463509], 48.32969670411907], [1, [-4.954000849507949, -2.4117025903773066], 30.548331846201542], [1, [-4.953784714409705, 1.6066003407700178], 27.309480781168254], [1, [-4.957842437412251, 4.820005998087714], 48.0412715773667], [2, [0.00044444444444512003, -4.82200000000002], 23.324310676120312], [2, [0.00044444444444512003, -2.411777777777818], 5.831131689039745], [2, [0.00044444444444512003, -1.6066666666666665], 2.5919050779541664], [2, [0.00044444444444512003, 1.606666666666667], 2.5919050779541646], [1, [-4.9507260990180315, -1.6082638190994167], 27.31552990664087], [1, [4.957997356176426, 4.8221128129193085], 48.03880501208922], [1, [4.953933359482445, 2.4117017187052725], 30.548426852766262], [1, [-4.9539333690619545, 2.411701138196999], 30.548426700391225], [2, [0.00044444444444512003, 2.411777777777819], 5.831131689039749], [1, [-4.859420972653798, 3.9670858799549644], 43.539293191975915], [1, [-4.85942351038898, -3.9670878834817755], 43.539137980010324], [1, [4.861323821840921, 3.966892504148337], 43.48319947388183], [1, [4.861324848312061, -3.9668928749309367], 43.48315271879288], [1, [1.2385822424602533, 2.4088059544756626], 7.378191309257005], [1, [2.4177161731715375, 2.408704896416296], 12.692493224824196], [1, [1.2063632890258822, 1.6062842123687344], 4.338294741612437], [1, [2.444210935125496, 1.6063084496773339], 8.991599763276865], [1, [3.7134829266917344, 1.6066802253783012], 16.498296892108815], [1, [1.2385954200402054, -2.408805943244774], 7.378187011563796], [1, [2.478139579404242, -2.3993726882455007], 12.060987717403906], [1, [1.2037633804620114, -1.6063145139496144], 4.3710195645094085], [1, [2.447401783653304, -1.6066975706519184], 8.952751596785838], [1, [3.7162531915196095, -1.6074721523484603], 16.494423412277563], [1, [1.2386291983289466, 4.820514013420904], 24.8706154111631], [1, [2.4573118154833864, 4.7102684130138295], 33.66358463723692], [1, [3.6480706499325537, 3.929805067322977], 33.64404240966201], [1, [1.238629260332107, -4.820514012532024], 24.87061539315578], [1, [2.4562688182627124, -4.7099402274293425], 33.69390582136245], [1, [3.6513962993700506, -3.92758442781379], 33.69012201687067], [1, [-1.2385835574729531, 2.408805382195651], 7.378191919431353], [1, [-2.4177048289295344, 2.408739455159367], 12.692677324730449], [1, [-1.2031618676865865, 1.606465459177806], 4.3788168296870875], [1, [-2.443460099216803, 1.6051635123996684], 9.00270636413074], [1, [-3.7139362804450684, 1.6078756880346543], 16.4972605729158], [1, [-1.2385964228161037, -2.4088053887458685], 7.378187697120072], [1, [-2.478163948216276, -2.3993407344767204], 12.061253076368741], [1, [-1.2068780043316993, -1.6072180047842899], 4.331549191622409], [1, [-2.446974638454345, -1.60679254806379], 8.957643544815275], [1, [-3.7161832645425705, -1.6075337061040567], 16.49447608165009], [1, [-1.238628872786665, -4.8205137442241215], 24.870615932934115], [1, [-2.4561535239597823, -4.710729708356699], 33.642353781382496], [1, [-3.649744612442971, -3.9294410993899818], 33.6235554761927], [2, [-0.011441879104210021, -3.9506264286347847], 17.816145309999357], [1, [-1.2386296465806481, 4.820513733138526], 24.870615708203392], [1, [-2.456174732709441, 4.710681445887049], 33.64537990766888], [1, [-3.6444250654222037, 3.9316027961616102], 33.63592389365121], [2, [-0.011465467633113116, 3.950516709803011], 17.82120826700972], [1, [1.2394586366558502, 0.803616031405923], 2.192577285581649], [2, [0.010376573003422474, 0.7375880170770246], 2.1928618853009763], [1, [1.233003067962737, -0.8041125061614288], 2.20033252888639], [1, [-1.2337236396545708, -0.8055682496157561], 2.1997999485752366], [2, [0.006380007223255272, -0.7373844836578591], 2.1896707318220656], [1, [-1.232683374511485, 0.802796463779353], 2.201429295446216], [1, [-2.4731912032661674, 0.8053807113816375], 6.8335755511938405], [1, [-2.4725749750967525, -0.8035492158088536], 6.834067308972854], [1, [2.4731749231385924, 0.8051970126913643], 6.833413488162979], [1, [2.4725898056501343, -0.8037401464739576], 6.834012831721392], [1, [3.708546895636591, -0.8051117237039337], 14.568312031500056], [1, [3.7080613432733176, 0.8042343552690631], 14.569553732626275], [1, [-3.708009394818546, 0.8041706872767301], 14.56973210049023], [1, [-3.708594440495285, -0.8051814934135102], 14.568208477450142], [1, [4.892532172706083, -0.7813120537727691], 26.303318390457925], [1, [-4.898139189433882, -0.7818535853141553], 26.17146176132034], [1, [-4.892120143594031, 0.7808166203667909], 26.320773959697732], [1, [4.892435053378363, 0.7811096185249046], 26.308787004162404], [1, [-1.2376136637982635, 4.018005648357246], 17.742920550351677], [1, [-1.2368602233287318, -4.016778258726206], 17.744888526403415], [1, [1.237801471007743, -4.003824255055552], 17.82329390064121], [1, [1.237800440794215, 4.003847899494881], 17.823042581902236], [1, [-3.717169213521125, 4.7961835966603505], 37.47348437963126], [1, [-3.7151708212342758, -4.796278083087202], 37.473375453770444], [1, [3.7151757070236058, -4.79621664402496], 37.47450325496649], [1, [3.717173585082753, 4.796211807856159], 37.47296094358871], [1, [2.434382083660932, -3.960132124676468], 23.93005288169121], [1, [2.4362752069882507, 3.959396669032891], 23.929351176334244], [1, [-2.4386855048219034, 3.9614027601151527], 23.81407194758633], [1, [-2.4380984048783216, -3.963524169112538], 23.741876313721434], [1, [3.6723198742995318, 2.3777292695428693], 20.517285426903307], [1, [-3.6723850174640926, 2.3778067943259935], 20.514383569453564], [1, [3.6677876053926, -2.3743527807350593], 20.67931710915682], [1, [-3.667884938119355, -2.374484075057498], 20.674167767159414]], "nr_of_basins": 90, "f_opt_dim_2": 0.0, "x_opt_dim_2": [6.099774955175812e-10, 1.8862624019447926e-10], "f_opt_dim_5": 10.412027305000363, "x_opt_dim_5": [-1.0238090761003984, -1.0964107750150096, -2.45763862530783, 4.75190254581874e-10, -1.4343840699216208]}
{"id": "ceb48b97-b638-41f6-a8ff-15ec92348548", "fitness": 0.6492082096907931, "name": "landscape_cosine_separable_plus", "description": "A strictly separable cosine-modulated quadratic landscape with two independent per-dimension cosine perturbations. Each dimension contributes a sum of a quadratic base and two independent cosine modulations, preserving a unique global minimum at the origin while increasing the density and variety of local minima. The per-dimension parameters (K1_i, A1_i, K2_i, A2_i) are sampled with a seed for reproducibility, enabling tunable GlobalLocal contrast without introducing cross-dimension coupling.", "code": "import numpy as np\n\nclass landscape_cosine_separable_plus:\n    \"\"\"\n    A strictly separable landscape with a quadratic base per dimension plus\n    two independent cosine modulations per dimension:\n        f_i(t) = t^2 + A1_i*(1 - cos(K1_i * t)) + A2_i*(1 - cos(K2_i * t))\n    Global minimum at t = 0 for each dimension, hence f(0) = 0.\n    \n    Domain per dimension: [-5, 5]\n    \"\"\"\n    def __init__(self, dim, seed=None):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Candidate ranges for frequencies (modulation) and amplitudes (depth)\n        freq_candidates = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=float)\n        amp_candidates  = np.array([0.25, 0.5, 0.75, 1.0, 1.25], dtype=float)\n\n        # Two independent cosine perturbations per dimension\n        self.K1 = rng.choice(freq_candidates, size=self.dim, replace=True).astype(float)\n        self.A1 = rng.choice(amp_candidates, size=self.dim, replace=True).astype(float)\n\n        self.K2 = rng.choice(freq_candidates, size=self.dim, replace=True).astype(float)\n        self.A2 = rng.choice(amp_candidates, size=self.dim, replace=True).astype(float)\n\n        # Ensure numpy arrays for fast evaluation\n        self.K1 = self.K1.astype(float)\n        self.A1 = self.A1.astype(float)\n        self.K2 = self.K2.astype(float)\n        self.A2 = self.A2.astype(float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n        - x must be a 1D array of length self.dim\n        - Returns a scalar objective value (minimization)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        # Per-dimension contributions:\n        # f_i(x_i) = x_i^2 + A1_i*(1 - cos(K1_i * x_i)) + A2_i*(1 - cos(K2_i * x_i))\n        contrib = x**2 + self.A1 * (1.0 - np.cos(self.K1 * x)) + self.A2 * (1.0 - np.cos(self.K2 * x))\n        return float(np.sum(contrib))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_cosine_separable_plus scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8f17f21f-4486-4814-a0fb-8836c74361fc"], "operator": null, "metadata": {"ela_features_2D": [-0.0027087452771252796, 0.3809329404504378, 0.013714499376807899, 0.021462135492174194, 1.8004792583599165, -0.0007361308277753275, 0.9951381271374566, 1.0345412660825017, 0.995128170388447, 0.3380069847198458, -0.5049128866135126, 1.6, 0.7046212161293209, 0.7176006857606734, 0.563354724729727, 0.3383536534608582, -0.2047339568628433, 0.14589446121998204, 0.21907667862001526, 0.31026129414972853, 0.4976912351093567, 0.14968067284345915, 0.2224086434544935, 0.3097558750415284, 0.49643647007673286, -0.44706499343375017, -0.4087542869188212, -0.361024506164375, -0.26291866817293813, -0.437545543913452, -0.4000957152176056, -0.35514099028753937, -0.25908608718580356, 1.0, 1.0, 1.0, 1.0, 0.5104315129209075, 0.5103296735825419, 0.3947014469543912, 0.348423070245263, 0.7278717604657597, 0.3893893893893893, 0.5133675096149647, -0.06306306306306309, 0.36947791164658633], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8949530720710754, "ela_features": [-0.0011254428967452546, 0.42682632703251394, 0.0032943878905044416, 0.022841925261047048, 11.190909975399986, 0.003290699992733703, 0.9786189845623008, 1.0623292876167014, 0.978520268078474, 0.26953313946493646, -0.24548954629089073, 1.2, 0.8993095261439491, 0.8670024171961573, 0.6362852368090577, 0.19074587063269485, -0.4745620731194208, 0.45661548607137126, 0.5407522866763619, 0.6106563758075699, 0.7228212325503882, 0.4576000800479937, 0.543228298315863, 0.6138051278465592, 0.7262720389004915, -0.4780016258599569, -0.40398721909418017, -0.34249448188807985, -0.24382539863710648, -0.4797764016545799, -0.40403190766511266, -0.34160532816819866, -0.24212165042961264, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21825515974704474, 0.2182788687386526, 0.20344660261054645, 0.18321878824334015, 0.8314487636561122, 0.1371371371371371, 0.27967148178791923, -0.37537537537537524, 0.5338141025641026], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00015064609760884196, "ela_features_10D": [-0.0014668642642063467, 0.43909348439126905, 0.0017578050028366778, 0.015371288825678392, 10.64714192777931, 0.0035138525580550306, 0.9859463253576438, 1.066708641824716, 0.9859002815508424, 0.19971530926734343, -0.035665995576357815, 1.2, 1.0173931190715766, 0.9381004177450281, 0.7136102612373809, 0.10511857170856935, -0.6012763685879646, 0.6202127935904171, 0.6821825593960525, 0.7327332124698257, 0.8089528371415664, 0.62178467440971, 0.6857691353190745, 0.7365555525323833, 0.8134753668205175, -0.4816722534946213, -0.40307748419803896, -0.3389654536292953, -0.24229857628453777, -0.48093239070147026, -0.3995688329460642, -0.3349888641211666, -0.23717927115604542, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11084980002579661, 0.11085025956152313, 0.10784636994161675, 0.10094347859308521, 0.8504823491839997, -0.1271271271271271, 0.1288508711242809, -0.6636636636636635, 0.5903923138510809], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0001455399760743603}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[40, [0.00044444444444512003, 1.1546666666666665], 2.402881424270539], [20, [0.00044444444444512003, 0.00044444444444512003], 3.6790113795245892e-06], [40, [-0.00040075542966565335, -1.1546631905245395], 2.4028811893232005]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.572712546409565e-163, 1.3041909657425028e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.4258328878692796e-162, -1.8528745779287662e-163, 8.59876645610206e-163, -1.4056287103081449e-162, -1.5944894786220225e-163]}
{"id": "457490de-017a-4541-905d-72272cfdb4e3", "fitness": 0.6708363809933265, "name": "landscape_separable_minquad_wells_improved", "description": "An enhanced strictly-separable per-dimension landscape built from per-dimension min-of-quadratic wells with randomized centers, maximizing separability by ensuring complete independence across dimensions. Each dimension contributes additively via f_i(x_i) = min_j ((x_i - s_i_j)^2 + d_i_j) with a global minimum at the origin; depths increase with distance from zero to boost GlobalLocal contrast. Seedable for reproducibility and fully partitionable into independent 1D subproblems.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_improved:\n    \"\"\"\n    An enhanced, strictly separable benchmark:\n    - Each dimension i has its own set of local wells with centers s_i_j in [-L, L].\n    - Per-dimension contribution: f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - Global minimum is at x = 0 with f(0) = 0 (due to a well at 0 with depth 0).\n    - Depths d_i_j are assigned so wells farther from zero are deeper, creating a tunable GlobalLocal contrast.\n    - The total objective is additive across dimensions: f(x) = sum_i f_i(x_i), ensuring strong separability.\n    - Fully reproducible with a seed; no cross-dimension interactions exist.\n    \"\"\"\n\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: span of wells along each axis; centers lie in [-L, L]\n        contrast: depth step between successive wells (controls GlobalLocal)\n        seed: random seed for reproducibility (optional)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.seed = seed\n\n        self.rng = np.random.default_rng(seed)\n\n        # Build per-dimension well centers with a guaranteed global well at 0\n        s_per_dim = []\n        for i in range(self.dim):\n            # Draw wells in [-L, L], then sort\n            s = self.rng.uniform(-self.L, self.L, size=self.wells)\n            s.sort()\n            # Ensure a well exactly at 0 for the global minimum\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n            s_per_dim.append(s)\n\n        S = np.stack(s_per_dim, axis=0)  # shape: (dim, wells)\n\n        # For each dimension, order wells by distance to zero and assign depths accordingly\n        order = np.argsort(np.abs(S), axis=1)  # shape: (dim, wells)\n        s_sorted = np.zeros_like(S)\n        d_sorted = np.zeros_like(S)\n\n        # Depths: 0, contrast, 2*contrast, ..., (wells-1)*contrast\n        depths = np.arange(self.wells, dtype=float) * self.contrast  # 0, contrast, ..., (wells-1)*contrast\n        for i in range(self.dim):\n            o = order[i]\n            s_sorted[i, :] = S[i, o]\n            d_sorted[i, :] = depths[o]\n\n        self.s = s_sorted  # per-dimension wells positions\n        self.d = d_sorted  # per-dimension depths aligned with wells\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        Global minimum at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        # Vectorized computation:\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())\n\n    def get_1d_profile(self, i, x):\n        \"\"\"\n        Optional helper: return the 1D per-dimension landscape value for dimension i at point x.\n        Useful for debugging or plotting 1D profiles.\n        i: dimension index (0-based)\n        x: scalar value for the i-th dimension\n        \"\"\"\n        i = int(i)\n        x = float(x)\n        s_i = self.s[i, :]\n        d_i = self.d[i, :]\n        vals = (x - s_i)**2 + d_i\n        return float(np.min(vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_minquad_wells_improved scored on:Separable 1.000, GlobalLocal 0.024,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7e96f668-95d2-4719-b32c-e3d800bec321"], "operator": null, "metadata": {"ela_features_2D": [0.8200954257487943, -0.07334401700809792, 0.3895988644071485, 0.5137832931930997, 1.319882951428484, 0.8209286909520694, 0.9515821692029085, 2.2282601285795574, 0.9718545406753585, 0.38357207113911507, -0.4009727059482723, 1.6, 0.659593428525219, 0.7026352536840805, 0.5386162876982279, 0.3478111832123116, -0.14003711409412323, 0.14088643315170407, 0.21803055638338634, 0.3274507656968838, 0.5160249762495267, 0.14001601373751899, 0.21671863340072406, 0.32207849938703526, 0.5096326472508058, -0.44971546053234646, -0.4093292622827862, -0.35205444000898123, -0.2533395373934723, -0.44243082877670153, -0.4029598010233693, -0.3487649659640457, -0.252266172807573, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5189060553120747, 0.5188967587972201, 0.5914088129930759, 0.6460682617967876, 0.7445844942334747, 0.3533533533533532, 0.4199539469709708, -0.20320320320320318, 0.4100401606425702], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9772531390190125, "ela_features": [0.8151917563556083, -0.15035186216147173, 0.1610174438505036, 0.3411346372097114, 2.120316992543309, 0.8156738464753586, 0.9361690445632534, 4.086867153515795, 0.960673012747135, 0.2763392524965603, -0.16465560069922613, 1.2, 0.867498990971163, 0.8642878628670447, 0.6217017927914593, 0.19033589576614596, -0.320210559479992, 0.48339861022412156, 0.5783715579401333, 0.6719244399344318, 0.7992403978056989, 0.4796072543420909, 0.5743023501773694, 0.6647129695521674, 0.7941914807319742, -0.4544439884252157, -0.3708997767538915, -0.28860092418297983, -0.17660320290393813, -0.46020534040878947, -0.3764657324908577, -0.2965088316542663, -0.1820036989646473, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21472851933594517, 0.2147084398648042, 0.2409737507611084, 0.3153820117787832, 0.8308793369247596, -0.011011011011011013, 0.16621009558532657, -0.5915915915915914, 0.5275641025641026], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.023619206622242928, "ela_features_10D": [0.7635478248960166, -0.24713908606275575, 0.04221684516218399, 0.2366446998349061, 5.66933115465612, 0.7652043250376417, 0.9075929496994434, 40.766605180945376, 0.9590325669852966, 0.17050439636751663, -0.07109026908435308, 1.2, 0.9185034433838973, 0.9251594914459048, 0.668125323859243, 0.1141666648202712, -0.4374738617174546, 0.7089892626637043, 0.777355188498683, 0.8256023073036209, 0.887121038900412, 0.709483766329122, 0.7791304920170592, 0.8271598542349597, 0.8881588737578273, -0.36907291299708006, -0.2823686264428488, -0.2211794560153509, -0.14315869573727952, -0.3693758037006891, -0.28082445630580216, -0.21975772380910014, -0.14220080365660462, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.11004971010053533, 0.11004817753182446, 0.12190740126052539, 0.17141428758447794, 0.8473697887458176, -0.24324324324324315, 0.10141692297832539, -0.7917917917917915, 0.5631705364291434], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.02414594031870365}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [1.498572782980262, 3.269951372015533], 10.00000006535133], [12, [1.4986666666666668, -3.974000000000113], 2.0000001260630187], [12, [1.4983218375459746, -1.9850586572844353], 3.0000001224737343], [8, [1.4894542977980292, 1.3702456092449014], 8.000084939307351], [12, [0.00044444444444512003, 1.3706666666666667], 6.000000717854381], [18, [0.00044444444444512003, -1.9846666666666668], 1.0000004066296628], [12, [0.00044444444444512003, 3.2708888888889573], 8.000000686614651], [18, [0.00044444444444512003, -3.974000000000113], 3.235928637286744e-07]], "nr_of_basins": 8, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.2753176194235865, -3.9214855097357377], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.9626569755513765, -3.5711248716382054, -3.1816680440520306, -3.499744171438393, -2.936481917721782]}
{"id": "f0356916-a631-4f19-8f0b-56e96cd1d600", "fitness": 0.6622092457764666, "name": "landscape_sep_bumpy_glocal", "description": "A novel separable benchmark with quadratic base plus nonnegative sin^2 bumps, enhanced by an explicit GlobalLocal contrast score computed from a 1D grid analysis. The global minimum is at the origin, while per-dimension local minima are introduced by sin^2 perturbations. The GlobalLocal score is the average per-dimension contrast of the strongest non-global local minima relative to the 1D mean landscape, making local minima more easily recognizable for evaluators.", "code": "import numpy as np\n\nclass landscape_sep_bumpy_glocal:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + a_i * sin^2(k_i * x_i) ]\n    - Separable: no cross-dimension interactions; f(x) is a sum of independent per-dimension functions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent,\n      yielding varied local minima across dimensions while preserving separability.\n    - The GlobalLocal score is computed by sampling the 1D landscape of each dimension over a grid to quantify\n      the contrast between the strongest non-global local minima and the 1D mean value. The overall score is the\n      average of per-dimension contrasts, providing a robust measure of local minima visibility.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5, grid_points=1001, domain=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n\n        # Deterministic, increasingly strong per-dimension structure for richer GlobalLocal contrast\n        self.a = 0.6 + 0.28 * np.arange(self.dim)      # amplitudes (nonnegative)\n        self.k = 1.1 + 0.32 * np.arange(self.dim)      # frequencies\n\n        # Precompute GlobalLocal score by analyzing the 1D landscapes\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        # 1D grid for analysis\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        for i in range(self.dim):\n            f1d = t**2 + self.a[i] * np.sin(self.k[i] * t) ** 2\n            mean_f = float(np.mean(f1d))\n\n            # Detect local minima along the grid, excluding the global minimum at t ~ 0\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < 1e-9:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                if mean_f > 0:\n                    gl_i = local_min_val / mean_f\n                else:\n                    gl_i = 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_sep_bumpy_glocal scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c028813c-50c5-4335-855b-58a7ad3860da"], "operator": null, "metadata": {"ela_features_2D": [-0.0027727206958225283, 0.34608190136770656, 0.010173664072449674, 0.021538995853894145, 3.301801964868126, -0.002945824345448056, 0.998846786802115, 1.0196948492938822, 0.9988407186249244, 0.4718842238033714, -0.4278802137651977, 2.0, 0.7212380021053724, 0.7299829224017789, 0.5592430700942368, 0.3298894016895851, -0.20186269336850865, 0.14845523631211638, 0.23434510462136404, 0.32270942554054327, 0.4898339909893089, 0.15567941769300922, 0.23641414747509365, 0.326643761510243, 0.4948453391690991, -0.44523523454184477, -0.40032451066869223, -0.35412193013023263, -0.2667372587457835, -0.4330673838613991, -0.3916511012459677, -0.34535953950873244, -0.259074539355816, 1.0, 1.0, 1.0, 1.0, 0.5197319344746214, 0.5196900704108695, 0.40393225603123684, 0.35148392108778076, 0.7102940109465073, 0.40140140140140124, 0.47855509988105477, -0.07907907907907906, 0.3481927710843374], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9727391600608826, "ela_features": [-0.001061352699281448, 0.4042743393327197, 0.0035993968254154837, 0.024277318338453775, 11.740355316844665, 0.0010315836425054848, 0.996925137978551, 1.0236577297569598, 0.9969157020268483, 0.2645170599014787, -0.19496081205827212, 1.4, 0.9132901157906159, 0.8736622924670838, 0.6478545869193489, 0.18318255808153458, -0.46765614202231925, 0.4144878306380879, 0.5064444202108827, 0.5849682621116461, 0.7088437626029707, 0.4192388084830384, 0.5091948483111918, 0.5872812443134132, 0.7119801982909045, -0.514903963242915, -0.4340369944046329, -0.36498195287555213, -0.25604467845850837, -0.5131386098071539, -0.43365880946182733, -0.3646628627589056, -0.25448222020365285, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21706462086685652, 0.21708499830554678, 0.2036597566388015, 0.1821246418452206, 0.8220019205975527, 0.09309309309309306, 0.23304837366189216, -0.4074074074074073, 0.5174679487179488], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0002997397677972913, "ela_features_10D": [-0.0007805107294412972, 0.41847231199754675, 0.0008662754322814551, 0.01908104554856791, 781.3277292147711, 0.006171014127794616, 0.9908760518688275, 1.030879157150577, 0.9908726674068875, 0.19432922962807414, -0.043368808416557506, 1.6, 1.0192549969695262, 0.9388327553922002, 0.7048162208017622, 0.10556969224548292, -0.6080004888014356, 0.6261351215802077, 0.6801523720275526, 0.7291717208028407, 0.8081420746585609, 0.6281184062973051, 0.6836478916100117, 0.7339307432155823, 0.8128184659413348, -0.4741632301274561, -0.40565543824819594, -0.34348558962352993, -0.2433292737494654, -0.4729051679568158, -0.4022917474716107, -0.3383494500332991, -0.23803121751413517, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11101772070761584, 0.11101796512634018, 0.10816074246817746, 0.10121638360482998, 0.8563095816206674, -0.13513513513513514, 0.11952972023841127, -0.6716716716716714, 0.5919935948759008], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00021657483011949807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 8.889741642640113e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [5.030126172500824e-163, 8.295474941939164e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.119465615156531e-163, -6.875550432042771e-163, -3.1336828417477037e-163, -3.0599375570156067e-163, 4.584458727017742e-163]}
{"id": "65a70365-c5f4-4804-9b61-a53e5e95cb74", "fitness": 0.5937393555650488, "name": "landscape_separable_rastrigin_glocal", "description": "A strictly separable Rastringin-inspired benchmark with per-dimension amplitude and frequency variation, augmented with a grid-based GlobalLocal score to quantify the contrast between global and local minima. The per-dimension function is f_i(x_i) = A_i + x_i^2 - A_i*cos(2\u03c0*w_i*x_i); the global minimum is at the origin, and the new GlobalLocal measure evaluates how pronounced non-global local minima are relative to the 1D landscape mean.", "code": "import numpy as np\n\nclass landscape_separable_rastrigin_glocal:\n    def __init__(self, dim=5, A_base=10.0, seed=None, variability=0.6, freq_min=0.5, freq_max=2.0, grid_points=1001):\n        \"\"\"\n        A strictly separable Rastringin-inspired landscape with an enhanced GlobalLocal descriptor.\n\n        Each dimension i contributes:\n            f_i(x_i) = A_i + x_i^2 - A_i * cos(2\u03c0 * w_i * x_i)\n\n        The global objective is F(x) = sum_i f_i(x_i).\n        Global minimum is at x = 0 with F(0) = 0.\n        Domain is [-5, 5] per dimension.\n\n        GlobalLocal (GL) score is computed deterministically from a dense 1D grid\n        of the individual landscapes, measuring how pronounced non-global local minima are\n        relative to the 1D mean value, averaged across dimensions.\n        \"\"\"\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Per-dimension amplitudes and frequencies\n        self.A = A_base * (1.0 + rng.uniform(-variability, variability, size=self.dim))\n        self.w = rng.uniform(freq_min, freq_max, size=self.dim)\n\n        self.lower, self.upper = -5.0, 5.0\n        self.separable = True\n\n        self.grid_points = int(grid_points)\n\n        # Compute a global-local score (0.0 .. ~1.0), higher means stronger local-minima contrast\n        self.global_local_score = self._compute_global_local_score()\n\n    def _compute_global_local_score(self):\n        \"\"\"\n        Compute a grid-based GlobalLocal score for the 1D per-dimension landscapes and\n        average across dimensions.\n\n        For each dimension i:\n            - Evaluate fi(x) on a dense grid x \u2208 [-5, 5]\n            - Compute the mean value mean_fi\n            - Identify non-global local minima (fi minima not near x=0)\n            - Take the deepest non-global local minimum min_non_global_fi\n            - Compute depth_i = (mean_fi - min_non_global_fi) / mean_fi\n        GlobalLocal score is the average of depth_i over all dimensions.\n        \"\"\"\n        x_grid = np.linspace(self.lower, self.upper, self.grid_points)\n        mean_vals = []\n        min_non_global_vals = []\n\n        # Precompute for each dimension\n        for i in range(self.dim):\n            fi = self.A[i] + x_grid**2 - self.A[i] * np.cos(2.0 * np.pi * self.w[i] * x_grid)\n            mean_vals.append(float(fi.mean()))\n\n            # Identify local minima excluding the global minima near x=0\n            minima_vals = []\n            # Exclude a small interval around zero to avoid counting the global minimum\n            exclude_zone = 0.1\n            for j in range(1, self.grid_points - 1):\n                if fi[j] <= fi[j - 1] and fi[j] <= fi[j + 1]:\n                    if abs(x_grid[j]) > exclude_zone:\n                        minima_vals.append(float(fi[j]))\n            if minima_vals:\n                min_non_global_vals.append(min(minima_vals))\n            else:\n                # Fallback: if no non-global local minima found, use the nearest local minimum value\n                # (should rarely happen for Rastringin-style landscapes)\n                min_non_global_vals.append(float(np.min(fi[np.abs(x_grid) > exclude_zone])))\n\n        mean_f = float(np.mean(mean_vals))\n        depths = []\n        for i in range(self.dim):\n            min_non_global_fi = float(min_non_global_vals[i])\n            if mean_f > 0.0:\n                depths.append(max(0.0, (mean_f - min_non_global_fi) / mean_f))\n            else:\n                depths.append(0.0)\n\n        return float(np.mean(depths))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        f(x) = sum_i [ A_i + x_i^2 - A_i * cos(2\u03c0 * w_i * x_i) ]\n        Domain: x_i \u2208 [-5, 5] for all i.\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, self.lower, self.upper)\n\n        # Per-dimension contributions, vectorized\n        return float(np.sum(self.A + x**2 - self.A * np.cos(2.0 * np.pi * self.w * x)))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_rastrigin_glocal scored on:Separable 1.000, GlobalLocal 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b3c62445-e900-4803-9d11-48eb2b60c760"], "operator": null, "metadata": {"ela_features_2D": [-0.0018694353338803093, 0.44937735215138436, 0.015285504574418438, 0.026481801214185335, 2.1187987446887604, -0.0014388572057972837, 0.6904916721572212, 1.063542173719539, 0.6888327333959493, 0.09773891233603196, -0.4732026276788967, 1.0, 0.37515825276262266, 0.5798307601053696, 0.3096088032880938, 0.41669391446288023, -0.4062978811579505, 0.3560449543626966, 0.4451665533216958, 0.5091428633983375, 0.5996010048297373, 0.3446163373205718, 0.4276865464226822, 0.5061613028125724, 0.5952175748860205, -0.33688085465371503, -0.2902603860417884, -0.25679776256279957, -0.209473210416999, -0.33661388860682173, -0.2939356276028776, -0.25365638407088376, -0.207912986947612, 1.0, 1.0, 1.0, 1.0, 0.5108511254288499, 0.5108158275834656, 0.4138245122250252, 0.3485208667366582, 0.8541978739190723, 0.9899899899899897, 2.109977014975202, 0.5095095095095094, 0.5734939759036144], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.557702898979187, "ela_features": [0.0006343444799834508, 0.48392458140906375, 0.0050783331818803025, 0.024463171379631055, 7.990661095860946, 0.0009406361891692195, 0.4712915360897247, 1.2810369493995133, 0.4683901194081422, 0.06050210486992944, -0.17987181757015494, 1.2, 0.6890918534553829, 0.822515275887133, 0.4746441765998449, 0.22489726189595044, -0.5956185673079479, 0.6310574464405385, 0.7014846086076206, 0.7471119988162908, 0.8201989754206609, 0.6213018617645257, 0.693967059527224, 0.7411643001197831, 0.8156630007636837, -0.3245460129608236, -0.2625937399207281, -0.22245812979823096, -0.15816590671485764, -0.33483974101959335, -0.27058769964781276, -0.22886054978507517, -0.16299006641678898, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21514581640076386, 0.2151258034945013, 0.20292109631775754, 0.18209149242585493, 0.8689071841638901, 0.48948948948948934, 0.3863970912562781, -0.19119119119119113, 0.6362179487179487], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0037027013022452593, "ela_features_10D": [-0.0009256723704021086, 0.5004073486877388, 0.0011369985041128552, 0.01595198642016324, 25.807766751502562, 0.0001236317981720969, 0.4457346153208368, 1.4968071992147283, 0.44159960630693645, 0.02416635920680742, -0.12452087594645152, 1.4, 0.8486738158578013, 0.913352698499007, 0.5644784929308699, 0.12887396482199592, -0.6401928044204607, 0.7698245106952444, 0.7972681080820846, 0.828667135293332, 0.8756238430516776, 0.7688497972831484, 0.7972331662151463, 0.8285819316158101, 0.8759167782758336, -0.29191250870899105, -0.2571070204339182, -0.21728643825026084, -0.15773535388876164, -0.29392869868405713, -0.25783368078220287, -0.2179722943271559, -0.1577817289399194, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10948362924028934, 0.1094886722479413, 0.1066206496460764, 0.09982491890114889, 0.8717981387326746, 0.021021021021021, 0.15465629676934617, -0.5595595595595594, 0.64435548438751], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0010305331088602543}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 66.85195393602746], [1, [5.0, -5.0], 66.85195393602746], [1, [-5.0, -0.5555555555555554], 27.574343749155574], [1, [5.0, -0.5555555555555554], 27.574343749155574], [1, [-5.0, 0.5555555555555554], 27.574343749155574], [1, [5.0, 0.5555555555555554], 27.574343749155574], [1, [-5.0, 5.0], 66.85195393602746], [1, [5.0, 5.0], 66.85195393602746], [1, [0.5055555555555553, -5.0], 40.06894786287775], [1, [-0.5055555555555553, -5.0], 40.06894786287775], [1, [3.890888888888889, -5.0], 66.80905007723815], [1, [0.5035555695559888, -3.888896372306413], 25.16215053735322], [1, [-0.4995578165731733, -3.8890231704359883], 25.162162639132035], [1, [-0.5035555673116238, -2.777784635192411], 13.297391748976686], [1, [0.5015562894559743, -2.7778378676866495], 13.297400147218614], [1, [-0.5035555841359541, -1.6666773587561834], 5.034302672909046], [1, [0.5035555824020916, -1.6666770293605615], 5.034328015255804], [1, [-0.503555744899493, -0.5555830753647727], 0.7913266663089384], [1, [0.5035557408045505, -0.5555827761665552], 0.7913346833921278], [1, [3.890888888888889, -0.5555555555555554], 27.531439890366286], [1, [-0.5035557415546489, 0.5555828312183088], 0.791333208262456], [1, [0.5035557463241591, 0.5555831786984377], 0.7913238974776355], [1, [3.890888888888889, 0.5555555555555554], 27.531439890366286], [1, [-0.503555583401652, 1.6666772205100895], 5.034313308987711], [1, [0.5035555977750555, 1.6666796619049735], 5.034125479979821], [1, [-0.5015563591050244, 2.7778405210834016], 13.297089636378665], [1, [0.501556281918701, 2.7778381218016186], 13.29737047320906], [1, [0.5015560992977026, 3.8889405259585033], 25.16213332193368], [1, [-0.5015560663490657, 3.8889401783001163], 25.162182687400843], [1, [0.5055555555555553, 5.0], 40.06894786287775], [1, [-0.5055555555555553, 5.0], 40.06894786287775], [1, [3.890888888888889, 5.0], 66.80905007723815], [1, [-3.8908888888888886, -5.0], 66.80905007723815], [1, [-3.8908888888888886, -0.5555555555555554], 27.53143989036628], [1, [-3.8908888888888886, 0.5555555555555554], 27.53143989036628], [1, [-3.8908888888888886, 5.0], 66.80905007723815], [1, [-1.5146666666666664, -5.0], 42.11030787588948], [1, [-2.5237777777778057, -5.0], 46.19375292536914], [1, [-1.5146666666666664, 5.0], 42.11030787588948], [1, [-2.5237777777778057, 5.0], 46.19375292536914], [1, [1.5146666666666668, -5.0], 42.11030787588948], [1, [2.5237777777778065, -5.0], 46.19375292536914], [1, [1.5146666666666668, 5.0], 42.11030787588948], [1, [2.5237777777778065, 5.0], 46.19375292536914], [1, [1.5146666667095303, 0.5555591654586518], 2.8326008894647146], [1, [-1.5146666667092092, -0.5555591519545935], 2.832601251534582], [1, [-1.5146666667084667, 0.5555591200485468], 2.8326021069985075], [1, [1.5146666667082984, -0.5555591128541546], 2.8326022998945675], [1, [1.5126668881664194, 1.6666981292104839], 7.075516430892732], [1, [2.521778337218891, 1.6667171543793808], 11.158944219877167], [1, [-1.5126668780162766, -1.666697138477518], 7.075592639561249], [1, [-2.5217783444259143, -1.6667173577881496], 11.158928561495088], [1, [-1.5126668729831338, 1.6666967721494022], 7.075620821597475], [1, [-2.521778343686275, 1.6667172896357536], 11.158933802513351], [1, [1.512666867964794, -1.6666963956805152], 7.075649783603238], [1, [2.5217783656596637, -1.6667181662555506], 11.158866350001597], [1, [1.5106674940179667, -3.8889611030400286], 27.203476878312458], [1, [1.5103903733037483, -2.779608212360039], 15.137912134444155], [1, [2.52177818695234, -2.7779957111876006], 19.400429611567617], [1, [-2.521778027941878, 2.777812467488179], 19.421839414248474], [1, [1.512666753795203, 2.7778042967204772], 15.337903776850137], [1, [1.5106675149502073, 3.8889689233803115], 27.202369763910667], [1, [-1.5106674706424468, 3.88896622499853], 27.20275195955474], [1, [-1.5106674980501833, -3.8889792751400933], 27.200904564732944], [1, [3.5337673135280263, 3.992498151479339], 28.530759575116832], [1, [3.5337641514151295, -3.9925294520794505], 28.53047314951176], [1, [-3.5337642628003576, 3.9925281891149824], 28.53048467297758], [1, [-3.5337643140446793, -3.9925275624507113], 28.53049039159605], [1, [4.975431798486109, 2.798279327148085], 39.70918577934516], [1, [-4.975433115221867, -2.7982808899100786], 39.708933237610665], [1, [-4.975433187002346, 2.7982809092383327], 39.70892551159734], [1, [4.975435195860274, -2.7982833672217513], 39.708533467597334], [1, [-1.5106679051555079, -2.777866139849084], 15.338350567755054], [1, [-1.5106679055298522, 2.7778748270611344], 15.337335275673972], [1, [-2.5197795423144425, -2.7778889858119356], 19.42200659285954], [1, [-2.520792768427408, 3.909539991689894], 28.514124685453684], [1, [-2.5207776686647807, -3.9095734422895725], 28.509963332508537], [1, [2.5150385905308097, -0.5604157405615413], 6.86223322671276], [1, [-2.5150388677675624, 0.5604162184999664], 6.86222094858428], [1, [-2.515038524987505, -0.5604156317186428], 6.862236052798828], [1, [2.515039140482401, 0.5604166925648478], 6.862208798684804], [1, [3.9455841236236253, -1.6513985575250842], 27.606188698442946], [1, [3.9642408323987888, -2.8298690340897816], 28.51469826696997], [1, [3.9640152271181464, 2.829954511946683], 28.53016891512761], [1, [-3.963205272319826, -2.8317833123831346], 28.522493388529064], [1, [-3.964055139457381, 2.8299758751516317], 28.525838856653024], [1, [4.992734546998405, -3.8922365263512395], 51.94146778332126], [1, [4.9927343547310485, 3.89223607043485], 51.94154450876778], [1, [-4.99094277528438, 3.8931252243147676], 51.94084611237394], [1, [-4.992736201019689, -3.892240153394805], 51.9408489493012], [1, [4.983989246834268, 1.6870318551245151], 31.668827591455862], [1, [-4.983988956322779, -1.6870314147844854], 31.668869407359278], [1, [-4.983989270610561, 1.6870316711026645], 31.668834032399854], [1, [4.983983494880442, -1.6870267616792318], 31.6694930776816], [1, [2.5207776747557915, 3.909572976895665], 28.51002215014971], [1, [-3.9439113059579793, 1.6504949476295583], 27.85759947644574], [1, [3.9438791837010285, 1.6504531151906157], 27.864890868559836], [1, [-3.9438774721499392, -1.6504512004989873], 27.865248109957104], [1, [2.519779621470172, 2.777893213505613], 19.421512120381422], [1, [2.520781123410144, -3.9094967346534686], 28.51964931667205]], "nr_of_basins": 100, "f_opt_dim_2": 0.08548791951351564, "x_opt_dim_2": [-0.010634959696960301, 0.0078099186362368565], "f_opt_dim_5": 4.337424890541669, "x_opt_dim_5": [1.1574601665385914e-09, 3.8646155066243897e-10, 0.8564958120524981, 1.2250147056656817, 1.432817660466031]}
{"id": "72a0a50d-57fe-4d4f-b2dd-51d33accabf9", "fitness": 0.6588466224978523, "name": "landscape_separable_multi_well_enhanced", "description": "A strictly separable, enhanced multi-well landscape where each dimension is the minimum of several shifted quadratic wells. Global minimum sits at the origin. Wells per dimension can be generated deterministically or supplied, ensuring a clear per-dimension subproblem structure (improved Separable score). The GlobalLocal contrast is computed as the average depth of the strongest local minima across dimensions, facilitating tunable difficulty via per-dimension wells.", "code": "import numpy as np\n\nclass landscape_separable_multi_well_enhanced:\n    \"\"\"\n    Separable, enhanced per-dimension multi-well landscape.\n\n    - Each dimension i defines fi(xi) = min_j [ (xi - mu_{i,j})^2 + c_{i,j} ].\n    - Global minimum at the origin: fi(0) = 0 for each i due to (mu=0, c=0) well.\n    - The full objective is f(x) = sum_i fi(xi); thus the problem is fully separable.\n    - Wells can be supplied per-dimension or generated deterministically with a seed.\n    - GlobalLocal contrast is computed as the mean of the strongest local minima depths across dimensions.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=None, seed=None, n_wells_per_dim=5):\n        self.dim = int(dim)\n        self.n_wells_per_dim = int(n_wells_per_dim)\n        self.rng = np.random.default_rng(seed)\n\n        self.wells_per_dim = []\n        # Build per-dimension wells\n        if wells_per_dim is not None:\n            if len(wells_per_dim) != self.dim:\n                raise ValueError(\"wells_per_dim must be a list with length equal to dim.\")\n            # Normalize and ensure global well is present for each dimension\n            for dim_wells in wells_per_dim:\n                normalized = [ (float(mu), float(c)) for (mu, c) in dim_wells ]\n                # Ensure global well (0,0) exists\n                if not any(abs(mu) < 1e-9 and abs(c) < 1e-9 for mu, c in normalized):\n                    normalized.insert(0, (0.0, 0.0))\n                # Pad or trim to desired count\n                while len(normalized) < self.n_wells_per_dim:\n                    mu = float(self.rng.uniform(-4.0, 4.0))\n                    if abs(mu) < 1e-6:\n                        mu = 1.0 if self.rng.random() < 0.5 else -1.0\n                    c = float(self.rng.uniform(0.2, 1.6))\n                    normalized.append((mu, c))\n                if len(normalized) > self.n_wells_per_dim:\n                    normalized = normalized[:self.n_wells_per_dim]\n                self.wells_per_dim.append(normalized)\n        else:\n            # Deterministically generate per-dimension wells with a global well at (0,0)\n            for _ in range(self.dim):\n                wells = [(0.0, 0.0)]\n                for _ in range(max(0, self.n_wells_per_dim - 1)):\n                    mu = float(self.rng.uniform(-4.0, 4.0))\n                    if abs(mu) < 1e-6:\n                        mu = 1.0 if self.rng.random() < 0.5 else -1.0\n                    c = float(self.rng.uniform(0.2, 1.6))\n                    wells.append((mu, c))\n                self.wells_per_dim.append(wells)\n\n        # Compute GlobalLocal contrast: for each dim, depth of strongest local minimum\n        per_dim_local_min = []\n        for i in range(self.dim):\n            wells = self.wells_per_dim[i]\n            non_global_vals = [ (mu**2 + c) for (mu, c) in wells if not (abs(mu) < 1e-9 and abs(c) < 1e-9) ]\n            if len(non_global_vals) > 0:\n                per_dim_local_min.append(min(non_global_vals))\n            else:\n                per_dim_local_min.append(0.0)\n        self.global_local_contrast = float(np.mean(per_dim_local_min))\n\n        # Track global minimum value (0) for clarity\n        self.global_min = 0.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i fi(x_i) where fi(x_i) = min_j [ (x_i - mu_{i,j})^2 + c_{i,j} ].\n\n        Domain: x_i in [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar value of the landscape at x\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = float(x[i])\n            best = None\n            for (mu, c) in self.wells_per_dim[i]:\n                val = (xi - mu)**2 + c\n                if (best is None) or (val < best):\n                    best = val\n            total += float(best)\n        return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_multi_well_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0e080937-ac3d-4df5-b8b9-4d08b6fceb50"], "operator": null, "metadata": {"ela_features_2D": [0.3329718997844263, 0.16970375129270895, 0.2167393445764033, 0.32310257524450375, 1.4916255492757542, 0.33408692998578104, 0.9100137902953012, 1.4572641636704842, 0.969455080878842, 1.2827327038424587, 1.1728078511917395, 2.0, 0.5202788079661418, 0.6905356935855934, 0.4299128589334913, 0.34946139917348595, -0.18034621269745213, 0.18399716964312138, 0.3855967631540194, 0.4839059704116191, 0.5639336468532672, 0.19025184415768726, 0.32108372792322476, 0.4758769519141497, 0.5594457533883184, -0.4268401164187254, -0.32138616395954567, -0.26996189242838575, -0.2281018484964354, -0.41539545415651524, -0.3482461607275061, -0.2688517555042364, -0.2260207019453387, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5137470855559749, 0.5137239763669139, 0.48830229010728854, 0.524625951797074, 0.7045657770093087, 0.4734734734734733, 0.29309768303473455, -0.2552552552552552, 0.39759036144578314], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9500133991241455, "ela_features": [0.38032595432120714, 0.20294436986153097, 0.014856049229178946, 0.30166527588446235, 49.03820259697917, 0.3858415658218595, 0.9527000027802994, 11.931385700135673, 0.9717602537536589, 1.0122896917254907, 0.8276427974939924, 1.6, 0.8347491493547746, 0.8620173747283065, 0.5919211132103384, 0.19222086237248792, -0.3844645966205942, 0.5633689214301598, 0.6235752168162138, 0.6694176623397727, 0.763943900631399, 0.5524537269648373, 0.612903703257399, 0.6577469962687414, 0.7571179658046614, -0.38405982578500597, -0.3311020821809082, -0.2907784439764828, -0.20763413038657577, -0.39575006670670787, -0.3422928784814279, -0.3026368726740019, -0.21476759223332711, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21600051635211487, 0.21601299300658142, 0.22271458637815505, 0.2721531250317761, 0.8175101749694947, 0.1611611611611611, 0.20229313886582306, -0.46746746746746737, 0.5344551282051283], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.002691064029932022, "ela_features_10D": [0.2417476102289718, 0.24061559086991674, 0.002586975720495139, 0.2561518025943211, 170.11099973294537, 0.24224506957435654, 0.9400677138027549, 13.495585028478828, 0.967256031598582, 0.6339856139660613, 0.2266805352675103, 1.4, 0.9760225900635439, 0.933247300866034, 0.6883353745322551, 0.10945400301253176, -0.5219279685244634, 0.685552184221476, 0.7331599532059598, 0.7762639446946084, 0.8469174006709899, 0.6838009900034291, 0.7326532405671783, 0.7763487760149056, 0.8477125160030654, -0.3987902420996224, -0.3384133780452361, -0.2837478480842533, -0.1941431753712768, -0.4020700096995918, -0.3399521279148137, -0.2843905728746024, -0.19364516354698852, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10930756553290044, 0.10930314097872718, 0.10934978865097042, 0.1355057142476074, 0.8531201419003546, -0.07107107107107109, 0.13119508965047752, -0.6516516516516514, 0.5913530824659727], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0003752718330360949}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [2.564666666666605, 2.8688888888890016], 1.2032373651777366], [24, [0.00044444444444512003, 2.8688888888890016], 0.33720405313636403], [24, [2.564666666666605, 0.00044444444444512003], 0.8660337071031009], [36, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.680790599240761e-163, -1.3099494190998216e-162], "f_opt_dim_5": 3.96462021e-315, "x_opt_dim_5": [5.136376891558766e-158, -2.5503789393208517e-159, -1.8892541025204933e-158, -2.9990223222901043e-158, -7.971036762690196e-159]}
{"id": "34497919-894f-4b0d-8285-0813e5dd672d", "fitness": 0.5586798291963836, "name": "landscape_improved_separable_wells", "description": "A strictly separable, multi-dimensional benchmark built from per-dimension min-of-quadratics wells with independent dimension-wise patterns. The global minimum is at the origin (f=0), and the objective is the sum of per-dimension 1D landscapes. GlobalLocal is computed as the average per-dimension local-minima contrast, promoting separability-friendly difficulty and enabling straightforward subproblem decomposition.", "code": "import numpy as np\n\nclass landscape_improved_separable_wells:\n    \"\"\"\n    Separable, multimodal landscape with per-dimension min-of-quadratics wells.\n    Each dimension has its own independent well layout; the global minimum is at the origin (f=0),\n    and the objective is the sum of per-dimension 1D landscapes. GlobalLocal is computed as the\n    average ratio of the deepest non-global local minimum to the mean 1D landscape level, promoting\n    separability-friendly difficulty: subproblems can be solved independently per dimension.\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, grid_samples=101, seed=None):\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.grid_samples = int(max(11, grid_samples))\n\n        # Allocate per-dimension wells (centers s) and depths d\n        self.s = np.zeros((self.dim, self.wells), dtype=float)\n        self.d = np.zeros((self.dim, self.wells), dtype=float)\n\n        # Deterministic construction: for each dimension, generate centers and depths\n        for i in range(self.dim):\n            # Base centers for this dimension\n            s_i = np.linspace(-self.L, self.L, self.wells)\n\n            # A small, deterministic dimension-dependent shift to create independent patterns\n            shift = (i + 1) * 0.25\n            s_i = s_i + shift\n\n            # Ensure a well at or near zero, then enforce exact zero for the global minimum\n            idx_zero = int(np.argmin(np.abs(s_i)))\n            s_i[idx_zero] = 0.0\n\n            # Depths increase with distance from zero (0 for the closest well)\n            depths = (np.arange(self.wells, dtype=float) * self.contrast)\n\n            # Reorder wells by distance to zero to align 0-depth with the nearest well to zero\n            order = np.argsort(np.abs(s_i))\n            self.s[i, :] = s_i[order]\n            self.d[i, :] = depths[order]\n\n        # Compute a GlobalLocal descriptor: average across dimensions of the 1D landscape contrast\n        self.global_local = self._compute_global_local_score()\n\n    def _compute_global_local_score(self):\n        scores = []\n        xs = np.linspace(-self.L, self.L, max(11, self.grid_samples))\n        for i in range(self.dim):\n            # 1D landscape for this dimension\n            g1d = []\n            for xval in xs:\n                vals = (xval - self.s[i, :]) ** 2 + self.d[i, :]\n                g1d.append(np.min(vals))\n            mean_1d = float(np.mean(g1d))\n            d_max = float(self.d[i, :].max()) if self.wells > 0 else 0.0\n            score_i = (d_max / mean_1d) if mean_1d > 0 else float('inf')\n            scores.append(score_i)\n        if len(scores) == 0:\n            return 0.0\n        return float(np.mean(scores))\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns the sum of per-dimension 1D landscapes.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        total = 0.0\n        for i in range(d):\n            t = x[i]\n            vals = (t - self.s[i, :]) ** 2 + self.d[i, :]\n            total += float(np.min(vals))\n        return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_improved_separable_wells scored on:Separable 1.000, GlobalLocal 0.027,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["6cc27429-cd3e-43b1-9e09-ead2dfad539d"], "operator": null, "metadata": {"ela_features_2D": [0.9529211614663801, -0.09484499731628795, 0.5230394981774895, 0.5552308425832777, 1.0615819819765633, 0.953102869883871, 0.9740954867238196, 1.7910085246587581, 0.9878258455073411, 0.15914438230904046, -0.6654844102533432, 1.0, 0.702988639175216, 0.7172920577776066, 0.5375810906545931, 0.3406498288847946, -0.11290483608848538, 0.13996438767597852, 0.22186858966698236, 0.3227527493827205, 0.5258420073835003, 0.1457237050453155, 0.221475188231201, 0.3195240438159376, 0.5141891791996325, -0.45035732564090064, -0.40746903625234465, -0.35464152179946973, -0.24829579522044173, -0.439773172141383, -0.4007745831313046, -0.35030089704113493, -0.25008763873977025, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5166192543972838, 0.5166115448563156, 0.6108462775247985, 0.6594687531723683, 0.7513752643015957, 0.1931931931931931, 0.3721011884433793, -0.3073073073073072, 0.3855421686746988], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.3212856650352478, "ela_features": [0.8697841168069746, -0.14389463229677862, 0.20008876709700188, 0.27605426704146974, 1.3821633741984836, 0.8706376414192192, 0.939124142016383, 3.461870237430862, 0.9811133236644249, 0.11034115667803102, -0.22806096508584978, 1.0, 0.8684616415158237, 0.8659163462183276, 0.6204642252984908, 0.18763666481304486, -0.29987917899270083, 0.4629627043340522, 0.5721381572305172, 0.6660677337536168, 0.8016122194901291, 0.460782826363819, 0.5662287842234892, 0.6583460392804081, 0.7952357499461881, -0.472438065105149, -0.3763982490304971, -0.29376665520273676, -0.17452449550240023, -0.4769396272403494, -0.3836791514439818, -0.3022014853395625, -0.18111652413530815, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21729247613463096, 0.21730393210891194, 0.24951851269198616, 0.3251244801758733, 0.8179134416881702, -0.09109109109109105, 0.15357845020630678, -0.5955955955955954, 0.5046474358974359], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.004194128327071667, "ela_features_10D": [0.5530920832260353, -0.07211145747873704, 0.005787709800285336, 0.18329547305008959, 47.35034244355609, 0.5555354888503861, 0.8647120158086004, 9.361163998521324, 0.9782288264755353, 0.1334487350937291, -0.14435188622912465, 1.4, 0.944603527486333, 0.9282905107185477, 0.6689141253976607, 0.11312610273030706, -0.48596292159051624, 0.6968531253044322, 0.7552374861245605, 0.8003080082745189, 0.8679575781965955, 0.6956070236299633, 0.7565910402657607, 0.8018229922921755, 0.8691987879657358, -0.38448004838571614, -0.31043149300680833, -0.25326962103663064, -0.16746905079713562, -0.3871222743873225, -0.3095648702922364, -0.2520411287810114, -0.1663517873759342, 0.9, 0.9, 0.8363636363636363, 0.909090909090909, 0.10952593994430507, 0.10953445009648852, 0.11666822605671176, 0.16019109175087928, 0.851843996292604, -0.17117117117117114, 0.10981541574294904, -0.7437437437437435, 0.5821457165732586], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.026599181815981865}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[30, [-3.7497777777776706, -3.499777777777698], 9.876543218177191e-08], [20, [1.2506666666666666, -3.499777777777698], 5.0000004938271605], [30, [-3.750005036441892, 0.0003070175875860793], 3.000000094285165], [20, [1.2493984620270178, -0.0007090889812396916], 8.000000864655117]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.75, -3.5], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.75, -3.5, -3.25, -3.0, -2.75]}
{"id": "d464d373-e226-4232-9c13-f756355ec035", "fitness": 0.6492309955259165, "name": "landscape_cosine_wells_separable", "description": "A strictly separable per-dimension benchmark with additive quadratic base and cosine wells. Each dimension has its own deterministic amplitude a_i and frequency n_i, yielding multiple local minima while preserving a global minimum at the origin. The landscape is fully additive across dimensions to ensure easy partitioning into subproblems by dimension.", "code": "import numpy as np\n\nclass landscape_cosine_wells_separable:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Deterministic, per-dimension nonnegative modulation amplitudes (cosine wells)\n        self.a = 0.20 + 0.25 * np.arange(dim)\n        # Deterministic, per-dimension cosine frequencies\n        self.n = 1.0 + 0.60 * np.arange(dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n        # Separable per-dimension function: f_i(t) = t^2 + a_i*(1 - cos(n_i * t))\n        per_dim = x**2 + self.a * (1.0 - np.cos(self.n * x))\n        return float(np.sum(per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_cosine_wells_separable scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["de571ef2-7f92-4f0e-9844-a80acda6e5a3"], "operator": null, "metadata": {"ela_features_2D": [-0.0028810082421860893, 0.35752505451213246, 0.005551864818823396, 0.021401163825017177, 12.75293653864448, 0.0017592039307279706, 0.9990901854527061, 1.0230598712523515, 0.9990986510026041, 0.40848002057530913, -0.4690378069592514, 1.4, 0.7059898536805436, 0.720753839340835, 0.5410811011668153, 0.33855580650656086, -0.20561963062170596, 0.1282469715520225, 0.2137312712680241, 0.299815508706251, 0.4879486831521274, 0.12902728732715577, 0.2110495834550262, 0.30046696479191715, 0.4866078077264301, -0.45586483057828237, -0.4111632527881044, -0.3661437299618225, -0.2677571065379707, -0.4472108301788474, -0.4050926165124499, -0.3591702318242175, -0.26357474200090153, 1.0, 1.0, 1.0, 1.0, 0.5142272399117926, 0.5141990300991588, 0.40031415216005, 0.34795311130392553, 0.7170692618399521, 0.39339339339339324, 0.6093283293355459, -0.07907907907907905, 0.34979919678714866], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8949530720710754, "ela_features": [1.0800895332230276e-05, 0.410144401783543, 0.005695600370558422, 0.029843953781810807, 7.9482642751850605, 0.004683646564053489, 0.9947608645671588, 1.041872723330131, 0.9947269522540362, 0.27212140616215247, -0.2012013275915364, 1.4, 0.9086083710189563, 0.8749701744685833, 0.6422179480557759, 0.18160936743492254, -0.47604625683741836, 0.432649705282717, 0.5208280003697561, 0.5981508876377502, 0.7198912574142724, 0.4355278420722164, 0.5215208750601737, 0.6010913727303026, 0.7240229793029517, -0.49918805584816645, -0.4216024356622209, -0.3535682536624132, -0.2464543800714935, -0.49943644655691316, -0.4233463034638823, -0.35294172090443976, -0.24417531847530577, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2156506736776787, 0.21566363502968072, 0.20052785836491785, 0.18235145976736125, 0.8271861816158645, 0.12912912912912908, 0.25482904197848744, -0.3513513513513512, 0.5092948717948718], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0001701374421827495, "ela_features_10D": [0.00047791452507326413, 0.4354107663753627, 0.00035088341906918324, 0.021694127672060196, 342.471766811976, 0.006793016363525894, 0.980042709847142, 1.055017198362918, 0.980046853667935, 0.177244477785157, -0.16371400251522186, 1.0, 1.0169978532915611, 0.9384472867056312, 0.711199332203105, 0.1050592231468173, -0.6102447980587471, 0.6303613542087103, 0.6853376345016848, 0.7320288809293187, 0.8076110492490983, 0.6365277290347103, 0.6901006836601982, 0.7368302825781357, 0.8120816876604895, -0.4687762498026844, -0.39905522023336226, -0.3398413453455743, -0.24398786588161098, -0.4621182213242923, -0.39400447534459, -0.334592194812866, -0.238917554427143, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11027590999153754, 0.11027156796361781, 0.10706008300261434, 0.10125334243607072, 0.8622051902491128, -0.10710710710710707, 0.13583193838380314, -0.6236236236236234, 0.5910328262610087], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0002627636422403157}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 5.285925874995442e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.2064037129315122e-162, 8.386921346376241e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.062271679879744e-162, -8.809440578946431e-163, 3.008393338407602e-163, -1.195375078344474e-163, -1.3935713111285582e-162]}
{"id": "f7b818fc-71f0-43fb-b5f5-7ae4d9f30869", "fitness": 0.6451798598354799, "name": "landscape_gaussian_pockets", "description": "A completely different, separable landscape built from additive Gaussian wells on top of a quadratic base. Each dimension has multiple Gaussian wells (centers, depths, and widths) arranged to create several local minima while preserving a global minimum structure (centered wells). The landscape is strictly separable across dimensions and tunable via per-dimension pocket depths and widths to adjust GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_gaussian_pockets:\n    \"\"\"\n    A separable landscape with a quadratic base per dimension plus multiple Gaussian wells.\n    The per-dimension wells (centers, depths, and widths) are randomly generated but fixed\n    for a given instance, to preserve reproducibility. The global minimum is shaped by a\n    deep well centered at 0 in each dimension, while additional wells create local minima.\n    The domain is [-5, 5] per dimension.\n    \n    f(x) = sum_i [ x_i^2 + sum_j (-A_i,j) * exp(- (x_i - C_i,j)^2 / (2 * S_i,j^2)) ]\n    where:\n      - C_i,j are centers for dimension i, pocket j\n      - A_i,j are depths (positive). The minus sign creates wells\n      - S_i,j are widths (standard deviations) for the Gaussians\n    \"\"\"\n    def __init__(self, dim, seed=None, pockets_per_dim=4, depth_scale=1.0):\n        self.dim = int(dim)\n        self.P = int(pockets_per_dim)\n        rng = np.random.default_rng(seed)\n\n        # Centers for each dimension (dim x P)\n        self.C = rng.uniform(-4.5, 4.5, size=(self.dim, self.P))\n        # Enforce a deep well at the origin for each dimension\n        self.C[:, 0] = 0.0\n\n        # Depths A for each dimension and pocket (dim x P)\n        self.A = rng.uniform(0.6, 1.6, size=(self.dim, self.P))\n        # Make the origin well the deepest to bias global minimum toward the origin\n        self.A[:, 0] = depth_scale * rng.uniform(1.8, 2.4, size=self.dim)\n\n        # Widths S for each dimension and pocket (dim x P)\n        self.S = rng.uniform(0.25, 1.0, size=(self.dim, self.P))\n        self.S[:, 0] = rng.uniform(0.2, 0.5, size=self.dim)\n\n        # Ensure numpy arrays of float type\n        self.C = self.C.astype(float)\n        self.A = self.A.astype(float)\n        self.S = self.S.astype(float)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        - x must be a 1D array-like of length self.dim\n        - Returns a scalar objective value (minimization)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            base = xi * xi  # quadratic base\n            dx = xi - self.C[i]  # difference to centers in this dimension\n            # Gaussian wells: sum over pockets\n            well_contrib = -self.A[i] * np.exp(- (dx * dx) / (2.0 * (self.S[i] * self.S[i])))\n            total += base + np.sum(well_contrib)\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_gaussian_pockets scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8f17f21f-4486-4814-a0fb-8836c74361fc"], "operator": null, "metadata": {"ela_features_2D": [-0.001771713646931583, 0.38378864901751364, 0.006209969668072892, 0.02881364404199996, 6.613151508799556, 0.0005935496777663696, 0.9955480187238205, 1.1291318058439326, 0.9957155195257531, 0.3688754412885329, -0.4880820559371105, 1.2, 0.7046151714386019, 0.7137807746171526, 0.5475298513697334, 0.34194186772234064, -0.19443709663348083, 0.11765787147572182, 0.2021619663053328, 0.3033039893293783, 0.49000302608882895, 0.11788324013743393, 0.19773455525603595, 0.30223724431073584, 0.4875783267544743, -0.4617915108598716, -0.4175635026673194, -0.36462849602428415, -0.2669162996571171, -0.4533873646306259, -0.412352040851694, -0.3586359024382423, -0.2633725857028207, 1.0, 1.0, 1.0, 1.0, 0.5206401065425547, 0.5206261322304055, 0.41067037249970195, 0.3559035603974251, 0.7307661104917889, 0.37737737737737725, 0.5088591670201958, -0.09909909909909909, 0.36345381526104414], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8706895709037781, "ela_features": [-5.054762462375351e-06, 0.3880183478724249, 0.005625900085647894, 0.02520366100426334, 12.430794523656393, 0.006804374868496987, 0.9959401318671844, 1.041637023367965, 0.9964741875637746, 0.3095668758865905, -0.101511728094032, 1.0, 0.9025995676845342, 0.8718027511791886, 0.6466510245670791, 0.18397083587695456, -0.46736049825965065, 0.451331028462044, 0.525881110593502, 0.5969256240611527, 0.7163513093578452, 0.4538790108070261, 0.5297715953922009, 0.6014181381208704, 0.7206864353368851, -0.48261197915044923, -0.41703813711536153, -0.35454655068589724, -0.24949926900614033, -0.4828155492014369, -0.4157272522618216, -0.3523838426657971, -0.24693981674033455, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21799069651789305, 0.21795049384721565, 0.2037080392193432, 0.1839024346523859, 0.8210291283016783, 0.10510510510510507, 0.24315633313995821, -0.3873873873873873, 0.5217948717948718], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00017301327898167074, "ela_features_10D": [0.00016161516505148744, 0.45085389404088366, 0.0020714944957956486, 0.02013194959045688, 80.64093172630933, 0.004179079985038881, 0.9940251822200029, 1.1090768123657326, 0.994810187227937, 0.17396508825142623, -0.04532911302599665, 1.2, 1.028648085026107, 0.9391719680710148, 0.7202670721100004, 0.10578512911757729, -0.61445503411695, 0.6179726570886144, 0.6741921462197509, 0.7251552260461249, 0.8054761404196904, 0.6214047612435438, 0.678744066890974, 0.7292207762143676, 0.810083431745495, -0.4844708061334023, -0.413174896988277, -0.3485456874858322, -0.24668639858917482, -0.4813511377373638, -0.4084479765693879, -0.3442709999464043, -0.24146174321720934, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10922322079189606, 0.10922208013617407, 0.10626700413472501, 0.0997725628087889, 0.8566026255818129, -0.1311311311311311, 0.12255906637064828, -0.6636636636636635, 0.5927942353883107], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00021657483011949807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-0.020444444444445126, 0.12266666666666559], -6.5728394214391]], "nr_of_basins": 1, "f_opt_dim_2": -4.8955535860050965, "x_opt_dim_2": [0.049252531478503996, 4.451198025163445e-05], "f_opt_dim_5": -14.744379684950541, "x_opt_dim_5": [0.03448645603033318, -0.039299337885321285, 0.1140659125798865, 0.0006878194220667269, -0.019647837588661198]}
{"id": "541abd0c-8cca-44ca-92bd-bfd6131c43fa", "fitness": 0.6644142957714697, "name": "landscape_minquad_wells_random", "description": "A completely different, separable landscape based on the minimum of several per-dimension quadratic wells. Each dimension has multiple wells with random centers and depths, including a global well at the origin. The objective is the sum over dimensions of the per-dimension min-quadratic wells, ensuring a global minimum at the origin. GlobalLocal contrast can be tuned via the depths and relative spacing of the nonzero wells, while preserving separability.", "code": "import numpy as np\n\nclass landscape_minquad_wells_random:\n    \"\"\"\n    A separable landscape where each dimension is the minimum of several quadratic wells.\n    - Each dimension i has wells: (x - c_{i,j})^2 + d_{i,j} for j = 0..m_i-1\n    - Well j=0 is fixed at center c=0 with depth d=0, guaranteeing a global minimum at x_i = 0\n    - Other wells have centers sampled away from zero and positive depths, creating local minima\n      with tunable GlobalLocal contrast via centers and depths.\n    - The overall objective is f(x) = sum_i min_j ((x_i - c_{i,j})^2 + d_{i,j})\n    - Domain per dimension: [-5, 5]\n    \"\"\"\n    def __init__(self, dim, seed=None):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be a positive integer.\")\n\n        # For each dimension, define a small set of wells\n        # Keep the first well fixed at origin with zero depth (global minimum per-dim)\n        # Others have centers away from zero and positive depths\n        self.well_centers = []\n        self.well_depths = []\n        wells_count_options = [3, 4, 5]  # number of wells per dimension\n\n        for i in range(self.dim):\n            m = rng.choice(wells_count_options)\n\n            centers = [0.0]  # global well at origin\n            depths  = [0.0]\n\n            # Sample remaining centers away from zero, within [-5, 5]\n            needed = m - 1\n            cand_centers = []\n            attempt = 0\n            while len(cand_centers) < needed and attempt < 100:\n                attempt += 1\n                c = rng.uniform(-5.0, 5.0)\n                # Avoid center too close to zero to create distinct wells\n                if abs(c) < 0.25:\n                    continue\n                # Simple check to avoid too-close centers\n                if all(abs(c - cc) > 0.15 for cc in cand_centers):\n                    cand_centers.append(c)\n\n            # If we couldn't fill enough distinct centers, fall back to randoms (ensuring diversity)\n            while len(cand_centers) < needed:\n                c = rng.uniform(-5.0, 5.0)\n                if any(abs(c - cc) < 0.05 for cc in cand_centers):\n                    continue\n                cand_centers.append(c)\n\n            centers.extend(cand_centers)\n\n            # Depths for non-origin wells (positive, tune GlobalLocal)\n            # Depths are chosen to create noticeable local minima away from the origin\n            for _ in range(needed):\n                depths.append(rng.uniform(0.25, 3.0))\n\n            self.well_centers.append(np.array(centers, dtype=float))\n            self.well_depths.append(np.array(depths, dtype=float))\n\n        # Convert lists to arrays for faster evaluation if needed later\n        # (Each dimension i has centers[i], depths[i] of equal length m_i)\n        # No explicit boundary handling beyond evaluation; inputs are assumed within [-5, 5]\n        self._rng = rng\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        - x must be a 1D array of length self.dim\n        - Returns a scalar objective value (minimization)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        total = 0.0\n        # For each dimension, compute min_j ((x_i - c_{i,j})^2 + d_{i,j})\n        for i in range(self.dim):\n            centers = self.well_centers[i]\n            depths  = self.well_depths[i]\n            # Compute squared distance to all centers, add depths\n            diffs = x[i] - centers\n            vals = diffs * diffs + depths\n            total += float(np.min(vals))\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_minquad_wells_random scored on:Separable 1.000, GlobalLocal 0.006,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8f17f21f-4486-4814-a0fb-8836c74361fc"], "operator": null, "metadata": {"ela_features_2D": [0.45926819038153227, 0.44817495238690475, 0.07159843525887837, 0.4898816294938383, 7.06430304831689, 0.4601650369108258, 0.9120834000639941, 2.489379940138156, 0.9852253475237644, 1.3941805816628652, 1.1468495953322388, 2.0, 0.5771122022830535, 0.7080000671940425, 0.4800083333030514, 0.33487040906298543, -0.151335652433791, 0.14823753870422857, 0.26739803456011024, 0.37620966305676184, 0.5489443754679485, 0.1362332020997139, 0.2518286452679609, 0.3713234130066083, 0.5364845219206132, -0.44574463500614375, -0.383387397840144, -0.32644481395097646, -0.23604896876381712, -0.4440482145156883, -0.38462746859100794, -0.32319764598388234, -0.23829043468224542, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5169389015089492, 0.5169187234438277, 0.5224301155844067, 0.5616029288255142, 0.683191597924161, 0.4694694694694693, 0.24679941516829412, -0.2992992992992992, 0.3911646586345382], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9800707697868347, "ela_features": [0.2514103821231166, 0.12828791980775744, 0.006995489176557676, 0.20875636619183444, 35.52161187026119, 0.25561488106466834, 0.8678200920819424, 235.03462143750602, 0.9341827269440686, 0.8720528616980584, 0.5137413402787984, 1.4, 0.7586420347424244, 0.8489528571898621, 0.5373109099158675, 0.20231672808575757, -0.4231203053263891, 0.6201691576457532, 0.6726360128690442, 0.7333663062192969, 0.8073091653954207, 0.6026459714133798, 0.653890695799034, 0.7177524963584657, 0.7981706465893297, -0.33408903261473644, -0.2879434490317948, -0.2345265979264523, -0.16948921967143715, -0.35129889346687854, -0.30599651046969045, -0.24953422930737537, -0.17844143566356832, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21819125382599186, 0.21820200391495867, 0.21106570484348106, 0.2506523424664717, 0.8345854966108085, 0.20120120120120114, 0.24279906358341358, -0.40340340340340325, 0.5479166666666666], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0006274152547121048, "ela_features_10D": [0.19724770688324245, 0.4653232788517275, 0.003967103461399308, 0.20772438419651357, 57.51172486160267, 0.2018759969699655, 0.9090960405351185, 18.413060009163836, 0.9510331563561, 0.527233125456859, 0.1576050808315726, 1.4, 0.9172307124109962, 0.9277859109978227, 0.6347403871227197, 0.11288290749574832, -0.5346200090607792, 0.7256430524346866, 0.7652835549081505, 0.7982132793747307, 0.8611043699066483, 0.7213830270148167, 0.7627672108751185, 0.7965971637735947, 0.8608185886718769, -0.3479942791294709, -0.2977136998979686, -0.25594597175964806, -0.17617491241552435, -0.35441431654998945, -0.3017698363236736, -0.2587367900296475, -0.1770442494691288, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10926707305357589, 0.10927352950469635, 0.10848897518542797, 0.13197298607011174, 0.8584434744632201, -0.0870870870870871, 0.13433916345680894, -0.6476476476476474, 0.5981585268214571], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0057875895872712135}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-1.2326666666666661, 0.00044444444444512003], 1.1819321449027258], [3, [-1.2326666666666661, -4.5768888888888135], 2.592823030170289], [6, [0.00044444444444512003, -4.5768888888888135], 1.4108912803292915], [6, [4.688000000000034, -4.5768888888888135], 1.7530511188269418], [9, [-3.5597777777776916, -4.5768888888888135], 2.5350327198622966], [6, [3.0957777777777435, -4.5768888888888135], 1.874903983147834], [14, [3.0957777777777435, 0.00044444444444512003], 0.46401309788027084], [14, [4.688000000000034, 0.00044444444444512003], 0.34216023355937863], [21, [-3.5597777777776916, 0.00044444444444512003], 1.1241418345947334], [15, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 10, "f_opt_dim_2": 0.8858700363508509, "x_opt_dim_2": [3.262569824253832, 1.0765154711485043e-10], "f_opt_dim_5": 0.0, "x_opt_dim_5": [4.3914826966104974e-163, 1.0549604563691973e-162, 9.618702981900573e-164, -7.727983059393029e-163, -9.856115751755061e-163]}
{"id": "d8c83eb3-0fc7-49f9-bfd1-d506a5309a77", "fitness": 0.6606709058905835, "name": "landscape_separable_minquad_wells_enhanced", "description": "A strictly separable, enhanced per-dimension min-of-quadratic wells landscape using deterministic grid centers. Each dimension has its own set of well centers arranged deterministically within [-L, L], with a guaranteed global well at 0 and depths increasing with distance from zero. The objective remains additive across dimensions, ensuring strong separability and enabling straightforward subproblem decomposition for separable optimizers.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_enhanced:\n    \"\"\"\n    Enhanced separable benchmark:\n    - Each dimension i has its own set of 'wells' (centers) s_i_j in [-L, L].\n    - A guaranteed global well at x_i = 0 with zero depth.\n    - Depths d_i_j increase with distance from zero to create a controllable GlobalLocal contrast.\n    - The per-dimension contribution is f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - The overall objective is f(x) = sum_i f_i(x_i), ensuring full separability.\n    - Centers are generated deterministically (grid-based) by default for reproducibility.\n    \"\"\"\n    def __init__(self, dim=5, wells_per_dim=7, L=5.0, contrast=1.0, seed=None, deterministic=True):\n        \"\"\"\n        dim: number of dimensions\n        wells_per_dim: number of local wells per dimension (>=3)\n        L: bounds for well centers per axis (centers lie in [-L, L])\n        contrast: depth step between consecutive wells (GlobalLocal control)\n        seed: random seed for reproducibility (used if deterministic is False)\n        deterministic: if True, use a deterministic grid of wells; if False, use random centers\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells_per_dim))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.rng = np.random.default_rng(seed)\n        self.deterministic = bool(deterministic)\n\n        # Build per-dimension well centers\n        s_per_dim = []\n        for i in range(self.dim):\n            if self.deterministic:\n                # Deteministic grid: evenly spaced in [-L, L]\n                s = np.linspace(-self.L, self.L, self.wells)\n            else:\n                # Random centers in [-L, L]\n                s = self.rng.uniform(-self.L, self.L, size=self.wells)\n            # Guarantee a well exactly at 0\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n\n            # Sort wells by distance to zero (nearest first) to align with increasing depth\n            order = np.argsort(np.abs(s))\n            s_sorted = s[order]\n            s_per_dim.append(s_sorted)\n\n        S = np.stack(s_per_dim, axis=0)  # shape: (dim, wells)\n\n        # Depths: 0, contrast, 2*contrast, ..., (wells-1)*contrast\n        depths = np.arange(self.wells, dtype=float) * self.contrast\n\n        # Assign depths per dimension aligned with the sorted wells.\n        # Since wells are sorted by distance to zero, this ensures the closest well to zero has depth 0.\n        self.s = S                 # (dim, wells)\n        self.d = np.tile(depths, (self.dim, 1))  # (dim, wells), same pattern across dimensions\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_minquad_wells_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7e96f668-95d2-4719-b32c-e3d800bec321"], "operator": null, "metadata": {"ela_features_2D": [0.06497967210902456, 0.29835501341227966, 0.10646902009956787, 0.14525029134254527, 1.365226524248031, 0.06821891016080164, 0.9510287677783665, 1.0119088241287575, 0.9540511686759974, 0.18441086057069178, -0.5643522902892222, 1.0, 0.6920791057194542, 0.7205736096698154, 0.5422684203916657, 0.33249680159036965, -0.19814381448245919, 0.1539084321177236, 0.2718003450206523, 0.33961754819236234, 0.5099973604678033, 0.15431287835564342, 0.26503392589916824, 0.333049483531539, 0.5098666352456529, -0.4429762405616625, -0.3812491683496864, -0.34574730873428644, -0.25654126019384044, -0.4357887788868129, -0.37872964014037724, -0.3436976333129542, -0.2525663759591853, 1.0, 1.0, 1.0, 1.0, 0.5114141872316279, 0.5114105166156722, 0.43378557820175, 0.4248912566615669, 0.7342713361211299, 0.44144144144144126, 0.5799187305230113, -0.08308308308308307, 0.3823293172690763], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9634974598884583, "ela_features": [0.06272050284627562, 0.29863698318710485, 0.051343443427870575, 0.0835060417818789, 1.6582797422093223, 0.06646392108848578, 0.9503334791415462, 1.0327009610749294, 0.9539139578206421, 0.13021246333285105, -0.24238721660963466, 1.2, 0.8940546151462939, 0.8713007877629295, 0.6371230752975009, 0.1844966200725602, -0.4621217270926742, 0.4641269492070367, 0.5429910550376397, 0.6124444390283245, 0.7216473572066736, 0.46464368931761857, 0.5464449072196926, 0.6148454897096391, 0.7249011722054374, -0.4713819302972254, -0.40200863935333364, -0.3409134412440641, -0.24485251263027993, -0.47325813991967003, -0.4009437633561457, -0.34047810118745847, -0.2431868558819287, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21425399676990226, 0.21424363802375118, 0.20195792336335194, 0.21072048861950385, 0.8327530754099801, 0.09309309309309305, 0.25179136329307, -0.4074074074074073, 0.5120192307692306], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0003284185950178653, "ela_features_10D": [0.05405842252733053, 0.27732084753309205, 0.022074637704066792, 0.05434043094165739, 2.5773042076410633, 0.0615346305911658, 0.9494725579425, 1.0445776591174067, 0.9532722290256332, 0.06040659243054082, -0.15649187141517115, 1.2, 0.9961006183717067, 0.93611452298615, 0.6944273073394207, 0.1060164057087541, -0.5989991306961864, 0.6382710301365374, 0.690673859954185, 0.7396525029481965, 0.8136397573634447, 0.641435500521372, 0.6948046517859241, 0.7432561149102318, 0.8175037424027265, -0.458791668306782, -0.3923273754238756, -0.3302065785143221, -0.2363663737112815, -0.456018089542928, -0.38814258440018745, -0.326523481939957, -0.23209637192154076, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11075766411372068, 0.11075718488393678, 0.10807209538896871, 0.11434242836850517, 0.849987648248263, -0.1271271271271271, 0.12976653659400755, -0.6476476476476474, 0.5838270616493195], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0001995568600250408}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 10.0], [1, [5.0, -5.0], 11.0], [1, [-5.0, 5.0], 11.0], [1, [5.0, 5.0], 12.0], [2, [0.00044444444444512003, -5.0], 5.0000001975308646], [1, [3.3328888888889505, -5.0], 9.000000197530865], [2, [3.3328888888889505, -1.6666666666666665], 5.0000001975308646], [2, [-5.0, 0.00044444444444512003], 5.0000001975308646], [2, [5.0, 0.00044444444444512003], 6.0000001975308646], [1, [-5.0, 3.3328888888889505], 9.000000197530865], [2, [-1.6666666666666665, 3.3328888888889505], 5.0000001975308646], [2, [3.3328888888889505, 1.666666666666667], 6.0000001975308646], [2, [1.666666666666667, 3.3328888888889505], 6.0000001975308646], [1, [5.0, 3.3328888888889505], 10.000000197530865], [1, [3.332662452973788, 4.991010080719342], 10.00008126872913], [2, [0.00044444444444512003, 5.0], 6.0000001975308646], [4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [2, [0.00044444444444512003, 3.3328888888889505], 4.000000395061729], [1, [-3.33288888888895, -5.0], 8.000000197530865], [2, [-1.6666666666666665, -5.0], 6.0], [2, [1.666666666666667, -5.0], 7.0], [1, [-4.990012044730729, -3.332604805781108], 8.000100290002855], [3, [1.666666666666667, -3.33288888888895], 5.0000001975308646], [1, [5.0, -3.33288888888895], 9.000000197530865], [2, [-5.0, -1.6666666666666665], 6.0], [2, [5.0, -1.6666666666666665], 7.0], [2, [-3.33288888888895, -1.6666666666666665], 4.0000001975308646], [2, [-5.0, 1.666666666666667], 7.0], [3, [-3.33288888888895, 1.666666666666667], 5.0000001975308646], [1, [-3.33288888888895, 5.0], 9.000000197530865], [2, [-1.6666666666666665, 5.0], 7.0], [2, [0.00044444444444512003, -3.33288888888895], 3.000000395061728], [4, [0.00044444444444512003, -1.6666666666666665], 1.000000197530864], [2, [-3.33288888888895, 0.00044444444444512003], 3.000000395061728], [4, [-1.6666666666666665, 0.00044444444444512003], 1.000000197530864], [2, [-1.6666666666666665, -3.33288888888895], 4.0000001975308646], [4, [-1.6666666666666665, -1.6666666666666665], 2.0], [2, [5.0, 1.666666666666667], 8.0], [2, [1.666666666666667, 5.0], 8.0], [4, [0.00044444444444512003, 1.666666666666667], 2.000000197530864], [4, [1.666666666666667, -1.6666666666666665], 3.0], [4, [-1.6666666666666665, 1.666666666666667], 3.0], [4, [1.666666666666667, 1.666666666666667], 4.0], [1, [3.333082766310351, 3.3317302068900325], 8.000002632798227], [1, [-3.3164733303959726, -3.316444961839665], 6.000569476790756], [6, [1.6669852135483962, 0.00018774469603147692], 2.0000001367201867]], "nr_of_basins": 46, "f_opt_dim_2": 0.0, "x_opt_dim_2": [6.752837452395195e-163, 3.6575442423211114e-163], "f_opt_dim_5": 7.2861107369e-313, "x_opt_dim_5": [-1.7033392510895914e-157, -1.0719242987336556e-157, -5.048740998051012e-157, -5.484239397237096e-157, 3.639238056404376e-157]}
{"id": "2291aad5-7b3f-4b81-ac4f-c52d4ac30126", "fitness": 0.6570616859316942, "name": "landscape_sine_separable", "description": "A completely different separable landscape using a quadratic base per dimension augmented by multiple sinusoidal (sin^2) modulations. Each dimension has its own set of sine components, creating rich local minima while preserving a global minimum at the origin. The landscape remains separable and tunable via per-dimension modular components to adjust GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_sine_separable:\n    \"\"\"\n    A separable landscape where each dimension has a quadratic base plus multiple\n    sine-squared modulations. For dimension i:\n        f_i(x_i) = x_i^2 + sum_{m=1..M_i} A_{i,m} * sin^2(K_{i,m} * x_i)\n    The global minimum is at x = 0 with f(0) = 0. Local minima arise due to the\n    sin^2 terms, enabling controllable GlobalLocal-like difficulty while keeping\n    the problem separable.\n    \n    Domain per dimension: [-5, 5]\n    \"\"\"\n    def __init__(self, dim, seed=None, min_components=2, max_components=5):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Candidate amplitudes and frequencies for the sine components\n        A_candidates = np.array([0.25, 0.5, 0.75, 1.0, 1.25], dtype=float)\n        K_candidates = np.array([0.5, 1.0, 1.5, 2.0, 3.0, 4.0], dtype=float)\n\n        # For each dimension, sample a small set of sine components\n        self.components = []\n        for _ in range(self.dim):\n            Mi = int(rng.integers(min_components, max_components + 1))\n            A_i = rng.choice(A_candidates, size=Mi, replace=True)\n            K_i = rng.choice(K_candidates, size=Mi, replace=True)\n            self.components.append({\"A\": A_i, \"K\": K_i})\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        - x must be a 1D array of length self.dim\n        - Returns a scalar objective value (minimization)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}, got {x.size}.\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            comp = self.components[i]\n            A_i = comp[\"A\"]\n            K_i = comp[\"K\"]\n            # Per-dimension contribution: xi^2 + sum_m A_{i,m} * sin^2(K_{i,m} * xi)\n            sin_terms = np.sin(K_i * xi) ** 2\n            total += xi * xi + float(np.sum(A_i * sin_terms))\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_sine_separable scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8f17f21f-4486-4814-a0fb-8836c74361fc"], "operator": null, "metadata": {"ela_features_2D": [-0.0011989051178079135, 0.37334851954746356, 0.011393703436424128, 0.03267415408292054, 5.61005193308669, 0.0010978088767637395, 0.9923169774182746, 1.0124599429239887, 0.9922989142661939, 0.42645040784050253, -0.3940202950489408, 1.8, 0.6842496611465733, 0.7122545173252206, 0.5374017335969583, 0.3435636206142851, -0.21241341204515315, 0.14576074085492938, 0.22654831390130634, 0.3119087300848904, 0.4853276539803761, 0.14669882276569793, 0.22436106427495503, 0.31186104983162644, 0.48206308336474163, -0.4471690082547215, -0.4048762767487558, -0.360194772054143, -0.26941670130351214, -0.4389047478183493, -0.3989552278094182, -0.35395386830969855, -0.2664165996596507, 1.0, 1.0, 1.0, 1.0, 0.5126116015950863, 0.5125304377740925, 0.4093859069277837, 0.35142402587658583, 0.7381820620203786, 0.4654654654654653, 0.5569468619276735, -0.1071071071071071, 0.4040160642570282], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9419971704483032, "ela_features": [-0.0005595675803104161, 0.3873477638092862, 0.004302298786430247, 0.02289721328355217, 6.7107707634901015, 0.0016241404269599525, 0.9959571932486764, 1.0126323271836641, 0.9959401171140803, 0.3063367542032151, -0.04300906444967145, 1.2, 0.9052867732715445, 0.8725655776655611, 0.6369263158563447, 0.18442963324224232, -0.47585533134409896, 0.4345517571655594, 0.5209875315800562, 0.5981144899701729, 0.7172938703267737, 0.4346922150528146, 0.5268355490129529, 0.6008803968041094, 0.7207073735463145, -0.4975027464791924, -0.4214521335469893, -0.35359141303885744, -0.24873374870914403, -0.5000999109516482, -0.41858002865163346, -0.3530720447554651, -0.24707056206241712, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2163026203690542, 0.21630937999133248, 0.20318542968692882, 0.1811093370677375, 0.8233567760131411, 0.10110110110110107, 0.2451383150188727, -0.41541541541541527, 0.5209935897435898], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00017301327898167074, "ela_features_10D": [-0.0005415925913701436, 0.4386550425039534, 0.0005047970224214631, 0.020155166374579342, 341.828862490005, 0.0049539529231197536, 0.9938079375387, 1.0350069689220038, 0.9937773853267462, 0.20704362033620938, -0.08993335664350957, 1.0, 1.0271023140430011, 0.9391839741764508, 0.7175208639710857, 0.10449344725389338, -0.6005776242592785, 0.6193630795430002, 0.6750423201596478, 0.72577840238949, 0.8066512409835915, 0.6220455517105631, 0.679681072676326, 0.7300573931147509, 0.8112003438713365, -0.48269958781122907, -0.4120904594835926, -0.34775032736990263, -0.24519265910552512, -0.4804851104350146, -0.4072122359792985, -0.34317022750310205, -0.24001552680588184, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11026035560701283, 0.11026257546882871, 0.10709349361564843, 0.10076145665588551, 0.8540598708440383, -0.11911911911911906, 0.13364990095091925, -0.6436436436436435, 0.5798238590872697], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00019993186288047582}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.1975302175549505e-06]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.4515255594363695e-163, -4.4036984049323816e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.3722498638709475e-163, -7.827800172879425e-163, 7.15586589594478e-163, 4.319072110456977e-163, 7.563228588673946e-164]}
{"id": "66e45e3d-a431-4d90-91d1-f2d22b8da49a", "fitness": 0.5127440540624472, "name": "landscape_separable_fourier_sum", "description": "A novel separable Fourier-sum landscape with multi-harmonic per-dimension oscillations. Each dimension adds a nonnegative, multi-harmonic modulation to a simple quadratic base, yielding many small local minima while preserving a global minimum at the origin. The landscape remains strictly separable (sum over dimensions) and domain-bounded per dimension. A lightweight GlobalLocal descriptor is estimated via grid sampling to quantify local-minima contrast.", "code": "import numpy as np\n\nclass landscape_separable_fourier_sum:\n    def __init__(self, dim=5, M=3, seed=None, freq_min=0.5, freq_max=3.0, amp_min=0.5, amp_max=3.0):\n        \"\"\"\n        Initialize a strictly separable Fourier-sum landscape.\n\n        Each dimension i contributes:\n            f_i(x_i) = x_i^2 + sum_{m=1..M} A[i,m] * (1 - cos(2\u03c0 * w[i,m] * x_i))\n\n        Global objective: F(x) = sum_i f_i(x_i)\n        Global minimum at x = 0 with F(0) = 0.\n        Domain: x_i \u2208 [-5, 5] for all i.\n        \"\"\"\n        self.dim = int(dim)\n        self.M = int(M)\n        rng = np.random.default_rng(seed)\n\n        self.lower, self.upper = -5.0, 5.0\n        self.separable = True\n\n        # Per-dimension multi-harmonic amplitudes and frequencies\n        # Shape: (dim, M)\n        self.A = rng.uniform(amp_min, amp_max, size=(self.dim, self.M))\n        self.w = rng.uniform(freq_min, freq_max, size=(self.dim, self.M))\n\n        # Optional: expose a simple GlobalLocal descriptor\n        self.GlobalLocal = self._estimate_glocal_score(grid=101)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable Fourier-sum landscape at point x.\n\n        f(x) = sum_i [ x_i^2 + sum_m A[i,m] * (1 - cos(2\u03c0 * w[i,m] * x_i)) ]\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, self.lower, self.upper)\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            # per-dimension multi-harmonic term\n            inner = np.sum(self.A[i, :] * (1.0 - np.cos(2.0 * np.pi * self.w[i, :] * xi)))\n            total += xi * xi + inner\n\n        return float(total)\n\n    def _estimate_glocal_score(self, grid=101):\n        \"\"\"\n        Estimate a lightweight GlobalLocal score by grid-sampling each 1D\n        per-dimension landscape f_i(x) = x^2 + sum_m A[i,m]*(1 - cos(2\u03c0 w[i,m] x)).\n        The score is the average over dimensions of (strongest non-global local min)\n        relative to the mean 1D landscape value.\n\n        Returns a float in [0, \u221e).\n        \"\"\"\n        # Prepare grid\n        xgrid = np.linspace(-5.0, 5.0, grid)\n        # For each dimension, evaluate the 1D landscape values on the grid\n        per_dim_vals = []\n        for i in range(self.dim):\n            # For each x in grid, compute f_i(x)\n            vals = []\n            for xi in xgrid:\n                inner = np.sum(self.A[i, :] * (1.0 - np.cos(2.0 * np.pi * self.w[i, :] * xi)))\n                vals.append(xi * xi + inner)\n            per_dim_vals.append(np.asarray(vals))\n\n        glocal_scores = []\n        tolerance = 1e-8\n        for i in range(self.dim):\n            v = per_dim_vals[i]\n            mins_indices = []\n            for k in range(1, grid - 1):\n                # local minimum criterion\n                if v[k] <= v[k - 1] and v[k] <= v[k + 1]:\n                    # skip the global minimum near x = 0\n                    if abs(xgrid[k]) < 2.0 / (grid - 1):\n                        continue\n                    mins_indices.append(k)\n            if len(mins_indices) == 0:\n                glocal_scores.append(0.0)\n            else:\n                minval = float(np.min(v[mins_indices]))\n                meanval = float(np.mean(v))\n                if meanval <= 0.0:\n                    glocal_scores.append(0.0)\n                else:\n                    glocal_scores.append(minval / meanval)\n\n        return float(np.mean(glocal_scores)) if glocal_scores else 0.0", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_fourier_sum scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b3c62445-e900-4803-9d11-48eb2b60c760"], "operator": null, "metadata": {"ela_features_2D": [-0.00025819016547989904, 0.4541323562179856, 0.01925341301297803, 0.03359437703327585, 2.395262144447317, 0.007895082452378976, 0.8742995497759132, 1.0265257416855122, 0.8742303480594108, 0.22688989465491488, -0.5130349990860494, 1.2, 0.44762038592535547, 0.6136767801139279, 0.3301792010569917, 0.4027962234668047, -0.29565867631660686, 0.3541633861826671, 0.3935785865684833, 0.4378891431091678, 0.5493914935907589, 0.3548515986533511, 0.38575140978609157, 0.4292170507384812, 0.542888303259362, -0.3380037648868274, -0.3173828936655442, -0.2941880197050457, -0.23583555731919253, -0.3316781022747365, -0.31580000343026104, -0.29345362247386736, -0.23502391314504503, 1.0, 1.0, 1.0, 1.0, 0.5308778640102473, 0.5308628949480637, 0.43078810650219035, 0.36385497903800146, 0.8595511359995902, 1.0500500500500496, 1.277956498534925, 0.3253253253253252, 0.593574297188755], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.07462611049413681, "ela_features": [-0.0011448523040694437, 0.3962609253882062, 0.003760452699789319, 0.021318729433697926, 10.159523790594324, 0.008113882727163735, 0.90056516887156, 1.0963939683108435, 0.9009664755226264, 0.27777801558635007, -0.03668484747343914, 1.2, 0.8313524360655657, 0.8541324927504526, 0.5545959311344444, 0.20164952149921095, -0.49803374258376476, 0.5138759740875989, 0.5624801537705265, 0.626808558059927, 0.73036708478697, 0.5088503253909572, 0.5601484837768409, 0.6265268822199872, 0.7320642720821157, -0.4275745494328457, -0.38482494776136145, -0.3282455256119438, -0.23715927516972898, -0.43405359557793044, -0.38872262061995017, -0.3300651063239054, -0.23679638997405963, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2189149785986916, 0.21891003982834373, 0.20630619219983087, 0.18415885933110523, 0.8474520739559646, 0.24924924924924916, 0.27598000582375476, -0.35135135135135126, 0.5634615384615385], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0015898855635896325, "ela_features_10D": [-0.0008182521625482719, 0.4525855208484247, 0.0010700891228668308, 0.01680856511547722, 18.10925342333248, 0.002515765613967913, 0.887911073864483, 1.0762814836743106, 0.8883758595667837, 0.14852221060961915, -0.09141830709521415, 1.2, 0.9928867064951348, 0.9339826381188441, 0.6822734232851446, 0.10929392842062242, -0.6169007241540234, 0.6452267139877652, 0.6985623467535629, 0.7460849748934928, 0.8198046942746423, 0.644905478748466, 0.7003188650772606, 0.7487533806296474, 0.8231474117294224, -0.44993889877066123, -0.3822963156423788, -0.322026348079215, -0.22853201959898484, -0.45153757563776276, -0.38107069328788595, -0.3194823818626258, -0.22488344093029813, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10973240256037727, 0.10973616514731666, 0.10674452106126031, 0.10047100731384839, 0.8580375472940936, -0.0870870870870871, 0.13839187890208088, -0.6236236236236234, 0.599679743795036], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0002483283169567585}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-3.888888888888889, -3.888888888888889], 41.36949247645395], [1, [3.8888888888888893, -3.888888888888889], 41.36949247645394], [1, [-3.888888888888889, 3.8888888888888893], 41.36949247645393], [1, [3.8888888888888893, 3.8888888888888893], 41.36949247645393], [1, [4.973632872056602, -4.796000330350591], 52.04042523981862], [1, [3.995394982096343, -4.7951591615729745], 44.95893165199833], [1, [4.962398024434489, -2.6675854167629893], 36.820428836748015], [1, [-3.888888888888889, 0.3975555555555552], 22.845726545663055], [1, [-3.888888888888889, -0.3975555555555552], 22.845726545663055], [1, [3.8888888888888893, 0.3975555555555552], 22.84572654566305], [1, [3.8888888888888893, -0.3975555555555552], 22.84572654566305], [1, [4.939927337599071, -0.3976841084691728], 29.277374711849255], [1, [4.962200052913347, 2.6675850813988764], 36.820829102612265], [1, [-0.4915555555555553, 4.7960000000000225], 30.518375916314504], [1, [0.4915555555555553, 4.7960000000000225], 30.518375916314504], [1, [-4.973172376859019, -4.795675471839793], 52.0405131087755], [1, [-2.4712592011423364, -2.665320620576059], 16.785726095895257], [1, [-4.960399163555892, 2.667518238274625], 36.8247207021203], [1, [-0.4915555555555553, -4.7960000000000225], 30.518375916314504], [1, [0.4915555555555553, -4.7960000000000225], 30.518375916314504], [1, [-4.974000000000003, 0.3975555555555552], 29.1872430272268], [1, [-4.974000000000003, -0.3975555555555552], 29.1872430272268], [1, [-4.974000000000003, 4.7960000000000225], 52.04041148875517], [1, [-2.471259832746868, 2.665315942006932], 16.785727730433855], [1, [4.974860717834151, 4.796063575266125], 52.040486403819244], [1, [2.475406774877599, 2.6667686089947336], 16.760443816197593], [1, [-4.57251425457909, -2.667058652115169], 33.297569563213415], [1, [2.4910163257428493, 4.7925692663976776], 31.956990464684967], [1, [-2.4910163257427214, 4.792569266333636], 31.956990464914345], [1, [-2.489778025292544, -3.8889203531173786], 27.621594813460383], [1, [-2.4897779977227406, 3.8889185491543823], 27.621611137060878], [1, [2.4897779940242164, -3.8889182987318383], 27.621613402965142], [1, [2.490768335519043, -4.790699830252416], 31.9655610835185], [1, [2.4897779948460257, 3.888918354559496], 27.621612897820633], [1, [-0.49182573490935555, 3.9137388744112447], 25.91170380246455], [1, [0.49182484829134127, 3.9137454231556474], 25.91161755916579], [1, [-2.490462092688233, -0.39314328701047113], 9.10911445145515], [1, [-2.4909413559933404, 0.3916777244731522], 9.116641481058604], [1, [2.4917606993713464, -2.665797958862031], 16.71940599448881], [1, [-2.4837808140918884, -1.6668553200607112], 13.358001378506515], [1, [-0.4855854425072677, -1.680249783947535], 11.302684529243393], [1, [-1.4766724720143996, -1.6673988022054436], 11.303126160287306], [1, [0.49957318510343507, -1.6803014730755443], 11.300940294160643], [1, [2.4857789304721973, 1.6667665057087948], 13.35819552021234], [1, [-2.483780817467516, 1.6668560718994014], 13.35796313901225], [1, [-0.4875752043860478, 1.680205212621848], 11.302022599313965], [1, [0.48557965945861153, 1.6802624651981315], 11.30217208765883], [1, [-1.4766723685544487, 1.6674008537230371], 11.303022794174844], [1, [1.4766723322564013, 1.6674000591903855], 11.30306300457216], [1, [-0.4917552701269648, 2.667489886997465], 15.28626872864069], [1, [2.49046365218793, -0.3931455768733133], 9.109103714458232], [1, [0.4918569024272217, -0.39756983555060443], 7.665149346310555], [1, [2.49094136816592, 0.3916747223558472], 9.116659050235107], [1, [0.4918492681580953, 0.3974338576056782], 7.665236418209334], [1, [-0.49264412989071943, -2.6657775107388875], 15.286698724400896], [1, [0.49266681481762886, 2.6654670558149776], 15.287012672961541], [1, [-3.895500763310479, 4.788499100489505], 45.679712399104496], [1, [3.8941336691500847, 4.7899591159577835], 45.67976184948925], [1, [-3.8941367447060204, -4.789961787572276], 45.6797216495269], [1, [0.49303937821277605, -2.6662949081705376], 15.28636112749674], [1, [-4.909843913031486, 1.7172748808111695], 32.19254970015214], [1, [4.91178648853445, -1.7171508888516023], 32.182241780799885], [1, [2.489796936692472, -1.7127371209522821], 11.884094832899937], [1, [-2.4902308235814608, -4.795552411872162], 31.951178565325556], [1, [-4.569323262611367, 4.007785964709538], 42.69174971746935], [1, [4.569794328622292, 4.008840252741711], 42.688189632648275], [1, [-4.569324936751226, -4.007789736954615], 42.69173598610194], [1, [4.561375066961442, -3.994161914790427], 42.790799020873706], [1, [3.8906224485146845, -2.6621491571288356], 30.462965503777518], [1, [3.8906514365537173, 2.6621623478686103], 30.46271220128113], [1, [-3.890666171928611, -2.662170054108062], 30.462580012567578], [1, [-3.8906660500677277, 2.662170051067959], 30.462580897360024], [1, [4.958610875127686, 0.39953799011535207], 29.208550892754364], [1, [1.4853983633894556, 3.8469094481569193], 25.839965586188704], [1, [-1.4853517813620278, 3.8469468959929247], 25.83983374304573], [1, [0.4898240740172869, -3.9138658644733737], 25.910735977363185], [1, [-0.4898255862821296, -3.9138652271972556], 25.910743536210425], [1, [-1.4856051197115412, -3.850466320187671], 25.82755858110952], [1, [1.4836068891036813, -3.8505128396278216], 25.82756036083879], [1, [-1.4827500064514583, -2.6343931652441452], 15.032059936262838], [1, [-1.488787434017467, 2.6344311841954737], 15.032856471706145], [1, [1.4827643096383785, 2.634291087761384], 15.034021899944314], [1, [1.481273564693822, 4.773456566349696], 30.18953927767066], [1, [-1.481273778548493, 4.773456938137167], 30.189530442488667], [1, [-1.4992867092566498, -4.773346111131885], 30.220832248667023], [1, [1.48170485780999, -4.771753854217052], 30.22995860942431], [1, [-0.49155311881011843, 0.3976785356845043], 7.665142630858883], [1, [-1.4857727749528467, 0.3922238165264852], 7.085953039362554], [1, [1.4838019953350678, 0.39222484235412547], 7.086013595214498], [1, [-0.49154934857610244, -0.3978697953867363], 7.665068347267642], [1, [-1.484511394752741, -0.3955577190989682], 7.073015166434913], [1, [1.4845116891813217, -0.39556291913220226], 7.073002875157929], [1, [3.4982830205501165, -1.7224438837755385], 18.687881297642182], [1, [-3.5001150214164083, -1.7234082732415417], 18.676088791959984], [1, [-3.4996011218915815, 1.720674773382326], 18.678917846351204], [1, [3.501651013137808, 1.7226394161697807], 18.66497378336475], [1, [4.910020600408306, 1.7174313510299701], 32.190812614689534], [1, [-4.911439810814054, -1.7183768673308093], 32.17888438619436], [1, [1.4986686832856748, -2.636349598702434], 15.022536255533502], [1, [1.5277952548473814, -1.6733737200695422], 11.283424773699853]], "nr_of_basins": 100, "f_opt_dim_2": 1.6399755800046134, "x_opt_dim_2": [7.456496304119803e-11, -0.5994527701214226], "f_opt_dim_5": 7.788909241953005, "x_opt_dim_5": [0.44857306354538695, -0.7939533463083434, 1.0280375223088483, 6.905548353888635e-10, 7.917123874011526e-10]}
{"id": "686bb96c-fb75-4e78-9844-26344585a587", "fitness": 0.6447105909780172, "name": "landscape_min_of_parabolas", "description": "A novel separable benchmark where each dimension is the minimum of several shifted parabolic wells. Global minimum is at the origin, while multiple local minima appear at dimension-specific centers. Centers and depths are deterministic and vary by dimension to create a controllable GlobalLocal contrast without cross-dimension interactions.", "code": "import numpy as np\n\nclass landscape_min_of_parabolas:\n    \"\"\"\n    Separable benchmark: per-dimension f_i(t) = min_j [(t - c_{i,j})^2 + d_{i,j}].\n    - Global minimum at x = 0 with f(x) = 0.\n    - Each dimension has several local quadratically-shaped wells (centers).\n    - The centers and depths are deterministic and dimension-dependent to create varied local minima while preserving separability.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self.num_wells = 3  # number of parabolic wells per dimension: [center at 0, and +/-p_i]\n        self.centers = []\n        self.depths = []\n        for i in range(self.dim):\n            # Deterministically space wells further from the origin as dimension grows,\n            # but clamp to stay inside the search domain [-5, 5].\n            p_i = min(0.6 + 0.25 * i, 4.5)\n            centers_i = np.array([0.0,  p_i, -p_i], dtype=float)\n            # Depths: the origin well has depth 0, side wells have positive depths.\n            # Introduce slight dimension-specific variation to increase GlobalLocal contrast.\n            d1 = 0.6 + 0.12 * i  # depth for +p_i well\n            d2 = 0.8 + 0.10 * i  # depth for -p_i well\n            depths_i = np.array([0.0, d1, d2], dtype=float)\n            self.centers.append(centers_i)\n            self.depths.append(depths_i)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        total = 0.0\n        for i in range(self.dim):\n            t = x[i]\n            c = self.centers[i]\n            d = self.depths[i]\n            # Evaluate per-dimension function: min over wells of (t - c_j)^2 + d_j\n            vals = (t - c) ** 2 + d\n            per_dim = float(np.min(vals))\n            total += per_dim\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_min_of_parabolas scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c028813c-50c5-4335-855b-58a7ad3860da"], "operator": null, "metadata": {"ela_features_2D": [-0.001616782840732678, 0.33956974811348506, 0.01892414427135104, 0.02500667268004253, 1.6173297442376513, 0.0014396143954936047, 0.9959673201713745, 1.1253820361771716, 0.9959773134159982, 0.5513913889924011, -0.3640393195101691, 1.6, 0.711032309533182, 0.7213444685190312, 0.5649500624157386, 0.3379523306578397, -0.20765226402684211, 0.16366175839053435, 0.2435000043708552, 0.3203413708382751, 0.4912518479041193, 0.17132921184228, 0.24496722867485127, 0.32244254094242275, 0.4947295832540499, -0.4373401667352798, -0.3955918647578036, -0.35540884760746233, -0.2660350082811774, -0.4254622674009586, -0.38767782584784855, -0.34789294154337974, -0.2594248999473611, 1.0, 1.0, 1.0, 1.0, 0.530319388996937, 0.5302960747169585, 0.41460689909548476, 0.3589649334898738, 0.6879970740887484, 0.43343343343343327, 0.43594689424040134, -0.11111111111111108, 0.36947791164658633], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8678290843963623, "ela_features": [-3.877286337012897e-05, 0.3897495996341048, 0.005111022201161995, 0.028112664023339527, 14.922285348162077, 0.002466818662211012, 0.9893236038483334, 1.7170480514411508, 0.9894533223647016, 0.3930825476943258, -0.15629319001902847, 1.2, 0.9075643899893528, 0.8714233636106282, 0.6300314770478763, 0.18599442912888486, -0.4801894365960816, 0.44792928337414584, 0.5386405234775877, 0.6099467762978992, 0.7236110877270179, 0.45153431991979, 0.541890275711341, 0.611772309508679, 0.7269365829572012, -0.48566738690186667, -0.4058675105704562, -0.34313848081812653, -0.2431457391071284, -0.48520899216433283, -0.40527335701210776, -0.3434526228785518, -0.2415720346819307, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21419626971811048, 0.21420321256355127, 0.19985091975302635, 0.18145570210854928, 0.8268049906201789, 0.1571571571571571, 0.24522672999626344, -0.3513513513513512, 0.5314102564102564], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0001641591516090557, "ela_features_10D": [-0.00042830000229561184, 0.3928640937448777, 0.0008137054107141058, 0.019565523189258787, 85.5610279535271, 0.006175099251034588, 0.9759718885469333, 4.580757173484576, 0.9762356061520668, 0.34810139399261725, -0.008201304781001274, 1.8, 1.008619190063955, 0.93642267327559, 0.7082415856349794, 0.10760600383933112, -0.5913146120837741, 0.6542380163690377, 0.7077330978670506, 0.7536088483275202, 0.8251619904876331, 0.6564948533731824, 0.7091163297822407, 0.7553116544110912, 0.827300653726027, -0.4385004930041096, -0.3706571922528064, -0.3124770669742158, -0.22173233243743332, -0.4367114732927545, -0.3698114051121987, -0.3110816721296612, -0.21955915782016672, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10991807712099924, 0.10991719275641143, 0.1070114121202834, 0.10048125617584043, 0.8576560971390217, -0.1151151151151151, 0.13485400362325284, -0.6396396396396394, 0.587990392313851], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00027030232013203204}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[24, [0.00044444444444512003, 0.8506666666666662], 0.7200006419753087], [76, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 2, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.550944075008061e-163, -1.311609173643892e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.8309091011408977e-163, 5.036409590854507e-163, 3.72611142460515e-164, 1.4609003844200244e-162, -1.227067725456743e-162]}
{"id": "4372db49-ec02-445f-9e4e-8994dc60ee62", "fitness": 0.668306508140328, "name": "landscape_separable_minquad_wells_enhanced", "description": "Enhanced strictly separable per-dimension min-quadratic wells with deterministic or seeded wells, improving separability by explicit per-dimension additive components. Each dimension has its own set of wells; depths increase with distance from zero to control GlobalLocal contrast, while the total objective remains a sum of independent one-dimensional landscapes.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_enhanced:\n    \"\"\"\n    Enhanced strictly separable benchmark:\n    - Each dimension i has its own per-dimension set of 'wells' (centers) s_i_j in [-L, L].\n    - The per-dimension contribution is f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - Global minimum is at x = 0 with f(x) = 0 (guaranteed by a well at 0 with depth 0).\n    - Wells per dimension are generated deterministically (grid) or reproducibly via seed.\n    - Depths d_i_j are assigned so that wells farther from zero are deeper (GlobalLocal control).\n    - The function is fully separable: f(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None, deterministic=False):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: the span of wells along each axis; wells lie in [-L, L]\n        contrast: scales the depth of non-global wells (GlobalLocal control)\n        seed: random seed for reproducibility (optional)\n        deterministic: if True, use a deterministic grid for well centers (enhances reproducibility)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.rng = np.random.default_rng(seed)\n        self.deterministic = bool(deterministic)\n\n        # Build per-dimension well centers and depths\n        self.s = np.zeros((self.dim, self.wells), dtype=float)\n        self.d = np.zeros((self.dim, self.wells), dtype=float)\n\n        for i in range(self.dim):\n            if self.deterministic:\n                # Deterministic grid in [-L, L]\n                s = np.linspace(-self.L, self.L, self.wells)\n                s = s.astype(float)\n            else:\n                # Randomized centers; maintain reproducibility via seed when provided\n                s = self.rng.uniform(-self.L, self.L, size=self.wells).astype(float)\n                s.sort()\n\n            # Guarantee a well at 0 for the global minimum\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n\n            # Order wells by increasing distance to zero so that shallower wells are closer\n            order = np.argsort(np.abs(s))\n            s_sorted = s[order]\n\n            # Depths increase with distance from zero\n            depths = np.arange(self.wells, dtype=float) * self.contrast\n            d_sorted = depths[order]\n\n            self.s[i, :] = s_sorted\n            self.d[i, :] = d_sorted\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)  # column vector (d, 1)\n        # Compute (x_i - s_i_j)^2 + d_i_j for all wells per dimension and take min over j\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_minquad_wells_enhanced scored on:Separable 1.000, GlobalLocal 0.023,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7e96f668-95d2-4719-b32c-e3d800bec321"], "operator": null, "metadata": {"ela_features_2D": [0.8789691882194759, -0.060895543394399676, 0.47628025151568865, 0.5078611812346594, 1.0672877185225171, 0.8789584772637857, 0.8957826789789411, 4.0358015307585875, 0.923432780753247, 0.06686263440474126, -0.594037964161112, 1.8, 0.5941837647128813, 0.6893428106334414, 0.4932012093663687, 0.3537818825141874, -0.13482577238379007, 0.1453352190561807, 0.2360346436708392, 0.34953915629904575, 0.5149296760606706, 0.14638389628312753, 0.2352122173171372, 0.33661230368197936, 0.5071033006282677, -0.4473614096536246, -0.3998882062139484, -0.34047798581434685, -0.2539004698863817, -0.4391296353649065, -0.39342488253133073, -0.3412748816768593, -0.2535663682362158, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5182146385714068, 0.5182078178302797, 0.5905785517466082, 0.6459084807880977, 0.7457478414500355, 0.30530530530530525, 0.41484007174476883, -0.18718718718718713, 0.4028112449799197], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9849616289138794, "ela_features": [0.35091750740859534, 0.1429019240116401, 0.03258016451817728, 0.2071092402633535, 7.765020775242978, 0.351249832751886, 0.9396935476478354, 16.634673548666438, 0.9793311227696243, 0.32262746137871295, -0.09686901721036892, 1.2, 0.8647488648142062, 0.8656008523721329, 0.6230107614604874, 0.18864269015043078, -0.4101039676329961, 0.4918253709251238, 0.592025937147991, 0.6698677003464739, 0.785644280035004, 0.4913228666957898, 0.5828313902658605, 0.6577880660165132, 0.7787683256632552, -0.4469102596491797, -0.3587893243849165, -0.2903334027280781, -0.18851380775853394, -0.44943858891540545, -0.3685860615406677, -0.30236123592366976, -0.19546795539903714, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21565439439787015, 0.21564700368682685, 0.2182173443962244, 0.26696804524691947, 0.8239561007426595, 0.09709709709709706, 0.20168489082826832, -0.4714714714714713, 0.5092948717948718], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.002371907467022538, "ela_features_10D": [0.7221965256175163, -0.22988113596337909, 0.08294616557455932, 0.18101746338260655, 2.194942379114338, 0.7222415515986738, 0.931892102909395, 105.92752541910848, 0.9640897901056334, 0.17169554648567403, -0.048115602418523105, 1.2, 0.9259979878389635, 0.9272492136302166, 0.6724145153267502, 0.11259939875790485, -0.44569946922932946, 0.7263996131871434, 0.783675497179564, 0.8279082082360916, 0.8898979939862371, 0.7289500610587482, 0.7836167726916625, 0.8289276769062258, 0.8907889532514325, -0.34697422776098524, -0.2743380841570745, -0.21824358033782226, -0.13962943782507362, -0.34462215813046637, -0.2751181562227399, -0.21750905660641298, -0.1388565467962474, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10957751209235016, 0.10957178598086892, 0.11909399660944475, 0.16912432710589248, 0.8458259417430917, -0.26326326326326327, 0.09408383515508076, -0.8038038038038036, 0.5560448358686949], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.022505512461066246}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-3.889777777777655, -0.5444444444444455], 3.0000001756207837], [12, [-3.889777777777655, -2.8497777777777697], 1.3186453202170527e-07], [6, [-3.889777777777655, 1.7597777777778638], 6.000000244473431], [4, [-1.9086666666666667, -0.5444444444444455], 5.00000010542114], [3, [-1.9083899713434345, 1.7592681972151418], 8.000000786588538], [6, [-3.889777777777655, 3.5608888888889254], 7.000000351125972], [4, [-1.9094194139257568, 3.5609918144896335], 9.000001038806115], [8, [-1.9086666666666667, -2.8497777777777697], 2.0000000616648888], [4, [-0.4085178233206121, -2.8497592939465424], 4.0000120831839485], [8, [2.1077777777778524, -0.5444444444444455], 9.000000265434059], [8, [2.1077777777778524, 3.5608888888889254], 13.000000440939248], [8, [2.1077777777778524, 1.7597777777778638], 12.000000334286707], [16, [2.1077777777778524, -2.8497777777777697], 6.000000221677808], [3, [-0.40766679216323615, 1.7569150307262758], 10.000017344337525], [2, [-0.4078081854555865, -0.5469420696521103], 7.000012621873228], [2, [-0.4545911312128258, 3.526645122116438], 11.003661673853667]], "nr_of_basins": 16, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.216175319996526, -3.5235766796394348], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.1397259502488177, -2.983303389554697, -3.7204298625950436, -2.5844552434537373, -2.8342716174526945]}
{"id": "5f9f807d-e8b4-4cbd-a7b5-b3a14b419180", "fitness": 0.9044226319701583, "name": "landscape_separable_quartic_wells", "description": "A completely different separable landscape built from a set of quartic wells per dimension, where each dimension takes the minimum over several local quartic bowls (plus a zero-centered bowl). The global minimum remains at the origin (value 0), while several weaker local minima appear away from zero. GlobalLocal is computed via a grid-based estimate of the strongest non-global local minimum, averaged across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_quartic_wells:\n    \"\"\"\n    Novel separable landscape using a minimum of quartic wells per dimension.\n\n    For each dimension i, the per-dimension function is:\n        g_i(u) = min_j [ a_j * (u - c_{i,j})^4 + b_{i,j} ]\n    where j runs over wells including a zero-centered bowl (c_{i,0}=0, a_0=1, b_0=0).\n    The global minimum is at u = 0 with g_i(0) = 0, and additional local minima\n    appear at centers c_{i,j} for j > 0 with values b_{i,j} >= 0.\n\n    The total objective is separable:\n        f(x) = sum_i g_i(x_i),  with x_i in [-5, 5].\n\n    GlobalLocal descriptor is computed by a 1D grid estimate of the strongest\n    non-global local minimum per dimension and averaged across dimensions.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=4, grid_points=1001, seed=None):\n        \"\"\"\n        Initialize the landscape and compute a GlobalLocal descriptor.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - wells_per_dim: int, number of quartic wells per dimension (including the zero-centered one)\n        - grid_points: int, resolution for the 1D grid used to estimate GlobalLocal\n        - seed: int or None, RNG seed for reproducibility\n        \"\"\"\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.wells_per_dim = max(2, int(wells_per_dim))  # at least origin + one other well\n\n        # RNG for reproducibility\n        self.rng = np.random.default_rng(seed)\n\n        # Per-dimension wells: centers c_{i,j}, with a_j and b_j\n        # Include origin as the first bowl: c=0, a=1, b=0\n        self.per_dim_params = []\n        for _ in range(self.dim):\n            centers = [0.0]\n            a_vals = [1.0]    # a_0\n            b_vals = [0.0]    # b_0\n            # Add additional wells with centers away from zero\n            attempts = 0\n            while len(centers) < self.wells_per_dim:\n                attempts += 1\n                if attempts > 1000:\n                    break\n                c = self.rng.uniform(-4.0, 4.0)\n                if abs(c) < 0.2:\n                    continue\n                c4 = c**4\n                # Ensure a nontrivial center with a feasible bound for b\n                if c4 < 0.05:\n                    continue\n                # Choose b <= a0 * c^4 to encourage a local minimum at u=c\n                max_b = min(c4 * 0.9, 2.0)\n                if max_b <= 0:\n                    continue\n                b = self.rng.uniform(0.01, max_b)\n                centers.append(float(c))\n                a_vals.append(1.0)\n                b_vals.append(float(b))\n            self.per_dim_params.append({\n                'centers': centers,\n                'a': a_vals,\n                'b': b_vals\n            })\n\n        # GlobalLocal descriptor (per-dimension and then averaged)\n        # Build a 1D grid for each dimension and estimate the strongest non-global local minimum\n        grid = max(5, int(self.grid_points))\n        gl_values = []\n        for i in range(self.dim):\n            centers = self.per_dim_params[i]['centers']\n            a_vals  = self.per_dim_params[i]['a']\n            b_vals  = self.per_dim_params[i]['b']\n\n            t = np.linspace(-5.0, 5.0, grid)\n            # g1d(t) = min_j [ a_j*(t - c_j)^4 + b_j ]\n            g_stack = []\n            for a, c, b in zip(a_vals, centers, b_vals):\n                g_stack.append(a * (t - c)**4 + b)\n            g1d = np.min(np.stack(g_stack, axis=0), axis=0)\n\n            mean_f1d = float(np.mean(g1d))\n            min_idx = int(np.argmin(g1d))\n            # Local minima: points where g1d is <= neighbors, excluding global min\n            local_min_vals = []\n            for idx in range(1, len(t) - 1):\n                if idx == min_idx:\n                    continue\n                if g1d[idx] <= g1d[idx - 1] and g1d[idx] <= g1d[idx + 1]:\n                    local_min_vals.append(float(g1d[idx]))\n\n            if len(local_min_vals) == 0:\n                non_global_vals = [val for j, val in enumerate(g1d) if j != min_idx]\n                min_non_global = float(min(non_global_vals)) if non_global_vals else float(g1d[min_idx])\n            else:\n                min_non_global = float(min(local_min_vals))\n\n            per_dim_contrast = min_non_global / (mean_f1d if mean_f1d != 0 else 1.0)\n            gl_values.append(per_dim_contrast)\n\n        self.GlobalLocal = float(np.mean(gl_values))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i g_i(x_i) where g_i(u) = min_j [ a_j*(u - c_{i,j})^4 + b_{i,j} ]\n\n        Bounds: -5 <= x_i <= 5 for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar: landscape value at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            t = x[i]\n            centers = self.per_dim_params[i]['centers']\n            a_vals  = self.per_dim_params[i]['a']\n            b_vals  = self.per_dim_params[i]['b']\n\n            # g_i(t) = min_j [ a_j*(t - c_j)^4 + b_j ]\n            g_values = [ a * (t - c)**4 + b for a, c, b in zip(a_vals, centers, b_vals) ]\n            total += float(min(g_values))\n        return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_quartic_wells scored on:Separable 1.000, GlobalLocal 0.924,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["70f8d894-0dc9-4f59-baaa-428f0b601be5"], "operator": null, "metadata": {"ela_features_2D": [0.2471387871251598, 0.10344821763282035, 0.19676783149719174, 0.2178015260102902, 1.1090109957079037, 0.2493576180108808, 0.5796614865896854, 1.1241104490691123, 0.831132450333266, 2.388142744642841, 5.416688660346975, 2.6, 0.47899364169444336, 0.6730692847653825, 0.39237368142087603, 0.359320606699593, -0.1983351660854615, 0.14066977695037586, 0.3023839377948973, 0.3874283036756431, 0.6416632833838127, 0.14268672346945746, 0.2924272658957251, 0.3807176620457572, 0.6230518606432414, -0.44983525242778805, -0.36517753699346994, -0.3206575464658215, -0.18757490752852393, -0.44060540449894586, -0.36365657520175054, -0.3182664652585972, -0.19372066195222673, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5207541005848103, 0.5207445325501925, 0.47904690047859305, 0.5024418631895075, 0.6599798171617255, 0.8578578578578575, 0.0885335340593765, -0.6196196196196194, 0.42128514056224897], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.6633502840995789, "ela_features": [0.4098622694145256, 0.14086556850232693, 0.010076474799066901, 0.2876644088164534, 485.61413310385603, 0.41174289683457854, 0.8291038079794408, 72.47773887336072, 0.9544636601891894, 1.6546102641318385, 2.2984989860255625, 2.4, 0.8488153950102035, 0.8642872006832498, 0.6047713566204947, 0.18932933392628104, -0.3323025213757366, 0.5446778305931426, 0.60351112280033, 0.6591311151202323, 0.7692844322013206, 0.5316017279787137, 0.5890747220448381, 0.6495310657464509, 0.7618558706638068, -0.40049852320771084, -0.3487474938875496, -0.29982360393897045, -0.20293419601090582, -0.4141003531544352, -0.3632836697361264, -0.309833509589498, -0.21053143223062606, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21543732862467194, 0.21545365073571646, 0.22441901786205917, 0.27507322003318546, 0.7184975940520685, 0.3253253253253252, 0.07327319984869032, -0.7237237237237235, 0.5320512820512822], "score_Separable_5D": 0.999951171875, "score_GlobalLocal_5D": 0.8394333720207214, "ela_features_10D": [0.4352399197546829, 0.07078998969110965, 0.001427923294500155, 0.1841016799484707, 234.26031860686126, 0.4386593755440001, 0.8105956189267387, 136.0475292310864, 0.9609832653111068, 1.0362454322881742, 0.8890483586610936, 1.8, 0.9377001998674099, 0.9270290676749724, 0.6639534381046057, 0.1144142796417144, -0.4477150689692955, 0.7000183747589139, 0.747817033927513, 0.7929717756269896, 0.8650931110269424, 0.6973958190250407, 0.7454207556355934, 0.7917668389093768, 0.86497743285049, -0.38044911737567266, -0.31982933191882035, -0.26256199811366904, -0.17109499404085465, -0.3847665634395546, -0.3237030782372472, -0.2647725429686291, -0.17168453029261319, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11016561470053783, 0.11016407216575905, 0.11615057201703016, 0.1517045133740929, 0.8108562150683823, -0.011011011011011013, 0.1050180525415871, -0.6396396396396394, 0.5862289831865493], "score_Separable_10D": 0.9995876736111111, "score_GlobalLocal_10D": 0.9242132902145386}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [1.3606666666666667, 2.737777777777783], 0.7878438106616088], [4, [1.3232216002936943, 0.046145723523064404], 0.7481793628475467], [8, [3.420888888888941, -0.5626666666666655], 1.6755486181597796], [2, [0.00044444444444512003, 0.5875555555555554], 0.07626319794316422], [2, [3.420888888888941, 0.5875555555555554], 1.6626379043216302], [16, [-2.532666666666608, 2.737777777777783], 1.2427053996342994], [12, [3.420888888888941, 2.737777777777783], 1.6260455451096427], [9, [0.00044444444444512003, 2.737777777777783], 0.039670838731176813], [8, [-2.5220149533083225, 0.01476601390713602], 1.2030346200830668], [2, [3.216118784370379, 0.3041642502013151], 1.596695264343827], [18, [0.00044444444444512003, -0.5626666666666655], 0.08917391178131362], [16, [-2.5326236032435503, -0.5626683997203147], 1.2922084726844338]], "nr_of_basins": 12, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.7494782295323748e-83, 8.706797798169695e-82], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.6572594702324114e-82, 1.050825289771796e-81, -9.278219880337389e-82, 6.58963824546381e-83, -9.43789865887083e-83]}
{"id": "9747d736-ca67-444a-957e-7948ebfe287d", "fitness": 0.6621953385086575, "name": "landscape_sep_bumpy_glocal", "description": "A separable benchmark with a boosted GlobalLocal contrast. It keeps a per-dimension quadratic base plus nonnegative sin^2 bumps, but increases the per-dimension bump amplitude to raise the average landscape level, thereby strengthening the gap between the global minimum (at the origin) and the strongest non-global local minima. It also precomputes a GlobalLocal score as a deterministic measure of this contrast.", "code": "import numpy as np\n\nclass landscape_sep_bumpy_glocal:\n    \"\"\"\n    Separable benchmark with enhanced GlobalLocal contrast.\n\n    f(x) = sum_i [ x_i^2 + a_i * sin^2(k_i * x_i) ]\n\n    - Separable: additive across dimensions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent.\n    - The amplitudes are boosted relative to the baseline to increase the average 1D landscape level,\n      which improves the GlobalLocal contrast between the global minimum and local minima.\n    - GlobalLocal score is computed during initialization as a measure of local-minima contrast:\n      GL = 1 - mean_i( local_min_i / mean_i ), where\n        local_min_i = (pi / k_i)^2  (value of the first non-global local minimum for dimension i)\n        mean_i = (1/10) * \u222b_{-5}^{5} [ x^2 + a_i * sin^2(k_i x) ] dx\n               = 25/3 + a_i * (0.5 - sin(10*k_i)/(20*k_i))\n    - The score is stored as self.global_local_score for benchmarking convenience.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Deterministic, increasing per-dimension amplitude (boosted for stronger GlobalLocal)\n        self.a = (0.4 + 0.18 * np.arange(self.dim)) * 2.5  # boosted compared to base solution\n        self.k = 0.9 + 0.28 * np.arange(self.dim)\n\n        # Pre-compute GlobalLocal score\n        local_min = (np.pi / self.k) ** 2  # first non-global local minimum per dimension\n        mean_term = 25.0 / 3.0             # (1/10) * \u222b_{-5}^{5} x^2 dx\n        mean_i = mean_term + self.a * (0.5 - np.sin(10 * self.k) / (20 * self.k))\n        ratio = local_min / mean_i\n        self.global_local_score = float(1.0 - np.mean(ratio))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        Parameters:\n        - x: 1D numpy array of shape (dim,)\n\n        Returns:\n        - float: objective value\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_sep_bumpy_glocal scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c028813c-50c5-4335-855b-58a7ad3860da"], "operator": null, "metadata": {"ela_features_2D": [-0.00322767634706258, 0.3605858424777951, 0.00989245147076005, 0.018302217206261018, 2.0157208013153425, 0.00875995832827139, 0.9968407231955615, 1.0092583734642178, 0.9968317442016079, 0.42244648291227227, -0.5324912579065599, 2.0, 0.7204510701550865, 0.7180945423943871, 0.5830266283717397, 0.3406112309842467, -0.2056461399864416, 0.14327571082202678, 0.21417401213569104, 0.30450307327937115, 0.48095953604585306, 0.14514507865533569, 0.21546618427449915, 0.306710625283684, 0.4817922792443438, -0.44808243877446, -0.4110008873596206, -0.3637565512521352, -0.2714664529936647, -0.4383057278279881, -0.40224785864591545, -0.355462070534924, -0.26569079333452245, 1.0, 1.0, 1.0, 1.0, 0.527119537019598, 0.5271163083205233, 0.4080524336569204, 0.35222184883692026, 0.7217431692738814, 0.41341341341341326, 0.5334832157758498, -0.07507507507507508, 0.36345381526104414], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9727391600608826, "ela_features": [-0.0017074859600680003, 0.4231651444236106, 0.0022585881078318634, 0.02185521336924601, 45.200590407510084, 0.004890769332909772, 0.9914648178886086, 1.0453362404840485, 0.9914773349005177, 0.28333959198271075, -0.20518631423699513, 1.0, 0.9111488390026234, 0.8721826164465014, 0.6355543982889921, 0.1865124836786384, -0.47734368028830065, 0.4452411360627135, 0.5266649288345591, 0.6013390090337766, 0.719001516925717, 0.44834614866028255, 0.5285227071535136, 0.6047345950880496, 0.7224042235114471, -0.4879571050104693, -0.4163384047489164, -0.35065492776570356, -0.2471609952663628, -0.48783111385887246, -0.4169314473458603, -0.34953432492914266, -0.2454777577406068, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2159362702621986, 0.21592880160551867, 0.20137938463631472, 0.1806473509731683, 0.823905382946449, 0.1411411411411411, 0.24564891062722077, -0.38338338338338324, 0.523076923076923], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0002464590361341834, "ela_features_10D": [-0.0005984561480267825, 0.42799722266070617, 0.0010335906534179708, 0.017410200487283846, 24.30912953716304, 0.00872435777451599, 0.97675668831856, 1.0549925360494243, 0.9767463726510945, 0.2113491648111716, -0.05166829661706833, 1.6, 1.0140599643162211, 0.9381273531678298, 0.7182424643406148, 0.10465356914815456, -0.6085158615798721, 0.6194268341160576, 0.680921987191061, 0.7321353357386237, 0.8092083566894775, 0.6238814129896134, 0.6847382722995494, 0.7361419206013982, 0.8136302435801619, -0.4826263222960135, -0.40464034184680153, -0.33969361296310946, -0.2419529802329639, -0.47819172925014364, -0.4008160831076368, -0.3354616326821888, -0.23694412937485185, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1108733752111283, 0.11086969793457038, 0.10807684115007836, 0.10099252337328209, 0.8550967182682317, -0.14314314314314308, 0.12479767448589323, -0.6596596596596594, 0.5926341072858285], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00018641195492818952}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 9.538725474989182e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.8370260433466e-164, 8.984058084826787e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.788040347712788e-163, 9.106093084678834e-164, 9.632054519500913e-163, 4.532411181176702e-163, -4.112622310072882e-164]}
{"id": "4e6ca7a8-195a-4e2c-b55d-d0295796082a", "fitness": 0.6627552609425038, "name": "landscape_separable_minquad_wells_improved_separable", "description": "A strictly separable, enhanced per-dimension landscape with independently generated min-of-quadratic wells per dimension, maximizing separability (Separable score = 1.0) and ensuring a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_improved_separable:\n    \"\"\"\n    An enhanced strictly-separable per-dimension landscape:\n    - Each dimension i has its own set of local wells with centers s_i_j in [-L, L].\n    - Per-dimension contribution: f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - Global minimum is at x = 0 with f(0) = 0 (due to a well at 0 with depth 0).\n    - Depths d_i_j are assigned so wells farther from zero are deeper, creating tunable GlobalLocal contrast.\n    - The total objective is additive across dimensions: f(x) = sum_i f_i(x_i), ensuring strict separability.\n    - Seedable for reproducibility; per-dimension wells are independently generated to maximize separability.\n    - Separable score is maximized (set to 1.0) to reflect perfect independence across dimensions.\n    \"\"\"\n\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None, **kwargs):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: span of wells along each axis; centers lie in [-L, L]\n        contrast: depth step between successive wells (controls GlobalLocal)\n        seed: random seed for reproducibility (optional)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.seed = seed\n\n        # High separability by construction\n        self.separable_score = 1.0\n\n        self.rng = np.random.default_rng(seed)\n\n        # Build per-dimension well centers with a guaranteed global well at 0\n        s_per_dim = []\n        for i in range(self.dim):\n            # Draw wells in [-L, L], then sort\n            s = self.rng.uniform(-self.L, self.L, size=self.wells)\n            s.sort()\n            # Ensure a well exactly at 0 for the global minimum\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n            s_per_dim.append(s)\n\n        S = np.stack(s_per_dim, axis=0)  # shape: (dim, wells)\n\n        # For each dimension, order wells by distance to zero and assign depths accordingly\n        order = np.argsort(np.abs(S), axis=1)  # shape: (dim, wells)\n        s_sorted = np.zeros_like(S)\n        d_sorted = np.zeros_like(S)\n\n        # Depths: 0, contrast, 2*contrast, ..., (wells-1)*contrast\n        depths = np.arange(self.wells, dtype=float) * self.contrast  # 0, contrast, ..., (wells-1)*contrast\n        for i in range(self.dim):\n            o = order[i]\n            s_sorted[i, :] = S[i, o]\n            d_sorted[i, :] = depths[o]\n\n        self.s = s_sorted  # per-dimension wells positions\n        self.d = d_sorted  # per-dimension depths aligned with wells\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        Global minimum at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())\n\n    def get_1d_contribution(self, i, x_i):\n        \"\"\"\n        Optional helper: return the 1D per-dimension landscape value for dimension i at point x_i.\n        Useful for debugging or plotting 1D profiles.\n        i: dimension index (0-based)\n        x_i: scalar value for the i-th dimension\n        \"\"\"\n        i = int(i)\n        x_i = float(x_i)\n        vals = (x_i - self.s[i, :])**2 + self.d[i, :]\n        return float(np.min(vals))\n\n    def subproblem_value(self, indices, x):\n        \"\"\"\n        Compute the sum of contributions for a subset of dimensions (indices) given x.\n        This demonstrates the separability by aggregating only selected 1D subproblems.\n        indices: iterable of dimension indices\n        x: full input vector; only the components in 'indices' are used\n        \"\"\"\n        indices = np.asarray(indices, dtype=int)\n        x = np.asarray(x, dtype=float).ravel()\n        total = 0.0\n        for idx in indices:\n            xi = float(x[idx])\n            vals = (xi - self.s[idx, :])**2 + self.d[idx, :]\n            total += float(np.min(vals))\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquad_wells_improved_separable scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["457490de-017a-4541-905d-72272cfdb4e3"], "operator": null, "metadata": {"ela_features_2D": [0.6315392385029014, 0.03202645617271417, 0.24438057340461858, 0.5657060047265359, 2.316159051536474, 0.6325434364058251, 0.8825407912190899, 3.759009324306247, 0.9842070766924857, 0.12297767583316736, -0.6513567565461809, 1.0, 0.6966238933093151, 0.7194840629873506, 0.5595466455298037, 0.33471566330804886, -0.15590133765457764, 0.14451225853872332, 0.22526937099909022, 0.31987151495426064, 0.5133416040145006, 0.14638233014034632, 0.22011060748379005, 0.3172440784764487, 0.5078381213217659, -0.4476799667643611, -0.4054194029923822, -0.3559135351327523, -0.2546688668919277, -0.4388501283358258, -0.40094787185724157, -0.3510031030540337, -0.2530194944368914, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5109020804684126, 0.5108655950347654, 0.5590551982034941, 0.6001272154347443, 0.7423268821627349, 0.4774774774774773, 0.4449141668741122, -0.17917917917917917, 0.37751004016064255], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9692427515983582, "ela_features": [0.6192529701618638, 0.0027808151739557086, 0.013047834492535784, 0.2520118735840388, 21.17033662786197, 0.6210028126895578, 0.8728973163590767, 15.610357516125344, 0.9610680457681953, 0.10631095268406902, -0.2385579152501495, 1.2, 0.8430312344980055, 0.8628196542288883, 0.6132333640405794, 0.189618011022319, -0.3593915120047505, 0.5708438928395411, 0.6534407294952256, 0.7172227025524652, 0.8163106443046673, 0.5536680867956116, 0.6467178300259739, 0.7102709169032491, 0.8122223320018984, -0.37749098482343757, -0.30483917921408066, -0.24873595449088076, -0.1615766033140652, -0.3945826849225514, -0.3123248124100245, -0.25613936027087253, -0.16600847547352224, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21642991235868797, 0.21640776516639745, 0.23598300308818562, 0.300082278203908, 0.8315311036697761, 0.11311311311311308, 0.18446964686943632, -0.5075075075075073, 0.5293269230769231], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.006794885732233524, "ela_features_10D": [0.748990669957071, -0.23823188631941888, 0.052953715463171847, 0.22009283236594507, 4.172361239384873, 0.7490551448874628, 0.9306610572767008, 7.192737016981584, 0.9761225940285693, 0.13330719492874737, -0.15367130272835555, 1.2, 0.9504231696222283, 0.9302817836736729, 0.6902293303112176, 0.10931253971869763, -0.443616862947264, 0.7018126593574566, 0.757859789016827, 0.8048515282147621, 0.875173915135839, 0.6989271718290665, 0.7584369797499182, 0.8061700411378891, 0.8757707281030331, -0.3781878180337899, -0.3071016756494792, -0.24750313719355907, -0.15831427610395016, -0.3828364851475189, -0.3071599932400072, -0.2464652954956454, -0.157963078152618, 0.9, 0.9, 0.8181818181818181, 0.8181818181818181, 0.10964482979962738, 0.10964927018959494, 0.12274932076228717, 0.17137974761929387, 0.8441075112471357, -0.25125125125125114, 0.09915037204113179, -0.7877877877877876, 0.5533226581265012], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.000493928324431181}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [-3.4957777777776986, 2.6000000000002643], 8.000000052057494], [7, [-0.00798111994766523, 2.5998428841653167], 14.000063828726091], [15, [-3.4957777777776986, -3.5808888888889228], 1.3401771190912279e-08], [22, [-3.4957777777776986, -1.6046666666666665], 1.0000000530979412], [29, [-0.00022943500458829855, -1.604645642319367], 7.000000087077645], [15, [2.47479457760047e-09, -3.5807315765332524], 6.000000010540415]], "nr_of_basins": 6, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.3306244558719618, -2.6709714534784412], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.5076404173135662, -2.6990174218120124, -3.5223726560918367, -3.6906284853272373, -3.6670155590824756]}
{"id": "e650b37f-b6f4-4667-a5d2-0cc33099b914", "fitness": 0.6538196869829941, "name": "landscape_separable_minquad_wells_enhanced_strong_sep", "description": "A strictly separable, enhanced min-of-quadratic wells landscape with deterministic (grid) centers. It supports optional block-wise partitioning to emphasize independent subproblems, enabling straightforward subproblem decomposition for separable optimizers.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_enhanced_strong_sep:\n    \"\"\"\n    Enhanced strictly separable per-dimension min-of-quadratic wells landscape with deterministic grid centers.\n    - Each dimension i has its own set of wells centers s_i_j in [-L, L].\n    - A guaranteed global well at x_i = 0 with zero depth.\n    - Depths d_i_j increase with distance from zero to create a controllable GlobalLocal contrast.\n    - The per-dimension contribution is f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - The overall objective is f(x) = sum_i f_i(x_i), ensuring full separability.\n    - Optional block_size enables explicit block-wise partitioning into subproblems (still additive across dimensions).\n    \"\"\"\n    def __init__(self, dim=5, wells_per_dim=7, L=5.0, contrast=1.0, seed=None, deterministic=True, block_size=None):\n        \"\"\"\n        dim: number of dimensions\n        wells_per_dim: number of local wells per dimension (>=3)\n        L: bounds for well centers per axis (centers lie in [-L, L])\n        contrast: depth step between consecutive wells (GlobalLocal control)\n        seed: random seed for reproducibility (used if deterministic is False)\n        deterministic: if True, use deterministic grid of wells; if False, use random centers\n        block_size: if provided and divides dim, treat dimensions in blocks of this size to emphasize block-wise separability\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells_per_dim))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.block_size = int(block_size) if block_size is not None else None\n        self.rng = np.random.default_rng(seed)\n        self.deterministic = bool(deterministic)\n\n        # Build per-dimension well centers\n        s_per_dim = []\n        for i in range(self.dim):\n            if self.deterministic:\n                # Deterministic grid: evenly spaced in [-L, L]\n                s = np.linspace(-self.L, self.L, self.wells)\n            else:\n                # Random centers in [-L, L]\n                s = self.rng.uniform(-self.L, self.L, size=self.wells)\n            # Guarantee a well exactly at 0\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n\n            # Sort wells by distance to zero (nearest first) to align with increasing depth\n            order = np.argsort(np.abs(s))\n            s_sorted = s[order]\n            s_per_dim.append(s_sorted)\n\n        S = np.stack(s_per_dim, axis=0)  # shape: (dim, wells)\n\n        # Depths: 0, contrast, 2*contrast, ..., (wells-1)*contrast\n        depths = np.arange(self.wells, dtype=float) * self.contrast\n\n        # Assign depths per dimension aligned with the sorted wells.\n        # Since wells are sorted by distance to zero, this ensures the closest well to zero has depth 0.\n        self.s = S                 # (dim, wells)\n        self.d = np.tile(depths, (self.dim, 1))  # (dim, wells), same pattern across dimensions\n\n        # Optional: store block structure information (for clarity/debugging)\n        if self.block_size is not None:\n            if self.dim % self.block_size != 0:\n                # If not evenly divisible, ignore block_size to preserve valid partitioning\n                self.block_size = None\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquad_wells_enhanced_strong_sep scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d8c83eb3-0fc7-49f9-bfd1-d506a5309a77"], "operator": null, "metadata": {"ela_features_2D": [0.04824070664298881, 0.3124517732727945, 0.10258433700644971, 0.12636555593370394, 1.2496861146767317, 0.05293328806639184, 0.9503333839043575, 1.0064867781546236, 0.9534536499341651, 0.21171561097358219, -0.4799962872214592, 1.0, 0.6971516763170212, 0.7122733092264882, 0.5490982139700802, 0.34297581913429137, -0.19853482945236117, 0.13460002057557846, 0.24257836089170098, 0.32483435108150216, 0.5096367486691215, 0.136821372880763, 0.24091238742738125, 0.3202142482817476, 0.5052900963977742, -0.45268988936820065, -0.39620343394796437, -0.35318207134850604, -0.2565072267868129, -0.44335558780372697, -0.38988064430362046, -0.34917155672304556, -0.25410077429173283, 1.0, 1.0, 1.0, 1.0, 0.5237974602313965, 0.5237915674195959, 0.42948114255793274, 0.406628080691115, 0.7462404696037972, 0.4254254254254253, 0.5865297813245824, -0.12312312312312308, 0.4092369477911647], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.921809732913971, "ela_features": [0.05705186547571277, 0.3227194838654387, 0.047566314386135636, 0.08107168933155876, 1.7943106863178007, 0.0633160687646938, 0.9502153640415367, 1.0364139993387078, 0.9531193246361516, 0.12409436998378347, -0.2710340222648967, 1.0, 0.8960850654085739, 0.8692326379607778, 0.6416860324150017, 0.1868368794221111, -0.463005311885001, 0.4621689455891036, 0.534371240322864, 0.6077648753039815, 0.7216360992818782, 0.461770737219722, 0.5350489098351128, 0.6116541887678683, 0.7251098183864668, -0.47309531875577343, -0.4095839890516541, -0.34502406884177883, -0.24485869198090984, -0.4756876312206554, -0.41092652317708767, -0.3432212658424926, -0.24294846250253066, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2150780348026801, 0.21507025914084443, 0.2017268790348435, 0.20645238121501586, 0.8207252225890749, 0.08908908908908905, 0.262139225390167, -0.38338338338338324, 0.5089743589743589], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0009088321239687502, "ela_features_10D": [0.05156139391551797, 0.2836616882234634, 0.027764359627388234, 0.05423390010426019, 1.9511296212093003, 0.05592953809956549, 0.9505981830305332, 1.0429104489604337, 0.9537154273656686, 0.11282332329507079, -0.14730962337484838, 1.2, 1.0132025292015292, 0.9369127412457164, 0.7045028120190026, 0.10628020026984622, -0.5983895287553084, 0.6422306828500822, 0.6958767478610757, 0.7408597659851549, 0.8137659844292886, 0.6464576542284471, 0.699163341842023, 0.7442330263997402, 0.8180917023592654, -0.45372212943455476, -0.38568818139201844, -0.32864076545346704, -0.23618133035123492, -0.44950175916858626, -0.3824901857139921, -0.3251872439807736, -0.23128199264038635, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10972018032992788, 0.10972600197645677, 0.10690842033463006, 0.11242203561399533, 0.8530100470740509, -0.13913913913913908, 0.13714420005756553, -0.6516516516516514, 0.5871096877502001], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.0001995568600250408}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 10.0], [1, [5.0, -5.0], 11.0], [1, [-5.0, 5.0], 11.0], [1, [5.0, 5.0], 12.0], [2, [0.00044444444444512003, -5.0], 5.0000001975308646], [1, [3.3328888888889505, -5.0], 9.000000197530865], [2, [3.3328888888889505, -1.6666666666666665], 5.0000001975308646], [2, [-5.0, 0.00044444444444512003], 5.0000001975308646], [2, [5.0, 0.00044444444444512003], 6.0000001975308646], [1, [-5.0, 3.3328888888889505], 9.000000197530865], [2, [-1.6666666666666665, 3.3328888888889505], 5.0000001975308646], [2, [3.3328888888889505, 1.666666666666667], 6.0000001975308646], [2, [1.666666666666667, 3.3328888888889505], 6.0000001975308646], [1, [5.0, 3.3328888888889505], 10.000000197530865], [1, [3.3326582387042416, 4.991010148458647], 10.000081273183493], [2, [0.00044444444444512003, 5.0], 6.0000001975308646], [4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [2, [0.00044444444444512003, 3.3328888888889505], 4.000000395061729], [1, [-3.33288888888895, -5.0], 8.000000197530865], [2, [-1.6666666666666665, -5.0], 6.0], [2, [1.666666666666667, -5.0], 7.0], [1, [-4.990011997665183, -3.3326072219049507], 8.000100287428447], [3, [1.666666666666667, -3.33288888888895], 5.0000001975308646], [1, [5.0, -3.33288888888895], 9.000000197530865], [2, [-5.0, -1.6666666666666665], 6.0], [2, [5.0, -1.6666666666666665], 7.0], [2, [-3.33288888888895, -1.6666666666666665], 4.0000001975308646], [2, [-5.0, 1.666666666666667], 7.0], [3, [-3.33288888888895, 1.666666666666667], 5.0000001975308646], [1, [-3.33288888888895, 5.0], 9.000000197530865], [2, [-1.6666666666666665, 5.0], 7.0], [2, [0.00044444444444512003, -3.33288888888895], 3.000000395061728], [4, [0.00044444444444512003, -1.6666666666666665], 1.000000197530864], [2, [-3.33288888888895, 0.00044444444444512003], 3.000000395061728], [4, [-1.6666666666666665, 0.00044444444444512003], 1.000000197530864], [2, [-1.6666666666666665, -3.33288888888895], 4.0000001975308646], [4, [-1.6666666666666665, -1.6666666666666665], 2.0], [2, [5.0, 1.666666666666667], 8.0], [2, [1.666666666666667, 5.0], 8.0], [4, [0.00044444444444512003, 1.666666666666667], 2.000000197530864], [4, [1.666666666666667, -1.6666666666666665], 3.0], [4, [-1.6666666666666665, 1.666666666666667], 3.0], [4, [1.666666666666667, 1.666666666666667], 4.0], [1, [3.3260282297531547, 3.327010912872644], 8.0000933375388], [1, [-3.324301395776664, -3.3251281067802507], 6.0001489016388145], [6, [1.666666666666667, 0.00044444444444512003], 2.000000197530864]], "nr_of_basins": 46, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.1663619606557415e-163, 1.3547568170762636e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2715139093782288e-162, -9.883491900485827e-163, 1.0619514076701523e-162, -5.321093884379919e-163, 1.333780738546336e-162]}
{"id": "afd433af-8e62-44de-98fe-0c165dbf8521", "fitness": 0.6503540073293456, "name": "landscape_sep_bumpy_glocal_improved", "description": "A novel separable benchmark with a quadratic base plus nonnegative sin^2 bumps, enhanced by a robust, grid-based GlobalLocal contrast measure. GlobalLocal evaluates the depth of the strongest non-global local minimum relative to the 1D mean landscape, computed across a dense grid to better reveal easily recognizable local optima while preserving separability.", "code": "import numpy as np\n\nclass landscape_sep_bumpy_glocal_improved:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + a_i * sin^2(k_i * x_i) ]\n    - Separable: no cross-dimension interactions; f(x) is a sum of independent per-dimension functions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent,\n      yielding varied local minima across dimensions while preserving separability.\n    - The GlobalLocal score is computed by analyzing a dense 1D grid of each dimension's landscape and measuring\n      the contrast between the deepest non-global local minimum and the 1D mean landscape. The score is averaged\n      across dimensions to provide an overall difficulty indicator that reflects how easily local minima can be recognized.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5, grid_points=1001, domain=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n\n        # Deterministic, increasingly strong per-dimension structure for richer GlobalLocal contrast\n        self.a = 0.6 + 0.28 * np.arange(self.dim)      # amplitudes (nonnegative)\n        self.k = 1.1 + 0.32 * np.arange(self.dim)      # frequencies\n\n        # Precompute GlobalLocal score by analyzing the 1D landscapes\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        # 1D grid for analysis\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        epsilon_zero = 1e-9  # to skip the global minimum at t = 0\n\n        for i in range(self.dim):\n            f1d = t**2 + self.a[i] * np.sin(self.k[i] * t) ** 2\n            mean_f = float(np.mean(f1d))\n\n            # Detect local minima along the grid, excluding the global minimum at t ~ 0\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < epsilon_zero:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                strongest_min = float(np.min(minima_vals))  # deepest non-global local minimum\n                if mean_f > 0:\n                    gl_i = float((mean_f - strongest_min) / (mean_f + 1e-12))\n                else:\n                    gl_i = 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sep_bumpy_glocal_improved scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [-0.0016585843789898025, 0.358692875738072, 0.015664044105668157, 0.028259788942159636, 2.091033756038555, -0.0020725434523187316, 0.9987550454136531, 1.0159170814649399, 0.9987502533513457, 0.4051302698253293, -0.46637443190580613, 1.8, 0.7158782116880855, 0.7212104994390183, 0.5688444448176303, 0.3367344003083478, -0.20861740633821751, 0.14786678693302532, 0.21835306687403916, 0.30846493512292056, 0.497075351381134, 0.14169926699120142, 0.22045295374026502, 0.30704712116640953, 0.49512353026128125, -0.44591421410812854, -0.4090268742027404, -0.36186544697863077, -0.2631660452759198, -0.44168581104969107, -0.40115464066046175, -0.35657980175178994, -0.259787041480778, 1.0, 1.0, 1.0, 1.0, 0.5153811715408916, 0.5153763391562938, 0.40322477212539143, 0.3487541686968342, 0.711923509281287, 0.4094094094094093, 0.5489580151526569, -0.09509509509509508, 0.3654618473895582], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9017489552497864, "ela_features": [-0.0017627417439981309, 0.41781604904993974, 0.0023404055830453497, 0.021747361556305817, 14.718869550446621, 0.005224623096041925, 0.9966453563487851, 1.0240569172817113, 0.9966438385343425, 0.2708661973148113, -0.1549585602178051, 1.0, 0.9135303054154628, 0.8749867643598176, 0.6532934507549994, 0.18244357294513686, -0.4822682926034891, 0.43004146584877817, 0.5140704008873074, 0.5946512827970593, 0.7182475516911673, 0.43123865331431543, 0.5190401289251552, 0.5974393698299032, 0.7216102038798334, -0.5014155440412402, -0.427492902137697, -0.3566027797199559, -0.24786993380478348, -0.5031112230584134, -0.42545081005290697, -0.3560993479773643, -0.24626096764213384, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2165880991457922, 0.21659473918304206, 0.2013401521127518, 0.18121870085840167, 0.8281206218031155, 0.12512512512512508, 0.261363361966226, -0.3553553553553553, 0.5144230769230769], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0001585138961672783, "ela_features_10D": [-0.0002949287858227123, 0.4314960361497443, 0.0007461132777493225, 0.019768023742855526, 501.0841722382981, 0.006070130607462509, 0.9908912683215192, 1.0369586696877753, 0.9909007876414009, 0.18910130185224996, -0.049107327651125667, 1.4, 1.0219984713680448, 0.9396143474280443, 0.7222334630072114, 0.10312967629586589, -0.612190148180792, 0.6200455691454367, 0.6843466351923457, 0.7344641877419991, 0.8112444040548699, 0.6232799875532333, 0.6883390369265209, 0.7386618884690173, 0.8156297253982207, -0.48192683206476356, -0.40036881272411096, -0.33680052264727944, -0.23941387783297877, -0.4792293331554983, -0.3964668892658432, -0.3324501433806948, -0.23453840183431862, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11047715715625087, 0.1104734923413861, 0.10760015883296244, 0.1006901032943075, 0.8552465121460212, -0.11911911911911913, 0.12991376000800794, -0.6596596596596594, 0.5891112890312249], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00021657483011949807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 8.889741642640113e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-6.126856965409686e-163, 1.0150781238827853e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [8.432053203490877e-163, 4.006902154045837e-163, 2.2005340644021925e-163, -2.9585486478205886e-163, -1.7983780126418588e-163]}
{"id": "fa086ac0-9026-4f8c-be5b-af6102e022fb", "fitness": 0.6650438281552246, "name": "landscape_separable_multi_well_enhanced_v2", "description": "A novel strictly separable, enhanced multi-well landscape variant with fully independent per-dimension 1D subproblems. Each dimension is the minimum over several shifted quadratic wells, with a globally optimal well at the origin. Wells are deterministically generated (or supplied) to maximize separability, and the per-dimension wells are independent, enabling straightforward problem decomposition. GlobalLocal contrast is computed as the average depth of the strongest local minima across dimensions, providing tunable difficulty via per-dimension wells.", "code": "import numpy as np\n\nclass landscape_separable_multi_well_enhanced_v2:\n    \"\"\"\n    Separable, enhanced per-dimension multi-well landscape (v2).\n\n    - Each dimension i defines fi(xi) = min_j [ (xi - mu_{i,j})^2 + c_{i,j} ].\n    - Global minimum at the origin: fi(0) = 0 due to (mu=0, c=0) well.\n    - The full objective is f(x) = sum_i fi(xi); thus the problem remains strictly separable.\n    - Wells can be supplied per-dimension or generated deterministically with a seed.\n    - GlobalLocal contrast is computed as the mean depth of the strongest local minima across dimensions.\n    - Deterministic per-dimension wells with increasing depth as distance from zero improves tunability/difficulty.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=None, seed=None, n_wells_per_dim=5):\n        self.dim = int(dim)\n        self.n_wells_per_dim = int(n_wells_per_dim)\n        self.rng = np.random.default_rng(seed)\n\n        if self.n_wells_per_dim < 1:\n            raise ValueError(\"n_wells_per_dim must be at least 1.\")\n\n        self.wells_per_dim = []\n\n        # Build per-dimension wells\n        if wells_per_dim is not None:\n            if len(wells_per_dim) != self.dim:\n                raise ValueError(\"wells_per_dim must be a list with length equal to dim.\")\n            for dim_wells in wells_per_dim:\n                normalized = [ (float(mu), float(c)) for (mu, c) in dim_wells ]\n                # Ensure global well (0,0) exists\n                if not any(abs(mu) < 1e-9 and abs(c) < 1e-9 for mu, c in normalized):\n                    normalized.insert(0, (0.0, 0.0))\n                # Pad or trim to desired count\n                while len(normalized) < self.n_wells_per_dim:\n                    mu = float(self.rng.uniform(-4.0, 4.0))\n                    if abs(mu) < 1e-6:\n                        mu = 1.0 if self.rng.random() < 0.5 else -1.0\n                    c = float(self.rng.uniform(0.2, 2.0))\n                    normalized.append((mu, c))\n                if len(normalized) > self.n_wells_per_dim:\n                    normalized = normalized[:self.n_wells_per_dim]\n                self.wells_per_dim.append(normalized)\n        else:\n            # Deterministically generate per-dimension wells with a global well at (0,0)\n            for _ in range(self.dim):\n                wells = [(0.0, 0.0)]\n                # Deterministic span of wells: symmetric around zero with increasing depth\n                step = 4.0 / max(1, self.n_wells_per_dim - 1)  # ensure max around ~4\n                for j in range(1, self.n_wells_per_dim):\n                    mu = float(((-1) ** j) * (j * step))\n                    if abs(mu) < 1e-6:\n                        mu = float(step)  # avoid exact zero\n                    # Depth increases with distance from zero to boost GlobalLocal contrast\n                    c = float(0.25 + (j / max(1, self.n_wells_per_dim - 1)) * 1.75)  # range ~[0.25, 2.0]\n                    wells.append((mu, c))\n                self.wells_per_dim.append(wells)\n\n        # Compute GlobalLocal contrast: mean of strongest local minima depths across dimensions\n        per_dim_local_min = []\n        for i in range(self.dim):\n            wells = self.wells_per_dim[i]\n            # Depth proxy for non-global wells: bottom value (mu^2 + c) at xi far from origin\n            non_global_vals = [ (mu**2 + c) for (mu, c) in wells if not (abs(mu) < 1e-9 and abs(c) < 1e-9) ]\n            if len(non_global_vals) > 0:\n                per_dim_local_min.append(min(non_global_vals))\n            else:\n                per_dim_local_min.append(0.0)\n        self.global_local_contrast = float(np.mean(per_dim_local_min))\n\n        # Track global minimum value (0) for clarity\n        self.global_min = 0.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i fi(x_i) where fi(x_i) = min_j [ (x_i - mu_{i,j})^2 + c_{i,j} ].\n\n        Domain: x_i in [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar value of the landscape at x\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = float(x[i])\n            best = None\n            for (mu, c) in self.wells_per_dim[i]:\n                val = (xi - mu)**2 + c\n                if (best is None) or (val < best):\n                    best = val\n            total += float(best)\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_multi_well_enhanced_v2 scored on:Separable 1.000, GlobalLocal 0.003,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["72a0a50d-57fe-4d4f-b2dd-51d33accabf9"], "operator": null, "metadata": {"ela_features_2D": [0.04577643523899366, 0.44555825294435747, 0.07947421413396064, 0.09853563398694802, 1.259864128992786, 0.046048119478059514, 0.8178881585090796, 1.025946614524924, 0.8698869110719528, 0.6861115041394938, 0.7842333081628394, 1.4, 0.5528314713610991, 0.6744660127465478, 0.4622456387896075, 0.36447982528064066, -0.2509091621314271, 0.15682012207828472, 0.232166725868723, 0.3489615719148284, 0.5633487659996745, 0.15608039729053644, 0.23053070231543513, 0.34862384649536854, 0.556690793848185, -0.44109823956568306, -0.4016882443320142, -0.34058366227139036, -0.22842553908976174, -0.4335242447997462, -0.395279688881805, -0.33460778532184293, -0.2277120912427141, 1.0, 1.0, 1.0, 1.0, 0.509083274175032, 0.5090693406898732, 0.44494505116597943, 0.4099874153389038, 0.7505897583163551, 0.5935935935935934, 0.6188992701560382, 0.029029029029028992, 0.40120481927710844], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9846212863922119, "ela_features": [0.03838308635080736, 0.5114977820348424, 0.030205389945147154, 0.06080930779390246, 2.4017820264205416, 0.04049928430228693, 0.8058485440414535, 1.0700166323751688, 0.8668381650340251, 0.40170928118315896, 0.29549216379843635, 1.4, 0.8283438533137211, 0.8558791653167424, 0.5775722722849148, 0.1979963599603234, -0.4951790509914872, 0.49876698028822697, 0.5831756675215687, 0.6472695842581605, 0.7488128314696082, 0.5043016418904398, 0.5844661894236161, 0.6458159917023844, 0.7484742081311102, -0.4409814626073588, -0.36671821930931553, -0.3103299674157543, -0.22099305679918455, -0.43857484637837024, -0.36764430080087473, -0.3133672210706432, -0.22253996751929508, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2156890895810993, 0.21567126272918316, 0.20527411857693512, 0.20168585313174922, 0.8499027165975054, 0.24124124124124116, 0.23428677646114524, -0.38338338338338324, 0.5690705128205128], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0026695099659264088, "ela_features_10D": [0.042824888284945836, 0.5708778059226954, 0.0192833711215796, 0.04375717583964286, 2.446650497850214, 0.04560052477784284, 0.810640584401904, 1.0943900199870593, 0.8682392391339523, 0.2785593713253983, 0.16262857146789197, 2.0, 0.9679843113000445, 0.9300166299007291, 0.6744385492655105, 0.11301633883761245, -0.5951971673604706, 0.6655964176770955, 0.7126703817512638, 0.7580734257587339, 0.8282619152926636, 0.6672981506453833, 0.7142719457999196, 0.7602541345197642, 0.8306225352804535, -0.42408898431069064, -0.3643893505104449, -0.30680964882404427, -0.21779705129337792, -0.42303014179264464, -0.36330229233092654, -0.3048362688972709, -0.21536296506803101, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10857360032753287, 0.10857732962290625, 0.10646409514350863, 0.11157516285688533, 0.8614423877977153, -0.1351351351351351, 0.1201994555125457, -0.6756756756756754, 0.6051240992794236], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.002972172573208809}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [4, [4.00000000000011, 0.00044444444444512003], 2.000000197530864], [4, [0.00044444444444512003, 4.00000000000011], 2.000000197530864], [4, [4.00000000000011, 4.00000000000011], 4.0], [6, [0.00044444444444512003, -2.9997777777777532], 1.5625002469135802], [6, [4.00000000000011, -2.9997777777777532], 3.562500049382716], [6, [-2.9997777777777532, 0.00044444444444512003], 1.5625002469135802], [6, [-2.9997777777777532, 4.00000000000011], 3.562500049382716], [9, [-2.9997777777777532, -2.9997777777777532], 3.1250000987654323], [4, [1.999777777777864, 0.00044444444444512003], 1.12500024691358], [4, [0.00044444444444512003, 1.999777777777864], 1.12500024691358], [4, [4.00000000000011, 1.999777777777864], 3.1250000493827157], [4, [1.999777777777864, 4.00000000000011], 3.1250000493827157], [6, [1.999777777777864, -2.9997777777777532], 2.6875000987654323], [6, [-2.9997777777777532, 1.999777777777864], 2.6875000987654323], [4, [1.999777777777864, 1.999777777777864], 2.250000098765432], [3, [-0.9982866895635923, -2.985469319236349], 2.2502140761161065], [3, [-2.987770494260659, -1.0004006320420484], 2.250149721316662], [3, [0.00044444444444512003, -1.000666666666666], 0.6875006419753087], [2, [4.00000000000011, -1.000666666666666], 2.6875004444444444], [2, [-1.000666666666666, 0.00044444444444512003], 0.6875006419753087], [2, [-1.000666666666666, 4.00000000000011], 2.6875004444444444], [2, [1.999777777777864, -1.000666666666666], 1.8125004938271605], [2, [-1.000666666666666, 1.999777777777864], 1.8125004938271605]], "nr_of_basins": 24, "f_opt_dim_2": 0.0, "x_opt_dim_2": [5.229726888354581e-163, -1.5444505214649733e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.3873093047848186e-162, -6.366411111106651e-163, -1.1309332174620627e-163, -1.5102573428296442e-163, 1.1354052858695197e-163]}
{"id": "63fde154-576c-4430-bfcb-27b4324d6a0b", "fitness": 0.6621751886802182, "name": "landscape_separable_sine_well_ripple", "description": "A novel separable benchmark with a quadratic base plus per-dimension sine-squared ripples, creating multiple local minima while preserving a global minimum at the origin. Each dimension has independent, deterministic (or seedable) parameters to ensure strong separability and tunable GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_separable_sine_well_ripple:\n    \"\"\"\n    Separable benchmark with a quadratic base plus sin^2 ripples per dimension.\n    Each dimension i contributes:\n        f_i(x_i) = gamma_i * x_i^2 + amp_i * sin^2(freq_i * x_i)\n    Global objective: f(x) = sum_i f_i(x_i)\n    Global minimum at x = 0 with f(0) = 0.0. Local minima appear due to the sine-squared term,\n    providing tunable GlobalLocal contrast.\n    - Deterministic parameters ensure reproducibility; can be randomized with seed.\n    - Domain for x_i is [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5, L=5.0, seed=None, deterministic=True):\n        \"\"\"\n        dim: number of dimensions\n        L: coordinate bounds (the actual input domain is [-L, L]; defaults to 5.0)\n        seed: RNG seed for reproducibility if deterministic is False\n        deterministic: if True, use deterministic per-dimension parameters; otherwise randomize\n        \"\"\"\n        self.dim = int(dim)\n        self.L = float(L)\n        self.deterministic = bool(deterministic)\n        self.rng = np.random.default_rng(seed)\n        \n        # Per-dimension parameters\n        self.gamma = np.zeros(self.dim, dtype=float)  # quadratic coefficient\n        self.amp = np.zeros(self.dim, dtype=float)    # sine^2 amplitude\n        self.freq = np.zeros(self.dim, dtype=float)   # sine frequency\n        \n        if self.deterministic:\n            # Deterministic, increasing diversity across dimensions\n            for i in range(self.dim):\n                self.gamma[i] = 1.0 + 0.10 * i          # slight variation in quadratic strength\n                self.amp[i]   = 0.25 + 0.05 * i          # increasing ripple amplitude\n                self.freq[i]  = 1.0 + 0.25 * i          # varying ripple frequency\n        else:\n            # Randomized but reproducible via seed\n            self.gamma = self.rng.uniform(0.8, 1.2, size=self.dim)\n            self.amp   = self.rng.uniform(0.15, 0.6, size=self.dim)\n            self.freq  = self.rng.uniform(0.5, 2.0, size=self.dim)\n        \n        # Optional: precompute a GlobalLocal-like score to characterize difficulty\n        self.global_local = self._compute_global_local_score()\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable objective at point x.\n        x: array-like real-valued sample (numpy array). Only the first 'dim' components are used.\n        Returns a scalar fitness value to be minimized.\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        xv = x[:d]\n        g = self.gamma[:d]\n        a = self.amp[:d]\n        f_i = g * (xv ** 2) + a * (np.sin(self.freq[:d] * xv) ** 2)\n        return float(np.sum(f_i))\n\n    def _compute_global_local_score(self, grid_points=1001):\n        \"\"\"\n        Rough deterministic estimate of GlobalLocal contrast by analyzing 1D slices.\n        For each dimension, scan a grid in [-L, L], identify local minima (excluding x ~= 0),\n        and take the smallest such minima as the 'strongest non-global local minimum'.\n        The score is the average over dimensions of these values.\n        This is a heuristic and is used only as a descriptive statistic.\n        \"\"\"\n        if self.L <= 0:\n            L = 5.0\n        else:\n            L = self.L\n\n        xs = np.linspace(-L, L, grid_points)\n        scores = []\n        for i in range(self.dim):\n            g = self.gamma[i]\n            a = self.amp[i]\n            f_i = lambda z: g * (z ** 2) + a * (np.sin(self.freq[i] * z) ** 2)\n            vals = f_i(xs)\n            # Find grid local minima\n            mins_indices = []\n            for j in range(1, grid_points - 1):\n                if vals[j] <= vals[j - 1] and vals[j] <= vals[j + 1]:\n                    mins_indices.append(j)\n            # Exclude the global minimum at x ~ 0\n            non_zero_min_vals = []\n            for idx in mins_indices:\n                if not np.isclose(xs[idx], 0.0, atol=1e-9):\n                    non_zero_min_vals.append(vals[idx])\n            if len(non_zero_min_vals) == 0:\n                # Fallback: use the smallest non-central grid value\n                fallback_vals = [vals[j] for j in range(1, grid_points - 1)]\n                non_zero_min_vals = [min(fallback_vals)]\n            scores.append(float(min(non_zero_min_vals)))\n        return float(np.mean(scores))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_sine_well_ripple scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["d8c83eb3-0fc7-49f9-bfd1-d506a5309a77"], "operator": null, "metadata": {"ela_features_2D": [-0.001746654248354984, 0.3627902780799404, 0.009654264974703734, 0.03215560762066902, 7.489349062534123, -0.0023581995480773223, 0.9998501338949248, 1.0953695549536056, 0.9998497808420194, 0.4104521242418645, -0.5508860498277245, 2.0, 0.7141135916006127, 0.7239754286453421, 0.567075542157179, 0.33439409260522535, -0.2016108547029892, 0.13681755806061832, 0.22377169037569353, 0.3110431755169188, 0.4861788801153274, 0.1329694866211522, 0.22928194863926804, 0.3142703536521921, 0.4883785417581981, -0.45157379064136816, -0.40608087221206224, -0.36042327083361175, -0.26880147055171333, -0.44539995545557787, -0.3959109090938598, -0.3522501564806563, -0.26280878867014623, 1.0, 1.0, 1.0, 1.0, 0.513037595574426, 0.5130005954514295, 0.39098570221607837, 0.35065778662300906, 0.7175570538752206, 0.42142142142142125, 0.5622817691811988, -0.07907907907907905, 0.36746987951807225], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9727391600608826, "ela_features": [-0.00022489717958182887, 0.41349696676917286, 0.004197659292287239, 0.026509374707903877, 11.255924381062632, 0.005774748272494468, 0.9998166328214448, 1.3922191279470195, 0.9998165813644867, 0.2738314390744326, -0.2594970846692701, 1.2, 0.9065997394784642, 0.8800634408965757, 0.6468976871237255, 0.1744931665636261, -0.48083934174894993, 0.4391779921194809, 0.5242340311330866, 0.5983250359770771, 0.714831216137236, 0.4406119555524056, 0.5266494588207971, 0.600935666907669, 0.7188530556224788, -0.4932829472051584, -0.41846998220205844, -0.35330229008982317, -0.2508274101315493, -0.4945963571534948, -0.41852501238465034, -0.3528438763413262, -0.248587397609093, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21733953419414367, 0.2173037883661706, 0.20178452000390848, 0.18304429617776344, 0.8266648767549336, 0.1371371371371371, 0.2590973755673213, -0.35935935935935925, 0.5115384615384615], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0001701374421827495, "ela_features_10D": [-0.0009352681547130981, 0.4369423830788719, 0.0013536060607474993, 0.018113537988234243, 37.51643823210567, 0.0036853822510129588, 0.9997509336626559, 1.8924859549331177, 0.9997515241510833, 0.1911476013546524, -0.11118053865453507, 1.4, 1.0185102026014927, 0.9396416988559064, 0.716839909060498, 0.10326634082436204, -0.6072062920956975, 0.617611200381701, 0.6802339246034043, 0.7316938413119793, 0.810526686034968, 0.6206711937237227, 0.6847479634432202, 0.734879749130462, 0.8145093585976666, -0.4849579789486029, -0.4055378722245405, -0.3402746749285722, -0.24029649109060042, -0.48235164082339566, -0.4008716935689513, -0.33712377751496553, -0.23586750874086332, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1103983990838577, 0.11039823753155527, 0.10738844339647777, 0.10081406121902747, 0.8565778071608072, -0.1271271271271271, 0.13111288031704826, -0.6436436436436435, 0.5851881505204164], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00014183457824401557}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 5.567901106809597e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1410899587087894e-162, 1.2891232642303066e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.043606497413595e-162, 1.1839266094382908e-162, -9.499130155997085e-163, -7.361496929788557e-163, -1.1812230966275652e-162]}
{"id": "b487f031-92cf-4fbb-8bff-6897c417b7d6", "fitness": 0.6091277522453177, "name": "landscape_separable_linear_wells", "description": "A fully separable, piecewise-linear wells landscape using per-dimension min of absolute-distance wells. Global minimum at the origin, with a grid-based GlobalLocal contrast to enable tunable difficulty via per-dimension wells.", "code": "import numpy as np\n\nclass landscape_separable_linear_wells:\n    \"\"\"\n    Separable, linear-well landscape.\n\n    - Each dimension i defines fi(xi) = min_j [ |xi - s_{i,j}| + c_{i,j} ].\n    - Global minimum at the origin: fi(0) = 0 due to a global well (s=0, c=0).\n    - The full objective is f(x) = sum_i fi(x_i); thus the problem is fully separable.\n    - Wells can be supplied per-dimension or generated deterministically with a seed.\n    - GlobalLocal contrast is computed as the average depth (value) of the strongest non-global local minima across dimensions.\n      A deterministic grid is used to estimate local minima depths.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=None, seed=None, n_wells_per_dim=5):\n        self.dim = int(dim)\n        self.n_wells_per_dim = int(n_wells_per_dim)\n        self.rng = np.random.default_rng(seed)\n\n        self.wells_per_dim = []\n\n        # Build per-dimension wells\n        if wells_per_dim is not None:\n            if len(wells_per_dim) != self.dim:\n                raise ValueError(\"wells_per_dim must be a list with length equal to dim.\")\n            for dim_wells in wells_per_dim:\n                normalized = [ (float(mu), float(c)) for (mu, c) in dim_wells ]\n                # Ensure global well (0,0) exists\n                if not any(abs(mu) < 1e-9 and abs(c) < 1e-9 for mu, c in normalized):\n                    normalized.insert(0, (0.0, 0.0))\n                # Pad or trim to desired count\n                while len(normalized) < self.n_wells_per_dim:\n                    mu = float(self.rng.uniform(-4.0, 4.0))\n                    if abs(mu) < 1e-6:\n                        mu = 1.0 if self.rng.random() < 0.5 else -1.0\n                    c = float(self.rng.uniform(0.2, 3.0))\n                    normalized.append((mu, c))\n                if len(normalized) > self.n_wells_per_dim:\n                    normalized = normalized[:self.n_wells_per_dim]\n                self.wells_per_dim.append(normalized)\n        else:\n            # Deterministically generate per-dimension wells with a global well at (0,0)\n            for _ in range(self.dim):\n                wells = [(0.0, 0.0)]\n                for _ in range(max(0, self.n_wells_per_dim - 1)):\n                    mu = float(self.rng.uniform(-4.0, 4.0))\n                    if abs(mu) < 1e-6:\n                        mu = 1.0 if self.rng.random() < 0.5 else -1.0\n                    c = float(self.rng.uniform(0.2, 3.0))\n                    wells.append((mu, c))\n                self.wells_per_dim.append(wells)\n\n        # Compute GlobalLocal contrast: for each dim, depth of strongest non-global local minimum\n        local_min_depths = []\n        for i in range(self.dim):\n            wells = self.wells_per_dim[i]\n            # Evaluate fi on a fine grid\n            xs = np.linspace(-5.0, 5.0, 501)\n            vals = []\n            for xi in xs:\n                best = None\n                for (s, c) in wells:\n                    v = abs(xi - s) + c\n                    if best is None or v < best:\n                        best = v\n                vals.append(best)\n            vals = np.asarray(vals)\n            global_min_val = float(vals.min())\n\n            # Find local minima on the grid\n            mins_indices = [k for k in range(1, len(vals) - 1)\n                            if (vals[k] <= vals[k-1]) and (vals[k] <= vals[k+1])]\n            # Non-global local minima values\n            non_global_vals = [ float(vals[k]) for k in mins_indices\n                                if vals[k] > global_min_val + 1e-9 ]\n            if len(non_global_vals) > 0:\n                # Depth defined as the value of the local minimum (since global min is 0)\n                deepest_local_min_depth = max(non_global_vals)\n            else:\n                deepest_local_min_depth = 0.0\n            local_min_depths.append(deepest_local_min_depth)\n\n        self.global_local_contrast = float(np.mean(local_min_depths))\n\n        # Track global minimum value (0) for clarity\n        self.global_min = 0.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i fi(x_i) where fi(x_i) = min_j [ |x_i - s_{i,j}| + c_{i,j} ].\n\n        Domain: x_i in [-5, 5] for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar value of the landscape at x\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        # Enforce bounds\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = float(x[i])\n            best = None\n            for (s, c) in self.wells_per_dim[i]:\n                val = abs(xi - s) + c\n                if (best is None) or (val < best):\n                    best = val\n            total += float(best)\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_linear_wells scored on:Separable 0.920, GlobalLocal 0.002,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["72a0a50d-57fe-4d4f-b2dd-51d33accabf9"], "operator": null, "metadata": {"ela_features_2D": [0.16509351277561699, 0.2732751138002346, 0.036594273443752344, 0.2968874125552758, 9.048737578901108, 0.1658197677769025, 0.9349313866006128, 1.3791214382692292, 0.9351590161694858, 0.20431836082192464, -0.44596571905439575, 1.0, 0.597983732264208, 0.7023003646492131, 0.46118225563287807, 0.3459498090868581, -0.1941186442730249, 0.22729975700657504, 0.31079282480918813, 0.36490942055390596, 0.5164971123608515, 0.2103282617650745, 0.25973539486775254, 0.33542376225462556, 0.5033039283521918, -0.404149956810069, -0.36049900494037035, -0.33219167708610864, -0.25290452275395575, -0.4057039547690412, -0.380343619887281, -0.34146125433011487, -0.25521319276533067, 1.0, 1.0, 1.0, 1.0, 0.5206501929135763, 0.5206403340639827, 0.4560369610875467, 0.46966016270911204, 0.7495215431178316, 0.20520520520520513, 0.6684347189404901, -0.06706706706706707, 0.3779116465863454], "score_Separable_2D": 0.97998046875, "score_GlobalLocal_2D": 0.7660203576087952, "ela_features": [0.32948932581196205, 0.6519655837930672, 0.07873749487797417, 0.2458474519357739, 3.140636644365209, 0.33031610538033285, 0.8769004182920863, 2.3280134185752965, 0.8963225722506021, 0.3566437595071176, -0.10972280568197146, 1.2, 0.8240492304154541, 0.860005746598023, 0.5756023032296713, 0.19496969128879876, -0.43597399831856576, 0.5612742185996172, 0.6257591136233659, 0.6778759982954898, 0.7593317725630513, 0.5588127333434325, 0.6240153104347824, 0.6760611940979974, 0.7577600619265086, -0.38582459678557746, -0.329112617068475, -0.28328224327780716, -0.21164802694559404, -0.3898630621532603, -0.33224358793837816, -0.28625904781961675, -0.21406216170162864, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21752456648395171, 0.21749902466872836, 0.21770342666287887, 0.26254592459087844, 0.8409796193902446, 0.09309309309309305, 0.25625020649905017, -0.4074074074074073, 0.5443910256410256], "score_Separable_5D": 0.980517578125, "score_GlobalLocal_5D": 0.006449150387197733, "ela_features_10D": [0.20057678773318588, 0.516519070556884, 0.010996955886658399, 0.129287405011775, 12.548850277007144, 0.2034497137508776, 0.8976499994408934, 2.169823191205726, 0.9139746594366505, 0.12560265469550522, -0.1235151254084208, 1.2, 0.9693282505681869, 0.9322022666779788, 0.6738843793485234, 0.11052053966356482, -0.5701054893164874, 0.6662875406008333, 0.7199775325076552, 0.7627599446943296, 0.83215704973688, 0.6663416763715577, 0.7218870198507032, 0.7643487791443855, 0.8345920038124804, -0.42324960363409236, -0.35515342757046364, -0.3008910662837795, -0.2128745842996242, -0.4243343608128954, -0.3536921539803724, -0.29968655758291607, -0.21035433830885655, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10955542049807303, 0.10955571360819441, 0.10865219721949733, 0.13250260287193474, 0.8534967062404106, -0.1271271271271271, 0.12287612206612461, -0.6676676676676674, 0.5881505204163331], "score_Separable_10D": 0.9201280381944444, "score_GlobalLocal_10D": 0.0016709204064682126}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [2.7260000056221347, 2.381937680938527], 2.7057420076834657], [18, [2.725779210067246, 0.00036876679652443075], 2.256938904563287], [28, [0.00044444444444512003, 2.381777777777822], 0.44967720675533224], [42, [0.00044444444444512003, 0.00044444444444512003], 0.0008888888888902401]], "nr_of_basins": 4, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-0.0, 0.0], "f_opt_dim_5": 4.81705621246167e-222, "x_opt_dim_5": [-9.861982286421268e-223, 2.749835418423478e-223, -2.43218774813562e-222, -2.3351863250660323e-223, -8.901680613349724e-223]}
{"id": "876732ac-33f1-4faf-9b68-455c7cf83a68", "fitness": 0.8971824187923362, "name": "landscape_separable_quartic_gaussian_wells", "description": "A completely different separable landscape using a mix of quartic bases and Gaussian-modulated wells per dimension. Each dimension takes the minimum over several wells, where each well combines a quartic term with a Gaussian modulation to create multiple, smoothly shaped local minima. The global minimum remains at the origin with value 0, and a grid-based GlobalLocal descriptor is computed to quantify the strongest non-global local minima across dimensions.", "code": "import numpy as np\n\nclass landscape_separable_quartic_gaussian_wells:\n    \"\"\"\n    Novel separable landscape using a mix of quartic bases and Gaussian-modulated wells per dimension.\n\n    For each dimension i, the per-dimension function is:\n        g_i(u) = min_j [ a_j * (u - c_{i,j})^4 + b_{i,j} * exp(-((u - c_{i,j})^2) / (2 * sigma_{i,j}^2)) ]\n    with j indexing wells, where:\n      - c_{i,0} = 0, a_{i,0} = 1, b_{i,0} = 0, sigma_{i,0} = 1 (global well at origin)\n      - other wells have centers away from zero and positive Gaussian amplitude.\n    The global minimum is at u = 0 with g_i(0) = 0, and additional local minima appear away from zero.\n    The total objective is separable:\n        f(x) = sum_i g_i(x_i),  with x_i in [-5, 5].\n\n    GlobalLocal descriptor is computed by a 1D grid estimate of the strongest non-global local minimum\n    per dimension and then averaged across dimensions.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=4, grid_points=1001, seed=None):\n        \"\"\"\n        Initialize the landscape and compute a GlobalLocal descriptor.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - wells_per_dim: int, number of wells per dimension (including the origin well)\n        - grid_points: int, resolution for the 1D grid used to estimate GlobalLocal\n        - seed: int or None, RNG seed for reproducibility\n        \"\"\"\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.wells_per_dim = max(2, int(wells_per_dim))  # at least origin + one other well\n\n        # RNG for reproducibility\n        self.rng = np.random.default_rng(seed)\n\n        # Per-dimension wells: centers c_{i,j}, with a_j, b_j, sigma_j\n        # Include origin as the first bowl: c=0, a=1, b=0, sigma=1\n        self.per_dim_params = []\n        for _ in range(self.dim):\n            centers = [0.0]\n            a_vals  = [1.0]    # a_0\n            b_vals  = [0.0]    # b_0 (Gaussian amplitude; 0 ensures origin has zero value)\n            sigmas  = [1.0]    # sigma_0\n            # Add additional wells with centers away from zero\n            attempts = 0\n            while len(centers) < self.wells_per_dim:\n                attempts += 1\n                if attempts > 1000:\n                    break\n                c = self.rng.uniform(-4.0, 4.0)\n                if abs(c) < 0.2:\n                    continue\n                c4 = c**4\n                # Choose a nontrivial center with a feasible bound for b\n                max_b = min(max(0.6 * c4, 0.01), 2.0)\n                if max_b <= 0:\n                    continue\n                b = self.rng.uniform(0.01, max_b)\n                sigma = self.rng.uniform(0.4, 2.0)\n                centers.append(float(c))\n                a_vals.append(1.0)\n                b_vals.append(float(b))\n                sigmas.append(float(sigma))\n            self.per_dim_params.append({\n                'centers': centers,\n                'a': a_vals,\n                'b': b_vals,\n                'sigma': sigmas\n            })\n\n        # GlobalLocal descriptor (per-dimension and then averaged)\n        grid = max(5, int(self.grid_points))\n        gl_values = []\n        for i in range(self.dim):\n            centers = self.per_dim_params[i]['centers']\n            a_vals  = self.per_dim_params[i]['a']\n            b_vals  = self.per_dim_params[i]['b']\n            sigmas  = self.per_dim_params[i]['sigma']\n\n            t = np.linspace(-5.0, 5.0, grid)\n            # g1d(t) = min_j [ a_j*(t - c_j)^4 + b_j*exp(-((t - c_j)^2)/(2*sigma_j^2)) ]\n            g_stack = []\n            for a, c, b, s in zip(a_vals, centers, b_vals, sigmas):\n                g_stack.append(a * (t - c)**4 + b * np.exp(-((t - c)**2) / (2.0 * (s**2))))\n            g1d = np.min(np.stack(g_stack, axis=0), axis=0)\n\n            mean_f1d = float(np.mean(g1d))\n            min_idx = int(np.argmin(g1d))\n            # Local minima: points where g1d is <= neighbors, excluding global min\n            local_min_vals = []\n            for idx in range(1, len(t) - 1):\n                if idx == min_idx:\n                    continue\n                if g1d[idx] <= g1d[idx - 1] and g1d[idx] <= g1d[idx + 1]:\n                    local_min_vals.append(float(g1d[idx]))\n\n            if len(local_min_vals) == 0:\n                non_global_vals = [val for j, val in enumerate(g1d) if j != min_idx]\n                min_non_global = float(min(non_global_vals)) if non_global_vals else float(g1d[min_idx])\n            else:\n                min_non_global = float(min(local_min_vals))\n\n            per_dim_contrast = min_non_global / (mean_f1d if mean_f1d != 0 else 1.0)\n            gl_values.append(per_dim_contrast)\n\n        self.GlobalLocal = float(np.mean(gl_values))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i g_i(x_i) where g_i(u) = min_j [ a_j*(u - c_j)^4 + b_j*exp(-((u - c_j)^2)/(2*sigma_j^2)) ]\n\n        Bounds: -5 <= x_i <= 5 for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar: landscape value at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            t = x[i]\n            centers = self.per_dim_params[i]['centers']\n            a_vals  = self.per_dim_params[i]['a']\n            b_vals  = self.per_dim_params[i]['b']\n            sigmas  = self.per_dim_params[i]['sigma']\n\n            # g_i(t) = min_j [ a_j*(t - c_j)^4 + b_j*exp(-((t - c_j)^2)/(2*sigma_j^2)) ]\n            g_values = [\n                a * (t - c)**4 + b * np.exp(-((t - c)**2) / (2.0 * (s**2)))\n                for a, c, b, s in zip(a_vals, centers, b_vals, sigmas)\n            ]\n            total += float(min(g_values))\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_quartic_gaussian_wells scored on:Separable 1.000, GlobalLocal 0.925,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f9f807d-e8b4-4cbd-a7b5-b3a14b419180"], "operator": null, "metadata": {"ela_features_2D": [0.30386871206778915, -0.09087391725715718, 0.019421467395901622, 0.3479209172746925, 59.523529443211075, 0.3030687409500806, 0.6540726014579504, 18.962591964927107, 0.8740502294405117, 3.108352261349304, 9.370675491704116, 2.6, 0.4244662126059797, 0.6575742926498567, 0.366155478045344, 0.36487465557922716, -0.14647683445704174, 0.13304918256747267, 0.3217412621160341, 0.4869895851683991, 0.7070373134066769, 0.13224699506251958, 0.2567782426471085, 0.5065129730301162, 0.717735836311228, -0.4538301787133599, -0.3550598947322038, -0.26855795062472626, -0.1533638690255989, -0.44637205083407466, -0.3823183616564859, -0.2538723025995182, -0.14520649910552264, 1.0, 1.0, 0.7333333333333332, 1.0, 0.5244629796383867, 0.5244552160376393, 0.48984693058791134, 0.5190454370988504, 0.6205994097338134, 0.8818818818818815, 0.08906260776633192, -0.6036036036036034, 0.416867469879518], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.4651784598827362, "ela_features": [0.4338064006515821, -0.01261749209859973, 0.007934220449300979, 0.26398352510440437, 45.65556719099454, 0.4350116939394413, 0.8134648631240399, 1188.318030448628, 0.9589092581950952, 1.4606362872594958, 1.8821575949579228, 2.0, 0.8492489833516332, 0.8613384875271375, 0.60316827271221, 0.19346279755025386, -0.35015512112649283, 0.5425176436177048, 0.626675953246971, 0.6717187217249143, 0.7727948525111075, 0.5392823611262323, 0.6183195989163075, 0.6642798266160577, 0.7684270674092885, -0.4023795106027202, -0.32835891444958026, -0.28874010867537037, -0.19983852519297204, -0.4073157135593398, -0.3374366445161271, -0.29679725472175333, -0.20472615278781953, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21237983714824452, 0.21236870664577992, 0.22525590042002355, 0.2785594857973593, 0.6874853099166871, 0.31731731731731727, 0.12345426524301466, -0.5555555555555554, 0.5198717948717949], "score_Separable_5D": 0.99990234375, "score_GlobalLocal_5D": 0.9935976266860962, "ela_features_10D": [0.4192042052598378, 0.20020539883129448, 0.0026000665007247696, 0.22155054750546016, 160.29842883573446, 0.42105057902921905, 0.793011114033904, 18.198926768498495, 0.9548254444614586, 1.0588381896199623, 0.9338305757230365, 1.2, 0.9410251248314611, 0.9279039507735751, 0.6624878076465821, 0.11359256994159772, -0.45057867337916, 0.6773207860285063, 0.7415726999710016, 0.7905295027544207, 0.8657516562903611, 0.6784128343286462, 0.7416399684110303, 0.7907982276527529, 0.86629164310394, -0.4092586499052107, -0.32776708781138886, -0.2656744572398206, -0.17026874216992902, -0.409011026224902, -0.3285945075687763, -0.26607321896047365, -0.17005565022606312, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11042101990973249, 0.11042600669642474, 0.11503340773428432, 0.14887923310690762, 0.8113758181948176, 0.005005005005004981, 0.12670859247442806, -0.6236236236236234, 0.588550840672538], "score_Separable_10D": 0.9998263888888889, "score_GlobalLocal_10D": 0.9245896935462952}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [-4.383742560272643, 0.9359490043235498], 0.9475030180682509], [8, [-4.430000000000063, 0.00044444444444512003], 0.756536554470943], [6, [2.7283231137803265, -9.485954231477282e-05], 1.6970582432827], [17, [3.4988348890866914, -0.08768980139374954], 0.5252512338170531], [21, [0.00044444444444512003, 0.00044444444444512003], 7.803688462172125e-14], [10, [-3.386888888888944, 0.00044444444444512003], 0.7565356634896748], [9, [0.00044444444444512003, 0.9686666666666663], 0.18812058046695834], [8, [2.729126405819394, 0.9697688579657662], 1.8851794086412679], [7, [-3.386374084350136, 0.9685354848801457], 0.9446565318744553], [9, [4.391562547314054, 0.9071965243006416], 0.713784418714842]], "nr_of_basins": 10, "f_opt_dim_2": 0.1755524011861271, "x_opt_dim_2": [0.6452399306031099, 0.21701357034480845], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.0307294633836517e-81, -8.733447248392174e-82, -3.5065773779656983e-82, 6.715454677311036e-82, 5.1624223050556997e-82]}
{"id": "d4d53afe-c1d2-45e7-8e2c-96b1405db844", "fitness": 0.649210840681917, "name": "landscape_separable_abs_sin_bumps", "description": "A novel separable benchmark with a quadratic base plus nonnegative abs(sin) bumps, yielding distinct local minima away from zero and a computed GlobalLocal contrast via 1D grid analysis.", "code": "import numpy as np\n\nclass landscape_separable_abs_sin_bumps:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + a_i * |sin(k_i * x_i)| ]\n    - Separable: no cross-dimension interactions; f(x) is a sum of independent per-dimension functions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent,\n      producing local minima away from zero due to the |sin| term, while preserving separability.\n    - The GlobalLocal score is computed by sampling the 1D landscape of each dimension over a grid to quantify\n      the contrast between the strongest non-global local minima and the 1D mean value. The overall score is the\n      average across dimensions.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5, grid_points=1001, domain=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n\n        # Deterministic per-dimension structure for richer GlobalLocal contrast\n        self.a = 0.5 + 0.25 * np.arange(self.dim)   # amplitudes (nonnegative)\n        self.k = 1.0 + 0.18 * np.arange(self.dim)   # frequencies\n\n        # Precompute GlobalLocal score by analyzing the 1D landscapes\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        # 1D grid for analysis\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        for i in range(self.dim):\n            f1d = t**2 + self.a[i] * np.abs(np.sin(self.k[i] * t))\n            mean_f = float(np.mean(f1d))\n\n            # Detect local minima along the grid, excluding the global minimum at t ~ 0\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < 1e-9:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                gl_i = float(local_min_val / mean_f) if mean_f > 0 else 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * |sin(k_i * t)|\n        per_dim = x**2 + self.a * np.abs(np.sin(self.k * x))\n        return float(np.sum(per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_abs_sin_bumps scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [-0.00031664869737408897, 0.3674224198435508, 0.011739979324108505, 0.04237007150562293, 6.310391533765474, 0.0005287425328399875, 0.9993803247053359, 1.0031284129150215, 0.9993783570138467, 0.4557444301039039, -0.4156496001456073, 1.4, 0.70335184104051, 0.7161654907000906, 0.5390277755131493, 0.3407576896220095, -0.20017749829974033, 0.14297118439120687, 0.21649575306620078, 0.3070211445640633, 0.491788402024706, 0.143362538402269, 0.21739976031453612, 0.3079374209150455, 0.4924884744422983, -0.4483829147429274, -0.4099137621016264, -0.3625530245769018, -0.2658862011731462, -0.4403770727308739, -0.4023065141080367, -0.35576267644928194, -0.26088922241062196, 1.0, 1.0, 1.0, 1.0, 0.5172112902028584, 0.5171914280576975, 0.399891366735052, 0.3562921895055621, 0.711547508956205, 0.40540540540540526, 0.4935388919676333, -0.09109109109109106, 0.3734939759036145], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8949530720710754, "ela_features": [0.0008675199289678969, 0.4184009110775319, 0.005769516226456604, 0.0323834303774219, 12.708147295275575, 0.003775234908366909, 0.9981004555819268, 1.0222225301455385, 0.9980823326043442, 0.2655450839508163, -0.1873117855298821, 1.0, 0.9083873939428617, 0.8744139024772398, 0.6490861609912186, 0.18104640050638782, -0.4713011495119034, 0.4248004568717514, 0.512901378687393, 0.5919342917652509, 0.7168206315878323, 0.4308042795432093, 0.5152820098258498, 0.5939501440419562, 0.719329613448065, -0.5059592958949368, -0.4284641171523195, -0.35894486768495326, -0.2490910541043337, -0.5035218568690947, -0.42879200166626025, -0.3592005512546019, -0.2482860399845545, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21600262055226413, 0.21600564299128439, 0.20069462433684687, 0.18179914927764249, 0.8238169888882247, 0.13313313313313307, 0.25733620791613976, -0.35535535535535523, 0.5094551282051282], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.0001701374421827495, "ela_features_10D": [-0.001149457351300054, 0.4426560521567307, 0.001644306167292945, 0.017060816204196194, 14.106271179429715, 0.002001288978358473, 0.9947468734348217, 1.0286778765668128, 0.9947087102052731, 0.21395845046035156, -0.0948062442783673, 1.4, 1.0213976478286446, 0.9391946868960208, 0.7136011835710769, 0.10412928780258493, -0.6134824333378038, 0.6222404075318606, 0.6826711183725593, 0.7320764929027124, 0.8095624027255935, 0.6254086820063407, 0.686766018992129, 0.7368481831052275, 0.8142012412358154, -0.4791167182759911, -0.40247212544239125, -0.3398106979177121, -0.24153435215076371, -0.47635429198272583, -0.39832818827481364, -0.3346403365236606, -0.2362731721995012, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1107590792457939, 0.11075424622712712, 0.10763557272601762, 0.10126784785600314, 0.8559756754640702, -0.10710710710710711, 0.1374353060850424, -0.6276276276276274, 0.5869495596477182], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00014183457824401557}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 0.0006159505919384003]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5e-324, -0.0], "f_opt_dim_5": 9.6204e-320, "x_opt_dim_5": [2.502e-320, 1.7164e-320, 1.3646e-320, -4.363e-321, 1.6107e-320]}
{"id": "a199f8e3-6b09-4fad-9d0b-d1890cd12bbd", "fitness": 0.5447725747829449, "name": "landscape_sep_minabs_wells", "description": "A novel separable benchmark using per-dimension min-of-absolute-value wells. Each dimension contains multiple linear (V-shaped) wells with additive depths, guaranteeing a global minimum at the origin but introducing multiple local minima away from zero. The landscape is completely separable since the objective is a sum over independent one-dimensional subproblems. A deterministic GlobalLocal score is computed from a 1D grid analysis to quantify how pronounced the strongest non-global local minima are on each dimension.", "code": "import numpy as np\n\nclass landscape_sep_minabs_wells:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i f_i(x_i) with f_i(t) = min_j ( |t - c_{i,j}| + d_{i,j} )\n    - Separable: f(x) is a sum of independent per-dimension functions.\n    - Global minimum at x = 0 with f(0) = 0 since there is a well centered at 0 with depth 0.\n    - Per-dimension wells are implemented as absolute-value (V-shaped) wells with additive depths.\n    - The GlobalLocal score is computed by analyzing the 1D landscapes on a grid to measure the contrast\n      between the strongest non-global local minima and the 1D mean value.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5, wells=7, grid_points=1001, domain=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n\n        # Ensure an odd number of wells to guarantee a center at 0\n        self.wells = int(wells)\n        if self.wells % 2 == 0:\n            self.wells += 1\n\n        # Base centers in 1D that include 0 in the middle\n        base_centers = np.linspace(self.domain[0], self.domain[1], self.wells)\n        zero_index = int(np.argmin(np.abs(base_centers)))\n        # Per-dimension centers with a small shift so dimensions differ slightly\n        self.centers = np.zeros((self.dim, self.wells), dtype=float)\n        self.depths = np.zeros((self.dim, self.wells), dtype=float)\n\n        for i in range(self.dim):\n            # Slight per-dimension offset to create diverse landscapes while keeping 0 as a well\n            offset_i = (i - self.dim // 2) * 0.15\n            centers_i = base_centers + offset_i\n            centers_i[zero_index] = 0.0  # force a center exactly at 0\n            centers_i = np.clip(centers_i, self.domain[0], self.domain[1])\n            self.centers[i, :] = centers_i\n\n            # Depth for each well: center at 0 has depth 0; others positive and increasing with distance from 0\n            depths_i = []\n            for c in centers_i:\n                if np.isclose(c, 0.0):\n                    depths_i.append(0.0)\n                else:\n                    depths_i.append(0.12 + 0.46 * (abs(c) / 5.0))  # deterministic increasing depth with distance\n            self.depths[i, :] = depths_i\n\n        # Precompute GlobalLocal score by analyzing the 1D landscapes\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        for i in range(self.dim):\n            centers_i = self.centers[i, :]\n            depths_i = self.depths[i, :]\n\n            # f_i(t) = min_j ( |t - c_ij| + d_ij )\n            vals = np.abs(t[:, None] - centers_i[None, :]) + depths_i[None, :]\n            f1d = np.min(vals, axis=1)\n\n            mean_f = float(np.mean(f1d))\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < 1e-9:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                gl_i = local_min_val / mean_f if mean_f > 0 else 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        total = 0.0\n        for i in range(self.dim):\n            # f_i(t) = min_j ( |t - c_ij| + d_ij )\n            t = x[i]\n            f_i_vals = np.abs(t - self.centers[i, :]) + self.depths[i, :]\n            total += float(np.min(f_i_vals))\n\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sep_minabs_wells scored on:Separable 0.979, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [-0.002096451071517591, 0.5288229896839022, 0.00751303858619193, 0.021564895953859988, 16.786503414397025, 0.00014395743996249434, 0.2320937936795914, 1.1165553253913307, 0.23333764689165734, -0.06457597113813958, -0.3751564099928261, 1.0, 0.2929877257664786, 0.5651319564478612, 0.2995361782889435, 0.4054067617631397, -0.5138142801402903, 0.44239846679383243, 0.570798178967466, 0.6611062600129405, 0.7771869649566165, 0.42477487644185724, 0.5392278711756573, 0.6540947695595513, 0.7523168063677833, -0.2918417259105836, -0.22460019205112963, -0.17735396800096745, -0.11660077497952619, -0.2960920384067139, -0.23711310854036016, -0.1780271489285535, -0.12747352638552018, 1.0, 1.0, 1.0, 1.0, 0.52682831110932, 0.5268217781418156, 0.4362036693503665, 0.35793519526813056, 0.8068729144702271, 0.8218218218218215, 2.0550668992620027, 0.5335335335335334, 0.4771084337349397], "score_Separable_2D": 0.9970703125, "score_GlobalLocal_2D": 0.329571008682251, "ela_features": [-0.0004339372442147216, 0.516849670847834, 0.004109084828625218, 0.025606544767033466, 18.08898867597645, 0.001932155089025267, 0.21655514681154892, 1.4080238159923704, 0.21881983631758822, -0.07940651113079603, -0.12269760859002554, 1.2, 0.6096391602615989, 0.8016782664529642, 0.43336464494542354, 0.23902420262494922, -0.6152704073845311, 0.6999355113577401, 0.7608009192209395, 0.797877982102537, 0.8658912825325269, 0.6877077650655747, 0.7504434812028812, 0.7872314145569586, 0.8589842603089226, -0.2639483154857779, -0.21040507345691917, -0.1777916589724103, -0.1179653861368261, -0.2760933289551118, -0.22062157526108975, -0.18809608040038306, -0.124663667167241, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21601376559738822, 0.21604174969833995, 0.20366422429124661, 0.1814800476809164, 0.8693783726260532, 0.5215215215215213, 0.4434711001519373, -0.13513513513513514, 0.6525641025641026], "score_Separable_5D": 0.960791015625, "score_GlobalLocal_5D": 0.0016771986847743392, "ela_features_10D": [-0.0009067870493167263, 0.5057511443169723, 0.0012237057302977232, 0.019177569023142698, 24.032624372583605, -0.0025177278035788176, 0.18072053468775112, 1.8542341460940726, 0.18652229963495112, -0.07627856240423646, -0.1300328725172238, 1.2, 0.7572036614856341, 0.89776944892236, 0.5380513975410868, 0.13893900947684504, -0.6268682084541876, 0.8360183985012007, 0.8553211322897563, 0.8766036122710865, 0.9129236639384434, 0.8301383151562416, 0.85370815688675, 0.8745536151008345, 0.9118032567388896, -0.20795939717182757, -0.18348126500147072, -0.15649093086098037, -0.11043016008908095, -0.2159468504910044, -0.185985682264492, -0.15948460756373878, -0.11212825971559956, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1092532470366239, 0.10925945982004251, 0.10634885016484463, 0.09979434630013609, 0.8723182379921528, 0.08108108108108103, 0.17141867649359632, -0.5195195195195194, 0.6576461168935148], "score_Separable_10D": 0.9792100694444444, "score_GlobalLocal_10D": 0.0003158437612000853}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 1.1600000000000001], [1, [-5.0, -1.6666666666666665], 0.8533333333333334], [1, [-5.0, 1.666666666666667], 0.8533333333333334], [1, [-5.0, 5.0], 1.1600000000000001], [2, [0.00044444444444512003, -5.0], 0.5804444444444452], [2, [3.182888888888967, -5.0], 0.9933111111110338], [2, [0.00044444444444512003, -1.6666666666666665], 0.27377777777777845], [2, [3.182888888888967, -1.6666666666666665], 0.6866444444443671], [2, [-5.0, 0.00044444444444512003], 0.5804444444444452], [2, [-1.6666666666666665, 0.00044444444444512003], 0.4375777777777784], [2, [0.00044444444444512003, 1.666666666666667], 0.27377777777777845], [2, [3.182888888888967, 1.666666666666667], 0.6866444444443671], [2, [-5.0, 3.3337777777777173], 1.0071111111110502], [2, [0.00044444444444512003, 5.0], 0.5804444444444452], [2, [3.182888888888967, 5.0], 0.9933111111110338], [4, [0.00044444444444512003, 0.00044444444444512003], 0.0008888888888902401], [4, [3.182888888888967, 0.00044444444444512003], 0.4137555555554789], [4, [0.00044444444444512003, 3.3337777777777173], 0.42755555555549524], [4, [3.182888888888967, 3.3337777777777173], 0.8404222222220838], [2, [-3.4837777777777, -5.0], 1.0209111111110336], [2, [-5.0, -3.33288888888895], 1.0071111111110498], [2, [-3.4837777777777, -1.6666666666666665], 0.714244444444367], [2, [-3.4837777777777, 1.666666666666667], 0.714244444444367], [2, [-3.4837777777777, 5.0], 1.0209111111110336], [4, [0.00044444444444512003, -3.33288888888895], 0.42755555555549474], [4, [3.182888888888967, -3.33288888888895], 0.8404222222220834], [4, [-3.4837777777777, 0.00044444444444512003], 0.44135555555547873], [4, [-3.4837777777777, 3.3337777777777173], 0.8680222222220837], [4, [-3.4837777777777, -3.33288888888895], 0.8680222222220833], [1, [1.5166666666666668, -5.0], 0.8395333333333337], [1, [1.5166666666666668, -1.6666666666666665], 0.5328666666666669], [1, [1.5166666666666668, 1.666666666666667], 0.5328666666666669], [1, [1.5166666666666668, 5.0], 0.8395333333333337], [2, [1.5166666666666668, 0.00044444444444512003], 0.25997777777777875], [2, [1.5166666666666668, 3.3337777777777173], 0.6866444444443838], [2, [1.5166666666666668, -3.33288888888895], 0.6866444444443832], [1, [4.8500000000000165, -5.0], 1.146200000000017], [1, [4.8500000000000165, -1.6666666666666665], 0.8395333333333502], [1, [4.8500000000000165, 1.666666666666667], 0.8395333333333502], [1, [4.8500000000000165, 5.0], 1.146200000000017], [2, [4.8500000000000165, 0.00044444444444512003], 0.566644444444462], [2, [4.8500000000000165, 3.3337777777777173], 0.9933111111110671], [2, [4.8500000000000165, -3.33288888888895], 0.9933111111110665], [1, [-1.8155498832879797, 4.863479716494229], 1.004770400217791], [1, [-1.8155136081557026, -4.8634401669253995], 1.0048462249188979], [2, [-1.8164108101015852, 3.2784791764083714], 0.7689100134900437], [2, [-1.8162890023944587, -3.286028773467938], 0.7614822241376027], [1, [-1.8165340870838764, -1.6472139341669378], 0.5800519787491853], [1, [-1.8155805545757995, 1.6485960219974334], 0.5796234234267672]], "nr_of_basins": 49, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-0.0, -0.0], "f_opt_dim_5": 1.7078798623748994e-246, "x_opt_dim_5": [4.363824512100559e-247, -8.352802988402679e-247, -3.829200973642973e-248, -2.527940227601166e-247, 1.4513107982802927e-247]}
{"id": "485b31c4-0628-4b47-b535-9daecfe2788a", "fitness": 0.6503453834229731, "name": "landscape_sep_bumpy_glocal_enhanced", "description": "A novel separable benchmark with fully independent per-dimension landscapes featuring quadratic base plus deterministic sine-based bumps, designed to maximize separability (no cross-dimension interactions) while preserving a clear global minimum at the origin and a tunable GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_sep_bumpy_glocal_enhanced:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + a_i * sin^2(k_i * x_i) ]\n    - Separable: independent per-dimension subproblems; no cross-dimension interactions.\n    - Global minimum at x = 0 with f(0) = 0.\n    - Per-dimension parameters a_i (amplitude) and k_i (frequency) are deterministic and dimension-dependent,\n      yielding varied local minima across dimensions while preserving separability.\n    - The GlobalLocal score is computed via a 1D grid analysis per dimension and averaged across dimensions.\n    - Separable_score is explicitly set to 1.0 to reflect perfect separability (independence of subproblems).\n    - The input domain per dimension is [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self.grid_points = 1001\n        self.domain = (-5.0, 5.0)\n\n        # Deterministic, dimension-dependent per-dimension structure for richer GlobalLocal contrast\n        # Amplitudes increase with dimension; frequencies also vary by dimension to create distinct local minima\n        self.a = 0.6 + 0.28 * np.arange(self.dim)  # amplitudes (nonnegative)\n        self.k = 1.1 + 0.32 * np.arange(self.dim)  # frequencies\n\n        # Separable score: perfect separability by construction (sum of independent 1D subproblems)\n        self.separable_score = 1.0\n\n        # GlobalLocal score (computed from 1D analyses)\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        # 1D grid for analysis\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        for i in range(self.dim):\n            # 1D landscape for dimension i\n            f1d = t**2 + self.a[i] * np.sin(self.k[i] * t) ** 2\n            mean_f = float(np.mean(f1d))\n\n            # Detect local minima along the grid, excluding the global minimum at t ~ 0\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < 1e-9:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                if mean_f > 0:\n                    gl_i = local_min_val / mean_f\n                else:\n                    gl_i = 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape.\n        Input:\n          x: array-like of shape (dim,) with real values in [-5, 5].\n        Output:\n          scalar objective value (minimization problem).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sep_bumpy_glocal_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [-0.0021145415250710007, 0.35195087658044744, 0.008675845274297904, 0.029498372607343427, 3.659049434028634, -0.0013025116265374282, 0.9987777255607531, 1.0189566229925937, 0.9987727266338196, 0.44716160728646626, -0.4497987325497809, 1.8, 0.7187443885962298, 0.7210043631374096, 0.5584276621040721, 0.3390345201857281, -0.2076041516330292, 0.12131359491691603, 0.213489610864819, 0.3156183697290778, 0.4937656920239727, 0.11796473094592716, 0.2107088935824606, 0.3150719194749554, 0.4932618289070009, -0.4597927772315515, -0.41155500325826616, -0.35811534063550343, -0.26489540565448727, -0.45344718250602367, -0.40576236780690633, -0.35210538561313615, -0.260501082447932, 1.0, 1.0, 1.0, 1.0, 0.519050998251576, 0.5190352421579647, 0.4017727617007042, 0.35344399539592886, 0.7156971873757942, 0.40140140140140124, 0.5748096541511579, -0.07107107107107105, 0.37068273092369475], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9017489552497864, "ela_features": [-0.0004341415795999115, 0.4019709193304678, 0.003631246809599329, 0.02399476392386305, 35.973195328996866, 0.002979002631769023, 0.9968415914895891, 1.0231909331973263, 0.9968138706836249, 0.24779607965562628, -0.21427885079355696, 1.2, 0.9113331814421886, 0.8727866417528363, 0.6309762037645011, 0.18418871058554115, -0.4772089738128037, 0.433558417922011, 0.5177705166273705, 0.592280656212829, 0.710839507186207, 0.4327024454273941, 0.5201229999339237, 0.5958890495242589, 0.7150377719053966, -0.4982157328057327, -0.4241457344009921, -0.35860928312288587, -0.25433065027608165, -0.5014317775394603, -0.4241588105739543, -0.3571885541008698, -0.25187401401697995, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21741100893420962, 0.21741813806393248, 0.20331246129002106, 0.18368502565527792, 0.8281867544264732, 0.10510510510510507, 0.2528366427866113, -0.3713713713713712, 0.5131410256410256], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00016970306751318276, "ela_features_10D": [0.00014926071780365646, 0.43273288126443743, 0.0016834276832129041, 0.021607887522713316, 19.060846152718145, 0.008411304535432974, 0.9911126653532933, 1.0334213424818863, 0.9911952952580527, 0.23695440259099718, -0.038288810330823875, 1.4, 1.0185030765181227, 0.9394092898278668, 0.7179610563512369, 0.10359539267799467, -0.6025309804064181, 0.6237881648301066, 0.6830915677756125, 0.7323874860441054, 0.8087350692080761, 0.6289696337208825, 0.6866292964564042, 0.7373428511096625, 0.8136493405219053, -0.47712932130939845, -0.40191793745529764, -0.33939830930095394, -0.24257053473720075, -0.47174470089370424, -0.39843336444155353, -0.3339530470698688, -0.2369329486527471, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11016444634984135, 0.11015776769882002, 0.10728668058452903, 0.10100605692881078, 0.8569887890892863, -0.14314314314314308, 0.11917536003824698, -0.6596596596596594, 0.589191353082466], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00015364222053904086}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 8.889741642640113e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [4.615866163180421e-163, -2.594205599961519e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [5.432256032590145e-163, -8.579962733315192e-163, -6.683512902798124e-163, -2.952548223804184e-163, -3.048718117950165e-163]}
{"id": "b055a617-bc6b-4bcd-874c-79cdbdd2be55", "fitness": 0.6623371898628344, "name": "landscape_sep_rastrigin_like", "description": "A separable Rastrigin-like benchmark with dimension-specific cosine perturbations on a quadratic base, featuring a grid-based GlobalLocal score. Each dimension contributes independently f_i(x_i) = x_i^2 + A_i*(1 - cos(2\u03c0 k_i x_i)), ensuring a global minimum at the origin while creating multiple local minima via the periodic term.", "code": "import numpy as np\n\nclass landscape_sep_rastrigin_like:\n    \"\"\"\n    Separable benchmark: f(x) = sum_i [ x_i^2 + A_i * (1 - cos(2 * pi * k_i * x_i)) ]\n    - Separable: independent per-dimension subproblems.\n    - Global minimum at x = 0, with f(0) = 0.\n    - Per-dimension parameters A_i (amplitude) and k_i (frequency) are deterministic and seedable for reproducibility.\n    - GlobalLocal score is computed by analyzing each 1D landscape on a grid to quantify the contrast\n      between the strongest non-global local minima and the 1D mean value; the overall score is the average\n      across dimensions.\n    - Domain per dimension: [-5, 5].\n    \"\"\"\n\n    def __init__(self, dim=5, grid_points=1001, domain=(-5.0, 5.0), seed=None):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n\n        rng = np.random.default_rng(seed)\n\n        # Deterministic but seedable per-dimension structure\n        # Amplitudes in [0.4, 0.8), frequencies in [0.5, 3.0)\n        self.A = 0.4 + 0.4 * rng.random(self.dim)\n        self.k = 0.5 + 2.5 * rng.random(self.dim)\n\n        # Precompute GlobalLocal score by analyzing the 1D landscapes\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        # 1D grid for analysis\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n\n        for i in range(self.dim):\n            # 1D landscape: f_i(t) = t^2 + A_i * (1 - cos(2*pi*k_i*t))\n            f1d = t**2 + self.A[i] * (1 - np.cos(2 * np.pi * self.k[i] * t))\n            mean_f = float(np.mean(f1d))\n\n            # Detect local minima along the grid, excluding the global minimum at t ~ 0\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    if abs(t[j]) < 1e-9:\n                        continue  # skip the global minimum at 0\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                gl_i = local_min_val / mean_f if mean_f > 0 else 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        if len(gl_values) > 0:\n            self.glocal_score = float(np.mean(gl_values))\n        else:\n            self.glocal_score = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + A_i * (1 - cos(2*pi*k_i*t))\n        per_dim = x**2 + self.A * (1 - np.cos(2 * np.pi * self.k * x))\n        return float(np.sum(per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sep_rastrigin_like scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [-0.002335826899529092, 0.3612073218914459, 0.012264298776881214, 0.024198664449783792, 3.5701759675142513, -0.0021638431335787357, 0.9958714813706763, 1.0036017593159663, 0.9958728498909604, 0.46339285140211184, -0.4950923666505074, 1.6, 0.659587725574725, 0.6987914738215621, 0.4987861323084741, 0.3544102802077277, -0.18896870389624745, 0.19221799437148493, 0.252748367081061, 0.3231910595795396, 0.4972465975571379, 0.18823493723080864, 0.2510145808784135, 0.32306447135781935, 0.5004664063344251, -0.4223588434899176, -0.3907036862945815, -0.3538708614869911, -0.2628652890729401, -0.4166433517792315, -0.38440100576874797, -0.3474240612030266, -0.2563740909193218, 1.0, 1.0, 1.0, 1.0, 0.5182025770767268, 0.5180910300417467, 0.3986121586892083, 0.35227654914563755, 0.7843371030311734, 0.5375375375375373, 0.7093471507153987, -0.015015015015015037, 0.4257028112449799], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9736950993537903, "ela_features": [-0.00055908311658317, 0.4096466663278944, 0.0036641718173747568, 0.02392098446849217, 20.480594696618375, 0.006780105773327749, 0.99595872343062, 1.0082663602367337, 0.9959403654711455, 0.28185635210343063, -0.24372765559392384, 1.0, 0.8989242033561247, 0.8734428267002269, 0.6291810293377835, 0.18247138129850288, -0.46283113157600564, 0.44877636654963904, 0.5229462023149549, 0.595548388528524, 0.7108660172941444, 0.454730428318358, 0.5287153093338229, 0.6006731973462559, 0.716137790637096, -0.48473927708637693, -0.41951484431910185, -0.35566959170860446, -0.25426120682281617, -0.4817645891429388, -0.41639415661900364, -0.3528187784142016, -0.2508038293518394, 1.0, 1.0, 0.8333333333333334, 1.0, 0.22133858391473202, 0.22131009740323973, 0.20608354561774034, 0.1860075071834077, 0.8290474955536775, 0.11711711711711707, 0.253624760446537, -0.3793793793793793, 0.5225961538461539], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00017439760267734528, "ela_features_10D": [0.0003704241532384467, 0.4318614402098174, 0.0012233406487170719, 0.021925892007830457, 27.546728440597484, 0.003333985512276949, 0.9961350255516646, 1.0157344905916017, 0.9961144602160482, 0.18651487687431859, -0.12445112733966228, 1.0, 1.0142735150545072, 0.9395125927570934, 0.7124693391619505, 0.10266132749599619, -0.6122431256049997, 0.6168051164781343, 0.6807360818145031, 0.7317221542299797, 0.8091274430061475, 0.6217724898820014, 0.6847653471025806, 0.7362743129726061, 0.8138014087014774, -0.4860354034212504, -0.40494687364173226, -0.34027747738979774, -0.24209847257541844, -0.4810651128843146, -0.400945005012721, -0.33543130457435577, -0.23682520466471257, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10901855798473159, 0.10902179680449445, 0.10602771879322541, 0.10032685347693948, 0.8594362067331526, -0.10310310310310308, 0.13439573413916997, -0.6316316316316314, 0.5938350680544435], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00015364222053904086}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [3.749105777552571, -2.65769787566578], 21.408044089151918], [1, [-0.3755555555555552, -0.3795555555555552], 0.2886200166572752], [1, [-0.3755555555555552, 0.3795555555555552], 0.2886200166572752], [1, [0.36376970601036845, 0.3794211056428714], 0.3020154314370881], [1, [0.36378318552847627, -0.3793668925815073], 0.3019893803352435], [1, [2.6275222680595802, -4.904818795972618], 31.630484939186736], [1, [2.6276523546286716, -3.7874304251444664], 21.57901015334516], [1, [-4.868001213788741, -3.7927846748404144], 38.67294939910285], [1, [2.627719147198447, -2.6540482957105493], 14.139467410560014], [1, [-2.6134330830727066, -2.6559020825278434], 14.157279519814649], [1, [-4.868217002359886, 2.657681471808816], 31.23420373939207], [1, [-2.6134338059549425, 2.6559024859440896], 14.157277714479505], [1, [3.7488899380517524, 2.6576954966039037], 21.408166476212976], [1, [-3.7488898862400024, 2.6576997147725514], 21.408166725780227], [1, [-4.868001140737772, -2.657681642126817], 31.234313591774026], [1, [2.627717222989794, 3.7888895306874932], 21.578236787642886], [1, [3.7501019222453493, -1.5186386350844698], 16.591330569477673], [1, [2.6158219593764773, 2.657532197825282], 14.151857254449336], [1, [-2.628270504611332, 3.4155788322362293], 18.806814673605107], [1, [4.873087920337774, 3.792639536428304], 38.67148951918145], [1, [4.863588980887413, 4.917203888419208], 48.72554848536852], [1, [-4.860612050086093, -4.917129270431309], 48.72845470938607], [2, [3.7533708722957173, 3.791487543093483], 28.845704563809736], [1, [-4.874424287038505, 3.4144861750289874], 35.901028091292005], [1, [2.615486648020991, 1.5187325574121353], 9.336316343827807], [1, [-2.6154864718154367, -1.5187337687089633], 9.336316634555658], [1, [-3.7388047757080622, -1.5187682277781624], 16.60432334917569], [1, [-4.868680655632489, 1.5185453662260675], 26.41775945541275], [1, [-1.5026255001516136, -0.3778099815762353], 2.4279873823981806], [1, [-1.5016480967863908, 0.365850414197733], 2.444126442963486], [1, [-1.501163599694413, 1.5083273276465705], 4.6268891116660615], [1, [4.868680724032835, 1.5185357065611738], 26.417760333322406], [1, [1.5026164161746351, -1.516916328985911], 4.617862960251609], [1, [1.50278805951786, -2.6439028395283635], 9.446254209195459], [1, [1.5019345641703459, -3.773822527553474], 16.890865280627033], [1, [1.5024416763137955, 4.909265698614011], 26.923677890592494], [1, [-1.502514039855469, -4.9110110909353235], 26.923096271900945], [1, [1.502578619780822, 3.7893935895670583], 16.873048567621456], [1, [-1.501137460533356, 2.6456855615342834], 9.44336416677942], [1, [-1.5023683232687002, 4.907427368267508], 26.92437474633455], [1, [-1.5019112642006158, 3.773598470525239], 16.891272475290776], [1, [-1.5025812367396636, -3.789226408945353], 16.873115696193445], [1, [3.738638021736768, 1.5189521628249716], 16.604623205378715], [1, [1.5026245697590837, -0.3777839543735636], 2.427996370773135], [1, [1.5016454143890128, 0.36581574918057513], 2.4442077718679887], [1, [-1.5011561130667266, -1.508219442815438], 4.627074890354601], [1, [1.501162648912065, 1.508216608861928], 4.6270781921799795], [1, [4.864646500024779, -0.37876282590485644], 24.23053472576223], [1, [1.502785982921585, 2.643849655136743], 9.446350812035593], [1, [-1.5011378110262263, -2.645647185955959], 9.443425292148273], [1, [-2.6154346916437214, 1.5187318189028522], 9.33642478577635], [1, [2.615434543075803, -1.5187322145209268], 9.336425071335988], [1, [-3.7387289084707955, 1.5189531872981759], 16.604455118127724], [1, [-4.865681092629111, -0.3790508666056302], 24.22971260441161], [1, [0.37463473519293344, -4.912719368589128], 24.783692380196815], [1, [4.854281411346995, -4.140248237827233], 41.78180328886291], [1, [-4.127977516139776, -1.5194194452795593], 19.58233106840445], [1, [-3.7497374050687013, -2.655800493418444], 21.40788507871387], [1, [-4.860811619864728, 4.9171304835316425], 48.72824138625055], [1, [-3.752298264045018, -4.91654783366244], 38.8951947164907], [1, [-2.6273238720050656, -4.910245411746782], 31.628387347494474], [1, [2.627324711726065, 4.9165290386745255], 31.626973512428826], [1, [0.37497047954609575, 4.9165441086466855], 24.782948244561656], [1, [-0.37497034890691894, -4.9165453845467635], 24.7829481330946], [1, [2.626270381159805, 0.37724472875433784], 7.133563481277321], [1, [-2.6262702009885652, -0.3772447286787419], 7.133563550330672], [1, [4.871084435667142, 2.655226713286288], 31.2334531964539], [1, [-2.6273422180378163, 4.910265513948288], 31.628376942733688], [1, [4.872547928630965, -2.655595670288228], 31.233101761204374], [1, [-2.62375924610519, -3.7846881618104438], 21.582891187318218], [1, [0.3752289293585684, -1.5172094536910459], 2.4787581549585522], [1, [0.3749879915836662, -2.656328349330941], 7.294802567797269], [1, [-2.617600346900492, 0.36884056745434607], 7.152591591740751], [1, [0.3749577041619876, -3.7914318638620865], 14.733499452097904], [1, [0.37495765034082684, 3.7914333586113544], 14.733499208838257], [1, [-4.871104258943163, 0.3786214857431522], 24.227178066681265], [1, [-0.3745766334217193, 2.6548213889480974], 7.295255608496956], [1, [4.869707325904163, 0.37822484581447774], 24.227697119977076], [1, [-3.749985404096978, -0.37842135030576773], 14.401699600214707], [1, [-0.37522089032015143, 1.5172018951030068], 2.478761157599927], [1, [-0.3689807743268512, -1.510805699162014], 2.4882149657652057], [1, [2.616289482664694, -0.37035624444917237], 7.152432387967042], [1, [-0.3684890762795017, -2.646987811608376], 7.307102878055121], [1, [0.36982313251816257, 2.6475683792853784], 7.304650057406942], [1, [0.368944158391771, 1.5107654114989317], 2.4883147543313324], [1, [3.750307069261589, -4.909948399139429], 38.897202377962046], [1, [-3.752214295511748, 4.916366429906573], 38.89522312108798], [1, [1.5040971025643386, -4.130748297516529], 19.986283118973223], [1, [3.749465051293259, -3.7908897660514733], 28.846719792307887], [1, [-0.37281675815354226, 3.7818161539324007], 14.740707516844859], [1, [-0.37334764859319824, -3.783561632656835], 14.73858510823853], [1, [-3.7509923376739227, 3.7880261168995353], 28.847212876287514], [1, [4.852853185743546, -3.757425398888039], 38.74473893115591], [1, [3.7400717568003596, 0.37614958351319416], 14.413400152010436], [1, [3.740170685431869, -0.3822831179275762], 14.412583336130462], [1, [-3.7358881223184635, 0.37415996351315783], 14.423029552032261], [1, [-0.375350983706127, 4.910482800937391], 24.78424967996748], [1, [-3.742527500075041, -3.788112305038172], 28.854447637218748], [1, [4.4305818868908835, -1.5193073375768995], 22.986757650726886]], "nr_of_basins": 99, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-8.29681304144705e-163, 6.596494477790871e-163], "f_opt_dim_5": 0.11279448545522994, "x_opt_dim_5": [4.637389778723031e-10, 3.2253167823549095e-10, -0.3336048408665543, 7.74892614872824e-11, 1.4793355800832524e-10]}
{"id": "42091572-531f-41da-b741-240b2468ced1", "fitness": 0.6503560121564078, "name": "landscape_sep_bumpy_glocal_enhanced", "description": "A novel separable benchmark with a quadratic base plus sin^2 bumps, enhanced by a robust GlobalLocal contrast score. For each dimension the per-dimension function is f_i(x_i) = x_i^2 + a_i * sin^2(k_i * x_i). The global minimum is at the origin. The GlobalLocal score is improved by evaluating, on a dense 1D grid per dimension, the strongest non-global local minimum and computing a contrast metric gl_i = max(0, (mean_f - local_min_val) / mean_f). The overall GlobalLocal score is the average of gl_i across dimensions, reflecting how visible the strongest local minima are relative to the typical 1D landscape level.", "code": "import numpy as np\n\nclass landscape_sep_bumpy_glocal_enhanced:\n    \"\"\"\n    Enhanced separable benchmark: per-dimension f_i(t) = t^2 + a_i * sin^2(k_i * t),\n    with deterministic increasing amplitude a_i and frequency k_i across dimensions.\n    Global minimum at origin. GlobalLocal score computed as a robust contrast measure:\n    for each dimension, compute the strongest non-global local minimum on a dense 1D grid,\n    then compute gl_i = max(0, (mean_f - local_min_val) / mean_f).\n    The overall GlobalLocal score is the average of gl_i across dimensions.\n    \"\"\"\n    def __init__(self, dim=5, grid_points=1001, domain=(-5.0, 5.0)):\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.domain = (float(domain[0]), float(domain[1]))\n        # Deterministic per-dimension structure\n        self.a = 0.6 + 0.28 * np.arange(self.dim)  # amplitudes\n        self.k = 1.1 + 0.32 * np.arange(self.dim)  # frequencies\n        self.glocal_score = 0.0\n        self._compute_glocal_score()\n\n    def _compute_glocal_score(self):\n        t = np.linspace(self.domain[0], self.domain[1], self.grid_points)\n        gl_values = []\n        # Estimate index of x = 0 in the grid\n        idx_center = int(round((0 - self.domain[0]) / (self.domain[1] - self.domain[0]) * (self.grid_points - 1)))\n        min_sep = max(1, int(self.grid_points * 0.01))  # skip near-global minimum region\n\n        for i in range(self.dim):\n            f1d = t**2 + self.a[i] * np.sin(self.k[i] * t) ** 2\n            mean_f = float(np.mean(f1d))\n\n            minima_indices = []\n            for j in range(1, len(t) - 1):\n                if f1d[j] <= f1d[j - 1] and f1d[j] <= f1d[j + 1]:\n                    # Exclude the global minimum near x = 0\n                    if abs(j - idx_center) <= min_sep:\n                        continue\n                    minima_indices.append(j)\n\n            if minima_indices:\n                minima_vals = f1d[minima_indices]\n                local_min_val = float(np.min(minima_vals))\n                if mean_f > 0.0:\n                    gl_i = max(0.0, (mean_f - local_min_val) / mean_f)\n                else:\n                    gl_i = 0.0\n            else:\n                gl_i = 0.0\n\n            gl_values.append(gl_i)\n\n        self.glocal_score = float(np.mean(gl_values)) if gl_values else 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Per-dimension function: f_i(t) = t^2 + a_i * sin^2(k_i * t)\n        per_dim = x**2 + self.a * np.sin(self.k * x) ** 2\n        return float(np.sum(per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sep_bumpy_glocal_enhanced scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f0356916-a631-4f19-8f0b-56e96cd1d600"], "operator": null, "metadata": {"ela_features_2D": [0.0006271524949612806, 0.35402050411033814, 0.012403332610388689, 0.047120931862014645, 6.0994025973480435, 0.005622231054505345, 0.9988122088259301, 1.018009004838425, 0.9988069856366794, 0.45732751175513675, -0.48928764297999844, 1.8, 0.728474399969297, 0.7251076087028288, 0.5699670348873802, 0.3352962391626658, -0.19661549750834023, 0.14658487624162236, 0.22945579143116285, 0.3165832491748877, 0.49184035638596163, 0.1518990650242319, 0.22978921981960973, 0.31730975885973184, 0.49442526950482424, -0.4463138035854505, -0.40296730948254533, -0.3574028353676481, -0.26574424767922117, -0.4354553037820291, -0.3954410705672665, -0.3505087431518887, -0.2595526211370981, 1.0, 1.0, 1.0, 1.0, 0.5131081875897647, 0.5130816797829686, 0.3971434326370915, 0.3591567963943791, 0.7098513653086475, 0.41341341341341326, 0.537586555945801, -0.07507507507507508, 0.3710843373493976], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9017489552497864, "ela_features": [-0.0012264640721542763, 0.3947565696640768, 0.002050577422394644, 0.01790748286546841, 13.251764712506851, 0.0038658464448965368, 0.9967797600290492, 1.0226422877801036, 0.9967731319108983, 0.26807610226437745, -0.17743430580094416, 1.4, 0.9110206176125788, 0.8750414817041477, 0.6375199662764358, 0.1818590277352267, -0.4765810489234287, 0.4405379178497624, 0.5194960908126524, 0.5920757311753106, 0.7135513277202687, 0.4481391539677757, 0.5229698459659765, 0.5947052554413529, 0.717784045932371, -0.4920690693680886, -0.422621179723892, -0.3587835732990697, -0.2519418753751096, -0.4877786892017181, -0.42163585066537734, -0.3582281357989116, -0.2494429020415175, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21669017523215076, 0.2166871604358859, 0.20277276837421865, 0.1818033915879713, 0.8240541945530063, 0.11311311311311308, 0.2521052329505303, -0.37537537537537524, 0.5081730769230769], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.00018718582578003407, "ela_features_10D": [-0.0015622226525596305, 0.4522726429997544, 0.0006152877725021301, 0.015447970020407677, 83.96510633414974, 0.0025324472110400454, 0.9913454314303678, 1.0335723747849936, 0.9912915687247434, 0.18645035386114234, -0.10765545753666306, 1.4, 1.0272471659587121, 0.9404839789361275, 0.7219512241082701, 0.10366293831740694, -0.6032835024698943, 0.6143792501301519, 0.6753976335709891, 0.7267666530444847, 0.8051092169902839, 0.6161606817513087, 0.6799784946010327, 0.7309755434411598, 0.8097910848795074, -0.48902113983732687, -0.4116411080168918, -0.34649815001841516, -0.24714875758254967, -0.4879797937353835, -0.40684723900962716, -0.3420145276633712, -0.2418150496760823, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10879464010703832, 0.10878905714434708, 0.10592183017139689, 0.09929931532681166, 0.856524477964135, -0.13113113113113106, 0.12319385162653351, -0.6636636636636635, 0.5854283426741393], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.00019993186288047582}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 8.889741642640113e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [8.665749563614006e-163, -4.382869515093781e-163], "f_opt_dim_5": 3.8704848956020634e-282, "x_opt_dim_5": [-4.828737010413683e-142, -9.200405081569072e-142, 4.71573424016467e-143, 1.9674211561793845e-142, 2.786745956229538e-142]}
{"id": "e2af5e0f-5b4f-477b-b88b-599eb0720d3e", "fitness": 0.6510695352917537, "name": "landscape_separable_minquad_wells_enhanced_glocal", "description": "Enhanced strictly separable per-dimension min-quadratic wells with explicit grid-based GlobalLocal scoring. Each dimension has its own set of wells; the global minimum is at the origin. The GlobalLocal measure is computed by a grid-based analysis of each 1D subproblem and aggregating a ratio of the deepest local well depth to the mean 1D landscape value, yielding a clear, tunable contrast between global and local minima while preserving separability.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_enhanced_glocal:\n    \"\"\"\n    Enhanced strictly separable benchmark with explicit GlobalLocal scoring:\n    - Each dimension i has its own per-dimension set of wells centers s_i_j in [-L, L].\n    - The per-dimension contribution is f_i(x_i) = min_j [ (x_i - s_i_j)^2 + d_i_j ].\n    - Global minimum is at x = 0 with f(x) = 0 (guaranteed by a well at 0 with depth 0).\n    - Wells per dimension are generated deterministically (grid) or reproducibly via seed.\n    - Depths d_i_j are assigned so that wells farther from zero are deeper (GlobalLocal control).\n    - The GlobalLocal score is computed via a grid-based analysis of the 1D landscape, as:\n      for each dimension, GL_i = max_depth_i / mean_fitness_1d_i, and the overall\n      GL score is the average of GL_i across dimensions.\n    - This keeps the problem fully separable: f(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None, deterministic=False):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: the span of wells along each axis; wells lie in [-L, L]\n        contrast: scales the depth of non-global wells (GlobalLocal control)\n        seed: random seed for reproducibility (optional)\n        deterministic: if True, use a deterministic grid for well centers (enhances reproducibility)\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.rng = np.random.default_rng(seed)\n        self.deterministic = bool(deterministic)\n\n        # 1) Build per-dimension well centers and depths\n        self.s = np.zeros((self.dim, self.wells), dtype=float)\n        self.d = np.zeros((self.dim, self.wells), dtype=float)\n\n        for i in range(self.dim):\n            if self.deterministic:\n                # Deterministic grid in [-L, L]\n                s = np.linspace(-self.L, self.L, self.wells)\n                s = s.astype(float)\n            else:\n                # Randomized centers; reproducible via seed when provided\n                s = self.rng.uniform(-self.L, self.L, size=self.wells).astype(float)\n                s.sort()\n\n            # Guarantee a well at 0 for the global minimum\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n\n            # Order wells by increasing distance to zero so that shallower wells are closer\n            order = np.argsort(np.abs(s))\n            s_sorted = s[order]\n\n            # Depths increase with distance from zero\n            depths = np.arange(self.wells, dtype=float) * self.contrast\n            d_sorted = depths[order]\n\n            self.s[i, :] = s_sorted\n            self.d[i, :] = d_sorted\n\n        # 2) Compute a grid-based GlobalLocal score to quantify the contrast\n        #    GL_i = max_depth_i / mean_fitness_1d_i; global-local score is the average over dims\n        grid_points = 401\n        grid = np.linspace(-self.L, self.L, grid_points)\n        glocal_per_dim = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            # Evaluate 1D landscape on the grid for dimension i\n            x_grid = grid.reshape(-1, 1)  # (G, 1)\n            # (G, wells) distances to all centers\n            diffs = (x_grid - self.s[i, :])**2 + self.d[i, :]\n            f_vals = diffs.min(axis=1)  # min over wells for each grid point\n            mean_fitness_i = float(f_vals.mean())\n            max_depth_i = float((self.wells - 1) * self.contrast)\n            # Avoid division by zero (though mean_fitness_i should be > 0 due to d>0 except at 0)\n            if mean_fitness_i <= 0:\n                glocal_per_dim[i] = 0.0\n            else:\n                glocal_per_dim[i] = max_depth_i / mean_fitness_i\n\n        self.glocal_score = float(np.mean(glocal_per_dim))\n\n    def f(self, x):\n        \"\"\"\n        x: real-valued sample (numpy array) with dimension up to self.dim\n        Returns a scalar fitness value to be minimized.\n        Each dimension contributes: min_j ( (x_i - s_i_j)^2 + d_i_j )\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)  # (d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]  # (d, wells)\n        min_vals = vals.min(axis=1)  # (d,)\n        return float(min_vals.sum())", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquad_wells_enhanced_glocal scored on:Separable 1.000, GlobalLocal 0.016,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4372db49-ec02-445f-9e4e-8994dc60ee62"], "operator": null, "metadata": {"ela_features_2D": [0.7662076739980613, -0.0340535230869051, 0.3788814355019474, 0.5250070250032293, 1.3871906491413664, 0.766187972580451, 0.9372285949482906, 8.321221589539363, 0.9578661150560794, 0.23326486216628797, -0.5207790997298801, 1.4, 0.6458020393753864, 0.7068599083929059, 0.5270166998610278, 0.34331577676083713, -0.148486037910957, 0.1527723741618674, 0.22378059734088374, 0.33100207795613834, 0.5455675386528794, 0.1590495569417086, 0.22838734728863094, 0.32557795773636844, 0.5354098950720487, -0.443144325186769, -0.4060008053738198, -0.34991613534791366, -0.23769110232135388, -0.43174578939321523, -0.39614689526317326, -0.34623854496002454, -0.23851639405767858, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5288455316524537, 0.528837653987876, 0.5866680444155081, 0.6350261194129201, 0.7348565713090129, 0.3813813813813812, 0.4665798987309146, -0.1631631631631631, 0.38112449799196785], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.8875954747200012, "ela_features": [0.6726885830687992, -0.07049776107665165, 0.09062204961875434, 0.31353772953535386, 3.461978814777092, 0.6733581741677747, 0.9016952853292576, 21.51614900351601, 0.967159429133787, 0.1689536290010195, -0.24863643964535492, 1.0, 0.8540939891680674, 0.8632301483751016, 0.6172058102368212, 0.19107734890070396, -0.34725015456023367, 0.47682611122176544, 0.6085409538152754, 0.6861874777118796, 0.8082818897295857, 0.4719364155852704, 0.5954590179900168, 0.6768470631180481, 0.8041092723562467, -0.46010325407582425, -0.3442644486373446, -0.2759771036350429, -0.16860512877004669, -0.4665552660712251, -0.35741415513704183, -0.28550149119601737, -0.1730704756555041, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21556691372211487, 0.21558830918694305, 0.23960204240698285, 0.3049017063724313, 0.8195519068113912, 0.05705705705705703, 0.18657731198372743, -0.5075075075075073, 0.5081730769230769], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.003053065622225404, "ela_features_10D": [0.5048282201749883, 0.09438079553223785, 0.011191026366803797, 0.16427490864196892, 114.53234659135342, 0.5067147056600303, 0.9115086841725886, 86.82340837052884, 0.9794120200561236, 0.32368339759832127, 0.03473698029120982, 1.2, 0.9353558730682332, 0.9269948591635936, 0.6737234021047235, 0.11295106850626353, -0.47577766972589847, 0.7286119980848834, 0.7756926822692594, 0.8142375482246413, 0.8771449088606197, 0.7271631937230624, 0.775843180357181, 0.8147661623299228, 0.8780715410182879, -0.3442031475051067, -0.28449028923016606, -0.23560388104102362, -0.15581826954219627, -0.34696777476150337, -0.28506120546371616, -0.23556418432644097, -0.155058787530073, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11051178755950983, 0.1105084852059279, 0.11680493660536799, 0.15755637245535048, 0.8560216268048316, -0.16316316316316315, 0.10516690658494783, -0.7277277277277274, 0.5747798238590873], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.01576867140829563}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-3.734888888888906, -3.888888888888889], 0.004897664394594902], [6, [-3.734888888888906, -2.5537777777778023], 1.0000002619698687], [6, [-1.0875555555555558, -2.5537777777778023], 2.000000189448934], [6, [2.6517777777777924, -2.5537777777778023], 7.000000837711163], [9, [-3.734888888888906, 2.4777777777778116], 8.00000019734485], [9, [-1.0875555555555558, 2.4777777777778116], 9.000000124823915], [9, [2.6495689978538435, 2.478710168120976], 14.000002466447992], [3, [1.1662013318492923, 2.4663236611528574], 13.000133663852829], [6, [2.613478496543529, -3.8581049017658167], 6.0029372299795325], [2, [1.1595968038936877, -2.562696991037303], 6.000119399872958], [9, [-1.0875555555555558, -1.207555555555556], 3.000000603178055], [9, [2.6502752958013285, -1.2061736921758504], 8.000000861736641], [9, [-3.734888888888906, -1.2073333333333354], 2.000000414039151], [3, [1.1660502583912666, -1.2062847961835106], 7.000000379615281], [6, [-1.1181088672827528, -3.874423571536635], 1.003995141782019], [2, [1.12090898367473, -3.855121381665848], 5.00337019302235]], "nr_of_basins": 16, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.910284341266629, -3.059093977789284], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.535711447361714, -3.9382002820283235, -3.259515472562434, -3.9045945271174265, -3.0022429543137674]}
{"id": "5a0257d2-a12e-4b85-8896-16b8c96fd76e", "fitness": 0.6664898107712226, "name": "landscape_separable_minquartic_wells_ensemble", "description": "A completely different separable benchmark based on the minimum of a deterministic ensemble of quartic wells per dimension. Each dimension uses several wells with centers evenly spread in [-5,5], including a zero-centered well with zero depth. The objective is the sum over dimensions of the per-dimension min wells, guaranteeing a global minimum at the origin. GlobalLocal contrast is precomputed deterministically by comparing the smallest non-global well depth to the 1D mean of the landscape.", "code": "import numpy as np\n\nclass landscape_separable_minquartic_wells_ensemble:\n    \"\"\"\n    Separable benchmark based on a deterministic ensemble of quartic wells per dimension.\n\n    Per-dimension subproblem:\n      f_i(x_i) = min_j [ (x_i - s_j)^4 + d_j ]\n    - There is a well centered at 0 with depth d_0 = 0, ensuring a global minimum at x_i = 0 with f_i(0) = 0.\n    - Other wells have centers s_j in [-5, 5] and depths d_j > 0, increasing with |s_j|.\n    - The full objective is f(x) = sum_i f_i(x_i).\n\n    GlobalLocal score is precomputed deterministically:\n      local_min = min_j (d_j) over all wells except the zero-centered one\n      mean_i = (1/10) * \u222b_{-5}^{5} f_i(x) dx, approximated numerically on a fine grid\n      GL = 1 - mean( local_min / mean_i )\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Deterministic set of well centers (including a zero-centered well)\n        self.n_wells = 7\n        self.s = np.linspace(-5.0, 5.0, self.n_wells)  # centers\n        # Depths: zero depth at the origin well; depths grow with distance from zero\n        self.d = ((np.abs(self.s) / 5.0) ** 2) * 4.0\n        # Guarantee exact global well at 0\n        idx0 = int(np.argmin(np.abs(self.s)))\n        self.d[idx0] = 0.0\n\n        # Precompute GlobalLocal score deterministically\n        # local_min is the smallest non-global depth (the first non-global local minimum)\n        nonzero_depths = self.d.copy()\n        nonzero_depths[idx0] = np.inf\n        local_min = float(np.min(nonzero_depths))\n\n        # Numerical mean of the 1D landscape across [-5,5]\n        xs = np.linspace(-5.0, 5.0, 10001)\n        # Compute min_j ((x - s_j)^4 + d_j) for each x\n        vals = (xs[:, None] - self.s[None, :])**4 + self.d[None, :]\n        fxs = vals.min(axis=1)\n        mean_i = float(np.mean(fxs))\n        ratio = local_min / mean_i if mean_i != 0 else 0.0\n        self.global_local_score = float(1.0 - ratio)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        Parameters:\n        - x: 1D numpy array of shape (dim,)\n\n        Returns:\n        - float: objective value\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension\")\n\n        # Compute per-dimension min_j ( (x_i - s_j)^4 + d_j )\n        # All dimensions share the same well configuration (separable)\n        diffs = (x[:, None] - self.s[None, :])**4 + self.d[None, :]\n        per_dim = diffs.min(axis=1)\n        return float(per_dim.sum())", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquartic_wells_ensemble scored on:Separable 1.000, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9747d736-ca67-444a-957e-7948ebfe287d"], "operator": null, "metadata": {"ela_features_2D": [-0.0020818637685699136, 0.351517012912703, 0.010289349678112718, 0.027404514495903087, 7.804769270718724, -0.0024462713559333603, 0.9321424680087468, 1.0185259111990212, 0.932232137984602, 0.6911841946634935, 0.07724032940043343, 3.6, 0.5784888167727373, 0.6771806450447928, 0.4781021822674341, 0.362734130593535, -0.21095671462551877, 0.14773558867704134, 0.31502348120468243, 0.3733801417581363, 0.5004812529772502, 0.1499547963454248, 0.3176132521139531, 0.37906177680995823, 0.5021524248059532, -0.4458397564764961, -0.35832819221965584, -0.3277980760980933, -0.26131098016544746, -0.4365858285990285, -0.3504867485334495, -0.3189222955352943, -0.25570364159394937, 1.0, 1.0, 1.0, 1.0, 0.5093889306119561, 0.5093749515435542, 0.4022341665199113, 0.34993470129719884, 0.7249265310233103, 0.7897897897897896, 0.410969656306064, -0.11111111111111112, 0.44497991967871486], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.9971722960472107, "ela_features": [-0.0017906543194246005, 0.3871939916556915, 0.0027761382035865105, 0.02140828068526541, 20.394691661967244, 0.0021802293251210526, 0.9302378763456647, 1.0344692457519724, 0.9304980137973848, 0.4009909501352418, -0.062112845022308696, 1.4, 0.8807264478278765, 0.8621741766344678, 0.5990805133031202, 0.19537012110223778, -0.4935868170908016, 0.4636077956955482, 0.5419402077065215, 0.6141898106980421, 0.7276468287385621, 0.46558741473146287, 0.5421925475623278, 0.615594593496177, 0.7300687351127426, -0.47187288840058256, -0.4029611393735763, -0.3394018798551121, -0.23959310878778126, -0.4725416389025504, -0.4047976819386526, -0.3398938843974937, -0.23867671354501718, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21567850543786254, 0.2156780722409454, 0.20196814433036878, 0.18053355633880916, 0.8469582812073296, 0.24524524524524516, 0.29764301305445856, -0.3273273273273272, 0.5639423076923078], "score_Separable_5D": 0.9998779296875, "score_GlobalLocal_5D": 0.0017636141274124384, "ela_features_10D": [-0.0011197786956664401, 0.40879139888242444, 0.0015911712582541144, 0.016080709812217715, 11.98544681033764, 0.002605270968831186, 0.9308393248486386, 1.047207449997213, 0.9306914438183235, 0.30916771846889424, 0.021966413707853773, 1.2, 1.0091256745353445, 0.9354785007925382, 0.6904564862570817, 0.10880307538160813, -0.6047641497894951, 0.6444437431730407, 0.69716224510468, 0.7421880562138895, 0.8163312577054629, 0.6479931350609349, 0.7010619794343051, 0.7462896273529267, 0.8204670818891099, -0.4509598793935517, -0.3840956703937004, -0.3269882082309749, -0.23295098558472568, -0.4476552414082546, -0.3801656638520997, -0.32264825257875307, -0.22831556432905434, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10936088001322983, 0.10935880690995434, 0.10671191169802327, 0.09951287124505163, 0.8613846544063077, -0.1151151151151151, 0.128613787188688, -0.6596596596596594, 0.6025620496397117], "score_Separable_10D": 0.9998643663194444, "score_GlobalLocal_10D": 0.0002606584457680583}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 8.0], [1, [-1.6666666666666665, -5.0], 4.444444444444445], [1, [1.666666666666667, -5.0], 4.444444444444445], [1, [5.0, -5.0], 8.0], [1, [-5.0, -1.6666666666666665], 4.444444444444445], [1, [-1.6666666666666665, -1.6666666666666665], 0.8888888888888888], [1, [1.666666666666667, -1.6666666666666665], 0.888888888888889], [1, [5.0, -1.6666666666666665], 4.444444444444445], [1, [-5.0, 1.666666666666667], 4.444444444444445], [1, [-1.6666666666666665, 1.666666666666667], 0.888888888888889], [1, [1.666666666666667, 1.666666666666667], 0.8888888888888891], [1, [5.0, 1.666666666666667], 4.444444444444445], [1, [-5.0, 5.0], 8.0], [1, [-1.6666666666666665, 5.0], 4.444444444444445], [1, [1.666666666666667, 5.0], 4.444444444444445], [1, [5.0, 5.0], 8.0], [2, [0.00044444444444512003, -5.0], 4.000000000000039], [2, [3.3337777777777173, -5.0], 5.777777777777818], [2, [0.00044444444444512003, -1.6666666666666665], 0.44444444444448344], [2, [3.3337777777777173, -1.6666666666666665], 2.2222222222222614], [2, [-5.0, 0.00044444444444512003], 4.000000000000039], [2, [-1.6666666666666665, 0.00044444444444512003], 0.44444444444448344], [2, [1.666666666666667, 0.00044444444444512003], 0.44444444444448356], [2, [5.0, 0.00044444444444512003], 4.000000000000039], [2, [0.00044444444444512003, 1.666666666666667], 0.44444444444448356], [2, [3.3337777777777173, 1.666666666666667], 2.222222222222262], [2, [-5.0, 3.3337777777777173], 5.777777777777818], [2, [-1.6666666666666665, 3.3337777777777173], 2.2222222222222614], [2, [1.666666666666667, 3.3337777777777173], 2.222222222222262], [2, [5.0, 3.3337777777777173], 5.777777777777818], [2, [0.00044444444444512003, 5.0], 4.000000000000039], [2, [3.3337777777777173, 5.0], 5.777777777777818], [4, [-0.00044444444444512003, -0.00044444444444512003], 7.803688462172125e-14], [4, [3.3337777777777173, 0.00044444444444512003], 1.7777777777778563], [4, [0.00044444444444512003, 3.3337777777777173], 1.7777777777778563], [4, [3.3337777777777173, 3.3337777777777173], 3.5555555555556344], [2, [-3.33288888888895, -5.0], 5.777777777777817], [2, [-1.6666666666666665, -3.33288888888895], 2.2222222222222614], [2, [1.666666666666667, -3.33288888888895], 2.2222222222222614], [2, [5.0, -3.33288888888895], 5.777777777777817], [2, [-3.33288888888895, -1.6666666666666665], 2.2222222222222614], [2, [-3.33288888888895, 1.666666666666667], 2.2222222222222614], [2, [-3.33288888888895, 5.0], 5.777777777777817], [4, [0.00044444444444512003, -3.33288888888895], 1.7777777777778558], [4, [3.3337777777777173, -3.33288888888895], 3.555555555555634], [4, [-3.33288888888895, 0.00044444444444512003], 1.7777777777778558], [4, [-3.33288888888895, 3.3337777777777173], 3.555555555555634], [4, [-3.33288888888895, -3.33288888888895], 3.5555555555556335], [2, [-4.829654331148018, -3.2452675751238473], 5.778679950595726]], "nr_of_basins": 49, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1047794106126824e-81, 4.236323658402117e-82], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.3466297063382696e-82, -1.0858859598169446e-81, 9.035783387349449e-82, 5.133425077987108e-82, 1.0422996817854915e-81]}
{"id": "90007921-604c-45d0-9d08-d9a006951d66", "fitness": 0.5546046197414398, "name": "landscape_separable_minquad_wells_enhanced_globalloc", "description": "Enhanced strictly separable per-dimension min-quadratic wells with a computed GlobalLocal score. Each dimension has its own wells with depths increasing with distance from zero. The function remains separable with f(x) = sum_i min_j ((x_i - s_i_j)^2 + d_i_j). An explicit grid-based GlobalLocal score (averaged over dimensions) quantifies how easily the strongest non-global local minimum stands out from the global minimum, enabling tunable difficulty and better benchmarking of optimizers.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_enhanced_globalloc:\n    \"\"\"\n    Enhanced strictly separable per-dimension min-quadratic wells with deterministic or seeded wells.\n    Adds a computed GlobalLocal score using a 1D grid analysis to quantify the contrast between the\n    strongest non-global local minima and the global minimum, averaged over dimensions.\n    - Global minimum is guaranteed at x = 0 with f(x) = 0 (due to a well at 0 with depth 0).\n    - Wells per dimension are generated deterministically (grid) or reproducibly via seed.\n    - Depths increase with distance from zero to boost GlobalLocal contrast.\n    - The overall objective remains additive across dimensions: f(x) = sum_i f_i(x_i).\n    \"\"\"\n    def __init__(self, dim=5, wells=9, L=4.0, contrast=1.0, seed=None, deterministic=False, grid_points=401):\n        \"\"\"\n        dim: number of dimensions\n        wells: number of local wells per dimension (>=3)\n        L: span of wells along each axis; centers lie in [-L, L]\n        contrast: base scale for the depth of non-global wells (GlobalLocal control)\n        seed: random seed for reproducibility (optional)\n        deterministic: if True, use a deterministic grid for well centers\n        grid_points: number of points in the 1D grid used to compute the GlobalLocal score\n        \"\"\"\n        self.dim = int(dim)\n        self.wells = int(max(3, wells))\n        self.L = float(L)\n        self.contrast = float(contrast)\n        self.seed = seed\n        self.rng = np.random.default_rng(seed)\n        self.deterministic = bool(deterministic)\n        self.grid_points = int(grid_points)\n\n        # Storage for per-dimension wells: centers s[i, :] and depths d[i, :]\n        self.s = np.zeros((self.dim, self.wells), dtype=float)\n        self.d = np.zeros((self.dim, self.wells), dtype=float)\n\n        for i in range(self.dim):\n            if self.deterministic:\n                # Deterministic grid in [-L, L]\n                s = np.linspace(-self.L, self.L, self.wells).astype(float)\n            else:\n                # Random centers; preserve reproducibility via seed\n                s = self.rng.uniform(-self.L, self.L, size=self.wells).astype(float)\n                s.sort()\n\n            # Guarantee a global well at 0\n            idx_zero = int(np.argmin(np.abs(s)))\n            s[idx_zero] = 0.0\n\n            # Order wells by increasing distance to zero\n            order = np.argsort(np.abs(s))\n            s_sorted = s[order]\n\n            # Depths increase with distance from zero\n            depths = np.arange(self.wells, dtype=float) * self.contrast\n            d_sorted = depths[order]\n\n            self.s[i, :] = s_sorted\n            self.d[i, :] = d_sorted\n\n        # Precompute GlobalLocal score using a 1D grid for each dimension\n        self.globalscore = self._compute_global_local_score()\n\n    def _1d_f(self, x, s_row, d_row):\n        \"\"\"\n        Compute f_i(x) = min_j ((x - s_row[j])^2 + d_row[j])\n        x: 1D array of points\n        s_row: per-dimension centers (length wells)\n        d_row: per-dimension depths (length wells)\n        Returns 1D array of f_i(x) values.\n        \"\"\"\n        xv = np.asarray(x, dtype=float)\n        vals = (xv[:, None] - s_row[None, :])**2 + d_row[None, :]\n        return vals.min(axis=1)\n\n    def _compute_global_local_score(self):\n        \"\"\"\n        Compute a grid-based GlobalLocal score for the whole landscape:\n        - For each dimension, evaluate the 1D landscape on a grid in [-L, L].\n        - Identify the global minimum (expected at x=0, value 0).\n        - Identify the strongest non-global local minimum (minimum on the grid excluding x=0).\n        - Compute contrast_i = (local_min_i - global_min) / mean(f_i over grid).\n        - GlobalLocal score is the average of contrast_i over all dimensions.\n        \"\"\"\n        grid_x = np.linspace(-self.L, self.L, self.grid_points)\n        # index of x closest to 0 (robust to grid layout)\n        idx_zero = int(np.argmin(np.abs(grid_x)))\n        contrasts = []\n        for i in range(self.dim):\n            F = self._1d_f(grid_x, self.s[i, :], self.d[i, :])\n            fmin = float(F.min())  # should be 0 due to a zero-depth well\n            # Exclude the global minimum location\n            F_non_global = np.delete(F, idx_zero)\n            local_min = float(F_non_global.min())\n            mean_val = float(F.mean())\n            denom = mean_val if mean_val != 0 else 1.0\n            contr = (local_min - fmin) / denom\n            contrasts.append(contr)\n        return float(np.mean(contrasts))\n\n    def f(self, x):\n        \"\"\"\n        Objective function:\n        f(x) = sum_i min_j [ (x_i - s_i_j)^2 + d_i_j ]\n        Works for x of any dimension; evaluates up to self.dim.\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        d = min(self.dim, x.size)\n        t = x[:d].reshape(d, 1)\n        vals = (t - self.s[:d, :])**2 + self.d[:d, :]\n        min_vals = vals.min(axis=1)\n        return float(min_vals.sum())", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquad_wells_enhanced_globalloc scored on:Separable 1.000, GlobalLocal 0.017,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4372db49-ec02-445f-9e4e-8994dc60ee62"], "operator": null, "metadata": {"ela_features_2D": [0.9373048116042657, -0.09719337174475598, 0.466343586983154, 0.5523261889994149, 1.1841940990334539, 0.9373274609529505, 0.9704835175189993, 54.22008413044732, 0.9788456492169493, 0.20372611319445086, -0.4911132033711076, 1.0, 0.6822613123046758, 0.7096538010852194, 0.519237186084536, 0.3454902613316643, -0.11371233583872953, 0.13802915906724303, 0.2292940753187934, 0.3337433356818017, 0.5431987516322712, 0.13557714800050974, 0.22733020944386184, 0.32464002756575394, 0.519894413892602, -0.4509693933977951, -0.4032200448360127, -0.3485701870453188, -0.23899139481680445, -0.44394160339626954, -0.3968145289152143, -0.34682707001583973, -0.24657425987006337, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5110690967299673, 0.5110517775906536, 0.6048233523159845, 0.659407548054831, 0.7408024960989343, 0.23323323323323314, 0.3442190397068619, -0.2792792792792792, 0.38795180722891565], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.20869916677474976, "ela_features": [0.7707685738333261, -0.09676768629641345, 0.11296700811129194, 0.30017137018745255, 2.658312294576562, 0.7708317657204222, 0.8689243117126415, 8.561593396072704, 0.9552687498334658, 0.08012557238352944, -0.23581827149074258, 1.4, 0.8413012235881135, 0.8603893471770634, 0.6090447933764318, 0.1940561739852019, -0.3321595125937543, 0.5254260132970632, 0.6296098256751321, 0.7149597095986147, 0.8226645781248847, 0.5108379152318168, 0.6152459816581036, 0.7043469302424386, 0.8183354735785533, -0.4174519527290679, -0.3258105631953631, -0.2507339392205045, -0.15599297177428778, -0.4326237744663013, -0.34028657559120756, -0.26148923359928594, -0.16067560648349566, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21487663012129743, 0.21486708040807376, 0.2372837006787102, 0.31086869708883896, 0.8332637902138597, 0.017017017017016984, 0.19457816524985944, -0.5395395395395394, 0.5397435897435898], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.10178208351135254, "ela_features_10D": [0.492279667435653, -0.04725669178491414, 0.0072592183949543145, 0.17418989352177588, 30.085772654156017, 0.4948018156158732, 0.9046166776483864, 98.92374581410668, 0.9667405425939201, 0.16412334954865243, -0.03661934974470702, 1.4, 0.9393793453195824, 0.9290771919104314, 0.6781119806655364, 0.11106884675072529, -0.49733282204202245, 0.7127832880914604, 0.7657949684942797, 0.8082734079580618, 0.8702390922358753, 0.7123142768438437, 0.7669688246169135, 0.8091768520583708, 0.8712186446644414, -0.36425098784127086, -0.29702124229129545, -0.2431496658018196, -0.16456399084947435, -0.3657664819557465, -0.2962782887561408, -0.2426146663320638, -0.16373391772627102, 0.9, 0.9, 0.8545454545454545, 0.909090909090909, 0.10900375031312222, 0.10900508894747676, 0.11628556826852973, 0.15696776452633107, 0.8506213694902316, -0.18318318318318316, 0.11085966144982577, -0.7397397397397395, 0.5680544435548438], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.01714646816253662}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [-3.9040000000001207, -2.376666666666625], 1.000000081706947], [18, [-3.9040000000001207, 2.245777777777837], 8.000000049804989], [12, [-3.9039389578024797, -0.08733333227112229], 4.0000000822355055], [22, [-3.9040000000001207, -3.4208888888889404], 1.3809167490872116e-07], [12, [1.5344342077429798, 2.2452819722463166], 16.000000406234136], [20, [1.5344632696156104, -3.420480582517329], 8.000000346250966], [8, [1.530786716628029, -0.09359629807075648], 12.000046090535356]], "nr_of_basins": 7, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.745225536593016, -2.3655064768580774], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.472116297987843, -3.9885025000966676, -1.786343117993182, -3.1903568002796865, -2.4578748059063367]}
{"id": "13627b85-e5c0-420e-9218-b5b0de032864", "fitness": 0.510904110056193, "name": "landscape_separable_minquad_wells_min_of_quadratics", "description": "A fully separable landscape based on a min-of-quadratics per dimension. Each dimension has a set of shifted quadratic wells; the per-dimension cost at u is the minimum across these wells, guaranteeing a global minimum at the origin. Local minima appear at the well centers, giving tunable GlobalLocal contrast. The function remains additive across dimensions and is bounded to [-5, 5] per coordinate.", "code": "import numpy as np\n\nclass landscape_separable_minquad_wells_min_of_quadratics:\n    \"\"\"\n    Separable landscape built from a per-dimension min of shifted quadratics.\n\n    For each dimension i, define wells as:\n        g_i(u) = min_j [ (u - c_{i,j})^2 + d_{i,j} ]\n    where:\n      - c_{i,0} = 0, d_{i,0} = 0 (global minimum at u=0 with value 0)\n      - c_{i,j>0} are centers away from zero\n      - d_{i,j>0} are positive depths\n\n    The total objective is:\n        f(x) = sum_i g_i(x_i)\n\n    GlobalLocal is computed via a 1D grid analysis of g_i to estimate the\n    strongest non-global local minimum per dimension, averaged across dimensions.\n    \"\"\"\n\n    def __init__(self, dim=5, wells_per_dim=4, grid_points=1001, seed=None):\n        \"\"\"\n        Initialize the landscape.\n\n        Parameters:\n        - dim: int, number of dimensions\n        - wells_per_dim: int, number of wells per dimension (including the origin well)\n        - grid_points: int, resolution for the 1D grid used to estimate GlobalLocal\n        - seed: int or None, RNG seed for reproducibility\n        \"\"\"\n        self.dim = int(dim)\n        self.grid_points = int(grid_points)\n        self.wells_per_dim = max(2, int(wells_per_dim))  # at least origin + one other well\n\n        self.rng = np.random.default_rng(seed)\n\n        # Per-dimension wells: centers c_{i,j} and depths d_{i,j}\n        # Include origin as the first bowl: c=0, d=0\n        self.per_dim_params = []\n        for _ in range(self.dim):\n            centers = [0.0]\n            depths = [0.0]\n            # Add additional wells with centers away from zero\n            attempts = 0\n            while len(centers) < self.wells_per_dim:\n                attempts += 1\n                if attempts > 5000:\n                    break\n                c = self.rng.uniform(-4.0, 4.0)\n                # enforce a minimum separation from existing centers to ensure distinct wells\n                if any(abs(c - ec) < 0.5 for ec in centers):\n                    continue\n                centers.append(float(c))\n                depths.append(float(self.rng.uniform(0.05, 0.8)))\n            # Sort by centers to have deterministic order\n            order = np.argsort(centers)\n            centers = [centers[i] for i in order]\n            depths = [depths[i] for i in order]\n            self.per_dim_params.append({\n                'centers': centers,\n                'depths': depths\n            })\n\n        # GlobalLocal descriptor: compute per-dimension contrast using a 1D grid\n        grid = max(5, int(self.grid_points))\n        gl_values = []\n        for i in range(self.dim):\n            centers = self.per_dim_params[i]['centers']\n            depths = self.per_dim_params[i]['depths']\n\n            t = np.linspace(-5.0, 5.0, grid)\n            # g1d(t) = min_j [ (t - c_j)^2 + d_j ]\n            stack = []\n            for c, d in zip(centers, depths):\n                stack.append(d + (t - c)**2)\n            g1d = np.min(np.stack(stack, axis=0), axis=0)\n\n            mean_f1d = float(np.mean(g1d))\n            min_idx = int(np.argmin(g1d))\n\n            # Detect local minima (excluding the global minimum index)\n            local_min_vals = []\n            for idx in range(1, len(t) - 1):\n                if idx == min_idx:\n                    continue\n                if g1d[idx] <= g1d[idx - 1] and g1d[idx] <= g1d[idx + 1]:\n                    local_min_vals.append(float(g1d[idx]))\n\n            if len(local_min_vals) == 0:\n                # fall back to any non-global point\n                non_global_vals = [val for j, val in enumerate(g1d) if j != min_idx]\n                min_non_global = float(min(non_global_vals)) if non_global_vals else float(g1d[min_idx])\n            else:\n                min_non_global = float(min(local_min_vals))\n\n            per_dim_contrast = min_non_global / (mean_f1d if mean_f1d != 0 else 1.0)\n            gl_values.append(per_dim_contrast)\n\n        self.GlobalLocal = float(np.mean(gl_values))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        f(x) = sum_i g_i(x_i) where g_i(u) = min_j [ (u - c_{i,j})^2 + d_{i,j} ]\n\n        Bounds: -5 <= x_i <= 5 for all i.\n\n        Parameters:\n        - x: 1D numpy array of length dim\n\n        Returns:\n        - scalar: landscape value at x\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        x = np.clip(x, -5.0, 5.0)\n\n        total = 0.0\n        for i in range(self.dim):\n            t = x[i]\n            centers = self.per_dim_params[i]['centers']\n            depths = self.per_dim_params[i]['depths']\n\n            # g_i(t) = min_j [ (t - c_j)^2 + d_j ]\n            g_values = [ (t - c)**2 + d for c, d in zip(centers, depths) ]\n            total += float(min(g_values))\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_separable_minquad_wells_min_of_quadratics scored on:Separable 1.000, GlobalLocal 0.021,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5f9f807d-e8b4-4cbd-a7b5-b3a14b419180"], "operator": null, "metadata": {"ela_features_2D": [0.5688301857934409, -0.0655603292557044, 0.049329067210965936, 0.5963778719534251, 19.171284374187216, 0.5706501783410092, 0.9320146782981492, 3.1799249497970066, 0.9848829926021547, 1.524765447501892, 1.2980243079937854, 1.4, 0.41620523284742383, 0.6695336308582105, 0.33316312778918045, 0.35407974508320766, -0.13274930522075315, 0.33163464480413185, 0.4966842188626076, 0.5407251800171894, 0.6371723629166361, 0.34361676353504694, 0.5099932388286867, 0.5435492247619719, 0.6361480761341769, -0.34967894260569654, -0.26332928869278327, -0.2402899284727101, -0.1898272211903865, -0.336750582926592, -0.2514875040880029, -0.23428812431089327, -0.1867717492276213, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5181313664575182, 0.5180737697226214, 0.5536218516820772, 0.5884922407825479, 0.6924495874285335, 0.4934934934934934, 0.27810696218142306, -0.3313313313313312, 0.39397590361445783], "score_Separable_2D": 1.0, "score_GlobalLocal_2D": 0.043508291244506836, "ela_features": [0.4643297637409069, -0.12319265011022935, 0.02200387088073912, 0.29250233067743187, 16.867764672270717, 0.46655783586036426, 0.9350109047007029, 6.772566315986744, 0.9844561383574713, 0.8673939011982947, 0.4427030085464538, 1.8, 0.8355604872904403, 0.8621675528875764, 0.5911447744279068, 0.19169874808034515, -0.36704909935465146, 0.569575159753995, 0.6258282488060549, 0.6757129825262436, 0.7575315829022284, 0.5759353397253962, 0.624990568829166, 0.6703687521565163, 0.7535558229424842, -0.37864958421573575, -0.32916305556810344, -0.2852779309348623, -0.21330057719533765, -0.37489842824044556, -0.3315353096098575, -0.29140787736723617, -0.217866201040584, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21271486568331682, 0.21269338065385898, 0.22519852460557205, 0.28049242868843305, 0.8111740946580543, 0.1371371371371371, 0.17879764849853533, -0.49949949949949934, 0.534775641025641], "score_Separable_5D": 1.0, "score_GlobalLocal_5D": 0.001403713715262711, "ela_features_10D": [0.4630572091065477, 0.45553616440008043, 0.0051641935723559, 0.21910860757207598, 83.09772216747157, 0.46503534514172473, 0.9238146169121191, 81.10269034081766, 0.9744538973740223, 0.6980191706790337, 0.33019102350804574, 2.0, 0.9172388478163869, 0.9277501877998627, 0.6447866048700104, 0.11397448556579279, -0.4745504013771912, 0.7316951021281223, 0.7670748293414184, 0.7988848766138119, 0.8579358718358566, 0.7307017054885291, 0.7650600270968384, 0.7976331353544219, 0.8577516841842222, -0.34026633768852405, -0.2953968869180829, -0.25505532066870895, -0.1801664504642356, -0.3424151433187236, -0.2987263734378741, -0.25730929911774963, -0.18086868564577072, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.1098996039939967, 0.10989855411490064, 0.1141287661039864, 0.15317710389521605, 0.8445434610443444, -0.1351351351351351, 0.11547872648991367, -0.7117117117117114, 0.5738190552441955], "score_Separable_10D": 1.0, "score_GlobalLocal_10D": 0.020512655377388}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-3.5337777777776944, 0.00044444444444512003], 0.11620565454496158], [7, [3.2266662229805436, -0.0007321187422686191], 0.20976915252191797], [6, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [3, [-3.5337777777776944, -1.5026666666666664], 0.6592628277863116], [3, [0.00044444444444512003, -1.5026666666666664], 0.5430575683030785], [2, [3.85669823810761, -1.5035886902348063], 0.6405522119888662], [8, [3.2254282670778918, 2.7268060937745218], 0.6669935118572754], [12, [-3.5337777777776944, 2.726666666666587], 0.5734309497886606], [12, [0.00044444444444512003, 2.726666666666587], 0.4572256903054275], [9, [-3.5337777777776944, -2.5737777777778], 0.4924447530203663], [9, [0.00044444444444512003, -2.5737777777778], 0.3762394935371331], [6, [3.8416385714370667, -2.57140975059618], 0.4740839375370261], [2, [3.225469827515429, -1.5025032086784118], 0.7528254732493095], [6, [3.2253995194608733, -2.5735289705405076], 0.5860074849509189], [8, [3.8609954905517765, 2.7189459721005678], 0.5547617967098115], [1, [3.837321881560635, 0.24791233786449726], 0.15947969765247605]], "nr_of_basins": 16, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.5861118075766487e-164, -5.233420259773843e-163], "f_opt_dim_5": 0.21489682927565268, "x_opt_dim_5": [-4.254298051292345e-09, -8.089076180288845e-10, -9.471746100808433e-11, 3.1908830517717406, 1.699549669982285]}
