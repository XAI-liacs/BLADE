{"id": "7df924f7-a745-49c5-ae81-b50a446188db", "fitness": 0.8812553344915312, "name": "landscape", "description": "A separable, non-homogeneous landscape with per-dimension phase transitions. Each dimension has its own threshold and slopes, yielding a quadratic region near zero and a linear growth beyond the threshold. The objective is to minimize the sum of independent per-dimension terms, with the global optimum at the origin. The varying parameters across dimensions create non-homogeneous structure (phase transitions) while preserving separability.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension phase parameters to create non-homogeneous landscape\n        # h: threshold for phase transition\n        # alpha: quadratic region coefficient\n        # beta: linear growth coefficient outside the threshold\n        self.h = np.zeros(self.dim, dtype=float)\n        self.alpha = np.zeros(self.dim, dtype=float)\n        self.beta = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            # Vary parameters across dimensions to create non-homogeneity\n            t = 0.6 + 0.4 * (i / max(1, self.dim - 1))  # threshold in [0.6, ~1.0]\n            self.h[i] = t\n            self.alpha[i] = 0.6 + 0.6 * (i / max(1, self.dim - 1))  # quadratic coeff in [0.6, ~1.2]\n            self.beta[i] = 1.8 + 1.2 * (i / max(1, self.dim - 1))    # linear slope in [1.8, ~3.0]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        absx = np.abs(x)\n        inside = absx <= self.h\n\n        g = np.empty(self.dim, dtype=float)\n        # Quadratic region\n        g[inside] = self.alpha[inside] * (x[inside] ** 2)\n        # Outside region: linear growth beyond threshold plus constant to ensure continuity\n        g[~inside] = self.beta[~inside] * (absx[~inside] - self.h[~inside]) + self.alpha[~inside] * (self.h[~inside] ** 2)\n\n        return float(np.sum(g))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.784, Separable 0.869,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0031270861074808474, 0.4500775221382883, 0.005263891578406026, 0.020935280856542733, 6.635971906640064, -0.00036030444516210736, 0.9549528594733795, 1.612456130149497, 0.9546327361800981, 0.053180736362381166, -0.789875333721789, 1.4, 0.7033982967910226, 0.7177255860481548, 0.5722892575635764, 0.3375267171235264, -0.19042384991388336, 0.14884778488348707, 0.21362471332589092, 0.3103145566731699, 0.503943095981336, 0.15278439560102597, 0.21754761642995302, 0.309496540946663, 0.49439121286530535, -0.44516822895810176, -0.41128698010387377, -0.3607155945399628, -0.25944515462703555, -0.4352715570527133, -0.4019846387565898, -0.3547393835256418, -0.25975115052302816, 1.0, 1.0, 1.0, 1.0, 0.5214248531307386, 0.5213259526660972, 0.39364342001514735, 0.35223745120565564, 0.7332303167259576, 0.23323323323323314, 0.5747586556792462, -0.07507507507507506, 0.3594377510040161], "score_NOT Homogeneous_2D": 0.9423928968608379, "score_Separable_2D": 0.92236328125, "ela_features": [-0.002510097278244627, 0.5020233503188483, 0.00251565030907837, 0.01689470105030844, 19.121435499684157, 0.0016561375475728113, 0.9562141098212216, 1.6344147154204944, 0.9562527380159989, 0.03544969798534521, -0.3632707688895026, 1.2, 0.8902143745260872, 0.8717428835816368, 0.643289571778288, 0.18230391922359399, -0.46172260161894235, 0.44697462861463233, 0.5418374745778858, 0.6145295989175283, 0.7237457069050753, 0.44380042139931214, 0.5412776666288686, 0.6148501095938522, 0.7256893910474114, -0.4864576995483745, -0.40301672463412136, -0.33907395638834703, -0.24300245995930386, -0.4917631150455823, -0.40558377465064976, -0.34053426421606936, -0.2425335111522413, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2131545668867602, 0.21315270166634429, 0.19849990755097163, 0.1786507719423909, 0.8143794248520873, 0.05305305305305301, 0.23596860098056766, -0.3913913913913913, 0.48782051282051275], "score_NOT Homogeneous_5D": 0.9454509168863297, "score_Separable_5D": 0.8248046875, "ela_features_10D": [-0.0009744623001254338, 0.48188848993743727, 0.0012964472964215755, 0.01711399266279474, 682.3276895687935, 0.002203387597326656, 0.9561365357390812, 1.635813796468471, 0.9562654750663496, 0.03052355457647051, -0.16613814384325928, 1.2, 0.9955903623411111, 0.9357662874690131, 0.6968755913895537, 0.10601488860581529, -0.6059880267509357, 0.632178331968759, 0.6938951936757318, 0.7409226330519428, 0.8147868588384114, 0.6346937235206862, 0.6962795541242991, 0.7442045565441296, 0.8185331331093064, -0.46649862412199583, -0.3882249325877212, -0.32858095059532155, -0.2349009528968154, -0.46456625353760084, -0.3862473303544645, -0.3252992364464319, -0.23077431097225384, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11063942711512731, 0.11064925693309113, 0.10750561796420119, 0.10105385379852741, 0.8542493072459845, -0.12312312312312308, 0.13696635562920362, -0.6316316316316314, 0.5860688550840673], "score_NOT Homogeneous_10D": 0.7838678807020187, "score_Separable_10D": 0.86865234375}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.555555555566365e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0224937293617885e-162, -1.297682678210734e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.743289555748497e-163, -3.3974397721363526e-163, 9.269166678673397e-164, 1.4474363464089062e-162, 4.419401738707913e-163]}
{"id": "9107ab6f-e078-4660-bdd8-df21abbac43a", "fitness": 0.5373870531717936, "name": "landscape", "description": "A separable, non-homogeneous landscape with a phase-transition-like shift from a smooth quadratic core near the origin to a rugged, oscillatory terrain in the outer region. Each dimension contributes independently, and the global optimum is at x = 0 (min value 0). The transition makes the search space non-homogeneous, while preserving separability.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the separable landscape.\n        Each dimension i contributes g_i(x_i) with a phase-transition\n        from a smooth quadratic near 0 to a rugged region as |x_i| grows.\n        Global optimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length self.dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x length must equal self.dim.\")\n\n        # Vectorized per-dimension contribution with a space-dependent transition\n        a = np.abs(x)\n        t = np.minimum(a / 5.0, 1.0)  # transition factor from 0 (near 0) to 1 (far away)\n        base = x * x                    # smooth quadratic part\n        rugged = (np.sin(5 * np.pi * x))**2 + 0.5 * np.abs(np.sin(3 * np.pi * x))  # rugged component\n\n        # g_i(x_i) = (1-t) * base + t * rugged\n        gi = (1.0 - t) * base + t * rugged\n        return float(np.sum(gi))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.038, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0030218623936600687, 0.5497555611504555, 0.007645891919288497, 0.022362248792099824, 8.624873779957742, -0.00260395286267201, 0.2260737565543133, 1.1033567155007504, 0.23362043700564303, -0.19201345859208016, -0.6395913012618822, 1.2, 0.26178201270006063, 0.5893425549592817, 0.29304629741258637, 0.3876762204975174, -0.295542263150953, 0.26287340014288824, 0.38539467387870685, 0.5418469715954235, 0.7373400651968872, 0.15730034102128326, 0.280378854054116, 0.416565131620271, 0.6979796469223465, -0.38568941348805275, -0.3215484026471767, -0.23972914601987724, -0.13743211753720613, -0.4331233811677982, -0.36979338501490566, -0.29984027689130516, -0.15519820874737647, 1.0, 1.0, 1.0, 1.0, 0.5219446069941829, 0.5219380716148243, 0.3994698288191839, 0.35315083814718257, 0.8287858465473013, 1.0380380380380376, 1.235368281727827, 0.28528528528528524, 0.4951807228915663], "score_NOT Homogeneous_2D": 0.17802655696868896, "score_Separable_2D": 1.0, "ela_features": [-0.0017297895478554537, 0.5524828758573472, 0.0020016886624306786, 0.020694049455064534, 17.46261131677648, -0.0019436934149096529, 0.21784130939145258, 1.1949377781756678, 0.2197002191574131, -0.09000887129580815, -0.2840332303631077, 1.2, 0.5782922121438877, 0.7995953526683465, 0.5100816364770309, 0.2311373263214783, -0.5367749055192992, 0.6887122536105643, 0.7395098786421619, 0.7911475001051743, 0.8596866717944888, 0.6830203462741113, 0.7294938187358289, 0.7773828231755628, 0.8453265365965598, -0.27384359423764143, -0.2291613198200501, -0.18373510256546532, -0.12343706406706527, -0.28031571104625275, -0.23922760084162115, -0.19687931573150677, -0.13678889179479825, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21628577904815552, 0.21629379574068025, 0.20287699653189545, 0.18143377155174972, 0.848510162055204, 0.26526526526526517, 0.34248609360680465, -0.2512512512512512, 0.5679487179487179], "score_NOT Homogeneous_5D": 0.00866842269897461, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00041009355172478835, 0.5139138824812709, 0.0015088960488200244, 0.018884204291170197, 16.602326574432418, 0.003484763763361198, 0.22549076562864298, 1.4201876294460851, 0.23506246585313403, -0.07656403789635086, -0.1323655930203988, 1.2, 0.7720393768773602, 0.8997859135313722, 0.5904413407537366, 0.1335948544876792, -0.596429557664859, 0.789974137152686, 0.8336031308645431, 0.864146011606598, 0.9047050812424937, 0.7843255161261693, 0.8262123126955206, 0.8586036551611258, 0.9014363449544842, -0.2663618980037268, -0.21103022796400342, -0.17229467685905608, -0.12085618418042503, -0.2742456585082828, -0.22098139922395124, -0.1797949812183166, -0.12532995869594185, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10924689829360794, 0.10925181368370496, 0.10623898169326854, 0.10007270460013631, 0.868035843430277, -0.011011011011011027, 0.16498523471653537, -0.5435435435435434, 0.6285028022417934], "score_NOT Homogeneous_10D": 0.037627339363098145, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 5.389683877521531e-15], [1, [5.0, -5.0], 5.389683877521531e-15], [1, [-5.0, 5.0], 5.389683877521531e-15], [1, [5.0, 5.0], 5.389683877521531e-15], [1, [3.798888888888899, -5.0], 3.827058748499044], [1, [-5.0, 3.798888888888899], 3.827058748499044], [1, [5.0, 3.798888888888899], 3.827058748499044], [1, [3.798888888888899, 5.0], 3.827058748499044], [1, [-3.7988888888888988, -5.0], 3.827058748499044], [1, [-1.5966666666666665, -5.0], 1.8339892821246457], [1, [-5.0, -3.7988888888888988], 3.827058748499044], [1, [5.0, -3.7988888888888988], 3.827058748499044], [1, [-5.0, -1.5966666666666665], 1.8339892821246457], [1, [5.0, -1.5966666666666665], 1.8339892821246457], [1, [-3.7988888888888988, 5.0], 3.827058748499044], [1, [-1.5966666666666665, 5.0], 1.8339892821246457], [1, [3.798888888888899, -3.7988888888888988], 7.654117496998083], [1, [3.798888888888899, -1.5966666666666665], 5.661048030623684], [1, [-3.7988888888888988, 3.798888888888899], 7.654117496998083], [1, [-1.5966666666666665, 3.798888888888899], 5.661048030623684], [1, [-3.7988888888888988, -3.7988888888888988], 7.654117496998083], [1, [-3.7988888888888988, -1.5966666666666665], 5.661048030623684], [1, [1.596666666666667, -5.0], 1.8339892821246457], [1, [-5.0, 1.596666666666667], 1.8339892821246457], [1, [5.0, 1.596666666666667], 1.8339892821246457], [1, [1.596666666666667, 5.0], 1.8339892821246457], [1, [3.798888888888899, 1.596666666666667], 5.661048030623684], [1, [1.596666666666667, 3.798888888888899], 5.661048030623684], [1, [1.596666666666667, -3.7988888888888988], 5.661048030623684], [1, [-3.7988888888888988, 1.596666666666667], 5.661048030623684], [1, [3.79962268959915, 3.7991608637880647], 7.653979586412404], [1, [-3.7985955785399854, -2.7927408660215405], 7.536519273817241], [1, [-2.7925362225579042, -3.798773471180762], 7.536469098298134], [1, [2.7927397366739277, -3.800595571419205], 7.536519274372123], [1, [3.7987839565959893, -2.7925440891881306], 7.536465797509576], [1, [-3.800595573349966, 2.792739972516473], 7.536519275027729], [1, [2.7927416577762574, 3.7985955765300616], 7.536519274764471], [1, [-2.7933489454902145, 3.8003276258386625], 7.536485394082715], [1, [3.800319263285903, 2.7932147577228252], 7.5364655761730655], [1, [-1.5962406421898814, -3.80012008295386], 5.661017804334853], [1, [1.5972269564110075, 2.7921771188340334], 5.543432775746386], [1, [2.791777777777777, -5.0], 3.7094875738647124], [1, [2.7927987860432024, -2.792042875649781], 7.418809907101691], [1, [-5.0, 2.791777777777777], 3.7094875738647124], [1, [-2.792045116726832, 2.792798676634545], 7.418809527105372], [1, [2.7927362650631014, 2.7920431220331903], 7.4188094449507815], [1, [5.0, 2.791777777777777], 3.7094875738647124], [1, [2.791777777777777, 5.0], 3.7094875738647124], [1, [-2.791777777777776, -5.0], 3.7094875738647124], [1, [-5.0, -2.791777777777776], 3.7094875738647124], [1, [5.0, -2.791777777777776], 3.7094875738647124], [1, [-2.791777777777776, 5.0], 3.7094875738647124], [1, [-2.7935752283953383, -2.7929975297418186], 7.418843687149495], [1, [2.7921847733300273, 0.5886759859234074], 4.05831608007964], [1, [0.588673868094386, 2.792184479503049], 4.058316147217293], [1, [-2.7921847876482726, 0.5886524468958704], 4.058316396322622], [1, [2.7921699738127277, -0.5886773417290301], 4.05831808390145], [1, [2.7934348662082367, -1.5972459223594686], 5.54345500268127], [1, [-0.5889975742888895, 2.793499840155791], 4.058347433792915], [1, [-1.5955863396163386, -2.7926500588141705], 5.543437305664812], [1, [2.793098668690011, 1.5974581131382641], 5.5434356453345135], [1, [-2.7931513882041035, 1.5974355980178963], 5.543437751128193], [1, [-1.5974237243512304, 2.7930015320627004], 5.543423986129959], [1, [-2.7929882893350357, -1.5974120237992029], 5.543421734647847], [1, [1.5973548649136389, -2.792936743257666], 5.543412248526066], [1, [1.5966106029675777, -1.596793413107768], 3.6679808286407845], [1, [-1.5967934030360957, 1.5966109847031786], 3.6679808298756176], [1, [1.5959839828404645, 1.5970450264958225], 3.668019273066645], [1, [-1.5969266177387258, -1.5964368276593603], 3.6679877195848585], [1, [0.5897490862402769, -1.5961354883714582], 2.182921085783833], [1, [0.5897483756644186, 1.596135536848798], 2.1829210543539173], [1, [-0.5897483887512263, -1.5961347486446575], 2.1829211063083545], [1, [-1.5961339637070142, 0.5897459313732732], 2.18292106004769], [1, [0.5884075503028776, -2.7922000259228863], 4.058319277289264], [1, [1.5961789211313748, 0.5893443832578082], 2.1829063381624754], [1, [-0.5893314372025761, 1.5961966496465279], 2.182905065043521], [1, [1.5962093800801678, -0.5893229762473109], 2.1829041997837124], [1, [-1.5962204496382488, -0.5893155726929022], 2.182903468594078], [1, [-0.5895555555555554, -5.0], 0.3489109399563857], [1, [-5.0, -0.5895555555555554], 0.3489109399563857], [1, [0.5895555555555554, -5.0], 0.3489109399563857], [1, [5.0, -0.5895555555555554], 0.3489109399563857], [1, [-5.0, 0.5895555555555554], 0.3489109399563857], [1, [0.5897971063142315, 0.5892345776430672], 0.6978234683358504], [1, [-0.5897800299465189, 0.5889424444982966], 0.6978206483159346], [1, [5.0, 0.5895555555555554], 0.3489109399563857], [1, [-0.5895555555555554, 5.0], 0.3489109399563857], [1, [0.5895555555555554, 5.0], 0.3489109399563857], [1, [-0.5881489969972917, -0.5884145464262706], 0.6978253948023871], [1, [0.5884420157301404, -0.5884199464669604], 0.6978160598237372], [1, [-0.5882990594495962, -3.7996792832798123], 4.175886533161414], [1, [0.5882131352605247, -3.79969437397166], 4.17588986253763], [1, [-3.8001187352460173, -0.5891991285595581], 4.175923550907472], [1, [3.800139301022042, 0.5891294591279471], 4.17592652873394], [1, [3.7999100537942323, -0.5883785920835634], 4.175899853364536], [1, [-0.5892509788164092, 3.8001061518645542], 4.175922055595687], [1, [-3.799621227887288, 0.5879879165627611], 4.175897501476005], [1, [-0.5880648216955535, -2.792614124517616], 4.05829752442008], [1, [-2.7926199383530905, -0.5880757999282697], 4.058296886858419], [1, [0.5897410342213117, 3.79978274875869], 4.175896975306951]], "nr_of_basins": 100, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.0608776651664296e-162, -1.5556265070726043e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.93532789406807e-163, 8.21146285238222e-163, -4.314344270848823e-164, 5.0879776399713323e-163, -9.548403726693814e-163]}
{"id": "1eced284-b275-4ca3-b2fc-81ce772f6703", "fitness": 0.6786890551447868, "name": "landscape", "description": "A separable, non-homogeneous landscape with a phase-transition at |x_i| = 1.0 for each dimension. Each coordinate behaves as a smooth quadratic near the origin, but beyond the threshold it enters a rugged, oscillatory growth with per-dimension phase offsets. The landscape is separable (sum of per-dimension functions) and global optimum is at x = 0.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        if dim <= 0:\n            raise ValueError(\"dim must be a positive integer.\")\n        self.dim = int(dim)\n        \n        # Phase-transitioned, separable landscape parameters\n        self.s = 1.0                 # threshold for phase transition\n        self.a = 1.0                 # quadratic curvature in the smooth region\n        self.A = 0.75                # linear growth scale in the rugged region\n        self.omega = 2.0 * np.pi * 0.6  # base frequency for oscillations in rugged region\n        \n        # Per-dimension phase offset to break homogeneity across space\n        self.phi = (np.arange(self.dim, dtype=float) * 1.23) % (2 * np.pi)\n    \n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape: sum_i f_i(x_i)\n        where each f_i has a quadratic region for |x_i| <= s and\n        a rugged, oscillatory region for |x_i| > s.\n        Global minimum at x = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be of dimension {self.dim}.\")\n        \n        ax = np.abs(x)\n        delta = ax - self.s\n        \n        # Rugged region: f_i = 0.5*a*s^2 + A*(|x|-s)*(1 + 0.5*cos(omega*(|x|-s) + phi_i))\n        # Smooth region: f_i = 0.5*a*x_i^2\n        rugged = 0.5 * self.a * (self.s ** 2) + \\\n                 self.A * delta * (1.0 + 0.5 * np.cos(self.omega * delta + self.phi))\n        smooth = 0.5 * self.a * (x ** 2)\n        \n        fi = np.where(ax <= self.s, smooth, rugged)\n        return float(np.sum(fi))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.874, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.002419718880178401, 0.3875754706433714, 0.009332189435626245, 0.023026088694712128, 11.763237969795892, -0.0032880631641931226, 0.7207137130708187, 1.2066583054357496, 0.7222158285501695, 0.38957672263852, -0.315420058809632, 1.6, 0.4169500120949404, 0.6133218421564852, 0.4141470037838927, 0.39156168596004026, -0.30196241299368326, 0.1458123915207385, 0.23784259147388073, 0.33440298080509073, 0.5536094308693464, 0.14607877948859277, 0.23480198954290626, 0.3341642950454561, 0.5448466740850483, -0.4471793230213203, -0.3990006127665693, -0.3484508160759964, -0.2336923296698735, -0.4390850783891482, -0.3934667128587085, -0.34237666774831815, -0.2340408149743222, 1.0, 1.0, 1.0, 1.0, 0.514270695735796, 0.5142541896584879, 0.40969255897702705, 0.3465542694019622, 0.7687184593199915, 0.8098098098098095, 0.8361261282428449, 0.23323323323323314, 0.4353413654618474], "score_NOT Homogeneous_2D": 0.0928424596786499, "score_Separable_2D": 1.0, "ela_features": [-0.0005887644295414108, 0.4036217472297333, 0.003112992257385107, 0.021024385687655568, 8.809681181534609, 0.0034793059481837084, 0.7654698396566586, 1.4223414205068032, 0.7674719025878248, 0.2949249177296718, -0.0365369579650948, 1.2, 0.7864445967031306, 0.8426877719259587, 0.5441159043195034, 0.20691582306380557, -0.49317983592251535, 0.49021104449496156, 0.5825372798442967, 0.6474646066222585, 0.752554617917846, 0.48945607335308566, 0.5778043517596725, 0.6458316293181976, 0.7508916239059067, -0.44840790325578694, -0.36720042279825654, -0.3100905118883931, -0.21765268962991033, -0.4513064090054688, -0.37321530101583206, -0.3130808691958167, -0.2202078557622955, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21784971006079656, 0.2178484874610084, 0.20593014516059038, 0.18375975447894025, 0.8537332880010681, 0.2772772772772772, 0.2870686047653784, -0.3273273273273272, 0.5836538461538462], "score_NOT Homogeneous_5D": 0.10501277446746826, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0013866024661717935, 0.4269154753181047, 0.0011203568597241806, 0.015805364893373277, 23.84233519200277, 0.005364483791163543, 0.7533395218239743, 1.4893525299752741, 0.7552980740032059, 0.20922420194580127, 0.009483553162277402, 1.6, 0.9535991509230046, 0.9277659049260819, 0.6609425367205066, 0.11395143403331313, -0.6074655569006675, 0.6612387387224496, 0.7167254278598596, 0.7661208377274774, 0.8366650848355721, 0.6613097698213755, 0.7162158037514669, 0.7669047008303839, 0.8383125742641612, -0.42968545106261413, -0.3593058217259514, -0.2966526285670776, -0.2071743071135132, -0.43081258211084544, -0.36097208027233957, -0.29649592633911154, -0.20566586707797807, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10989922865627504, 0.1099065193816986, 0.10708746554302309, 0.10047550138982772, 0.8599240401908531, -0.0830830830830831, 0.14412408503031798, -0.6276276276276274, 0.610888710968775], "score_NOT Homogeneous_10D": 0.8742790967226028, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [3.4708888916871508, -3.140855788409409], 2.7411370600059524], [4, [3.470888891652889, 3.140854028158886], 2.741137053477478], [4, [0.00044444444444512003, 3.1408888888889717], 1.308979551714433], [4, [-3.4708888916664495, -3.14085549250832], 2.741137058906207], [4, [0.00044444444444512003, -3.140888888888971], 1.308979551714433], [4, [-1.725777777777863, 3.1408888888889717], 2.1032147055418116], [2, [5.000179136222665, -3.1308910717734273], 3.595442832544743], [4, [-5.0, 0.00044444444444512003], 2.2864746072030115], [4, [5.0, 0.00044444444444512003], 2.2864746072030115], [8, [0.00044444444444512003, 0.00044444444444512003], 1.975308641981314e-07], [8, [-1.725777777777863, 0.00044444444444512003], 0.7942353513582426], [8, [1.7257777777778638, 0.00044444444444512003], 0.7942353513582426], [4, [0.00044444444444512003, 4.82200000000002], 1.936696533628324], [4, [0.00044444444444512003, -4.82200000000002], 1.936696533628324], [1, [5.000073106860142, -4.818000500362695], 4.2231156891531665], [1, [5.000142143649531, 4.816001672614944], 4.223114867565441], [2, [5.000260005083033, 3.128892696003268], 3.5954407966589192], [2, [-5.000181367752257, 3.130891075229534], 3.5954364178335556], [2, [-3.4661918283364987, 3.1368866557705513], 2.7413741695861744], [2, [1.6698847085605402, -3.133750097183006], 2.1066353009333194], [2, [-1.6698665689879153, -3.133739839493768], 2.1066379324304942], [2, [1.6687449540758812, 3.135400850576379], 2.1066470006667175], [4, [-3.4673718602802133, -0.0441635920415394], 1.4332305912591583], [4, [3.4640416162575294, -0.08345885108685423], 1.435975384261958], [1, [-5.000136790408832, 4.81600170743458], 4.22313025428404], [1, [-5.000140321092132, -4.816001796474413], 4.223120092740108], [2, [3.464263221683211, 4.819944066401025], 3.369208560387131], [2, [-3.462215147933672, 4.819920466971212], 3.3694193434016713], [2, [-3.4642631354104427, -4.819941209095415], 3.3692086822283436], [2, [3.464263120514593, -4.819943908563906], 3.3692085757445955], [2, [-5.000260776053967, -3.1288926829281363], 3.5954385831769167]], "nr_of_basins": 31, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.2332266086063602e-162, -6.7446523874548215e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.2992958336315507e-162, -2.1614050570923646e-162, -9.097375719872456e-163, -4.425176376277966e-163, -2.4569959938494694e-162]}
{"id": "0968fbdf-f2be-48fe-a950-f715f3f12b06", "fitness": 0.896943828711907, "name": "landscape", "description": "A separable, non-homogeneous landscape with per-dimension phase transitions. Each dimension behaves as a piecewise function: a smooth quadratic inside a dimension-specific threshold, and a different, rugged regime outside. This creates nonuniform curvature across dimensions and a non-homogeneous search space, while keeping the problem separable and suitable for minimization.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic, per-dimension parameters to induce non-homogeneity\n        rng = np.random.default_rng(seed=12345 + self.dim)\n\n        # Transition threshold per dimension (phase boundary within [-5,5])\n        self.a = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # Inside threshold: quadratic curvature per dimension\n        self.alpha = rng.uniform(0.5, 2.0, size=self.dim)\n\n        # Outside threshold: different curvature to increase difficulty\n        self.beta = rng.uniform(0.5, 2.0, size=self.dim)\n\n        # Outside threshold: add a small rippled term to introduce local minima\n        self.gamma = rng.uniform(0.0, 0.6, size=self.dim)\n        self.omega = rng.uniform(0.8, 3.5, size=self.dim)  # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim)  # ripple phase shift\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n        \n        absx = np.abs(x)\n        inside = absx <= self.a\n\n        val = np.zeros(self.dim, dtype=float)\n\n        # Inside threshold: smooth quadratic\n        val[inside] = self.alpha[inside] * (x[inside] ** 2)\n\n        # Outside threshold: different curvature plus a ripple term\n        outside = ~inside\n        delta = absx[outside] - self.a[outside]\n        val[outside] = (\n            self.beta[outside] * (delta ** 2) +\n            self.gamma[outside] * (np.sin(self.omega[outside] * delta + self.phase[outside]) ** 2)\n        )\n\n        return float(np.sum(val))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.517, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0026510869843024754, 0.29959445205358926, 0.005274376039772067, 0.02981884654330802, 16.521283053874207, -0.0005206563999401448, 0.9327731630356304, 6.603010091143824, 0.9324525756399048, 0.8175108483938809, -0.4561088346341585, 1.6, 0.4930269645996447, 0.682023860982719, 0.4121487757555494, 0.34997998421096854, -0.22723608897302836, 0.4242840476036749, 0.4745081423499656, 0.5019089202612815, 0.6184818610421924, 0.4487758314672739, 0.4736223917195076, 0.4980333438641516, 0.603731461775069, -0.30124658251479586, -0.27496222690371686, -0.2606216755137097, -0.19962787800876272, -0.28333508660495915, -0.27055080728894004, -0.25799805375627133, -0.2036722201031151, 1.0, 1.0, 1.0, 1.0, 0.5177058467688869, 0.5176691823685492, 0.37117754895871646, 0.35147005936727843, 0.7160536964281513, 0.9259259259259256, 0.47970706076146763, 0.06506506506506503, 0.4092369477911647], "score_NOT Homogeneous_2D": 0.9397353753447533, "score_Separable_2D": 1.0, "ela_features": [3.0420143230602824e-05, 0.3530880774839823, 0.0040935245592471576, 0.02872217120913841, 15.143602763516995, 0.00787802844951968, 0.9548662061827677, 4.698195870525977, 0.9552194006779849, 0.5309888066589058, -0.11285248838900674, 1.0, 0.8609911863262167, 0.8648687707384417, 0.6089586276701281, 0.1909518757842083, -0.48247423236340037, 0.5177252822542265, 0.5770746933156738, 0.6432272588275177, 0.7510177513371179, 0.5154990822095571, 0.5731691543146606, 0.6384976458857817, 0.7490450092259292, -0.42420505315904167, -0.3720034896968915, -0.3138163483774888, -0.21900400296286376, -0.4282797548995285, -0.3773099515635717, -0.3195630752918435, -0.22184056847396114, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2152590707957121, 0.21527482966536135, 0.19912179146264083, 0.18114371721784003, 0.8313909166422405, 0.22522522522522515, 0.28013443632500146, -0.30730730730730726, 0.5344551282051281], "score_NOT Homogeneous_5D": 0.9247912019491196, "score_Separable_5D": 1.0, "ela_features_10D": [0.0007364022284369831, 0.3924041843849369, 0.002166154427059952, 0.02331182333958986, 19.604625402743732, 0.006140082555175508, 0.9630009830531845, 6.659976246872847, 0.96312490013927, 0.331842389941459, -0.03819897452732892, 1.4, 0.9944399502377206, 0.9351288752581173, 0.6801156996790905, 0.10848363266952465, -0.6013159121569192, 0.6588386373247566, 0.7082661071849098, 0.7562834609338966, 0.8267239154069026, 0.6563239218330184, 0.708838393229842, 0.7571791046856157, 0.8287953146883188, -0.4327304530353797, -0.37003707565440164, -0.3091315717430514, -0.21978447151208588, -0.43713085374823724, -0.3703377688824497, -0.30885144277241106, -0.21776077027216814, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11111768712600918, 0.11111140450189586, 0.10804233549417838, 0.10158705499926772, 0.8602306802020989, -0.10310310310310308, 0.13776731945983106, -0.6516516516516514, 0.6005604483586869], "score_NOT Homogeneous_10D": 0.5171363949775696, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [0.00044444444444512003, 0.00044444444444512003], 6.282023416514741e-07], [16, [0.00044444444444512003, -1.194666666666666], 0.3269364045037622], [12, [1.979294978731566, -1.1846934934440674], 0.356079595304727], [6, [1.9797763805148976, -0.29471690219853325], 0.13640600381206333], [12, [-1.9794633663604264, -1.1808051011802998], 0.356254211198881], [6, [-1.9806227020666958, -0.296276334997879], 0.1377276407886994], [16, [0.00044444444444512003, 1.1946666666666665], 0.32693640450376216], [12, [1.9794934782539058, 1.1923525048426595], 0.35598134186840935], [12, [-1.9797506576593333, 1.1922877748570944], 0.356037079478233]], "nr_of_basins": 9, "f_opt_dim_2": 0.028976208794305614, "x_opt_dim_2": [1.979208307584309, -2.7825732168603995e-10], "f_opt_dim_5": 0.15082186702927367, "x_opt_dim_5": [2.2112629861003814e-09, -8.815042881187816e-10, -2.2422275815500786e-10, -1.265570191846003e-09, 0.6996304640714972]}
{"id": "c16b2ad0-70d5-44ae-b624-abed19e902ff", "fitness": 0.8672533890404911, "name": "landscape", "description": "A separable, non-homogeneous landscape with per-dimension phase-transition-like regions. Each dimension has three regimes (inner quadratic, middle quadratic with higher curvature, outer linear growth) and dimension-specific transition thresholds, creating a not-homogeneous search space while keeping the problem separable. The global optimum is at x = 0 (per-dimension minimum 0).", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self._setup_params()\n\n    def _setup_params(self):\n        # Per-dimension parameters to induce non-homogeneity (phase-transition like regions)\n        # s1: inner boundary, s2: outer boundary (per-dimension, but kept simple and within [-5,5])\n        self.s1 = np.zeros(self.dim)\n        self.s2 = np.zeros(self.dim)\n        # Coefficients for each region (per-dimension, but globally similar to keep separability)\n        self.a1 = np.full(self.dim, 0.5)  # inner quadratic\n        self.a2 = np.full(self.dim, 0.9)  # middle quadratic\n        self.a3 = np.full(self.dim, 0.7)  # outer linear\n\n        for i in range(self.dim):\n            # Slightly different thresholds per dimension to create non-homogeneity\n            self.s1[i] = 1.0 + 0.3 * (i % 4)      # inner boundary\n            self.s2[i] = 2.0 + 0.6 * (i % 5)      # outer boundary\n            if self.s2[i] <= self.s1[i]:\n                self.s2[i] = self.s1[i] + 0.5\n\n        # Precompute piecewise constants for continuity at boundaries\n        # For continuity: b_i = a1_i * s1_i^2; d_i = a2_i * (s2_i - s1_i)^2 + b_i\n        self.b = self.a1 * (self.s1 ** 2)\n        self.d = self.a2 * ((self.s2 - self.s1) ** 2) + self.b\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape value: sum_i g_i(x_i)\n        where each g_i is piecewise (depending on |x_i|) with three regions:\n        - |x_i| <= s1_i: a1_i * (|x_i|)^2\n        - s1_i < |x_i| <= s2_i: a2_i * (|x_i| - s1_i)^2 + b_i\n        - |x_i| > s2_i: a3_i * (|x_i| - s2_i) + d_i\n        The global optimum is at x = 0 (value 0).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        xi = np.abs(x)\n        total = 0.0\n\n        for i in range(self.dim):\n            if xi[i] <= self.s1[i]:\n                gi = self.a1[i] * (xi[i] ** 2)\n            elif xi[i] <= self.s2[i]:\n                gi = self.a2[i] * ((xi[i] - self.s1[i]) ** 2) + self.b[i]\n            else:\n                gi = self.a3[i] * (xi[i] - self.s2[i]) + self.d[i]\n            total += gi\n\n        return total", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.409, Separable 0.951,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.003146814995994207, 0.48165326328281965, 0.00770776900369149, 0.019369633712679905, 8.507757110440712, 0.0026270664678973875, 0.9188028059072373, 1.2143867395909576, 0.9187664634324048, -0.004000774382453496, -0.7277247625919748, 1.0, 0.7101359417487819, 0.7137094300955292, 0.5439594515292753, 0.345948861500034, -0.18758246361737915, 0.175907585589525, 0.24545515781040858, 0.33152053715562035, 0.5106211209938325, 0.18530067566065908, 0.24698754982900611, 0.3372296834336699, 0.5128446208589519, -0.4312828399686538, -0.3948916102380816, -0.34985218965167275, -0.256118131367432, -0.41906115846173864, -0.38734086799460343, -0.3409397460462762, -0.25059462178202774, 1.0, 1.0, 1.0, 1.0, 0.532846082555552, 0.5328401891555263, 0.4054974515026112, 0.3561582924614741, 0.740949164003515, 0.43343343343343327, 0.5947929509283056, -0.11111111111111109, 0.3614457831325301], "score_NOT Homogeneous_2D": 0.989359769038856, "score_Separable_2D": 0.99951171875, "ela_features": [-0.0019094243117986575, 0.45348737434515796, 0.003175871482903672, 0.021671011208893167, 67.04135068259193, -0.0014947092779859172, 0.9687804917603765, 3.706182098162561, 0.9688242862682792, 0.32427319714083447, -0.4709002681993934, 1.0, 0.8913496204463704, 0.8667859535014429, 0.6402801890192423, 0.18809292204244535, -0.46696149044969354, 0.44152031828462696, 0.54444859035103, 0.6191914671045003, 0.7384210416838746, 0.4416671253436917, 0.541299147552788, 0.6166403120841238, 0.7365215528113318, -0.4914098002510577, -0.40084211252585417, -0.33507486647500906, -0.23016451593545534, -0.49408584974958353, -0.4059162938449374, -0.3392421510032229, -0.23315627521909493, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21199613713638268, 0.2119583935281566, 0.19542507471699347, 0.1772150531457624, 0.8167974093038921, 0.1971971971971971, 0.24388908844336918, -0.37137137137137133, 0.49967948717948724], "score_NOT Homogeneous_5D": 0.8813342899084091, "score_Separable_5D": 0.972802734375, "ela_features_10D": [-0.00019762059927093124, 0.426794298180476, 0.0016355866787300382, 0.023219915362986027, 22.566776090780866, -0.00012365751014555836, 0.9666341574037943, 3.8839003413638244, 0.9669519634428969, 0.23587043522557663, -0.23181503637568168, 1.0, 0.9890994203846777, 0.933886155570945, 0.6968328081238587, 0.1083855122038955, -0.5921091080730773, 0.6469662014030716, 0.7087376097572375, 0.7580929584624216, 0.831055168058674, 0.6459073852796254, 0.7097373268904945, 0.7594245068917004, 0.832510305221164, -0.4477472860450451, -0.3694059563491911, -0.30680889356995633, -0.214271498438721, -0.45027738966726477, -0.36911544064970025, -0.3059309221040171, -0.21299055906792944, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10977326334949777, 0.10977506989583272, 0.10621797957135123, 0.10058197691152113, 0.8597359216123965, -0.06706706706706708, 0.14247714115689705, -0.5995995995995994, 0.5858286629303443], "score_NOT Homogeneous_10D": 0.4091663360595703, "score_Separable_10D": 0.9513454861111111}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.975308641981314e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1064419173005993e-162, 8.10636330761566e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.401643065708898e-162, -1.5555029407012386e-162, -4.578552679929693e-163, 1.7247957210208332e-162, -2.4183431982078475e-162]}
{"id": "1d3b4f7b-ccbd-4b83-b9fd-738fece23c15", "fitness": 0.8346066897114118, "name": "landscape", "description": "A separable landscape with per-dimension phase transitions that create non-homogeneous regions in the search space. Each dimension blends a quadratic well near the origin with a stronger quartic growth beyond a per-dimension threshold, producing a smooth yet non-uniform landscape. The global minimum is at x = 0 with value 0, and the problem remains separable across dimensions.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # Per-dimension transition thresholds (non-homogeneous across space)\n        # These thresholds are deterministic and vary with dimension\n        self.thresholds = np.array([1.0 + (i % 5) * 0.4 for i in range(dim)], dtype=float)\n        self.k = 5.0  # steepness of the transition\n        self.a_quad = 1.0  # coefficient for the quadratic term (near origin)\n        self.a_quartic = 0.3  # coefficient for the quartic term (far from origin)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n        \n        r = np.abs(x)  # per-dimension distance from origin\n        # Smooth per-dimension phase transition from quadratic to quartic growth\n        # h ~ 0 near origin (quadratic dominates), h ~ 1 far from origin (quartic dominates)\n        h = 1.0 / (1.0 + np.exp(-self.k * (r - self.thresholds)))\n        \n        quad_term = self.a_quad * (x ** 2)\n        quartic_term = self.a_quartic * (x ** 4)\n        \n        per_dim_val = (1.0 - h) * quad_term + h * quartic_term\n        return float(np.sum(per_dim_val))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.834, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.002511378345388282, 0.23673720031205017, 0.011327678795742892, 0.023549507861144924, 305.25093028535446, -5.6931251476433076e-05, 0.9130938323322091, 1.0177493593175935, 0.9141828672802083, 0.9908001599198745, 0.402329565169769, 1.2, 0.7147062512227444, 0.7160200128990267, 0.5602542477204926, 0.34406672727509297, -0.22262311174835275, 0.150146956813137, 0.23135042271128653, 0.3181617112089146, 0.4979950818379761, 0.15422261398539824, 0.23602957212862968, 0.32117436896957974, 0.49899493455831845, -0.4447525116433912, -0.40225421722012367, -0.35682448824566093, -0.26271105786010035, -0.43491002166626264, -0.39283483555958576, -0.3490550191615494, -0.25761773902359403, 1.0, 1.0, 1.0, 1.0, 0.5198729443164838, 0.51986767268663, 0.40451096072004633, 0.3501772592218056, 0.636905226814785, 0.6496496496496494, 0.5452923787824799, -0.1191191191191191, 0.4036144578313253], "score_NOT Homogeneous_2D": 0.8122976273298264, "score_Separable_2D": 1.0, "ela_features": [-0.0004016620909480073, 0.31860163515790724, 0.0034534469751167684, 0.030201137145573174, 10.116015206731598, 0.004191874693914177, 0.9167292145475235, 1.0457004119060973, 0.9173894524940354, 0.6077447016164038, 0.03500614390492736, 1.6, 0.9064567615334006, 0.8725845210410853, 0.6326710763358021, 0.18671093581694168, -0.5074086046430375, 0.43352956352731614, 0.526253633407616, 0.6026102020020303, 0.7262872871498469, 0.43402957035994394, 0.5284554617350784, 0.6059172231432672, 0.7291897158205412, -0.49824105008440894, -0.41668526027515024, -0.349526159450637, -0.2407458443703522, -0.5002504819970983, -0.41678753647626454, -0.34832116466278046, -0.23936517266590585, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21407286963882238, 0.21406784963318937, 0.1975867001039828, 0.18153011577551761, 0.830887971727565, 0.2772772772772772, 0.2972592068907841, -0.2592592592592592, 0.5413461538461538], "score_NOT Homogeneous_5D": 0.3608567714691162, "score_Separable_5D": 1.0, "ela_features_10D": [5.411525563920882e-05, 0.35523918731296067, 0.0007449362480090734, 0.023490254251115887, 78.32588279905879, 0.005386528185581585, 0.9154104055590494, 1.0490316454019442, 0.9163811865567574, 0.40628693399751736, -0.02467412921722456, 1.4, 1.0161817730999865, 0.9386217055361892, 0.6960372816092821, 0.10638822726303865, -0.6098496505531482, 0.6318655387757299, 0.6920930562210713, 0.7442590953111043, 0.8176043867259415, 0.6326160160714334, 0.6943597771656276, 0.7475077586951511, 0.8212819349186808, -0.46690133702499514, -0.39051534539195815, -0.3243536639670397, -0.23133049814475895, -0.46726102966766037, -0.38873134216226934, -0.3211345182645061, -0.22730389636815235, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10978101342378628, 0.10979210293000677, 0.10656224610331595, 0.1003810684903953, 0.8630668529449735, -0.047047047047047055, 0.1410352156026404, -0.5995995995995994, 0.6083266613290632], "score_NOT Homogeneous_10D": 0.8344857394695282, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.935564017212913e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.3829104703552625e-162, -1.384883033936934e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.500455286046887e-163, -9.893396281082763e-163, -6.003319841118019e-163, 1.552946134421952e-162, 1.0313070889628934e-162]}
{"id": "e85dcf09-6a04-4b56-84a6-e40839b844e9", "fitness": 0.7524827073017756, "name": "landscape", "description": "A separable, non-homogeneous landscape with phase transitions in each dimension. Each dimension uses a piecewise-quadratic function with two transition zones, making the landscape non-uniform across the domain while remaining separable (sum of per-dimension costs). Global minimum is at x = 0 for all dimensions.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 0:\n            x = x.reshape(1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n\n        # Phase transition thresholds\n        t1 = 0.5\n        t2 = 1.5\n\n        # Per-dimension parameters (separable landscape)\n        c1 = 0.3  # curvature inside [-t1, t1]\n        c2 = 1.0  # curvature in (t1, t2]\n        c3 = 3.0  # curvature outside |x| > t2\n\n        f0 = c1 * (t1 ** 2)  # continuity constant at transition t1\n\n        absx = np.abs(x)\n        # Piecewise definition with continuity at boundaries:\n        # |x| <= t1       -> c1 * x^2\n        # t1 < |x| <= t2  -> c2 * (|x| - t1)^2 + f0\n        # |x| > t2        -> c3 * (|x| - t2)^2 + (c2 + f0)\n        f = np.where(\n            absx <= t1,\n            c1 * x ** 2,\n            np.where(\n                absx <= t2,\n                c2 * (absx - t1) ** 2 + f0,\n                c3 * (absx - t2) ** 2 + (c2 + f0)\n            )\n        )\n\n        return float(np.sum(f))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.530, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0030425686332359535, 0.2659293413397862, 0.006587266338932895, 0.019365317689066165, 4.7822995775412505, -0.0028336270563679377, 0.9682848492721037, 1.0085194141235203, 0.9683213095514368, 0.800471725379156, 0.018167983077459038, 1.4, 0.7144086120657507, 0.7179398294691615, 0.5805290183619951, 0.34061157600192893, -0.21443605817255365, 0.14982722770683315, 0.2208530936362365, 0.309529316669176, 0.49500025155631067, 0.1488921843505402, 0.2252917970847864, 0.3112822234165561, 0.4940361943775919, -0.44485009599883396, -0.4076859115325774, -0.3612878355534074, -0.2642415015214434, -0.43735903549354693, -0.3980906905664595, -0.35389172929307877, -0.25997521097670545, 1.0, 1.0, 1.0, 1.0, 0.5169409934529273, 0.5169277620948535, 0.39849385109278207, 0.3478541255852403, 0.6375428541196371, 0.5255255255255253, 0.5639314772202597, -0.09509509509509509, 0.36305220883534134], "score_NOT Homogeneous_2D": 0.6021458208560944, "score_Separable_2D": 1.0, "ela_features": [-0.00012044813374891827, 0.35001965495385673, 0.0027618412050997537, 0.026939325686663025, 10.335932208346154, 0.002022770905865845, 0.9676806542063799, 1.0242962153958408, 0.9677535346065081, 0.45807639984727083, -0.07526484884787958, 1.4, 0.9153191936630531, 0.8740013883252138, 0.6484908631545151, 0.1839855415226735, -0.49139129385211194, 0.4320386076576151, 0.5173320260035051, 0.5955128896035348, 0.718033332930048, 0.43590593461676513, 0.5215396379513134, 0.5981131057725178, 0.721112104213851, -0.4995837607366302, -0.4245596475121493, -0.35579127004695305, -0.24802087649839777, -0.4987351979738614, -0.4230243605726459, -0.3553231118048987, -0.24657495965357068, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21472820496962025, 0.21475470548524717, 0.19899837410846083, 0.18107737066222584, 0.82342275382644, 0.22122122122122115, 0.2763191001663486, -0.3233233233233233, 0.5243589743589744], "score_NOT Homogeneous_5D": 0.38271230459213257, "score_Separable_5D": 1.0, "ela_features_10D": [0.00020145264142159557, 0.38690565084532147, 0.0016130511370502057, 0.02124183070754846, 18.523194806845694, 0.004993469452894783, 0.9683707387059222, 1.0280811899626294, 0.9685329381883534, 0.34596030117250853, 0.07045878890075183, 1.6, 1.0186726325953104, 0.9386126820923841, 0.7060702934528722, 0.10495810098409622, -0.6081000873016718, 0.6192903899930362, 0.681403617175993, 0.7323390754778805, 0.8110124605515798, 0.6229383398008858, 0.6846229958741625, 0.7360401240318694, 0.8151445603692373, -0.4828488142880917, -0.4040707117829213, -0.3394699971172024, -0.23968980154219272, -0.4794937578938976, -0.4010495639090882, -0.33566409844005457, -0.235071113244422, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11020122931904222, 0.11019945717212325, 0.10726499184276928, 0.10054547817771323, 0.8598157282368384, -0.10710710710710707, 0.12344069633161872, -0.6556556556556554, 0.5979983987189752], "score_NOT Homogeneous_10D": 0.5300381183624268, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.1851851851887883e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [2.590839270496839e-162, 5.512233563257998e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-7.087455537308778e-164, 7.984686045731485e-163, -3.8183836417565555e-164, 2.349785434062752e-162, -6.805154013652376e-163]}
{"id": "41ec7f41-5a65-45ce-a2f5-c084aa2e1422", "fitness": 0.8657927898069223, "name": "landscape", "description": "A separable, piecewise-quadratic landscape with radial phase transitions. Each dimension contributes a non-homogeneous, region-dependent cost g(|x|) with phase boundaries at |x|=1.0 and |x|=2.5. The inner region behaves like a simple parabola, the middle region shifts curvature with an offset, and the outer region adds another quadratic growth. The global minimum is at the origin (all zeros) with value 0, and the problem remains separable across dimensions.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Dimension mismatch: expected dim {}, got {}\".format(self.dim, x.shape[0]))\n        \n        t = np.abs(x)\n        g = np.zeros_like(t)\n        \n        # Phase 1: near origin - gentle quadratic\n        mask1 = t <= 1.0\n        g[mask1] = t[mask1] ** 2\n        \n        # Phase 2: intermediate region - different curvature with offset\n        mask2 = (t > 1.0) & (t <= 2.5)\n        g[mask2] = 2.0 * (t[mask2] - 1.0) ** 2 + 1.0\n        \n        # Phase 3: outer region - another quadratic growth with continuity\n        mask3 = t > 2.5\n        g[mask3] = (t[mask3] - 2.5) ** 2 + 5.5\n        \n        return float(np.sum(g))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.592, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.00013006203388494787, 0.4401931638369089, 0.019905956390143843, 0.040628807704098394, 1.99001054557085, 0.0019788444712913744, 0.9567043460110641, 1.0134290007555031, 0.9565019573034693, 0.15554277582787607, -0.5656714253866297, 1.4, 0.6949931907355712, 0.7118371056500052, 0.5333163619362569, 0.34542619675404446, -0.19924829496887148, 0.1431132192134862, 0.2361360766388429, 0.327175028909153, 0.5059619528310235, 0.14313142007035928, 0.23768149819036113, 0.32601694553692384, 0.509170093083936, -0.44832524534399276, -0.3996558518420455, -0.3520233092049764, -0.25847852043345, -0.44088126079395684, -0.39223608006061367, -0.34677922515728354, -0.252534805652322, 1.0, 1.0, 1.0, 1.0, 0.515274011372186, 0.5152643825991419, 0.4010680734754975, 0.35733526367295343, 0.7359716535147349, 0.44144144144144126, 0.5273167840557192, -0.055055055055055056, 0.3899598393574297], "score_NOT Homogeneous_2D": 0.8814076408743858, "score_Separable_2D": 1.0, "ela_features": [0.0005770359691031679, 0.4662632023480341, 0.003414412776730497, 0.03065560046262466, 15.792541875779218, 0.0004452819133960118, 0.9588619310695561, 1.0240892113062823, 0.9587197257678677, 0.07579115706454252, -0.21693363181311137, 1.2, 0.8999885659299643, 0.8717404316186087, 0.6411814014266335, 0.18381452785888935, -0.469632850308502, 0.42084837326901836, 0.5201485639555521, 0.6049759530447731, 0.7201856633771004, 0.4242430676899643, 0.5210218501666765, 0.606265980826343, 0.7224418925911659, -0.5094730953488912, -0.4221203299095409, -0.34749841569827755, -0.24614957593819944, -0.5090891244685244, -0.42351603861777676, -0.3481430414469734, -0.24541912184136852, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21549172988573959, 0.21549427047302178, 0.20163484045140484, 0.1818018264258586, 0.8281402729288485, 0.09309309309309305, 0.26198734567971277, -0.39139139139139123, 0.5136217948717949], "score_NOT Homogeneous_5D": 0.7208674848079681, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00035216428919180307, 0.4627567336616898, 0.0009605268176091704, 0.020285803854460754, 22.420891683891192, 0.0002438085554976821, 0.959045558389923, 1.0383498237940847, 0.9589302840095912, 0.04709394571254592, -0.12656565576856477, 1.2, 1.003538047653016, 0.9368731267873581, 0.7128736871321855, 0.10502702556825969, -0.6154221645637065, 0.620070420885717, 0.6805066432859833, 0.7322432988001176, 0.8099893987421769, 0.622820437237392, 0.6841004537778145, 0.7360172203893316, 0.8138594350729071, -0.4818452068000374, -0.40519616087462185, -0.3395805494186232, -0.24097956101502332, -0.4795901524249345, -0.4016689330813006, -0.33565486473343187, -0.23667780552188114, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10926150215635037, 0.10925719227723571, 0.10627125726907313, 0.09972858476261412, 0.8548835266878776, -0.1311311311311311, 0.1345115443287619, -0.6476476476476474, 0.589111289031225], "score_NOT Homogeneous_10D": 0.5924816131591797, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.886950589554913e-163, -9.92737898410427e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-9.378670452094538e-163, 1.4936763924406149e-162, 2.7119265792091487e-163, -6.377896475751404e-163, 5.858668793516721e-163]}
{"id": "699c576a-d6e3-4602-b3e6-2404ca83e66e", "fitness": 0.9223542412122091, "name": "landscape_three_regime", "description": "A separable, non-homogeneous landscape with per-dimension three-regime behavior. Each dimension has its own inner and outer thresholds, producing an inner quadratic region, a middle cubic-growth region, and an outer quadratic region. This creates phase-transition-like non-homogeneity across dimensions while preserving separability; the global minimum is at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape_three_regime:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self._setup_params()\n\n    def _setup_params(self):\n        # Per-dimension parameters to induce non-homogeneity (phase-transition like regions)\n        self.s1 = np.zeros(self.dim, dtype=float)  # inner boundary\n        self.s2 = np.zeros(self.dim, dtype=float)  # outer boundary\n\n        self.a1 = np.zeros(self.dim, dtype=float)  # inner quadratic\n        self.a2 = np.zeros(self.dim, dtype=float)  # middle cubic\n        self.a3 = np.zeros(self.dim, dtype=float)  # outer quadratic\n\n        self.b = np.zeros(self.dim, dtype=float)   # continuity offset for middle region\n        self.d = np.zeros(self.dim, dtype=float)   # continuity offset for outer region\n\n        for i in range(self.dim):\n            # Non-homogeneous thresholds per dimension\n            self.s1[i] = 0.5 + 0.2 * (i % 6)         # in [0.5, 1.9]\n            self.s2[i] = 1.8 + 0.25 * (i % 7)       # in [1.8, ~3.05]\n            if self.s2[i] <= self.s1[i]:\n                self.s2[i] = self.s1[i] + 0.4\n\n            # Per-dimension region coefficients (introduce non-homogeneity)\n            self.a1[i] = 0.6 + 0.2 * (i % 4)        # inner quadratic curvature\n            self.a2[i] = 0.9 + 0.15 * (i % 3)       # middle cubic growth\n            self.a3[i] = 0.7 + 0.15 * (i % 5)       # outer quadratic curvature\n\n            # Continuity constants to ensure a smooth join at s1 and s2\n            self.b[i] = self.a1[i] * (self.s1[i] ** 2)\n            self.d[i] = self.a2[i] * ((self.s2[i] - self.s1[i]) ** 3) + self.b[i]\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape value: sum_i g_i(x_i)\n        Each g_i has three regimes:\n        - |x_i| <= s1_i: g_i = a1_i * (|x_i|)^2\n        - s1_i < |x_i| <= s2_i: g_i = a2_i * (|x_i| - s1_i)^3 + b_i\n        - |x_i| > s2_i: g_i = a3_i * (|x_i| - s2_i)^2 + d_i\n        Global optimum at x = 0 with value 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        xi = np.abs(x)\n        total = 0.0\n\n        for i in range(self.dim):\n            if xi[i] <= self.s1[i]:\n                gi = self.a1[i] * (xi[i] ** 2)\n            elif xi[i] <= self.s2[i]:\n                gi = self.a2[i] * ((xi[i] - self.s1[i]) ** 3) + self.b[i]\n            else:\n                gi = self.a3[i] * ((xi[i] - self.s2[i]) ** 2) + self.d[i]\n            total += gi\n\n        return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_three_regime scored on:NOT Homogeneous 0.914, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c16b2ad0-70d5-44ae-b624-abed19e902ff"], "operator": null, "metadata": {"ela_features_2D": [-0.00214387718575173, 0.35886585753374706, 0.009641962621544795, 0.02584309353213205, 3.2536339251837427, 0.0044087347392271605, 0.9870166803246387, 1.1120578024680068, 0.9869494452417509, 0.4063962267251887, -0.24738188482091816, 1.2, 0.6943876582336824, 0.7057722894575077, 0.543092191924136, 0.34870500461813875, -0.21224495474277366, 0.16205410860452005, 0.21780962176096472, 0.30303693382923386, 0.4951482453591896, 0.15046703752929186, 0.21876593195179997, 0.3068111186027529, 0.49164746048395436, -0.438632700485056, -0.4094478658264272, -0.36483522785316025, -0.26426853706481124, -0.43694819062696516, -0.4018191433333775, -0.3565333704431071, -0.26146402633564947, 1.0, 1.0, 1.0, 1.0, 0.5231503456126169, 0.5231482901447866, 0.4162568484275379, 0.35316722865880373, 0.7261705467572419, 0.4694694694694693, 0.5878886095412585, -0.03103103103103102, 0.3791164658634538], "score_NOT Homogeneous_2D": 0.9486803114414215, "score_Separable_2D": 1.0, "ela_features": [1.0632628701268132e-06, 0.4055534983012484, 0.0031055703939315282, 0.028492421839198267, 14.365793426884427, 0.005858643631624272, 0.9850659582930692, 1.2267182622850528, 0.9850038348031832, 0.26208838090165587, -0.16967223857892177, 1.6, 0.9065732571613629, 0.8724749687587974, 0.6350161344264177, 0.1856119834726121, -0.4745338203196563, 0.4712700005387346, 0.5413580567531203, 0.6089594426631025, 0.7230917244356233, 0.4743553985343385, 0.5438897390522962, 0.6124705928473585, 0.7276834144864613, -0.4651653819254415, -0.403503021685973, -0.34402838387611184, -0.24361771724648093, -0.46508562196131764, -0.4035587243012483, -0.34287876906929105, -0.24094173274274772, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21482491538878784, 0.21483883488002867, 0.20106085891715555, 0.18176358192875913, 0.8311019893151906, 0.12112112112112108, 0.275252073696569, -0.36736736736736725, 0.5189102564102563], "score_NOT Homogeneous_5D": 0.6713494658470154, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0002905177596150832, 0.4448442930956021, 0.0020422292257354724, 0.019902018302123844, 17.210319390324422, 0.0009209000976747372, 0.9408504611262785, 3.282988796507682, 0.941247073442069, 0.14719474949694344, -0.48382385236560876, 1.6, 1.0022654435670983, 0.937032089280217, 0.7145390995014519, 0.10492128516873564, -0.5873295304746274, 0.6370130858095792, 0.6963333054691077, 0.7473276860823892, 0.82717385468847, 0.6424252963460548, 0.6996937302854048, 0.7512003420153509, 0.8301856683896804, -0.4603329181642778, -0.3851042839617386, -0.3204342206474012, -0.2191748700497615, -0.45464481966429826, -0.3818302675967061, -0.3163412071338049, -0.215913165627707, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10960104760870529, 0.10959622340420945, 0.10614125806863255, 0.10010301488134046, 0.8608514084500383, -0.07507507507507508, 0.13336644611160556, -0.6036036036036034, 0.5924739791833467], "score_NOT Homogeneous_10D": 0.9140956699848175, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.7654320987738394e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.5153055656551252e-162, -8.589323165433674e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.501482930927219e-163, -8.347288791808094e-163, 9.4165381254595e-163, -2.3689279353375892e-163, 1.5062555215600946e-163]}
{"id": "ab5a9c3a-122f-4af3-97df-ea5d93b2c3d3", "fitness": 0.5001104176044464, "name": "landscape_novel", "description": "A deterministic, separable, non-homogeneous landscape with per-dimension phase transitions. Each dimension has its own transition threshold and unique phase (via per-dimension offset and frequency), yielding a smooth quadratic core near the origin and a dimension-specific rugged outer region. The problem remains separable (sum of independent per-dimension terms) and the global minimum is at x = 0 with f(x) = 0.", "code": "import numpy as np\n\nclass landscape_novel:\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Per-dimension, non-homogeneous transition thresholds (0 <= t <= 1)\n        # Each dimension has its own threshold scaling to create phase transitions\n        i = np.arange(dim, dtype=float)\n        self.threshold = np.minimum(5.0, 0.8 + i * 0.25)  # ensures transitions within [-5,5]\n\n        # Dimension-specific phase offsets (deterministic, no randomness)\n        # Phases shift the rugged components across dimensions\n        self.phi = (i * 1.61803398875) % (2.0 * np.pi)\n\n        # Dimension-specific high-frequency components\n        self.omega1 = np.pi * (2.0 * i + 1.0)  # base frequencies increasing with i\n\n    def f(self, x):\n        \"\"\"\n        Evaluates the separable landscape.\n        Each dimension i contributes g_i(x_i) with a phase-transition\n        from a smooth quadratic near 0 to a rugged outer region.\n        The global optimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length self.dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x length must equal self.dim.\")\n\n        a = np.abs(x)\n        # Per-dimension transition factor (0 -> 1 as |x| grows)\n        t = np.minimum(a / self.threshold, 1.0)\n\n        # Smooth quadratic core\n        base = x * x\n\n        # Rugged outer region with deterministic dimension-specific phase/frequency\n        rugged = (np.sin(self.omega1 * x + self.phi))**2 + 0.5 * np.abs(np.sin(2.0 * self.omega1 * x + self.phi))\n\n        # g_i(x_i) = (1 - t_i) * (x_i^2) + t_i * rugged_i\n        gi = (1.0 - t) * base + t * rugged\n\n        return float(np.sum(gi))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_novel scored on:NOT Homogeneous 0.000, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9107ab6f-e078-4660-bdd8-df21abbac43a"], "operator": null, "metadata": {"ela_features_2D": [-0.0023630417906932875, 0.5241993822715836, 0.010754877709669325, 0.02482296194224191, 3.444861369614531, -0.003306600546323768, 0.024748840696206375, 1.3052115007520406, 0.026095919156747183, 0.07288484861426389, -0.48959392936467533, 1.8, 0.23587329708856086, 0.5137951892288155, 0.23050464063281498, 0.44059932040220817, -0.6225667286803974, 0.6471737262458627, 0.8963610573976709, 0.920747687929031, 0.9265645506036748, 0.6466689359185229, 0.87252455530285, 0.8987912529650004, 0.9086282428619599, -0.1847482801047616, -0.054275836648637846, -0.041503338922755026, -0.03845378350740323, -0.18197186339406035, -0.06566905685207955, -0.05212733768988823, -0.047058337577075074, 1.0, 1.0, 1.0, 1.0, 0.5144861661386231, 0.5143293412124684, 0.3990068007197057, 0.34853972520506005, 0.8601140427100138, 1.594594594594595, 3.7354413469110215, 0.8138138138138136, 0.6273092369477913], "score_NOT Homogeneous_2D": 0.00019425153732299805, "score_Separable_2D": 1.0, "ela_features": [-0.00010440898321619762, 0.4823644508098468, 0.004138882914961622, 0.026583066530688017, 21.269073903446248, 0.0009329367213220197, 0.02640460463756522, 2.3787437427843288, 0.027711651956285756, -0.055962595429272656, -0.24847959289947052, 1.0, 0.5167364703655541, 0.7817096862846248, 0.38033540802148336, 0.25314566624512647, -0.640921009748798, 0.9054356159352832, 0.9175614060482777, 0.9301710376854009, 0.953844433468506, 0.893153325861606, 0.9083870334863648, 0.9219367813030471, 0.9477122522771534, -0.08318326854011462, -0.07251495801081972, -0.06142079363019544, -0.04059726817746474, -0.09446963186887132, -0.08099028659254877, -0.0690043711411105, -0.046217682059992105, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21430935408351698, 0.2142935917097374, 0.2003424768658002, 0.17975172981703283, 0.8704043494248085, 0.6216216216216214, 0.4897986790397072, -0.06306306306306309, 0.6621794871794873], "score_NOT Homogeneous_5D": 0.00022917985916137695, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00044875431709181515, 0.49168748160180886, 0.0013620511733605533, 0.019460708557429367, 18.91553926986575, 0.0006195622709829652, 0.010386279345211635, 91.02969452011203, 0.008749498632946407, 0.015729782328678922, -0.1510904370994318, 1.0, 0.6593887667777047, 0.8815675535405759, 0.494143792933783, 0.15133886104036592, -0.6082248534844567, 0.9482215144097956, 0.9537319856341447, 0.9719141697425153, 0.9882354262810085, 0.9454899996752181, 0.9523349547915133, 0.9706350772733157, 0.9875382058272233, -0.06567240040892215, -0.0586833936413599, -0.035622388152426285, -0.014921570965571406, -0.06932368236120867, -0.06061932285068661, -0.037346711737953564, -0.01584946127949958, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10986129836164668, 0.1098609735095871, 0.10682973735523485, 0.10012313849799996, 0.8672382683722777, 0.11311311311311308, 0.18822554875721437, -0.49549549549549543, 0.6609287429943955], "score_NOT Homogeneous_10D": 0.0002390742301940918, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 1.4972125170571606], [1, [5.0, 5.0], 1.4972125170571606], [1, [-5.0, -0.41955555555555524], 0.31491437524877747], [1, [-5.0, 0.44155555555555526], 0.31472643634479236], [1, [5.0, -0.41955555555555524], 0.31491437524877747], [1, [5.0, 0.44155555555555526], 0.31472643634479236], [1, [-0.4995555555555553, 5.0], 2.216249681399169], [1, [0.4995555555555553, 5.0], 2.216249681399169], [1, [-0.4995555555555553, -0.41955555555555524], 1.033951539590786], [1, [0.4995555555555553, -0.41955555555555524], 1.033951539590786], [1, [2.999777777777754, 5.0], 1.4979111359189845], [1, [-5.0, -4.918000000000009], 0.4764080478125273], [1, [-5.0, -3.9188888888888855], 0.47639327352096544], [1, [5.0, -4.918000000000009], 0.4764080478125273], [1, [5.0, -3.9188888888888855], 0.47639327352096544], [1, [-4.000888888888877, -0.41955555555555524], 0.31771468571982875], [1, [-3.994475271693265, 0.41634672474634704], 0.31117958331692014], [1, [2.999980126517547, -4.9080023388143355], 0.4770903943767345], [1, [-5.0, 1.748666666666667], 0.4764080478125275], [1, [-5.0, 2.747777777777782], 0.47639327352096533], [1, [-5.0, 3.7488888888889047], 0.4764127764229096], [1, [5.0, 1.748666666666667], 0.4764080478125275], [1, [5.0, 2.747777777777782], 0.47639327352096533], [1, [5.0, 3.7488888888889047], 0.4764127764229096], [1, [-0.4995555555555553, 1.748666666666667], 1.195445212154536], [1, [-0.4995555555555553, 2.747777777777782], 1.1954304378629739], [1, [-0.4995555555555553, 3.7488888888889047], 1.1954499407649182], [1, [0.4995555555555553, 1.748666666666667], 1.195445212154536], [1, [0.4995555555555553, 2.747777777777782], 1.1954304378629739], [1, [0.4995555555555553, 3.7488888888889047], 1.1954499407649182], [1, [2.999777777777754, 2.747777777777782], 0.4770918923827894], [1, [3.995101871921249, 0.4165592527615851], 0.30931831411341904], [1, [4.000079292783948, -0.4195579653043051], 0.3151655617339592], [1, [2.9957671822386653, 0.4144413308994963], 0.30547459497717766], [1, [2.9992154704768277, -0.4195567180219228], 0.3173860859324576], [1, [2.9997701059317867, 3.7475017740059333], 0.47711278912087957], [1, [-5.0, -2.9177777777777623], 0.4764127764229096], [1, [5.0, -2.9177777777777623], 0.4764127764229096], [1, [-2.9997301430858316, 0.4369569107381409], 0.3115631858653669], [1, [-2.9997771589875035, 3.74941304773124], 0.47712613461911063], [1, [-1.9997636445197091, 3.7480718916702163], 0.4771405122872387], [1, [-2.9997777777777532, 5.0], 1.4979111359189865], [1, [-2.9997777777777532, -0.41955555555555524], 0.3156129941106033], [1, [-2.0006666666666666, -0.41955555555555524], 0.3170131507109096], [1, [-1.9949991439204677, 0.41839515422050927], 0.3111306611588538], [1, [-5.0, -1.5846666666666664], 0.47640804781252744], [1, [5.0, -1.5846666666666664], 0.47640804781252744], [1, [-2.999982563202857, -1.574669053752535], 0.47708273342059276], [1, [2.000597186689594, 0.43474322869739973], 0.31068578810807235], [1, [2.000666666666556, -0.41955584692482084], 0.3170133948120385], [1, [2.000666485860488, 3.748541356877145], 0.4785037689630409], [1, [-2.000048159147456, 1.7492651545219304], 0.47657304577152015], [1, [-1.999798770799155, 2.747569325090331], 0.4770233476441052], [1, [2.9998941961875376, 1.7486653276593356], 0.47674052351490415], [1, [-2.9999908223950644, -2.90774551486421], 0.4770835871822303], [1, [2.9999831462367483, -2.9097801627050215], 0.47691019642475946], [1, [2.9999547407149456, -3.908890735667534], 0.4770816198826831], [1, [2.999981385698738, -1.5766690119540807], 0.4768962167021423], [1, [-2.0000411898860033, -1.576673805731073], 0.4769667368218065], [1, [-1.9999481633964469, -2.9089965908756747], 0.4770921700060434], [1, [-3.9999939123321004, 1.7486575816241035], 0.4764269886396603], [1, [-4.00001777915627, 2.747767358761534], 0.4764489976203931], [1, [-3.99997427392061, 3.747774595176188], 0.47647405992083525], [1, [4.000000985646805, 1.7486571012820953], 0.47641095007531936], [1, [1.9994429637184457, 2.7489655534692785], 0.4781675437187201], [1, [1.999718292175434, 1.7489902533877393], 0.47730086479609485], [1, [-3.0000354307990564, 1.748980572469668], 0.47652616946420645], [1, [-2.999939129125637, 2.74854156639347], 0.4765968359940275], [1, [2.0002441101930453, -4.784856491418724], 0.5204416473890733], [1, [-2.0003055036345088, -3.904998870497736], 0.47833552977673083], [1, [2.000270769707658, -1.571657817934627], 0.47822719801449093], [1, [2.000345357783361, -3.9048933331446927], 0.4784745057338372], [1, [-0.49860091722559186, 0.414309267921729], 1.0115356590417721], [1, [0.05687806005287188, 0.41565575573402014], 0.3106582473079944], [1, [4.0001445410719745, -1.5722083702874952], 0.47776103924963864], [1, [-3.9998323671468525, -1.5727181591055897], 0.4777718666059362], [1, [2.0003276673461707, -2.9057823645596703], 0.4783077695354631], [1, [4.000074244870579, 4.748484244748544], 0.47663777701039817], [1, [4.000010790734344, 2.7477678691042398], 0.47642704741177533], [1, [4.000003905855546, 3.748886848126711], 0.47642500187269393], [1, [-4.000049267766771, 4.7484851718075625], 0.4765592961321249], [1, [4.000149879247137, -2.90524967091597], 0.47781416519959274], [1, [-2.0000441040388193, 4.9980993643762135], 1.4992463354497936], [1, [1.999926272578372, 4.998142093491583], 1.4993109097524553], [1, [-0.5000030023796338, -1.5807344206307823], 1.1953125981184956], [1, [-0.5000029241792859, -4.912067761835129], 1.1954354218407128], [1, [0.5000003211587385, -4.912067589658671], 1.1954269064091103], [1, [0.4999998883816562, -1.5807341380057351], 1.1953028500700393], [1, [-3.9999114705916776, -2.9035942574310494], 0.47784022418138195], [1, [-2.0001677331834227, -4.90157673109482], 0.4783855951820039], [1, [3.999895905854853, -3.902921209444691], 0.47798442618426706], [1, [-0.5000184546734684, -2.913844719662781], 1.1953752964299071], [1, [0.5000179747972977, -2.9138446655786368], 1.1953737273912632], [1, [-0.5000175901165167, -3.9129368512503584], 1.1954258990712292], [1, [-2.9999344242305686, -4.770473224539401], 0.522660265659589], [1, [-3.00003184481083, -3.8944263367343503], 0.4792631743494309], [1, [3.9999427118520634, -4.900275060826405], 0.4782465943508458], [1, [-3.999946742537959, -4.9002739013035725], 0.4782341185655099], [1, [-4.000056791031704, -3.902008513353481], 0.47797068372085644], [1, [0.5000039748186752, -3.912922059033364], 1.1953822237016696]], "nr_of_basins": 100, "f_opt_dim_2": 0.47638995187272826, "x_opt_dim_2": [53.0, -128.25250603580008], "f_opt_dim_5": 1.4205465011370849e-05, "x_opt_dim_5": [-4.0000000029239615, 4.897365541408359e-09, -0.003007217539473005, 6.772214803255285e-09, 2.0551299534172867e-08]}
{"id": "3fc53af3-c7a7-4010-8b0a-d97b6cb54e19", "fitness": 0.653553020209074, "name": "phase_transition_landscape", "description": "A novel separable, non-homogeneous landscape with multi-phase transitions. Each dimension has three regimes (inner quadratic, middle high-curvature with ripples, outer high-order growth with ripples) determined by per-dimension thresholds. The non-homogeneous phase boundaries create diverse appearances across the search space while keeping the problem separable and the global minimum at zero.", "code": "import numpy as np\n\nclass phase_transition_landscape:\n    \"\"\"\n    A separable, non-homogeneous landscape with multi-phase transitions per dimension.\n\n    Each coordinate x_i has:\n      - an inner region: |x_i| <= a_i, with quadratic cost alpha_i * x_i^2\n      - a middle region: a_i < |x_i| <= b_i, with cubic cost beta_i * (|x_i|-a_i)^3 plus a ripple term\n      - an outer region: |x_i| > b_i, with quartic cost gamma2_i * (|x_i|-b_i)^4 plus a stronger ripple term\n\n    The parameters a_i, b_i, alpha_i, beta_i, gamma2_i, and ripple parameters are per-dimension\n    to ensure non-homogeneous structure across dimensions. The global optimum is at x = 0\n    with value 0, and the problem is separable (sum of per-dimension terms).\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=98765 + self.dim)\n\n        # Inner and outer region boundaries (per-dimension)\n        self.a = rng.uniform(0.25, 1.5, size=self.dim)  # inner threshold\n        # Ensure outer boundary strictly greater than inner, but within domain [-5,5]\n        self.b = rng.uniform(1.8, 4.5, size=self.dim)\n        # Guarantee a < b\n        self.b = np.maximum(self.b, self.a + 0.2)\n\n        # Region coefficients (per-dimension)\n        self.alpha = rng.uniform(0.4, 2.0, size=self.dim)  # inner quadratic coefficient\n        self.beta = rng.uniform(0.6, 3.0, size=self.dim)   # middle region base coefficient\n        self.gamma2 = rng.uniform(0.6, 3.5, size=self.dim) # outer region base coefficient\n\n        # Ripple-related parameters to inject non-homogeneity\n        self.omega_mid = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase_mid = rng.uniform(0.0, 2*np.pi, size=self.dim)\n        self.ripple_mid = rng.uniform(0.0, 0.6, size=self.dim)\n\n        self.omega_outer = rng.uniform(0.5, 3.0, size=self.dim)\n        self.phase_outer = rng.uniform(0.0, 2*np.pi, size=self.dim)\n        self.ripple_outer = rng.uniform(0.0, 0.8, size=self.dim)\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        inside = absx <= self.a\n        middle = (absx > self.a) & (absx <= self.b)\n        outer = absx > self.b\n\n        # Inner region: smooth quadratic\n        val[inside] = self.alpha[inside] * (x[inside] ** 2)\n\n        # Middle region: cubic growth plus ripple\n        delta_mid = absx[middle] - self.a[middle]\n        val[middle] = (\n            self.beta[middle] * (delta_mid ** 3) +\n            self.ripple_mid[middle] * (\n                np.sin(self.omega_mid[middle] * delta_mid + self.phase_mid[middle]) ** 2\n            )\n        )\n\n        # Outer region: quartic growth plus stronger ripple\n        delta_outer = absx[outer] - self.b[outer]\n        val[outer] = (\n            self.gamma2[outer] * (delta_outer ** 4) +\n            self.ripple_outer[outer] * (\n                np.sin(self.omega_outer[outer] * delta_outer + self.phase_outer[outer]) ** 2\n            )\n        )\n\n        return float(np.sum(val))", "configspace": "", "generation": 1, "feedback": "The optimization landscape phase_transition_landscape scored on:NOT Homogeneous 0.000, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0968fbdf-f2be-48fe-a950-f715f3f12b06"], "operator": null, "metadata": {"ela_features_2D": [-0.002155259476350402, 0.1636098538328749, 0.012508448645809984, 0.024047920266006485, 2.0219360029521667, 0.000862462691190724, 0.5500885216003487, 1.3733377091365173, 0.5502862614004546, 1.5284762011735649, 2.0632507911765714, 1.8, 0.39621729584771714, 0.6462990604654317, 0.32100214922121983, 0.36751859100264134, -0.3311883522405084, 0.16986707749915325, 0.385075835202748, 0.5640984102643765, 0.6904516639172769, 0.16566873960083012, 0.33966688399011125, 0.5817147112873584, 0.6883111807682134, -0.4343999171261421, -0.3217795845610115, -0.22809267808803776, -0.16197901484580102, -0.4292888510731709, -0.339768080950678, -0.21517611398079697, -0.1603412993983855, 1.0, 1.0, 1.0, 1.0, 0.5188207931967439, 0.5188114480884602, 0.42935608456621355, 0.3524276489678488, 0.6714721429116238, 1.0300300300300296, 0.5071077011528271, 0.11311311311311308, 0.4385542168674698], "score_NOT Homogeneous_2D": 0.9209308698773384, "score_Separable_2D": 1.0, "ela_features": [0.0006125987717604531, 0.21995492141571932, 0.005464570664701397, 0.028658700847938062, 10.521765979136251, 0.0053817420325607875, 0.41601751820472, 47.17376666172733, 0.4256297768203474, 1.0369580246100143, 0.7716044683039962, 1.8, 0.582604693211316, 0.8074081043618364, 0.45579617806956607, 0.23129117545049266, -0.48062666392224307, 0.8465036304729925, 0.8253749318004047, 0.841478642226544, 0.8769005219375969, 0.8249714369461101, 0.8067645549330376, 0.827665029850215, 0.8679333042175745, -0.13504764186027368, -0.1536373970744848, -0.13946748512824575, -0.10830190192649092, -0.15483953702527747, -0.17094374104248697, -0.15244903403124765, -0.11682231007143493, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2152581090013946, 0.21527777896354663, 0.19960751478379418, 0.18451277829766227, 0.8238252178258778, 0.5055055055055053, 0.32315905629566255, -0.17117117117117114, 0.5940705128205128], "score_NOT Homogeneous_5D": 0.0002745985984802246, "score_Separable_5D": 1.0, "ela_features_10D": [0.000293247358901505, 0.3091794070676846, 0.0008929920659545221, 0.023191486470497003, 37.56170765073325, 0.0035399468109058585, 0.3275665708337825, 33.053958464608584, 0.3336573712168642, 0.6737857442262504, 0.3736493543075136, 1.4, 0.7487159853614253, 0.8983189767721139, 0.5404332475729892, 0.139118850502235, -0.5477566102471034, 0.8758664258889466, 0.8958392016753406, 0.9109851585487656, 0.9285389836137531, 0.8743879122726211, 0.8936281420344241, 0.9082318381815844, 0.9263032451437739, -0.15743945433738565, -0.13210633114729134, -0.11289710970768282, -0.090632047823661, -0.15974990468688363, -0.1352784206855684, -0.11670652115630005, -0.09372039021840192, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11008025668304762, 0.11008210714018447, 0.10685993272219343, 0.1006033144740192, 0.8669538804721124, 0.08508508508508505, 0.15825734247771145, -0.5275275275275273, 0.6460368294635709], "score_NOT Homogeneous_10D": 0.00011265277862548828, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-0.34555555555555517, -2.9897777777777543], 0.17272053965983047], [6, [0.34555555555555517, 0.00044444444444512003], 0.002870716680251372], [9, [0.34555555555555517, -2.9897777777777543], 0.17272053965983047], [6, [-0.34399675645565486, -0.00030189276886488994], 0.0028536800060179964], [3, [0.34425629337387886, 0.8051461674778253], 0.0045161659640720365], [3, [-0.34414644233253777, 0.807105470296206], 0.004513640910124832], [3, [-0.34390696842936563, -0.8048538984959631], 0.004516501620521746], [3, [0.3441633173679331, -0.8052678079300346], 0.004513738897531996], [9, [-0.34555555555555517, 2.9900000000002214], 0.17272002216338395], [9, [0.34555555555555517, 2.9900000000002214], 0.17272002216338395], [6, [-2.9293147876480607, 2.5861990519214078], 0.8641818418724776], [2, [-2.928985318432573, 0.727977278940367], 0.2962267886668399], [6, [2.9293559538856018, 2.5861830801979977], 0.8642185233647919], [2, [2.928993518725956, 0.7274502569345647], 0.2966931447502411], [6, [2.9296619168550126, -0.882202789703165], 0.2960568371178865], [6, [2.928991478084549, -2.9634692578902886], 0.4337041964505663], [6, [-2.9289818603313997, -2.9634699445995674], 0.43369779104031325], [6, [-2.9291455663193866, -0.8796725011984367], 0.29348190284062264]], "nr_of_basins": 18, "f_opt_dim_2": 0.002851148088507125, "x_opt_dim_2": [0.3437704173789004, -4.971748451611378e-10], "f_opt_dim_5": 0.06693847261602207, "x_opt_dim_5": [-8.083451840267817e-10, -0.691853377325026, -3.165901837316545e-10, -3.1460592228021307, -3.1717910760053233e-09]}
{"id": "142a822a-aa92-4aea-b8c1-5df68f83caaa", "fitness": 0.8471004484842221, "name": "landscape3phase", "description": "A separable, non-homogeneous landscape with three-phase per-dimension transitions. Each dimension features an inner quadratic region, a middle regime with higher curvature, and an outer rugged region with a phase-influenced ripple. The boundaries (phase transitions) vary across dimensions, producing a highly non-homogeneous search space while preserving separability. Global optimum remains at the origin.", "code": "import numpy as np\n\nclass landscape3phase:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Seeded RNG for deterministic, per-dimension heterogeneity\n        rng = np.random.default_rng(seed=2029 + self.dim)\n\n        # Phase boundaries per dimension (inner threshold a1, outer threshold a2)\n        self.a1 = rng.uniform(0.25, 1.0, size=self.dim)      # inner boundary\n        self.a2 = rng.uniform(1.5, 3.0, size=self.dim)       # outer boundary\n        # Ensure a2 > a1 (margin to enforce three distinct regions)\n        self.a2 = np.maximum(self.a2, self.a1 + 0.5)\n\n        # Curvature parameters\n        self.alpha = rng.uniform(0.6, 2.2, size=self.dim)    # inside a1: quadratic curvature\n        self.alpha2 = rng.uniform(1.5, 3.0, size=self.dim)   # between a1 and a2: higher-curvature quadratic\n\n        # Outside region: base quadratic growth parameter\n        self.beta = rng.uniform(0.7, 2.5, size=self.dim)\n\n        # Outside-region ripple parameters to create ruggedness\n        self.gamma = rng.uniform(0.0, 0.6, size=self.dim)     # ripple amplitude\n        self.omega = rng.uniform(0.8, 3.5, size=self.dim)     # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim) # ripple phase shift\n\n        # Ensure continuity at a2 by computing a per-dimension offset C:\n        # C[i] = alpha2*(a2 - a1)^2 + alpha*(a1)^2 - gamma*(sin(phase))^2\n        self._continuity_C = (\n            self.alpha2 * ((self.a2 - self.a1) ** 2) +\n            self.alpha * (self.a1 ** 2) -\n            (self.gamma * (np.sin(self.phase) ** 2))\n        )\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        # Region 0: inside a1 -> smooth quadratic\n        inside0 = absx <= self.a1\n        if np.any(inside0):\n            val[inside0] = self.alpha[inside0] * (x[inside0] ** 2)\n\n        # Region 1: between a1 and a2 -> middle regime with higher curvature\n        region1 = (absx > self.a1) & (absx <= self.a2)\n        if np.any(region1):\n            # Continuity at a1 is ensured by constructing region1 to start at alpha*a1^2\n            val[region1] = (\n                self.alpha2[region1] * ((absx[region1] - self.a1[region1]) ** 2) +\n                self.alpha[region1] * (self.a1[region1] ** 2)\n            )\n\n        # Region 2: outside a2 -> outer rugged region with ripple, tuned for continuity\n        outside = absx > self.a2\n        if np.any(outside):\n            # Use per-dimension continuity constant C[i]\n            C = self._continuity_C\n            val[outside] = (\n                self.beta[outside] * ((absx[outside] - self.a2[outside]) ** 2) +\n                C[outside] +\n                self.gamma[outside] * (np.sin(self.omega[outside] * (absx[outside] - self.a2[outside]) + self.phase[outside]) ** 2)\n            )\n\n        return float(np.sum(val))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape3phase scored on:NOT Homogeneous 0.523, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["0968fbdf-f2be-48fe-a950-f715f3f12b06"], "operator": null, "metadata": {"ela_features_2D": [-0.0019468424502278926, 0.47158953162289796, 0.01733244878088802, 0.03227541937928047, 2.4627296967873287, -0.0009586327832510566, 0.8931080855190524, 1.4291949797871994, 0.892644493759391, -0.031081721091571757, -0.9231725018515086, 1.8, 0.7095149885982407, 0.720775614308903, 0.5638687213350955, 0.33746190745801913, -0.1768382056087361, 0.1545377271501735, 0.23602216593074532, 0.3248022996535368, 0.5078480607872209, 0.1621365272579731, 0.23577396900829864, 0.3277579360618801, 0.5050605487476739, -0.4423720832294, -0.3997384496669257, -0.3532869943353333, -0.2575108244354799, -0.43065674276544497, -0.39279864085846167, -0.3455200222250417, -0.2543926799604626, 1.0, 1.0, 1.0, 1.0, 0.5137677002672791, 0.5137593154263037, 0.37751480864371256, 0.34788562812787605, 0.7114068772601065, 0.5095095095095094, 0.44634429548228455, -0.0870870870870871, 0.3622489959839358], "score_NOT Homogeneous_2D": 0.6212866604328156, "score_Separable_2D": 1.0, "ela_features": [0.002051214291475012, 0.43933270254518125, 0.004738098086234454, 0.03155588616831541, 127.7822669798788, 0.008764473632287717, 0.9465244219712545, 1.5814765729099132, 0.9464450766894936, 0.11340604863096138, -0.2533174331545469, 1.2, 0.8841399843331029, 0.8692878055761, 0.6320924055275899, 0.1849244126134703, -0.46304169793865435, 0.4682886699822701, 0.551286902995943, 0.6241254135249236, 0.7325174461823869, 0.4666844506090581, 0.5521191945881238, 0.624816710379574, 0.7345450623504858, -0.4678681116942863, -0.3948389215171961, -0.33074674279623983, -0.23536753473292849, -0.471829892612185, -0.3962560675715318, -0.3319424231819985, -0.23485797983567105, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2154172403837097, 0.21540037238737403, 0.20178932809456893, 0.1828849696317123, 0.8290290721493108, 0.10510510510510507, 0.23878499612334375, -0.4194194194194193, 0.5184294871794871], "score_NOT Homogeneous_5D": 0.938297163695097, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0008578243812158215, 0.44840425821854435, 0.0008382370205832088, 0.016390964203125934, 54.22133601654, 0.003004495735180357, 0.9640725165260511, 2.278609238800291, 0.9638620666013965, 0.17125212781634988, -0.02603590481914635, 1.2, 1.011873927442964, 0.9369198118977149, 0.7104836113024146, 0.10502020798379941, -0.6034565285859885, 0.6298396007615426, 0.6926473864279106, 0.7406829226898191, 0.8169736735221388, 0.6323712773785071, 0.694467114737965, 0.7436647504387707, 0.8204422696701418, -0.4694575523558986, -0.3898011650598042, -0.32888018025484855, -0.2321242390653096, -0.4674748750640122, -0.3885137398792681, -0.32595421871682273, -0.22832447287838095, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.110176562468749, 0.11017464547970768, 0.10737643051039214, 0.10037838686033966, 0.856320795671411, -0.1471471471471471, 0.12861378718868802, -0.6636636636636635, 0.5916733386709369], "score_NOT Homogeneous_10D": 0.52301886677742, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [0.00044444444444512003, -3.080888888888978], 9.7491801477857], [16, [-0.000197070848157455, 3.080886103085179], 9.749179920665119], [64, [0.00044444444444512003, 0.00044444444444512003], 6.393749689096145e-07]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.438153389046108e-162, 1.3727289610676732e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.850410501838574e-163, 1.5427119207068273e-162, 2.5695357064197946e-163, -6.441514990763654e-163, 3.6116268053173236e-163]}
{"id": "2d203bac-a1d7-4a75-be71-9e11459eb2a4", "fitness": 0.8894147165119648, "name": "landscape_phase_sep_enhanced", "description": "A separable, non-homogeneous landscape with per-dimension phase transitions that blend a quadratic well near the origin with a dimension-specific, smoother quartic growth beyond a threshold. Each dimension has its own threshold and curvature parameters, preserving separability while creating a non-uniform search space. The global minimum remains at the origin (0, ..., 0).", "code": "import numpy as np\n\nclass landscape_phase_sep_enhanced:\n    \"\"\"\n    Enhanced separable landscape with per-dimension phase transitions.\n    Each dimension has its own threshold t_i, steepness k_i, quadratic\n    coefficient a_qi and quartic coefficient a_q4i. The per-dimension\n    cost smoothly transitions from quadratic near the origin to quartic\n    growth beyond the threshold using a logistic blend.\n\n    Global optimum at x = 0 with value 0. \n    Domain per-dimension: [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension non-homogeneous parameters (deterministic, vary with i)\n        idx = np.arange(self.dim)\n\n        # Thresholds vary per dimension to create non-homogeneous search space\n        # Values cycle through 1.0, 1.5, 2.0, 2.5, ...\n        self.thresholds = 1.0 + (idx % 4) * 0.5\n\n        # Dimension-specific logistic steepness (k_i)\n        self.k_arr = 2.5 + (idx % 4) * 0.8  # e.g., 2.5, 3.3, 4.1, 4.9, ...\n\n        # Per-dimension coefficients for quadratic vs quartic terms\n        self.a_quad = 0.8 + (idx % 5) * 0.15      # ~0.8 to ~1.65\n        self.a_quartic = 0.12 + (idx % 5) * 0.04  # ~0.12 to ~0.32\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        x: array-like of length self.dim, real-valued.\n        Returns: float, the sum of per-dimension costs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        # Per-dimension absolute distance from origin\n        r = np.abs(x)\n\n        # Smooth per-dimension phase transition from quadratic to quartic\n        # h_i ~ 0 near origin, h_i ~ 1 far from origin\n        # h_i = 1 / (1 + exp(-k_i * (r - t_i)))\n        h = 1.0 / (1.0 + np.exp(-self.k_arr * (r - self.thresholds)))\n\n        # Per-dimension terms\n        quad_term = self.a_quad * (x ** 2)\n        quartic_term = self.a_quartic * (x ** 4)\n\n        per_dim_val = (1.0 - h) * quad_term + h * quartic_term\n\n        return float(np.sum(per_dim_val))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_phase_sep_enhanced scored on:NOT Homogeneous 0.930, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1d3b4f7b-ccbd-4b83-b9fd-738fece23c15"], "operator": null, "metadata": {"ela_features_2D": [-0.001035137931616603, 0.22429964556268073, 0.011548635975378571, 0.03647604066115847, 18.753100068927132, 0.006619425850248706, 0.917283405308123, 1.3343955595334045, 0.9182207404401257, 1.045263105230052, 0.49482251932326815, 1.4, 0.712002317392117, 0.7177974119180947, 0.5483167516502349, 0.34233175179703573, -0.22805731288433675, 0.1311823266623416, 0.21762726532935078, 0.30661705241483556, 0.48686215082468953, 0.12703955914614254, 0.212779698115685, 0.3040596689880214, 0.48863175208700715, -0.4543108031730053, -0.40910269661038284, -0.36257191283685414, -0.26831887969145224, -0.4478617315989172, -0.4038652871082732, -0.35704003406513685, -0.26234035686676843, 1.0, 1.0, 1.0, 1.0, 0.526807509204928, 0.5268009816886486, 0.4173209804418245, 0.35985206556609656, 0.612139266708106, 0.6536536536536535, 0.53272945564776, -0.11911911911911913, 0.38554216867469876], "score_NOT Homogeneous_2D": 0.8622229248285294, "score_Separable_2D": 1.0, "ela_features": [0.001732377680669317, 0.3095478697293933, 0.0059837432074127134, 0.03301360536164809, 19.61283738087494, 0.007041726634070966, 0.9133184511522657, 2.3255970439754554, 0.9140214141710145, 0.6536726655025843, 0.10930852507365012, 1.6, 0.9057514683187815, 0.8755330155069739, 0.6249961317365903, 0.18206070194753562, -0.5027415443295735, 0.4366930384153765, 0.5314864934916232, 0.6067383864547601, 0.7337025489402891, 0.43818146407277875, 0.5338329510853621, 0.6096973301350472, 0.7345172366076167, -0.49557812139830837, -0.4121828059426186, -0.34597844639560904, -0.23427894659369022, -0.49703326650683477, -0.4124131822689455, -0.3452965076713871, -0.23486795512008643, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21523950030513234, 0.2152287888535585, 0.19953250627932892, 0.18225681478397343, 0.8252626417623858, 0.2772772772772772, 0.28899986474011485, -0.29129129129129117, 0.5318910256410256], "score_NOT Homogeneous_5D": 0.5441032350063324, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0009089416396440786, 0.3309791109505133, 0.0011373382692847042, 0.01629347322891713, 21.655410106302508, 0.006572751142851607, 0.9184208031273897, 2.376408828191515, 0.9193982118959674, 0.5054781517838322, 0.2114298354803455, 1.6, 1.0134187965117254, 0.9391178767650888, 0.7025794391758813, 0.10479169399899795, -0.5944362114769618, 0.6347460204237334, 0.6917436776024829, 0.7424835316437237, 0.8198806614793289, 0.6363947772874006, 0.6949196141399379, 0.7454108127726691, 0.8232259357719887, -0.4632102082449124, -0.3909266342026645, -0.3265787748343905, -0.2284247611606173, -0.4622439746792832, -0.3878424832345748, -0.3236534161810578, -0.22472884309021005, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11089521324983556, 0.11089573350604251, 0.10768276895547162, 0.10122623527702346, 0.8638982941443064, -0.07507507507507508, 0.1430634145561257, -0.6196196196196194, 0.6063250600480383], "score_NOT Homogeneous_10D": 0.930162139236927, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.323574258141164e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [2.817847113982332e-163, 1.3083720020076888e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.835033849739991e-163, 1.0989707259195448e-162, 2.3569152713162437e-163, 5.302895697949198e-163, -1.4102298871619275e-162]}
{"id": "8b938bce-d3cb-4a77-825c-375d72f6d29b", "fitness": 0.86193094526728, "name": "landscape", "description": "A separable, non-homogeneous benchmark landscape with two per-dimension phase transitions. Each dimension uses two thresholds to create three regimes: near-origin quadratic, mid-range enhanced-quadratic, and outer-region quartic growth. The thresholds vary across dimensions to produce a non-homogeneous global landscape while keeping the problem separable. The global minimum remains at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension, non-homogeneous phase-transition thresholds\n        # Two thresholds per dimension to create a three-regime landscape\n        # Thresholds vary with dimension to ensure non-homogeneous appearance\n        self.t1 = np.array([0.8 + (i % 5) * 0.25 for i in range(self.dim)], dtype=float)\n        self.t2 = np.array([2.0 + (i % 5) * 0.25 for i in range(self.dim)], dtype=float)\n\n        # Transition sharpness (per-dimension, can be tuned)\n        self.k1 = 6.0  # sharpness for inner -> mid transition\n        self.k2 = 6.0  # sharpness for mid -> outer transition\n\n        # Per-dimension curvature coefficients to enhance non-homogeneity\n        # Quadratic term near origin (inner regime)\n        base_quad0 = np.array([0.6 + 0.08 * i for i in range(self.dim)], dtype=float)\n        # Quadratic term in the middle regime (higher curvature)\n        base_quad1 = base_quad0 * 1.4\n        # Quartic term in the outer regime\n        base_quartic = np.array([0.25 + 0.04 * (i % 4) for i in range(self.dim)], dtype=float)\n\n        self.a_quad0 = base_quad0\n        self.a_quad1 = base_quad1\n        self.a_quartic = base_quartic\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)  # per-dimension distance from origin\n\n        # Two smooth transitions per dimension to create non-homogeneous regions\n        # u: inner -> mid transition, centered at t1\n        # v: mid -> outer transition, centered at t2\n        u = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        v = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        inner = self.a_quad0 * (x ** 2)\n        mid = self.a_quad1 * (x ** 2)\n        quart = self.a_quartic * (x ** 4)\n\n        # Three-regime blending:\n        # near origin -> inner quadratic\n        # middle region (t1 < |x| < t2) -> mid quadratic\n        # outer region (|x| > t2) -> quartic\n        val = (1.0 - v) * ( (1.0 - u) * inner + u * mid ) + v * quart\n\n        return float(np.sum(val))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.899, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1d3b4f7b-ccbd-4b83-b9fd-738fece23c15"], "operator": null, "metadata": {"ela_features_2D": [-0.0022830587495054288, 0.21948862096884286, 0.01636969736854708, 0.023338947212682936, 1.855757663665279, 0.0006971830178786442, 0.9151563708212347, 1.1655248076047218, 0.9152566652675352, 0.9827995653521355, 0.3362369989184691, 1.2, 0.712797636783803, 0.7206114147085756, 0.5665074507337569, 0.33872154672198984, -0.23298601850389744, 0.13668066067427898, 0.22130823804401975, 0.30668848882121197, 0.4852284759971651, 0.1403888978547067, 0.22528430037871341, 0.3085216699546652, 0.4864110249552587, -0.45177629890487053, -0.40748784194186627, -0.36280760463206324, -0.26937634732162, -0.4414146829696131, -0.3978039778034148, -0.35505896471978676, -0.26370778983239634, 1.0, 1.0, 1.0, 1.0, 0.5179896353515507, 0.5178723243155151, 0.4045930671364557, 0.3510239497343564, 0.6150260521796638, 0.6456456456456454, 0.48888712540337825, -0.09909909909909909, 0.36947791164658633], "score_NOT Homogeneous_2D": 0.7486514449119568, "score_Separable_2D": 1.0, "ela_features": [-0.00037572407208648074, 0.3173116291333193, 0.002633163481375471, 0.028637052679553555, 25.293014954374364, 0.002998591658127392, 0.9128671204887876, 1.4834513503602194, 0.9138919327162984, 0.6403820532784281, 0.09453062932239283, 1.2, 0.9080044239769306, 0.8724277790052846, 0.6382216783795218, 0.18637257080540479, -0.49311228449014594, 0.41540017711264665, 0.5180082601184323, 0.6012005725672337, 0.7246785395293099, 0.419122448058581, 0.5183938711925213, 0.6025498494239538, 0.7272867218293028, -0.5140840367518302, -0.4238521614142249, -0.35069477703782936, -0.24211104844681017, -0.5131597212742517, -0.4254596792741864, -0.35111389719625874, -0.24092001898241433, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21694678810379514, 0.21694243742802183, 0.20040703170211804, 0.183193523565235, 0.8301253563972599, 0.28128128128128116, 0.2764121210289495, -0.29129129129129117, 0.5485576923076924], "score_NOT Homogeneous_5D": 0.5236814022064209, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00023241104392996982, 0.3536174775207573, 0.0015462724321186044, 0.022536903525493025, 16.344008318896563, 0.005241338618259395, 0.9117157868894905, 1.5194708451961678, 0.9128074584090573, 0.46197788510664217, 0.08311331300091718, 1.4, 1.005624300672562, 0.9374315408836589, 0.6956687720063081, 0.10716500059028453, -0.5972864950995922, 0.6355599393780332, 0.6969663826296205, 0.7467582159498283, 0.8176794632554986, 0.6355686139798683, 0.7001668785063646, 0.7500039049120708, 0.8213268215231408, -0.46220857182950115, -0.3843286670961756, -0.3211790751512512, -0.23123171516501945, -0.46342883661205825, -0.3812812596837552, -0.31790523330422943, -0.2272079453301162, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10997505315532867, 0.10996903828354451, 0.10672419988424083, 0.10031818242013804, 0.8616869256489702, -0.05505505505505507, 0.1461256092099701, -0.6116116116116114, 0.6027221777421937], "score_NOT Homogeneous_10D": 0.899252824485302, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.5332532338206224e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-5.308078053288258e-163, -1.3303728033982542e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.3159648556565646e-162, 6.284333250746378e-163, 1.4283173122150912e-162, 4.738254559649767e-163, 5.3980845524479963e-163]}
{"id": "457e84bc-eba8-45a9-a4a8-d411617b020c", "fitness": 0.5629856189092001, "name": "landscape", "description": "A separable, non-homogeneous landscape with per-dimension phase transitions that switch from an inner quadratic well to an outer region combining linear growth and oscillatory terms. Each dimension uses its own threshold and parameters, making the search space non-homogeneous while preserving separability. The global optimum remains at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5):\n        self.dim = dim\n        # Dimension-specific, deterministic parameters to create non-homogeneity\n        # r_i: threshold for phase transition (inner quadratic vs outer region)\n        # a_i: quadratic curvature inside the threshold\n        # b_i: linear growth slope outside the threshold\n        # d_i: frequency multiplier for the sinusoidal term in the outer region\n        # c, e: fixed outer-region coefficients (c controls sin term, e shifts baseline)\n        self.r = np.zeros(self.dim, dtype=float)\n        self.a = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.d = np.zeros(self.dim, dtype=int)\n        self.c = 0.8\n        self.e = 1.0\n        for i in range(self.dim):\n            k = i + 1  # 1-based indexing for deterministic variation\n            # thresholds: mix of 0.8, 1.2, 1.6, 2.0, 2.4 in a repeating pattern\n            self.r[i] = 0.8 + 0.4 * ((k * 3) % 5)\n            # inner quadratic curvature: variety across dimensions\n            self.a[i] = 0.6 + 0.4 * ((k * 2) % 5)\n            # outer region slope (linear growth)\n            self.b[i] = 0.4 + 0.3 * ((k * 3) % 6)\n            # frequency for the sinusoidal component in the outer region\n            self.d[i] = 1 + ((k * 4) % 6)\n\n    def f(self, x):\n        \"\"\"\n        Separable, non-homogeneous landscape with per-dimension phase transitions.\n        Each dimension i contributes:\n          - g_i(x_i) = a_i * x_i^2 if |x_i| <= r_i\n          - g_i(x_i) = b_i * |x_i| + c * sin(d_i * x_i) + e otherwise\n        Global minimum is at x = 0 with f(x) = 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            raise ValueError(\"Input x must be a 1D array of length self.dim.\")\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x length must equal self.dim.\")\n\n        gi = np.zeros(self.dim, dtype=float)\n        for i in range(self.dim):\n            xi = x[i]\n            if abs(xi) <= self.r[i]:\n                gi[i] = self.a[i] * xi * xi\n            else:\n                gi[i] = self.b[i] * abs(xi) + self.c * np.sin(self.d[i] * xi) + self.e\n        return float(np.sum(gi))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.070, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["9107ab6f-e078-4660-bdd8-df21abbac43a"], "operator": null, "metadata": {"ela_features_2D": [0.0012373675250705318, 0.5176828629505431, 0.02093803236862138, 0.044167641234128606, 69.29887508185438, 0.001922462545267245, 0.7418640898281069, 3.326205126098697, 0.7482560461578546, -0.2475688572191242, -0.7743793705464116, 1.4, 0.4567298904774095, 0.6394315121227904, 0.3989591805189669, 0.3793599151811406, -0.26436695003012356, 0.21567169668457487, 0.36150359324187403, 0.5212096011821591, 0.6388336685908026, 0.20411280416979322, 0.3335495123814475, 0.4596924800507992, 0.581748812827002, -0.4102353902740714, -0.33395068076055756, -0.25042732245101423, -0.188903865390868, -0.4085983914548127, -0.3421317072289203, -0.27739074006745995, -0.21472197108460045, 1.0, 1.0, 1.0, 1.0, 0.5227446160495683, 0.5227332704739476, 0.4062089881377299, 0.3620185029644089, 0.8013495000952208, 0.9299299299299296, 1.0066187747445332, 0.21721721721721715, 0.4710843373493976], "score_NOT Homogeneous_2D": 0.2977885603904724, "score_Separable_2D": 1.0, "ela_features": [0.00412214744192656, 0.5498696257536152, 0.005782258698098889, 0.038653976774127415, 7.770616422795365, 0.004817178545725209, 0.750729337784574, 4.115914219879313, 0.7564817941211686, -0.16555482919280684, -0.313039459998777, 1.0, 0.79777715461675, 0.8472354643294094, 0.574175142598269, 0.20355358120648206, -0.49602336767375216, 0.5742228662757444, 0.6313190965256251, 0.6811873972184794, 0.7790815683942581, 0.5575908751720862, 0.6129825997453098, 0.6695881864712794, 0.7717704102101989, -0.374465088531273, -0.32424945314761733, -0.2803910570887598, -0.1942948221042497, -0.3909626372693228, -0.3420104190993528, -0.29199036096735903, -0.20169181285612195, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2169403106874678, 0.21695261016972012, 0.20309949508090494, 0.1878495807032589, 0.851635038688633, 0.24924924924924916, 0.2794402502472247, -0.31931931931931923, 0.5631410256410257], "score_NOT Homogeneous_5D": 0.009694933891296387, "score_Separable_5D": 1.0, "ela_features_10D": [0.007267590988837625, 0.5648087702728579, 0.0013119778627113977, 0.03444241682470168, 66.61368491604472, 0.010638597428102936, 0.7108544592662949, 4.7957366023430925, 0.7222645733328369, -0.08790631179458888, -0.1127504913838834, 1.0, 0.8993327834481694, 0.9220411678510629, 0.6288641743012642, 0.11832173705644458, -0.608714775365467, 0.7276598242582025, 0.7642142898363001, 0.8032547539269705, 0.8606949319461595, 0.722840324892273, 0.7605855992373158, 0.8014750409847364, 0.8605886429878504, -0.3453933356003713, -0.2990328081260298, -0.24951974290088605, -0.1766719136484003, -0.3524454024845493, -0.3044441865040662, -0.2524462833718021, -0.17727627282613984, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11041876818504089, 0.11042909911970847, 0.10741169799547594, 0.1030532611744464, 0.8597405173307763, -0.04304304304304305, 0.1424607388755177, -0.6036036036036034, 0.6064851881505204], "score_NOT Homogeneous_10D": 0.0704302191734314, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, 5.0], 11.126111672203912], [1, [-3.888888888888889, 5.0], 9.127452682538959], [2, [-5.0, 0.00044444444444512003], 7.605881834646119], [2, [-3.888888888888889, 0.00044444444444512003], 5.607222844981167], [1, [3.3868893743591313, 5.000044064101793], 8.170077607854706], [1, [-5.0002795505990285, 1.5006702218111254], 8.423042851159948], [1, [-3.8890847347953232, 1.5046690815353], 6.424386615736403], [4, [-0.0003318347340222341, 1.5146545593954837], 0.8171820131911336], [4, [0.00044444444444512003, 5.0], 3.520230548668903], [8, [0.00044444444444512003, 0.00044444444444512003], 7.111111111132731e-07], [8, [0.00044444444444512003, 3.609777777777687], 1.6549403746562257], [8, [0.00044444444444512003, -4.656888888888805], 2.073819174714372], [8, [0.00044444444444512003, -2.5617777777778015], 1.2360613475453475], [1, [4.644347023650896, 1.5146095532991208], 7.100685353324893], [2, [3.376663835670085, 1.5148074998332217], 5.468582975554395], [2, [4.646077348659567, -4.656299679708933], 8.35729033428152], [2, [-3.889059366069381, 3.599779690793653], 7.262145243455693], [2, [-5.000259213413112, 3.595781004702859], 9.260784483892891], [2, [3.3883326054969864, -4.656636043137647], 6.723675786848288], [3, [4.645743889500848, 3.608380519817682], 7.938416301957411], [3, [2.1321836167632116, 3.608092638766479], 4.67116543803075], [2, [3.389037923889256, -2.5616503966968622], 5.885907197908953], [2, [2.1333180414664694, -4.634155974768836], 5.0918114949458175], [2, [4.645999094238036, -2.5612650613729304], 7.5195352049533515], [2, [-5.000206228271887, -2.5497800360079466], 8.841936682794005], [2, [-3.8890825026781743, -2.551780138717541], 6.8432764646540996], [2, [2.1322377065077056, -2.5628736063009936], 4.252281578828331], [1, [-2.7617777777779287, 1.5146665969204527], 4.650213802137855], [2, [-2.7617470011482617, -4.654900642684362], 5.906860129031902], [2, [-2.7617508646636684, 3.607789476143085], 5.487980147741827], [1, [-2.75977782534327, 5.000013793465816], 7.35325973799773], [2, [-2.7617777777777794, 0.00044444444444512003], 3.833032404995215], [2, [-2.7601220434523324, -2.560999660491794], 5.0691061956320755], [1, [3.377601505973193, 3.598359368453642], 6.306553102762889], [2, [3.3021708965520875, -0.09332670874652282], 4.736489954666793], [1, [2.1265090025208524, 1.5049193242974805], 3.834141537717874], [2, [4.632387757079347, -0.03502975618623992], 6.287956778925409], [2, [-3.9042028418538295, -4.582693798108887], 7.670633452493718], [2, [2.1168212510555, 0.027221795392167406], 3.020270153160558], [2, [-5.000253975517215, -4.642891988507761], 9.679685815877466]], "nr_of_basins": 40, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.485566427344469e-163, 1.654592178974291e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.8767399889779e-163, 6.091620584849596e-163, -1.298944806268338e-162, -5.607793725527935e-163, 1.0836382792829276e-162]}
{"id": "90662704-9851-41a8-8ed7-72f5e993b9ce", "fitness": 0.9160417889555296, "name": "landscape_nh", "description": "A separable, non-homogeneous landscape with dimension-specific phase transitions and small outer-region oscillations to enforce not-homogeneous structure. Each dimension has its own inner and outer thresholds, yielding varied curvature across the search space while preserving separability. The global optimum remains at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape_nh:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self._setup_params()\n\n    def _setup_params(self):\n        # Deterministic seed for reproducibility\n        rng = np.random.RandomState(2025)\n\n        # Per-dimension phase-transition thresholds (non-homogeneous across dims)\n        # Inner boundary\n        self.s1 = rng.uniform(0.4, 1.8, size=self.dim)\n        # Outer boundary (kept > s1)\n        self.s2 = self.s1 + rng.uniform(0.9, 2.8, size=self.dim)\n        # Clamp to domain to avoid unrealistic thresholds\n        self.s1 = np.clip(self.s1, 0.0, 4.5)\n        self.s2 = np.clip(self.s2, self.s1 + 0.01, 5.0)\n\n        # Per-dimension region coefficients (introduce non-homogeneity)\n        self.a1 = rng.uniform(0.4, 0.9, size=self.dim)   # inner quadratic\n        self.a2 = rng.uniform(0.7, 1.4, size=self.dim)   # middle quadratic\n        self.a3 = rng.uniform(0.5, 1.5, size=self.dim)   # outer linear\n\n        # Continuity constants\n        self.b = self.a1 * (self.s1 ** 2)\n        self.d = self.a2 * ((self.s2 - self.s1) ** 2) + self.b\n\n        # Outer-region ripple to enforce not-homogeneity (small ruggedness)\n        self.ripple = rng.uniform(-0.18, 0.18, size=self.dim)\n        self.k = rng.uniform(0.6, 2.2, size=self.dim)  # ripple frequency\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape value: sum_i g_i(x_i)\n        Each dimension i has three regimes based on |x_i|:\n        - |x_i| <= s1_i:     g_i = a1_i * (|x_i|)^2\n        - s1_i < |x_i| <= s2_i: g_i = a2_i * (|x_i| - s1_i)^2 + b_i\n        - |x_i| > s2_i:      g_i = a3_i * (|x_i| - s2_i) + d_i + ripple_i * sin(k_i * (|x_i| - s2_i))\n        Global optimum at x = 0 with value 0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        xi = np.abs(x)\n\n        gi = np.zeros(self.dim, dtype=float)\n\n        mask1 = xi <= self.s1\n        mask2 = (xi > self.s1) & (xi <= self.s2)\n        mask3 = xi > self.s2\n\n        # Inner region\n        if np.any(mask1):\n            gi[mask1] = self.a1[mask1] * (xi[mask1] ** 2)\n\n        # Middle region\n        if np.any(mask2):\n            gi[mask2] = self.a2[mask2] * ((xi[mask2] - self.s1[mask2]) ** 2) + self.b[mask2]\n\n        # Outer region\n        if np.any(mask3):\n            gi[mask3] = (self.a3[mask3] * (xi[mask3] - self.s2[mask3])\n                       + self.d[mask3]\n                       + self.ripple[mask3] * np.sin(self.k[mask3] * (xi[mask3] - self.s2[mask3])))\n\n        total = float(np.sum(gi))\n        return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh scored on:NOT Homogeneous 0.729, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c16b2ad0-70d5-44ae-b624-abed19e902ff"], "operator": null, "metadata": {"ela_features_2D": [-0.0026943130409127214, 0.44232307552164374, 0.012347357876947023, 0.02698484585252129, 3.0136903453525785, -0.0009633488810941282, 0.9350716164564135, 1.7683928191743579, 0.9354760063381418, 0.11433290820534998, -1.0256367342502553, 2.6, 0.7102826982331726, 0.7111961502171928, 0.5473334844835747, 0.3463638130038467, -0.16836604856839804, 0.1473146728277303, 0.22305436379116977, 0.3147747971525674, 0.505987504194539, 0.15071813184163385, 0.22276958453531912, 0.3155821049748925, 0.5010768456983248, -0.446053432567281, -0.4064370023325129, -0.3584552039812636, -0.25842477978047784, -0.43629640736943137, -0.3992894379698136, -0.35160299597703804, -0.2563029962305567, 1.0, 1.0, 1.0, 1.0, 0.5195157893769677, 0.519509486821838, 0.36572828403836316, 0.3513195575570929, 0.7098279807686395, 0.5135135135135134, 0.5914639910150143, -0.1351351351351351, 0.3558232931726908], "score_NOT Homogeneous_2D": 0.9040753543376923, "score_Separable_2D": 1.0, "ela_features": [-0.0016758442390415907, 0.4567570876043181, 0.005381266866029712, 0.02027324977123444, 10.741305956205881, 0.0049022820513644925, 0.9577478295478807, 1.7247665655434417, 0.9578529964052919, 0.1095148403818531, -0.34221472180393225, 1.0, 0.8982832342814728, 0.8703541392216273, 0.6389961956181864, 0.18601947483306291, -0.46961147707219386, 0.4189610578819926, 0.5215451586582791, 0.6000600397400749, 0.71983806102534, 0.42215595332470846, 0.5203479889384806, 0.6010853701695835, 0.7218722973796655, -0.5110243568097095, -0.4208008829787234, -0.35174696469818734, -0.24640202482308968, -0.5108218645792855, -0.424017764471024, -0.3526448368705233, -0.2458666180727279, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21520525225945392, 0.21523429235927236, 0.19988733682139648, 0.18061129425917352, 0.8181824003879555, 0.12112112112112108, 0.24501586376658366, -0.3633633633633632, 0.49951923076923077], "score_NOT Homogeneous_5D": 0.8633813112974167, "score_Separable_5D": 1.0, "ela_features_10D": [-0.000550194373730406, 0.4741318543720062, 0.0008559328509203897, 0.021740862210197668, 34.44293331295515, 0.00188762851274884, 0.9513533317001676, 2.862938288170935, 0.9521169222487252, 0.1639653947508533, -0.18902132546392086, 1.0, 0.9904577457347548, 0.9362719267687126, 0.701297502611457, 0.10456160809076369, -0.6000349187278573, 0.64816038768828, 0.7065268708100739, 0.754010522764764, 0.8257716547064037, 0.6482225135095386, 0.7079142310224789, 0.7560284108077283, 0.8281144410826753, -0.44625327884909394, -0.37222536850638926, -0.3119998348163423, -0.2209821557833352, -0.44734172054131793, -0.3714359085266638, -0.3102510934282029, -0.21858201838207797, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10913220794710869, 0.10912511163512373, 0.10587345958356416, 0.09938262040996111, 0.8560532701733058, -0.0990990990990991, 0.14097318136387044, -0.6196196196196194, 0.5868694955964772], "score_NOT Homogeneous_10D": 0.7287940680980682, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.2181056606636735e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.746118522086977e-163, -2.2715600737466886e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2788574676758273e-164, 6.672533186251974e-163, -1.80914624392839e-162, -7.819951864605755e-164, -9.239921841717417e-163]}
{"id": "fd7a3891-64ad-471f-8e10-39c8b6ae7b5e", "fitness": 0.8663572867711385, "name": "landscape", "description": "A separable, non-homogeneous landscape with per-dimension adaptive phase transitions. Each dimension has its own inner and outer boundaries (a_i, b_i) and distinct curvature in the middle and outer regimes, ensuring a non-uniform, phase-transitioned search space while preserving separability. The global minimum remains at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape:\n    \"\"\"\n    A separable, non-homogeneous landscape with per-dimension adaptive phase transitions.\n    Each dimension i has its own inner radius a_i and outer radius b_i.\n    - Phase 1 (ri <= a_i): g_i(ri) = ri^2\n    - Phase 2 (a_i < ri <= b_i): g_i(ri) = p_i * (ri - a_i)^2 + q_i\n    - Phase 3 (ri > b_i):      g_i(ri) = s_i * (ri - b_i)^2 + t_i\n    q_i and t_i are chosen to ensure continuity; p_i and s_i control curvature.\n    The function is separable: f(x) = sum_i g_i(|x_i|).\n    The minimum is at x = 0 with value 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters (deterministic, non-homogeneous across dims)\n        # These choices create a varied landscape across dimensions\n        self.a = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.p = np.zeros(self.dim, dtype=float)  # middle-region curvature\n        self.q = np.zeros(self.dim, dtype=float)  # phase-2 intercept to ensure continuity\n        self.s = np.zeros(self.dim, dtype=float)  # outer-region curvature\n        self.t = np.zeros(self.dim, dtype=float)  # phase-3 intercept to ensure continuity\n\n        for i in range(self.dim):\n            # Non-homogeneous, dimension-specific parameters\n            # Inner radius (phase boundary near origin)\n            self.a[i] = 0.8 + 0.4 * (i % 3)      # values: 0.8, 1.2, 1.6, ...\n            # Outer radius (phase boundary to outer region)\n            self.b[i] = 2.5 + 0.5 * (i % 3)      # values: 2.5, 3.0, 3.5, ...\n            # Middle-region curvature\n            self.p[i] = 0.9 + 0.3 * (i % 3)      # values: 0.9, 1.2, 1.5, ...\n            # q_i ensures continuity at ri = a_i\n            self.q[i] = self.a[i] ** 2\n            # Outer-region curvature\n            self.s[i] = 0.4 + 0.6 * (i % 3)      # values: 0.4, 1.0, 1.4, ...\n            # t_i ensures continuity at ri = b_i\n            self.t[i] = self.p[i] * (self.b[i] - self.a[i]) ** 2 + self.a[i] ** 2\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Dimension mismatch: expected dim {}, got {}\".format(self.dim, x.shape[0]))\n        total = 0.0\n        for i in range(self.dim):\n            ri = abs(x[i])\n            ai = self.a[i]\n            bi = self.b[i]\n            pi = self.p[i]\n            qi = self.q[i]\n            si = self.s[i]\n            ti = self.t[i]\n            if ri <= ai:\n                gi = ri * ri\n            elif ri <= bi:\n                gi = pi * (ri - ai) ** 2 + qi\n            else:\n                gi = si * (ri - bi) ** 2 + ti\n            total += gi\n        return float(total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.549, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["41ec7f41-5a65-45ce-a2f5-c084aa2e1422"], "operator": null, "metadata": {"ela_features_2D": [-0.0005444603697367211, 0.44058140795690076, 0.015185227866606116, 0.03765331628642023, 122.54608021272979, 0.003210778744238585, 0.9510317305679363, 1.6386494660764739, 0.950961078222279, 0.12376246338087174, -0.784419128994694, 1.2, 0.7042024046067148, 0.7225362672730304, 0.5689872667486172, 0.33323722257501454, -0.1942341210142367, 0.1298533755122287, 0.215607293752746, 0.3021380943117341, 0.495525037834336, 0.1270027849994347, 0.21406366764923784, 0.30073104096537717, 0.4923998598320817, -0.4549073523905996, -0.4100733228493215, -0.36483752328042646, -0.26373684520299545, -0.44771386575347644, -0.40305828588429166, -0.35861628416707564, -0.26031396223989267, 1.0, 1.0, 1.0, 1.0, 0.5238930140486933, 0.523882025690862, 0.4013317839936941, 0.3585444621069687, 0.7306926372910036, 0.4454454454454453, 0.5617648536092934, -0.06706706706706705, 0.3606425702811245], "score_NOT Homogeneous_2D": 0.8149596601724625, "score_Separable_2D": 1.0, "ela_features": [0.0011464349529951346, 0.4573799892912695, 0.005311431603232759, 0.029018434545745105, 10.454938244611514, 0.005061671873267138, 0.9585542157834472, 2.1512526260637572, 0.9586502293435636, 0.12895108747490702, -0.29211205754913283, 1.0, 0.9056737294871585, 0.8716075030686788, 0.6617960215071189, 0.18264242044523796, -0.46620822761877145, 0.44380815993372946, 0.5429246292389734, 0.6237361596586722, 0.7361594167989964, 0.43826527941686094, 0.5369225777697665, 0.620340759048421, 0.7355272183715743, -0.48924776896066824, -0.40206136045874796, -0.33097603128923947, -0.23208395262589096, -0.49675831956399136, -0.40951697392515174, -0.33574493037366265, -0.2338816540441618, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21856557244928254, 0.21856226279346233, 0.20406526568287067, 0.18539386333747138, 0.8295098166958429, 0.08908908908908905, 0.26138372727724074, -0.3873873873873873, 0.4980769230769231], "score_NOT Homogeneous_5D": 0.8337744027376175, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00015472460349559293, 0.47246652210161616, 0.0013533012683319943, 0.020598981283105344, 28.877977057503585, 0.001164115537916155, 0.958866834910913, 2.179503062969535, 0.9590920305399173, 0.09957273513242196, -0.1387273770044212, 1.0, 0.9945255547598396, 0.9353645319476005, 0.7022764453067636, 0.10672442056314832, -0.6022714912898783, 0.6467655736546101, 0.700049262138794, 0.7493652340327261, 0.8213399197655905, 0.6467781451620687, 0.7005718077698525, 0.7507218307160821, 0.8242690073728255, -0.44803228802817713, -0.3804490207639201, -0.3178979122515574, -0.22660730008838215, -0.44925728569712786, -0.38083830639493615, -0.31705218949143843, -0.2235086908883371, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10986690912690822, 0.10986055942622615, 0.10695817340325586, 0.10044627567434557, 0.8573600816120773, -0.13913913913913908, 0.13330987542924455, -0.6436436436436435, 0.5868694955964772], "score_NOT Homogeneous_10D": 0.5494096577167511, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.8887236084376806e-163, -5.4315149621617044e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.087061649835744e-162, -3.950985062536742e-164, 3.732702487873553e-163, -1.157354128223814e-162, 6.156790514343168e-163]}
{"id": "57d9be25-cc6f-4081-9e30-aa2737dc9342", "fitness": 0.691448782881101, "name": "landscape_nh_phase", "description": "A separable, non-homogeneous landscape with per-dimension phase transitions and multi-zone structure. Each dimension has its own two thresholds, creating an inner quadratic region, a middle oscillatory transition, and an outer convex growth. The per-dimension parameters (thresholds, curvature, and oscillation) vary across dimensions to produce a highly non-homogeneous search space, while keeping the problem separable and the global optimum at the origin.", "code": "import numpy as np\n\nclass landscape_nh_phase:\n    \"\"\"\n    Not-homogeneous, separable landscape with per-dimension phase transitions.\n    Each dimension i has:\n      - t1[i]: inner quadratic threshold\n      - t2[i]: outer threshold (start of outer growth)\n      - a[i]: quadratic coefficient in the inner region\n      - b[i]: linear growth coefficient in the middle region\n      - c[i]: amplitude of a sinusoidal modulation in the middle region\n      - d[i]: quadratic growth coefficient in the outer region\n      - omega[i]: frequency of the sinusoid used in the middle region\n    The per-dimension function g_i(x_i) is:\n      - if |x_i| <= t1[i]: g_i = a[i] * x_i^2\n      - if t1[i] < |x_i| <= t2[i]: g_i = a[i] * t1[i]^2 + b[i] * (|x_i| - t1[i])\n                                      + c[i] * sin(omega[i] * (|x_i| - t1[i]))\n      - if |x_i| > t2[i]: g_i = base_at_t2 + d[i] * (|x_i| - t2[i])^2\n        where base_at_t2 = a[i] * t1[i]^2 + b[i] * (t2[i] - t1[i]) + c[i] * sin(omega[i] * (t2[i] - t1[i]))\n    The global function f(x) = sum_i g_i(x_i), minimized at x = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # per-dimension parameters\n        self.t1 = np.zeros(self.dim, dtype=float)   # inner threshold\n        self.t2 = np.zeros(self.dim, dtype=float)   # outer threshold\n        self.a = np.zeros(self.dim, dtype=float)    # inner quadratic coeff\n        self.b = np.zeros(self.dim, dtype=float)    # middle linear coeff\n        self.c = np.zeros(self.dim, dtype=float)    # middle sine amplitude\n        self.d = np.zeros(self.dim, dtype=float)    # outer quadratic coeff\n        self.omega = np.zeros(self.dim, dtype=float)  # middle-region frequency\n\n        self._init_params()\n\n    def _init_params(self):\n        # Create pronounced non-homogeneity across dimensions\n        for i in range(self.dim):\n            ratio = i / max(1, self.dim - 1)\n\n            # thresholds allow varying phase transition points across dims\n            self.t1[i] = 0.25 + 0.15 * ratio        # ~0.25 to ~0.4\n            self.t2[i] = 2.2 + 0.6 * ratio          # ~2.2 to ~2.8\n\n            # curvature and slope parameters varying by dimension\n            self.a[i] = 0.6 + 0.8 * ratio          # inner quadratic coeff\n            self.b[i] = 0.7 + 0.9 * ratio          # middle linear coeff\n            self.c[i] = 0.12 + 0.5 * ratio         # middle sine amplitude\n            self.d[i] = 0.08 + 0.25 * ratio        # outer quadratic growth\n\n            # dimension-specific frequency for the middle-region ripple\n            self.omega[i] = 2.0 * np.pi * (1.0 + 0.5 * ratio)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        absx = np.abs(x)\n\n        for i in range(self.dim):\n            xi = x[i]\n            y = absx[i]\n            t1 = self.t1[i]\n            t2 = self.t2[i]\n            a = self.a[i]\n            b = self.b[i]\n            c = self.c[i]\n            d = self.d[i]\n            omega = self.omega[i]\n\n            if y <= t1:\n                gi = a * (xi ** 2)\n            elif y <= t2:\n                # middle region with a sinusoidal modulation to introduce ruggedness\n                gi = a * (t1 ** 2) + b * (y - t1) + c * np.sin(omega * (y - t1))\n            else:\n                # outer region: continuity ensured by using a base value at t2\n                base_at_t2 = a * (t1 ** 2) + b * (t2 - t1) + c * np.sin(omega * (t2 - t1))\n                gi = base_at_t2 + d * ((y - t2) ** 2)\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh_phase scored on:NOT Homogeneous 0.625, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7df924f7-a745-49c5-ae81-b50a446188db"], "operator": null, "metadata": {"ela_features_2D": [-0.002228255457321282, 0.5891545077286604, 0.014928183267090509, 0.026743475232404577, 1.7060797332309232, -0.0010302069828931558, 0.7634925446635838, 2.8642995135466895, 0.7628682089553853, -0.43619117465357854, -0.8399709701571793, 1.6, 0.6055801643034797, 0.6776232226155616, 0.4755711939307862, 0.3671881470147804, -0.21715675068682727, 0.17192409519522994, 0.2669341127433715, 0.41524875993327537, 0.6259122558159588, 0.1653542503570125, 0.2599377266803144, 0.3788173765193834, 0.571838253693431, -0.4331352447626305, -0.38342522120763683, -0.30584671770937305, -0.19566264918845583, -0.4284715466912492, -0.3798946176012367, -0.31885554751407946, -0.21979166449802925, 1.0, 1.0, 1.0, 1.0, 0.5218358241329619, 0.5218206052502262, 0.39584363811308637, 0.353484364748536, 0.7906463627704252, 0.9179179179179175, 0.6679421770907277, 0.1451451451451451, 0.4971887550200803], "score_NOT Homogeneous_2D": 0.3620539903640747, "score_Separable_2D": 1.0, "ela_features": [-0.0009412127724307328, 0.5507437120656474, 0.0014350693363841976, 0.026315231434359633, 41.06967717625818, -0.0010649298907879467, 0.7911128426347028, 2.878871983366826, 0.7901101882978379, -0.2623150795794076, -0.27805885763207233, 1.0, 0.817484885564226, 0.8549086269311397, 0.576041565440618, 0.19806397489312655, -0.48189656097323297, 0.4978817311399658, 0.5912728764301439, 0.6622352603771433, 0.7665799219428473, 0.48504117049674206, 0.5812309721947362, 0.6539723185561173, 0.7613197880504952, -0.4416942692390351, -0.35953881626855244, -0.29711836180890083, -0.20532996630249753, -0.4553797025678362, -0.37031122321590004, -0.3059930684230817, -0.21106392643213043, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21469340464400663, 0.21470701769088368, 0.19949194755896463, 0.18171594015336714, 0.8362904531314621, 0.19719719719719714, 0.28999790643761336, -0.3273273273273272, 0.5256410256410258], "score_NOT Homogeneous_5D": 0.16185539960861206, "score_Separable_5D": 1.0, "ela_features_10D": [3.220483614396752e-05, 0.5367127975393627, 0.0017681855012824203, 0.02054540244519021, 21.967185204154344, 0.0018862580576496147, 0.8027337102086906, 3.2117172027062195, 0.8026903149817917, -0.1583757534070413, -0.19937514632486214, 1.4, 0.9460754082200594, 0.9275067496740996, 0.6664936132373038, 0.1132265526644467, -0.6104569706630908, 0.6778330684153001, 0.7297860932609879, 0.7720403093390701, 0.8371667780953492, 0.6762143572151971, 0.728794261755125, 0.7710826602351248, 0.8381131836899529, -0.40859343547016264, -0.34270332658815805, -0.28911324550440265, -0.20651562766973575, -0.4117475733355541, -0.34488337693608834, -0.2911054998367878, -0.20586514123524985, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11020638458748737, 0.11020796587025232, 0.10716220772446591, 0.1012510043314017, 0.8545079017075384, -0.09509509509509512, 0.14787264416140428, -0.6236236236236234, 0.5919135308246598], "score_NOT Homogeneous_10D": 0.6247833073139191, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [2, [0.8106666666666662, 0.00044444444444512003], 0.38532502916343875], [2, [0.00044444444444512003, 1.5366666666666668], 1.447284700065481], [2, [0.8095880388372513, 2.8000935681692023], 4.0848987741694005], [3, [0.8095047329734759, -2.8001499233332288], 4.084898930579383], [2, [0.00044444444444512003, -1.5366666666666664], 1.447284700065481], [2, [-0.8106666666666658, 0.00044444444444512003], 0.38532502916343875], [3, [-0.8095872000740889, -2.800094105637627], 4.084898775672011], [6, [-1.8108888888890966, 0.00044444444444512003], 1.0853251024698505], [4, [-1.8107531014778566, 1.536635578260972], 2.532610318180806], [4, [-1.8107530763789286, -1.5366344493925137], 2.532610354207137], [3, [-0.8095872000740889, 2.800094105637628], 4.084898775672011], [6, [-0.0011951651980590477, 2.800632491691155], 3.6995741326456706], [6, [-0.0011951647108611367, -2.8006324909936744], 3.6995741326446807], [9, [-1.802961099164059, -2.8004128789081117], 4.784947126070803], [6, [1.8100000000003302, 0.00044444444444512003], 1.0853253302210482], [9, [1.8100000000003302, -2.801777777777775], 4.784899240219468], [10, [1.8100000000003302, 2.801777777777776], 4.784899240219468], [4, [1.8107531091288938, 1.5366353158405113], 2.5326103265534536], [4, [1.8107530911010994, -1.5366369250481167], 2.5326102752765074], [9, [-1.8098029332822427, 2.800098283681346], 4.7848984382275415]], "nr_of_basins": 21, "f_opt_dim_2": 0.0, "x_opt_dim_2": [4.270690574831489e-163, -2.1749664463604548e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [3.059068588752074e-163, 1.020900150031497e-162, 8.712641647338133e-163, 1.250451890912609e-162, -6.638312685910042e-163]}
{"id": "f064e5d3-a062-4908-907c-709de759f55a", "fitness": 0.7528842393308878, "name": "landscape_three_regime", "description": "A separable, non-homogeneous landscape with per-dimension three-regime phase transitions. Each dimension has an inner quadratic well, a middle cubic growth, and an outer linear growth, with dimension-specific thresholds creating non-homogeneous structure. The global optimum is at x = 0 (value 0) and the problem remains separable across dimensions.", "code": "import numpy as np\n\nclass landscape_three_regime:\n    def __init__(self, dim=5):\n        self.dim = dim\n        idx = np.arange(dim, dtype=float)\n\n        # Per-dimension phase boundaries (non-homogeneous across space)\n        self.t1 = 0.6 + (idx % 5) * 0.3           # inner threshold for quadratic regime\n        self.t2 = self.t1 + 1.0 + (idx % 3) * 0.4  # outer threshold for linear regime (t2 > t1)\n\n        # Coefficients controlling curvature per dimension\n        self.c1 = 0.9 + (idx % 5) * 0.18  # quadratic coefficient (inner region)\n        self.c2 = 0.6 + (idx % 3) * 0.28  # cubic contribution (middle region)\n        self.c3 = 0.4 + (idx % 2) * 0.22  # linear growth (outer region)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        absx = np.abs(x)\n\n        # Initialize per-dimension costs\n        per_dim = np.zeros(self.dim, dtype=float)\n\n        # Zone 1: inner quadratic |x| <= t1\n        mask1 = absx <= self.t1\n        if np.any(mask1):\n            per_dim[mask1] = self.c1[mask1] * (x[mask1] ** 2)\n\n        # Zone 2: middle cubic t1 < |x| <= t2\n        mask2 = (absx > self.t1) & (absx <= self.t2)\n        if np.any(mask2):\n            t1_m = self.t1[mask2]\n            per_dim[mask2] = (self.c1[mask2] * (t1_m ** 2) +\n                              self.c2[mask2] * ((absx[mask2] - t1_m) ** 3))\n\n        # Zone 3: outer linear |x| > t2\n        mask3 = absx > self.t2\n        if np.any(mask3):\n            t1_o = self.t1[mask3]\n            t2_o = self.t2[mask3]\n            per_dim[mask3] = (self.c1[mask3] * (t1_o ** 2) +\n                              self.c2[mask3] * ((t2_o - t1_o) ** 3) +\n                              self.c3[mask3] * (absx[mask3] - t2_o))\n\n        return float(np.sum(per_dim))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_three_regime scored on:NOT Homogeneous 0.043, Separable 0.943,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1d3b4f7b-ccbd-4b83-b9fd-738fece23c15"], "operator": null, "metadata": {"ela_features_2D": [-0.0022789357741209494, 0.5479515616641851, 0.011968753836723852, 0.033171491540314325, 14.74601630516546, -0.00024990790947008177, 0.8433805466807301, 2.387210049200027, 0.8429922259754095, -0.22730086565436797, -1.1556633730513635, 2.0, 0.6739776924186771, 0.709057244484648, 0.5484304546322514, 0.34447624244775904, -0.1713587923258152, 0.1598889159253703, 0.2330958572439962, 0.324983337139106, 0.5590390437370075, 0.15294593222852884, 0.23005444239254333, 0.32288566646132055, 0.5277729136343339, -0.43967194372826734, -0.4013659025661179, -0.3532750796139731, -0.23078006334082005, -0.4352959619548997, -0.39567660528793097, -0.34796755542200886, -0.2426747054180379, 1.0, 1.0, 1.0, 1.0, 0.5217671953567639, 0.5217638464187868, 0.3746627712891353, 0.35338236119089766, 0.7484395230959112, 0.6896896896896895, 0.543054156596342, -0.09509509509509509, 0.3759036144578313], "score_NOT Homogeneous_2D": 0.9590714536607265, "score_Separable_2D": 0.900390625, "ela_features": [-0.0015798850384763474, 0.5672871408334764, 0.0013092405063053702, 0.02498548695116309, 163.6042847133122, -0.0016220988341622445, 0.8090401250873228, 4.805384136160817, 0.808867212228918, -0.11633899252325193, -0.5331489965579197, 1.0, 0.8215791544719158, 0.8602094346562918, 0.5976764817995612, 0.19057669876466682, -0.4614605705636194, 0.5418404009524719, 0.6100248585503163, 0.6666246222996348, 0.7704579664109934, 0.5294855111650828, 0.5933581416795084, 0.6555144236562916, 0.7629427216209589, -0.4030679090941298, -0.3430809980798142, -0.29328754183275557, -0.20194030374222266, -0.416203258878145, -0.3596965701313032, -0.3047181349654394, -0.20969307962297865, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2134260615863821, 0.213411578897749, 0.19539230660976142, 0.17934034628615264, 0.8281469445463969, 0.24924924924924916, 0.2611524957365462, -0.3353353353353352, 0.5099358974358974], "score_NOT Homogeneous_5D": 0.7076862752437592, "score_Separable_5D": 0.964013671875, "ela_features_10D": [-8.575455691033352e-05, 0.5545930662973975, 0.001339172250397073, 0.02144682219632365, 46.53590461117063, 0.00022159668471370962, 0.809658276537436, 6.343482735466028, 0.8098441658328254, -0.07042196357947565, -0.27305156508568107, 1.0, 0.9392980715907232, 0.9266360496969469, 0.6654765672909461, 0.11393355174161748, -0.6052404534888784, 0.6924268341346103, 0.7417976086714007, 0.7791338783949336, 0.8464320902476923, 0.6871836227458537, 0.7397902592678436, 0.7786112195403502, 0.8465422695476533, -0.39010775331414604, -0.32748897642762714, -0.28013345633735515, -0.1947763642036005, -0.3978717648464805, -0.3309607470271726, -0.28158220832137354, -0.1951809484869358, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10983809247854592, 0.10984054256826017, 0.10632468129257577, 0.10104804536716724, 0.8598123128882624, -0.05505505505505507, 0.14881750444600464, -0.5795795795795794, 0.5878302642113692], "score_NOT Homogeneous_10D": 0.042784035205841064, "score_Separable_10D": 0.943359375}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.911111111123002e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.4640891656924457e-162, -1.304182301128321e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.203722566764681e-163, -6.896319279552668e-164, -1.5664866457276727e-162, 6.749252366474752e-163, 5.4159338631864993e-163]}
{"id": "75d81739-fdb3-41ae-a89d-0ba1add80244", "fitness": 0.8244481210907301, "name": "landscape_new", "description": "A novel separable, non-homogeneous landscape with per-dimension, independently parameterized two-transition piecewise-quadratic costs. Each dimension has its own t1, t2, and curvature parameters, ensuring non-uniform (not homogeneous) structure across dimensions while preserving separability (sum of per-dimension costs). Global minimum remains at x = 0 with value 0. The per-dimension parameters are generated deterministically from a seed for reproducibility.", "code": "import numpy as np\n\nclass landscape_new:\n    def __init__(self, dim=5, seed=1234):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Per-dimension phase-transition thresholds\n        # Ensure t1 < t2 and both within the domain [-5, 5]\n        self.t1 = rng.uniform(0.2, 1.5, size=self.dim)\n        delta = rng.uniform(0.5, 2.5, size=self.dim)\n        self.t2 = self.t1 + delta\n        self.t2 = np.clip(self.t2, self.t1 + 0.15, 5.0)\n\n        # Per-dimension curvatures (positive)\n        self.c1 = rng.uniform(0.2, 1.5, size=self.dim)\n        self.c2 = rng.uniform(0.8, 6.0, size=self.dim)\n        self.c3 = rng.uniform(2.0, 9.0, size=self.dim)\n\n        # Precompute constants for continuity:\n        # f0_i = c1_i * t1_i^2 (continuity at t1)\n        self.f0 = self.c1 * (self.t1 ** 2)\n\n        # f_at_t2_i = c2_i * (t2_i - t1_i)^2 + f0_i (continuity at t2)\n        self.f_at_t2 = self.c2 * ((self.t2 - self.t1) ** 2) + self.f0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 0:\n            x = x.reshape(1)\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            ai = abs(xi)\n\n            if ai <= self.t1[i]:\n                fi = self.c1[i] * (xi ** 2)\n            elif ai <= self.t2[i]:\n                fi = self.c2[i] * ((ai - self.t1[i]) ** 2) + self.f0[i]\n            else:\n                fi = self.c3[i] * ((ai - self.t2[i]) ** 2) + self.f_at_t2[i]\n\n            total += fi\n\n        return float(total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_new scored on:NOT Homogeneous 0.523, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e85dcf09-6a04-4b56-84a6-e40839b844e9"], "operator": null, "metadata": {"ela_features_2D": [-0.0009842147950084312, 0.2858574048990081, 0.017606059300723363, 0.036124958636010736, 2.042654980001934, 0.004529339630356577, 0.9703749298210023, 1.8653148158513762, 0.9705751716094511, 0.8067199499588018, -0.10337939557207836, 1.4, 0.7128114707820753, 0.718090202925977, 0.5601283501913465, 0.3397995542482184, -0.2134742241400244, 0.1456824568431833, 0.21904126201652413, 0.3149671004714187, 0.48758505543033176, 0.14380166654675794, 0.22256869389566183, 0.31191677621301966, 0.48730214793352405, -0.4468837842498908, -0.4085085733925757, -0.35833348574421386, -0.2680378159367219, -0.4400867805958697, -0.399598390938995, -0.3536778316294106, -0.26352639740220846, 1.0, 1.0, 1.0, 1.0, 0.5146500597368309, 0.5146243216261974, 0.3978346527781832, 0.35495731208122877, 0.6667185098487736, 0.5735735735735734, 0.42969781336416524, -0.08308308308308307, 0.3602409638554217], "score_NOT Homogeneous_2D": 0.7917439192533493, "score_Separable_2D": 1.0, "ela_features": [-0.00018262617168227636, 0.34127952081476487, 0.00659901214242387, 0.027672400917265267, 5.509945235544742, 0.004912343361212023, 0.9649751872557063, 3.62926145151735, 0.9650400243879007, 0.6326821739088637, -0.0941815526266014, 1.0, 0.9042259011423285, 0.8723377238271736, 0.6347263225044033, 0.1857011516754528, -0.47069986323334606, 0.44758363277256175, 0.5290149096316398, 0.6047209203352769, 0.7275283228155323, 0.4479889204919772, 0.5316863286159238, 0.6050659606367195, 0.7281148330107408, -0.4858641905334453, -0.41424193018396194, -0.34765722741625726, -0.2396438415063919, -0.48796144018036075, -0.41397442026476616, -0.34911011326534835, -0.24033439693475273, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21443852865194693, 0.21446573681456402, 0.19865652073677098, 0.1815190857111591, 0.8200077928080531, 0.24124124124124116, 0.2456961595668156, -0.34734734734734724, 0.5270833333333333], "score_NOT Homogeneous_5D": 0.6319259405136108, "score_Separable_5D": 1.0, "ela_features_10D": [-4.4673035742315294e-05, 0.4258254962155588, 0.001772095615582947, 0.019451446898698745, 31.542123752236783, 0.006192270662801924, 0.9728130608928751, 3.708652919560817, 0.9730117509162961, 0.28656127419303273, -0.024003801010061564, 1.4, 1.0070810109144186, 0.9366238746774036, 0.7053979514580982, 0.1066710944246497, -0.594729120235034, 0.6435587986835596, 0.7014106147960932, 0.7486686628758519, 0.8195222041339759, 0.6433118117135241, 0.7035071497268846, 0.7511320256501353, 0.8222893876481848, -0.4520599404717542, -0.3786887590142757, -0.3187531989620957, -0.22889270335957707, -0.45358255838250783, -0.3770340758698102, -0.3164718436646744, -0.22598498447210388, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1093706804460743, 0.1093621675738073, 0.10633791555807197, 0.100068155143861, 0.8605320525917841, -0.10710710710710707, 0.13074180252968798, -0.6356356356356354, 0.5917534027221778], "score_NOT Homogeneous_10D": 0.52301886677742, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.91277980997143e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-3.016792770279954e-163, -8.149197999289642e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.0531872407299509e-162, -1.4048707042411218e-162, 9.385857755904292e-163, 1.0341626024495434e-162, -1.6753271691052277e-163]}
{"id": "7efee4b3-2de9-4050-afd3-311308e0b399", "fitness": 0.7663827141125997, "name": "landscape_two_phase_separable", "description": "A more easily optimizable separable landscape with per-dimension two-phase transitions. Each dimension has its own thresholds and curvatures, preserving non-homogeneity across dimensions while keeping the problem strictly separable (sum of independent per-dimension costs). The global minimum remains at the origin.", "code": "import numpy as np\n\nclass landscape_two_phase_separable:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be positive\")\n\n        # Deterministic, reproducible per-dimension parameters to introduce non-homogeneity\n        idx = np.arange(self.dim, dtype=float)\n\n        # Phase thresholds (per-dimension)\n        self.t1 = 0.25 + (idx / max(self.dim - 1, 1)) * 0.25  # 0.25 .. 0.50\n        self.t2 = 1.0 + (idx / max(self.dim - 1, 1)) * 0.9    # 1.0 .. ~1.9\n        self.t2 = np.maximum(self.t2, self.t1 + 0.2)          # ensure t2 > t1\n\n        # Per-dimension curvatures (non-identical across dimensions)\n        self.c1 = 0.32 + (idx / max(self.dim - 1, 1)) * 0.08  # [0.32, ~0.40]\n        self.c2 = 0.85 + (idx / max(self.dim - 1, 1)) * 0.35  # [0.85, ~1.20]\n        self.c3 = 3.0  + (idx / max(self.dim - 1, 1)) * 2.0   # [3.0, ~5.0]\n\n        self._validate_params()\n\n    def _validate_params(self):\n        if self.t1.shape[0] != self.dim or self.t2.shape[0] != self.dim:\n            raise ValueError(\"Parameter arrays dimension mismatch\")\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 0:\n            x = x.reshape(1)\n\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n\n        absx = np.abs(x)\n\n        # Precompute constants for per-dimension continuity\n        f0 = self.c1 * (self.t1 ** 2)                    # value at |x| = t1\n        f2 = self.c2 * ((self.t2 - self.t1) ** 2) + f0   # value at |x| = t2\n\n        # Per-dimension piecewise costs\n        term1 = self.c1 * (x ** 2)\n        term2 = self.c2 * (absx - self.t1) ** 2 + f0\n        term3 = self.c3 * (absx - self.t2) ** 2 + f2\n\n        mask1 = absx <= self.t1\n        mask2 = (absx > self.t1) & (absx <= self.t2)\n        mask3 = absx > self.t2\n\n        per_dim_cost = np.where(mask1, term1, np.where(mask2, term2, term3))\n        return float(np.sum(per_dim_cost))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_two_phase_separable scored on:NOT Homogeneous 0.586, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e85dcf09-6a04-4b56-84a6-e40839b844e9"], "operator": null, "metadata": {"ela_features_2D": [-0.0011235003085884987, 0.25422089722081165, 0.018511600370226776, 0.024719866273039064, 2.893847859535093, 0.007071528537629756, 0.9680121195964511, 1.0332965113491999, 0.9681014021074148, 0.7758971916876989, 0.017136106993095625, 1.6, 0.7170058268585958, 0.7212391599158304, 0.5832684843538871, 0.33764747638584774, -0.21532614327104033, 0.15233626253086854, 0.230279622563858, 0.3132661357238061, 0.498760212516064, 0.15859256855622275, 0.23274205649403873, 0.3174521298284655, 0.4976926753920886, -0.4436629168746178, -0.4028660745188043, -0.3594299813903318, -0.2623436693840144, -0.432671886872895, -0.39455128882731005, -0.3509912220582607, -0.25830399769890666, 1.0, 1.0, 1.0, 1.0, 0.5211290189292686, 0.521123291319497, 0.40527349598318707, 0.35433593345467357, 0.6549003416015433, 0.5295295295295295, 0.6624184751342416, -0.06706706706706708, 0.36305220883534134], "score_NOT Homogeneous_2D": 0.5974288284778595, "score_Separable_2D": 1.0, "ela_features": [-0.0009814601893569862, 0.32770868091462196, 0.003175280311802968, 0.02278266864646477, 8.1579563970943, 0.005754824815351079, 0.9681043837528407, 1.0642636994842278, 0.9681168733816037, 0.44264320414067393, -0.1105379405620515, 1.6, 0.9141049480395494, 0.872360803708579, 0.6399874537622368, 0.18623416036431303, -0.49181504932632036, 0.424756567824211, 0.5152418226156679, 0.5982776005593371, 0.72073515774647, 0.42191067153465783, 0.5166573453829684, 0.6008533302239499, 0.7241828050071375, -0.5059837207067506, -0.42639194290213017, -0.3533535289825178, -0.24564040013518654, -0.5110544986077811, -0.4272891651594854, -0.3528546559719837, -0.2438277443089273, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21758866327026558, 0.21757775235844234, 0.2031338041822468, 0.1834664887848101, 0.8222228027337082, 0.18518518518518512, 0.24941760701704818, -0.3353353353353352, 0.5222756410256411], "score_NOT Homogeneous_5D": 0.41488099098205566, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0006021879153591314, 0.391184785941434, 0.0011663404880753888, 0.016117700243744443, 20.01893215327661, 0.007707716895078076, 0.9684584767218027, 1.071210174027414, 0.968875075896172, 0.3027526107910986, -0.09213057139067962, 1.6, 1.0184409026992385, 0.9391594460856071, 0.7091246604496078, 0.10516893168992172, -0.6069889265110706, 0.627847142198706, 0.6860916984558507, 0.7340997878186661, 0.8105121216611598, 0.6308762937616876, 0.6899325308383857, 0.7380571574950573, 0.8149821359857281, -0.47199358684053505, -0.3981233395193874, -0.3372356501599567, -0.24032344611246487, -0.4693608300649955, -0.3942681765546225, -0.33307469047273014, -0.2352599863343933, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10955103318118597, 0.10954746683404407, 0.10641366181085114, 0.0998167431231223, 0.8581725954201016, -0.09109109109109109, 0.1412780208478567, -0.6316316316316314, 0.5923939151321058], "score_NOT Homogeneous_10D": 0.585986465215683, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.422222222226546e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [2.343263587572551e-162, -1.8739535226211094e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [5.452067298760674e-163, 2.45468385620694e-162, 9.675966666433639e-163, -2.2051963948440207e-162, 5.08125559598968e-163]}
{"id": "82bd2d85-e148-4b41-987f-41e521f34894", "fitness": 0.9534957986325026, "name": "landscape_rugged_phase", "description": "A completely different separable, non-homogeneous landscape using per-dimension piecewise phase transitions with a rugged outer region. Each dimension has its own threshold, quadratic core, and a noisy, cosine-modulated outer growth to induce non-homogeneity while keeping separability. Global optimum remains at the origin.", "code": "import numpy as np\n\nclass landscape_rugged_phase:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters to create non-homogeneous phase transitions\n        # h: threshold for phase transition (abs(x) <= h -> quadratic region)\n        # a: quadratic region coefficient\n        # b: outer linear growth coefficient (b * (|x| - h))\n        # w: frequency of rugged cosine modulation in outer region\n        # e: amplitude of ruggedness\n        self.h = np.zeros(self.dim, dtype=float)\n        self.a = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.w = np.zeros(self.dim, dtype=float)\n        self.e = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            ratio = i / max(1, self.dim - 1)  # in [0, 1]\n            # Vary parameters across dimensions to create non-homogeneity\n            self.h[i] = 0.4 + 0.6 * ratio        # thresholds in [0.4, 1.0]\n            self.a[i] = 0.6 + 0.4 * ratio        # quadratic coeffs in [0.6, 1.0]\n            self.b[i] = 1.0 + 0.8 * ratio        # outer slope in [1.0, 1.8]\n            self.w[i] = 4.0 + 3.0 * ratio        # frequency of ruggedness in [4, 7]\n            self.e[i] = 0.15 * (0.5 + 0.5 * ratio)  # ruggedness amplitude in [0.075, 0.15]\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        absx = np.abs(x)\n        inside = absx <= self.h\n\n        g = np.zeros(self.dim, dtype=float)\n\n        # Quadratic region: |x| <= h_i\n        g[inside] = self.a[inside] * (x[inside] ** 2)\n\n        # Outer region: linear growth plus rugged cosine modulation\n        outside = ~inside\n        if np.any(outside):\n            base = self.b[outside] * (absx[outside] - self.h[outside]) + self.a[outside] * (self.h[outside] ** 2)\n            rugged = self.e[outside] * np.cos(self.w[outside] * (absx[outside] - self.h[outside]))\n            g[outside] = base + rugged\n\n        return float(np.sum(g))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_rugged_phase scored on:NOT Homogeneous 0.902, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7df924f7-a745-49c5-ae81-b50a446188db"], "operator": null, "metadata": {"ela_features_2D": [-0.0006987305238298047, 0.4802435981394713, 0.010041667944244253, 0.04036799853693049, 6.171718493513347, -0.0021225934785498836, 0.9455579598871822, 1.770229364302225, 0.9454688983122683, 0.02008214426834428, -0.8067518154325357, 1.8, 0.7166078567322977, 0.7149599868980095, 0.5570485901377118, 0.34458243401403565, -0.19583594185372707, 0.1385558967244505, 0.21178963288819133, 0.3132475982074828, 0.5206453434528878, 0.14949523543453408, 0.2077093747353612, 0.30961757822863945, 0.5062972957329126, -0.4507485925242193, -0.412428828424941, -0.3593422653498306, -0.25082052265347815, -0.4375583959485705, -0.407608792476078, -0.3551810067429305, -0.2539897933822438, 1.0, 1.0, 1.0, 1.0, 0.5132646665425153, 0.513244491471827, 0.38892374455559686, 0.354945975351766, 0.734895967346185, 0.36936936936936926, 0.6362640969410929, -0.0870870870870871, 0.3562248995983936], "score_NOT Homogeneous_2D": 0.8575543910264969, "score_Separable_2D": 1.0, "ela_features": [0.0002517436920899785, 0.49471795925631723, 0.004652732550351662, 0.024026020376023978, 7.337020600021285, -0.0006347737723914504, 0.9481531133511216, 1.8342445921574615, 0.9483153980751015, 0.04191903109495748, -0.3028936219353229, 1.2, 0.8874286551997317, 0.8697116014235202, 0.6454370613014506, 0.18289315406551648, -0.46811701320137783, 0.4742504529064484, 0.5499940893704819, 0.6208314907047372, 0.7357461966626382, 0.47146909247068863, 0.5483036085546977, 0.621242220527724, 0.7359514744263749, -0.4625451967218909, -0.395905863891524, -0.33358165565880166, -0.23248234235053059, -0.4676071373253202, -0.399631152996938, -0.3350913766261815, -0.23360422982453705, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2169633090903918, 0.21695670886810298, 0.20261981183556013, 0.18327165277440544, 0.8173776762213087, 0.05305305305305301, 0.2574292287787407, -0.38338338338338324, 0.49919871794871795], "score_NOT Homogeneous_5D": 0.9612797982990742, "score_Separable_5D": 1.0, "ela_features_10D": [0.00010159990427343058, 0.49208564673830857, 0.0011196230442693884, 0.01945892335342393, 402.99085186298055, 0.004710577719990061, 0.9484504151734068, 1.7952760366578768, 0.9485814413260151, 0.03549610255339565, -0.17883533376011912, 1.4, 1.0061350607083361, 0.9364662575590245, 0.7080822210137238, 0.10586683871174776, -0.60900056977041, 0.6376690354981533, 0.6947485099452395, 0.7408466277680184, 0.8135348784845773, 0.638825333938736, 0.6974134785534558, 0.743796163411752, 0.8174414085830014, -0.4594941993559497, -0.387108650424142, -0.3286489213209606, -0.2364682693412421, -0.4591390743166798, -0.3846608179528103, -0.32569778967260266, -0.23207645821362588, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11125251045609034, 0.11125197756836777, 0.10821946190558145, 0.10157388472508691, 0.8578999962148777, -0.1471471471471471, 0.1373140323390415, -0.6396396396396394, 0.5840672538030425], "score_NOT Homogeneous_10D": 0.9021406024694443, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.160493827170102e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.337160170004073e-163, -1.1879196626963682e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2431528782387757e-163, -9.498097301584812e-163, -1.3162303521698347e-162, 7.510804968313524e-163, 2.332651708538986e-163]}
{"id": "b2d964c3-baf5-4216-a4e1-fbf1909f93ed", "fitness": 0.8668526280671358, "name": "landscape_nh2", "description": "A novel separable, non-homogeneous landscape with per-dimension phase-driven regimes and outer-region ripples to amplify non-uniformity. Each dimension has its own phase-specific thresholds and region curvatures, plus a dimension-dependent outer-region oscillatory ripple to break homogeneity while preserving separability. Global optimum remains at x = 0 with value 0.", "code": "import numpy as np\n\nclass landscape_nh2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        self._setup_params()\n\n    def _setup_params(self):\n        # Per-dimension non-homogeneous phase parameters\n        self.s1 = np.zeros(self.dim, dtype=float)  # inner boundary per-dim\n        self.s2 = np.zeros(self.dim, dtype=float)  # outer boundary per-dim\n\n        self.a1 = np.zeros(self.dim, dtype=float)  # inner quadratic coeff\n        self.a2 = np.zeros(self.dim, dtype=float)  # middle quadratic coeff\n        self.a3 = np.zeros(self.dim, dtype=float)  # outer linear slope\n\n        # Build per-dimension thresholds and coefficients with non-homogeneous patterns\n        for i in range(self.dim):\n            # Dimension-specific phase boundaries to induce non-homogeneity\n            self.s1[i] = 0.6 + 0.2 * (i % 4)      # inner boundary in [0.6, 1.0, 1.2, 1.4]...\n            self.s2[i] = 1.9 + 0.4 * (i % 5)     # outer boundary in [1.9, 2.3, 2.7, 3.1, 3.5]\n\n            if self.s2[i] <= self.s1[i]:\n                self.s2[i] = self.s1[i] + 0.4\n\n            # Phase-based coefficients to introduce non-homogeneous curvature\n            if i % 2 == 0:\n                self.a1[i] = 0.5\n                self.a2[i] = 0.9\n                self.a3[i] = 0.7\n            else:\n                self.a1[i] = 0.4\n                self.a2[i] = 1.2\n                self.a3[i] = 0.75\n\n        # Precompute constants for continuity and base level\n        self.b = self.a1 * (self.s1 ** 2)\n        self.d = self.a2 * ((self.s2 - self.s1) ** 2) + self.b\n\n        # Outer-region ripple parameters to inject non-homogeneity (dimension-dependent)\n        self.ripple_amp = 0.15 + 0.08 * np.sin(np.arange(self.dim) * np.pi / 3.0)\n        self.w = 1.0 + 0.5 * (np.arange(self.dim) % 3)  # frequency per-dimension\n\n    def f(self, x):\n        \"\"\"\n        Separable landscape value: sum_i g_i(x_i)\n        Each g_i has three regimes:\n        - |x_i| <= s1_i: a1_i * |x_i|^2\n        - s1_i < |x_i| <= s2_i: a2_i * (|x_i| - s1_i)^2 + b_i\n        - |x_i| > s2_i: a3_i * (|x_i| - s2_i) + d_i  + ripple(|dx|)\n          ripple = ripple_amp_i * (1 - cos(w_i * dx))\n        Global optimum at x = 0 (value 0).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must have length {self.dim}\")\n\n        xi = np.abs(x)\n\n        # Initialize per-dimension contributions\n        gi = np.zeros(self.dim, dtype=float)\n\n        # Inner region\n        mask1 = xi <= self.s1\n        if np.any(mask1):\n            gi[mask1] = self.a1[mask1] * (xi[mask1] ** 2)\n\n        # Middle region\n        mask2 = (xi > self.s1) & (xi <= self.s2)\n        if np.any(mask2):\n            gi[mask2] = self.a2[mask2] * ((xi[mask2] - self.s1[mask2]) ** 2) + self.b[mask2]\n\n        # Outer region with non-homogeneous ripple\n        mask3 = xi > self.s2\n        if np.any(mask3):\n            dx = xi[mask3] - self.s2[mask3]\n            gi[mask3] = (\n                self.a3[mask3] * dx\n                + self.d[mask3]\n                + self.ripple_amp[mask3] * (1.0 - np.cos(self.w[mask3] * dx))\n            )\n\n        return float(np.sum(gi))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh2 scored on:NOT Homogeneous 0.579, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["c16b2ad0-70d5-44ae-b624-abed19e902ff"], "operator": null, "metadata": {"ela_features_2D": [-4.729017763891452e-05, 0.49098685129198677, 0.01772154807209302, 0.043392853638909025, 3.980610843745184, 0.0033635014105202867, 0.8933675126462306, 1.3755780601212213, 0.8938143911278258, -0.07090895636912484, -0.8139575166423754, 1.2, 0.7113840253565812, 0.7163867902177036, 0.5673076094261857, 0.34000794457501465, -0.1834993255533618, 0.15767474003325183, 0.23584618481384445, 0.32701307187694495, 0.52169202231416, 0.1636478513073419, 0.23717671290712153, 0.3283620217661388, 0.5116293904611846, -0.4408343075103193, -0.3999177940083604, -0.3522054134812775, -0.2503211583656836, -0.4303535501153791, -0.39251410359782535, -0.3455936835769956, -0.251287723614361, 1.0, 1.0, 1.0, 1.0, 0.5235377150893619, 0.5235059424683736, 0.38641486007538184, 0.36227878106858197, 0.7209965925042249, 0.5095095095095094, 0.5352699114145926, -0.11911911911911907, 0.3325301204819277], "score_NOT Homogeneous_2D": 0.6690626740455627, "score_Separable_2D": 1.0, "ela_features": [-0.0004752759108432425, 0.4626820582456833, 0.0059633701172619276, 0.025575748774289385, 5.353886356021421, 0.0010099427244674608, 0.9166183098567563, 2.5652014103238963, 0.9174258230891663, 0.070175382524308, -0.47653877321466365, 1.2, 0.8922724391804178, 0.8666658577199504, 0.6414726765409199, 0.1874546328591386, -0.4543214013995381, 0.44445993637393305, 0.5454704667701137, 0.6269163602968061, 0.7432458767498465, 0.4435363654540848, 0.5403169964628209, 0.623737801652575, 0.7412461380573208, -0.4887120183003645, -0.3998516784941594, -0.3282024896356194, -0.22586788221389584, -0.4921719092679421, -0.4065667182989601, -0.33278226057337473, -0.22885474577219284, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2145415282418043, 0.21456112976885877, 0.1977335794789456, 0.18219277256717323, 0.816894796628284, 0.1531531531531531, 0.24501586376658366, -0.36736736736736725, 0.49214743589743587], "score_NOT Homogeneous_5D": 0.9533806554973125, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0006366199418343932, 0.48858571792637606, 0.000799782591779717, 0.01857147434336332, 34.81209528480017, 0.005015598609489902, 0.9179871521629501, 3.0702142218653985, 0.9186694368134581, 0.06336087450657846, -0.24491304073007783, 1.2, 0.9869868185466946, 0.9325763670371888, 0.6987417886451519, 0.10899805215738934, -0.5902791088015394, 0.6365475137822427, 0.7011538043375782, 0.7529932544675328, 0.8287479667919513, 0.6380424335756436, 0.7015750101483491, 0.7533678630281494, 0.8302230745765394, -0.46094846034192355, -0.3790112203870043, -0.31326589572741614, -0.217190149407251, -0.4602367996332382, -0.3794536880036779, -0.3135977245926881, -0.21587470042060675, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10902351704979305, 0.10901934131506852, 0.10556442354750925, 0.09962434303199141, 0.8545291490376338, -0.09109109109109108, 0.14355498771993644, -0.6116116116116114, 0.5838270616493194], "score_NOT Homogeneous_10D": 0.5786724388599396, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.7777777777831825e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.4897124217492298e-162, -9.049623133221392e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.249748331135873e-162, 3.87901301307622e-163, 1.6431478822282166e-163, 1.1252034763774587e-162, -1.6243088426497454e-162]}
{"id": "03f21f89-1004-45e9-9c70-0f81f4c77edf", "fitness": 0.7351165562868118, "name": "PhaseSeparableThreeRegime", "description": "A completely new separable, non-homogeneous landscape with per-dimension triple-regime phase transitions. Each dimension has its own thresholds, producing an inner quadratic core, a middle quadratic region with higher curvature, and an outer quadratic growth. The landscape remains separable (sum over dimensions) and non-homogeneous (dimension-specific thresholds and slopes). The global minimum is at x = 0 with value 0.", "code": "import numpy as np\n\nclass PhaseSeparableThreeRegime:\n    \"\"\"\n    A separable, non-homogeneous landscape with per-dimension triple-regime phase transitions.\n    Each dimension has its own thresholds (t1, t2) and curvature parameters (p1, p2, p3).\n    The per-dimension cost is piecewise quadratic with three regimes:\n      - |x| <= t1:      f = p1 * x^2\n      - t1 < |x| <= t2: f = f0 + p2 * (|x| - t1)^2, where f0 = p1 * t1^2\n      - |x| > t2:       f = f1 + p3 * (|x| - t2)^2, where f1 = f0 + p2 * (t2 - t1)^2\n    The total objective is the sum over dimensions.\n    Global minimum is at x = 0, with value 0.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Initialize per-dimension parameters with dimension-specific (non-homogeneous) values\n        self.t1 = np.zeros(self.dim, dtype=float)  # first threshold\n        self.t2 = np.zeros(self.dim, dtype=float)  # second threshold\n        self.p1 = np.zeros(self.dim, dtype=float)  # inner curvature\n        self.p2 = np.zeros(self.dim, dtype=float)  # middle curvature ( > p1 )\n        self.p3 = np.zeros(self.dim, dtype=float)  # outer curvature ( > p2 )\n\n        for i in range(self.dim):\n            # Deterministic, non-uniform thresholds across dimensions\n            if self.dim > 1:\n                frac = i / (self.dim - 1)\n            else:\n                frac = 0.0\n\n            # Per-dimension thresholds (non-homogeneous, spread across domain)\n            t1i = 0.2 + 0.55 * frac        # in [0.2, 0.75] as dimension increases\n            t2i = t1i + 0.6 + 0.6 * frac    # ensures t2 > t1, varies per dimension\n\n            # Curvatures per regime (increasing with dimension to add heterogeneity)\n            p1i = 0.6 + 0.7 * frac\n            p2i = p1i * 1.8 + 0.4\n            p3i = p2i * 2.5 + 0.8\n\n            self.t1[i] = t1i\n            self.t2[i] = t2i\n            self.p1[i] = p1i\n            self.p2[i] = p2i\n            self.p3[i] = p3i\n\n        # Precompute f0 and f1 for continuity at the thresholds\n        self.f0 = self.p1 * (self.t1 ** 2)           # f0_i = p1_i * t1_i^2\n        self.f1 = self.f0 + self.p2 * ((self.t2 - self.t1) ** 2)  # f1_i = f0_i + p2_i*(t2_i - t1_i)^2\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 0:\n            x = x.reshape(1)\n\n        if x.size != self.dim:\n            raise ValueError(\"Input dimension mismatch: expected {}, got {}\".format(self.dim, x.size))\n\n        absx = np.abs(x)\n\n        # Piecewise evaluation per-dimension\n        mask1 = absx <= self.t1\n        mask2 = (absx > self.t1) & (absx <= self.t2)\n        mask3 = absx > self.t2\n\n        f = np.zeros_like(x)\n\n        # Inner regime: |x| <= t1\n        if np.any(mask1):\n            f[mask1] = self.p1[mask1] * (x[mask1] ** 2)\n\n        # Middle regime: t1 < |x| <= t2\n        if np.any(mask2):\n            f[mask2] = self.f0[mask2] + self.p2[mask2] * (absx[mask2] - self.t1[mask2]) ** 2\n\n        # Outer regime: |x| > t2\n        if np.any(mask3):\n            f[mask3] = self.f1[mask3] + self.p3[mask3] * (absx[mask3] - self.t2[mask3]) ** 2\n\n        return float(np.sum(f))", "configspace": "", "generation": 1, "feedback": "The optimization landscape PhaseSeparableThreeRegime scored on:NOT Homogeneous 0.567, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e85dcf09-6a04-4b56-84a6-e40839b844e9"], "operator": null, "metadata": {"ela_features_2D": [-0.002005108160720881, 0.2859853845139244, 0.014341073309351615, 0.028942670186860937, 2.2397792098382343, 0.006062024038394664, 0.9730335706997904, 1.1516769883516336, 0.9729572733200283, 0.6691589073707979, -0.23927004915857406, 1.6, 0.7179966979501039, 0.7182721821056461, 0.5717097930820765, 0.33930878998568337, -0.2149095494371835, 0.14512225264153847, 0.2255113772912427, 0.3211203150072891, 0.4995781103788179, 0.14245881936977361, 0.2270020101021518, 0.31989088772966773, 0.4997256909460705, -0.44734011726450673, -0.4052731918862732, -0.3552415733111328, -0.2618593143731689, -0.4409923208899228, -0.39751860987728627, -0.3497431921425849, -0.2572596825514194, 1.0, 1.0, 1.0, 1.0, 0.5273306296546515, 0.5273209446419352, 0.4059437287781228, 0.35467517234235746, 0.6603437574869803, 0.5215215215215213, 0.5631484361766128, -0.06306306306306306, 0.35622489959839354], "score_NOT Homogeneous_2D": 0.592958003282547, "score_Separable_2D": 1.0, "ela_features": [-0.0009900183333225066, 0.34292739361008173, 0.003612967308687968, 0.022158231536495373, 6.39481665597632, 0.0019995436880702487, 0.973559743167445, 1.1547300618413927, 0.9735044053642739, 0.4754779914261532, -0.008128587857090164, 1.4, 0.9218040014320167, 0.8741573607063741, 0.6543188897092131, 0.18407161242629855, -0.48822321423252346, 0.4276554591719798, 0.5200415069953758, 0.5959855077249963, 0.7159757804885417, 0.4277518106929363, 0.5217279380232954, 0.5993878620141515, 0.7201434138153603, -0.5033393192097526, -0.4220932678635167, -0.3553055336088692, -0.2497824874206867, -0.5055180596043533, -0.42250982964046, -0.35390242835086727, -0.24723066179404335, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21882221916775926, 0.21878604061396692, 0.2034159849994166, 0.18321563370512567, 0.8307007407327858, 0.17717717717717713, 0.2572995252542155, -0.3433433433433432, 0.5302884615384615], "score_NOT Homogeneous_5D": 0.2511177062988281, "score_Separable_5D": 1.0, "ela_features_10D": [0.0006821010236245595, 0.40273043476529, 0.0015186844108938048, 0.02437900030738403, 27.724621752246367, 0.006084075792429688, 0.972711272522956, 1.1638003046109167, 0.9730247402848858, 0.32525259054282046, -0.041995191817466714, 1.4, 1.01418602656404, 0.9378122474680358, 0.6995355381475391, 0.10615359139798178, -0.606160366044321, 0.6308977272475791, 0.6890642613127367, 0.7389426118538578, 0.8132484026597675, 0.634849283972809, 0.6930923333866703, 0.7429562903105795, 0.8178879285391817, -0.46817483177428365, -0.39439558910289707, -0.3311292592775995, -0.23687854122340837, -0.4644193493931418, -0.3903429243997988, -0.32692318133257964, -0.23162040107209977, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10985001036556241, 0.1098491173976027, 0.10673399389653329, 0.10067292106330854, 0.8553257135794945, -0.09109109109109109, 0.13341281701532637, -0.6396396396396394, 0.5951160928742996], "score_NOT Homogeneous_10D": 0.5666236281394958, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.753086419764496e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.546201609217341e-163, -9.80617571619086e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.3171903075598106e-162, -6.440501921138487e-163, 8.11129380892451e-164, -2.88847028912182e-163, -3.760131028475907e-163]}
{"id": "6a4fb304-5192-446b-8d3e-c13b713b9930", "fitness": 0.6730453697964549, "name": "landscape_nh_phase_v2", "description": "A refined separable, non-homogeneous benchmark with per-dimension phase transitions across three regions (inner quadratic, middle oscillatory, outer convex growth). Each dimension has its own thresholds and curvature, ensuring strong non-homogeneity while preserving strict separability (f(x) = sum_i g_i(x_i)). The global optimum remains at the origin, facilitating subproblem decomposition for optimization algorithms.", "code": "import numpy as np\n\nclass landscape_nh_phase_v2:\n    \"\"\"\n    Separable, non-homogeneous landscape with per-dimension phase transitions\n    and multi-zone structure. Each dimension i has its own two thresholds\n    (t1[i], t2[i]), creating:\n      - inner quadratic region: |x_i| <= t1[i]\n      - middle oscillatory region: t1[i] < |x_i| <= t2[i]\n      - outer convex growth region: |x_i| > t2[i]\n    The per-dimension parameters (t1, t2, a, b, c, d, omega) vary across\n    dimensions to produce a highly non-homogeneous search space, while keeping\n    the problem separable and the global optimum at x = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension parameters\n        self.t1 = np.zeros(self.dim, dtype=float)    # inner threshold\n        self.t2 = np.zeros(self.dim, dtype=float)    # outer threshold\n        self.a  = np.zeros(self.dim, dtype=float)    # inner quadratic coef\n        self.b  = np.zeros(self.dim, dtype=float)    # middle linear coef\n        self.c  = np.zeros(self.dim, dtype=float)    # middle sine amplitude\n        self.d  = np.zeros(self.dim, dtype=float)    # outer quadratic growth\n        self.omega = np.zeros(self.dim, dtype=float) # middle-region frequency\n\n        self._init_params()\n\n    def _init_params(self):\n        # Create pronounced non-homogeneity across dimensions\n        max_ratio = max(1, self.dim - 1)\n        for i in range(self.dim):\n            ratio = i / max_ratio\n\n            # Ensure t1 < t2 and varied across dims\n            self.t1[i] = 0.15 + 0.25 * ratio       # ~0.15 to ~0.4\n            self.t2[i] = 1.8 + 1.0 * ratio         # ~1.8 to ~2.8\n\n            # Curvature and slope parameters varying by dimension\n            self.a[i] = 0.5 + 0.9 * ratio           # inner quadratic\n            self.b[i] = 0.6 + 1.0 * ratio           # middle linear\n            self.c[i] = 0.08 + 0.25 * ratio         # middle sine amplitude\n            self.d[i] = 0.05 + 0.20 * ratio         # outer quadratic growth\n\n            # Frequency for the middle-region ripple\n            self.omega[i] = 2.0 * np.pi * (1.0 + 0.4 * ratio)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape for a given input x.\n\n        x: 1D numpy array of length self.dim, evaluated in [-5, 5]^dim.\n        Returns a scalar value to be minimized. Global optimum at x = 0 with f(x)=0.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        absx = np.abs(x)\n\n        for i in range(self.dim):\n            xi = x[i]\n            y  = absx[i]\n            t1 = self.t1[i]\n            t2 = self.t2[i]\n            a  = self.a[i]\n            b  = self.b[i]\n            c  = self.c[i]\n            d  = self.d[i]\n            omega = self.omega[i]\n\n            if y <= t1:\n                gi = a * (xi ** 2)\n            elif y <= t2:\n                # Middle region with oscillatory ripple, continuity ensured\n                base_at_t1 = a * (t1 ** 2)\n                gi = base_at_t1 + b * (y - t1) + c * np.sin(omega * (y - t1))\n            else:\n                # Outer region with continuous growth\n                base_at_t2 = a * (t1 ** 2) + b * (t2 - t1) + c * np.sin(omega * (t2 - t1))\n                gi = base_at_t2 + d * ((y - t2) ** 2)\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_phase_v2 scored on:NOT Homogeneous 0.005, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["57d9be25-cc6f-4081-9e30-aa2737dc9342"], "operator": null, "metadata": {"ela_features_2D": [-0.0026642028836823426, 0.5797345753673099, 0.005037476655424617, 0.028374920013406774, 11.180192352626303, -0.0033443124490779574, 0.7991796702067926, 5.359916532452296, 0.7981795419206643, -0.3974321279168987, -1.1560083479139693, 2.2, 0.6403752043272826, 0.699387059252189, 0.49091597639189066, 0.3501425325882801, -0.1748572952566197, 0.1880659633159636, 0.3334766160426159, 0.5169647689136962, 0.6584581367494474, 0.18828253115742882, 0.29378939836390827, 0.45536732536844476, 0.5942805040326022, -0.4249614319178052, -0.3488576871320106, -0.2528218182811557, -0.17876059371621628, -0.4176669357596414, -0.36338094838275153, -0.28023944317901056, -0.20876043399320637, 1.0, 1.0, 1.0, 1.0, 0.5128276832976809, 0.512817934122615, 0.36559902710810416, 0.3475948713562005, 0.7664012974752066, 0.7417417417417416, 0.40457648815009933, -0.09509509509509509, 0.42008032128514056], "score_NOT Homogeneous_2D": 0.9958740044385195, "score_Separable_2D": 1.0, "ela_features": [0.000657492918192526, 0.5931024214206038, 0.002756908832260428, 0.02831399455466608, 30.948655345658715, 0.0003017659734929179, 0.7892556059437592, 5.199940429990212, 0.7885148784308094, -0.2885306872442886, -0.3923819511688211, 1.2, 0.8173383740952026, 0.8555476986167418, 0.5772646865110055, 0.19764751926703608, -0.46925610991608463, 0.5581375308441565, 0.6314533594372105, 0.6889735627774074, 0.7774591320701653, 0.5397129483048956, 0.6220534579975439, 0.6786496951932166, 0.7713516524940642, -0.3887554050267769, -0.3242475111144726, -0.27364207411043096, -0.19579236478505396, -0.40722485171688066, -0.33436522305448657, -0.2842985036181511, -0.20228391170055637, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21660126100823204, 0.2165943766784229, 0.20171602109637238, 0.18302808955559782, 0.8228291836077899, 0.1651651651651651, 0.2542885812326692, -0.38738738738738726, 0.5161858974358975], "score_NOT Homogeneous_5D": 0.03779381513595581, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0009417260251483484, 0.5604839226760712, 0.000904802030381386, 0.017651275589392418, 41.77147527794942, -0.0006406073550569768, 0.7842715463998969, 5.058089165347393, 0.7840365277122663, -0.17359474726775562, -0.1971821034671753, 1.4, 0.9263141796635063, 0.9257094997599413, 0.6472109589726095, 0.11407933549151375, -0.6119762474943002, 0.6924224170582705, 0.7456366076649965, 0.7909533183508751, 0.8501815676981976, 0.6893844013479973, 0.7427309495968883, 0.7897260629752563, 0.8507297708880234, -0.3901051616738559, -0.32261328875192136, -0.26513686970921196, -0.19001707885346814, -0.3950401745576969, -0.32719579576219626, -0.26742644567034274, -0.18984202619091203, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10956631971940545, 0.1095696456278095, 0.10636958788045278, 0.0998032139077095, 0.858094710315289, -0.08308308308308308, 0.1488795386847746, -0.5995995995995994, 0.5933546837469976], "score_NOT Homogeneous_10D": 0.00460439920425415, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[10, [0.0007822586678351106, 1.58268369704496], 1.8424782713676553], [20, [0.00044444444444512003, 0.00044444444444512003], 3.7530864197644967e-07], [10, [0.00044444444444512003, -2.2977777777778305], 2.9853258172680235], [8, [0.00044444444444512003, 2.2977777777778314], 2.9853258172680235], [20, [0.00044444444444512003, -2.8008888888890087], 4.318269666412308], [10, [0.00044444444444512003, -1.5826666666666664], 1.8424784111333485], [22, [0.00044444444444512003, 2.800888888889009], 4.318269666412308]], "nr_of_basins": 7, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.6043122879802012e-162, 7.412226700269761e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-2.355321486083174e-162, 1.2331103915931485e-162, 8.130423171314651e-165, -1.4425280914630907e-162, 1.3840813038430076e-162]}
{"id": "e03f2973-a7ee-45e7-9eb4-8a3906217fc4", "fitness": 0.7643448016606271, "name": "landscape_nh_phase_adv", "description": "A novel, highly non-homogeneous, separable landscape with per-dimension phase-transition modes. Each dimension follows one of three distinct regimes (inner quadratic, middle oscillatory with dimension-specific parameters, outer convex-cubic growth) with per-dimension thresholds and curvature varying across dimensions to create diverse, non-uniform search-space appearances while preserving separability. The global minimum remains at the origin.", "code": "import numpy as np\n\nclass landscape_nh_phase_adv:\n    \"\"\"\n    Not-homogeneous, separable landscape with per-dimension phase transitions and multi-mode structure.\n    Each dimension i has:\n      - t1[i]: inner threshold (end of quadratic region)\n      - t2[i]: outer threshold (start of outer growth)\n      - a[i]: inner quadratic coefficient\n      - b[i]: middle linear coefficient\n      - c[i]: amplitude of a sinusoidal modulation in the middle region\n      - d[i]: outer quadratic growth coefficient\n      - e[i]: outer cubic term coefficient for additional nonlinearity\n      - omega[i]: frequency of the sinusoidal modulation in the middle region\n    The per-dimension function g_i(x_i) is:\n      - if |x_i| <= t1[i]: g_i = a[i] * (x_i)^2\n      - if t1[i] < |x_i| <= t2[i]: g_i = a[i] * (t1[i]^2) + b[i] * (|x_i| - t1[i])\n                                      + c[i] * sin(omega[i] * (|x_i| - t1[i]))\n      - if |x_i| > t2[i]: g_i = base_at_t2 + d[i] * (|x_i| - t2[i])^2 + e[i] * (|x_i| - t2[i])^3\n        where base_at_t2 = a[i] * (t1[i]^2) + b[i] * (t2[i] - t1[i]) + c[i] * sin(omega[i] * (t2[i] - t1[i]))\n    The global function f(x) = sum_i g_i(x_i), minimized at x = 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # per-dimension parameters\n        self.t1 = np.zeros(self.dim, dtype=float)   # inner threshold\n        self.t2 = np.zeros(self.dim, dtype=float)   # outer threshold\n        self.a = np.zeros(self.dim, dtype=float)    # inner quadratic coeff\n        self.b = np.zeros(self.dim, dtype=float)    # middle linear coeff\n        self.c = np.zeros(self.dim, dtype=float)    # middle sine amplitude\n        self.d = np.zeros(self.dim, dtype=float)    # outer quadratic growth\n        self.e = np.zeros(self.dim, dtype=float)    # outer cubic term coefficient\n        self.omega = np.zeros(self.dim, dtype=float)  # middle-region frequency\n\n        self._init_params()\n\n    def _init_params(self):\n        # Create pronounced non-homogeneity across dimensions by mode-based phase transitions\n        for i in range(self.dim):\n            ratio = i / max(1, self.dim - 1)\n            mode = i % 3  # three distinct per-dimension regimes to ensure non-homogeneity\n\n            if mode == 0:\n                # Mode A: modest nonlinearity, earlier transition\n                t1 = 0.25\n                t2 = 2.2\n                a = 0.6\n                b = 0.7\n                c = 0.12\n                d = 0.08\n                omega = 2.0 * np.pi * (1.0 + 0.1 * ratio)\n                e = 0.0\n            elif mode == 1:\n                # Mode B: stronger middle region, larger outer growth\n                t1 = 0.4\n                t2 = 2.6\n                a = 0.4 + 0.6 * ratio\n                b = 0.9 + 0.8 * ratio\n                c = 0.18 + 0.15 * ratio\n                d = 0.16 + 0.25 * ratio\n                omega = 2.0 * np.pi * (1.2 + 0.3 * ratio)\n                e = 0.0005 * (1.0 + ratio)\n            else:\n                # Mode C: late transitions, larger curvature in outer region\n                t1 = 0.55\n                t2 = 3.0\n                a = 0.7 + 0.3 * ratio\n                b = 0.6 + 0.8 * ratio\n                c = 0.25 + 0.2 * ratio\n                d = 0.25 + 0.25 * ratio\n                omega = 2.0 * np.pi * (1.4 + 0.2 * ratio)\n                e = 0.001 * (1.0 + ratio)\n\n            self.t1[i] = float(t1)\n            self.t2[i] = float(t2)\n            self.a[i] = float(a)\n            self.b[i] = float(b)\n            self.c[i] = float(c)\n            self.d[i] = float(d)\n            self.omega[i] = float(omega)\n            self.e[i] = float(e)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        absx = np.abs(x)\n\n        for i in range(self.dim):\n            xi = x[i]\n            y = absx[i]\n            t1 = self.t1[i]\n            t2 = self.t2[i]\n            a = self.a[i]\n            b = self.b[i]\n            c = self.c[i]\n            d = self.d[i]\n            omega = self.omega[i]\n            e = self.e[i]\n\n            if y <= t1:\n                gi = a * (xi ** 2)\n            elif y <= t2:\n                # middle region with sinusoidal modulation\n                gi = a * (t1 ** 2) + b * (y - t1) + c * np.sin(omega * (y - t1))\n            else:\n                # outer region: includes a cubic term for extra nonlinearity\n                base_at_t2 = a * (t1 ** 2) + b * (t2 - t1) + c * np.sin(omega * (t2 - t1))\n                gap = y - t2\n                gi = base_at_t2 + d * (gap ** 2) + e * (gap ** 3)\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_phase_adv scored on:NOT Homogeneous 0.553, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["57d9be25-cc6f-4081-9e30-aa2737dc9342"], "operator": null, "metadata": {"ela_features_2D": [0.001054538935230842, 0.528101654346959, 0.006221062349981458, 0.049401639270683376, 12.345429800665606, 0.0036701350827728963, 0.8554731045740095, 3.6167304206690476, 0.8552383039298274, -0.2532563563944948, -1.0055549170810583, 2.0, 0.6749382877913742, 0.7041297087288239, 0.5231787333657985, 0.35024176103786264, -0.1900351447252044, 0.17016048096159248, 0.25194480045726503, 0.4325570771463122, 0.62963357570384, 0.165983074935022, 0.2436106304590321, 0.38548059469476115, 0.56774779326868, -0.4341393547907213, -0.3913513116565855, -0.2968563638374644, -0.19376018527238292, -0.428777278583724, -0.38887156984355303, -0.31592235539406327, -0.22222815419547662, 1.0, 1.0, 1.0, 1.0, 0.5139058751468264, 0.5137841857217944, 0.3847749347104499, 0.3564569111993455, 0.7656986700461572, 0.6856856856856854, 0.5579422659129125, -0.04704704704704704, 0.4301204819277108], "score_NOT Homogeneous_2D": 0.9921685764566064, "score_Separable_2D": 1.0, "ela_features": [-0.0005840866636633635, 0.5433981071988117, 0.0037123593219660633, 0.02597995000167575, 9.221375148400764, 0.0040504720327634745, 0.8468401368569367, 3.7422540340896866, 0.8465075667289581, -0.16347257024953726, -0.40784869633775855, 1.2, 0.8288057238692093, 0.8577742323925228, 0.6076286619518305, 0.19323993518056534, -0.4705033632736053, 0.5129520707408405, 0.6045992915547721, 0.676227335161796, 0.7749437078494292, 0.5070935453626544, 0.5909175715554488, 0.6661062005185302, 0.7678679123875158, -0.4284058162222607, -0.34779699205919323, -0.28478981217205457, -0.19795793190117508, -0.43572296626687645, -0.36163749075169466, -0.29516269603326994, -0.2052004326681624, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2161001938038644, 0.21612853473436572, 0.20053734024112096, 0.18105879895442617, 0.8303565995917495, 0.1571571571571571, 0.2649365578155296, -0.3633633633633633, 0.517948717948718], "score_NOT Homogeneous_5D": 0.041143059730529785, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0008342976510403499, 0.5386512775222798, 0.0005427673900480219, 0.019069940836669578, 138.23153844536938, 0.006117621794751127, 0.8393067807188246, 3.2403787865010885, 0.8388453363862103, -0.12422778079455417, -0.16067537669012114, 1.2, 0.9563007258130568, 0.929569537528377, 0.667748874904807, 0.11219409323741274, -0.6100477176114621, 0.6849567182911525, 0.7320854187262744, 0.7728487332945357, 0.8395108730535877, 0.6824632969482746, 0.7308637727528391, 0.772421820515041, 0.8407037096419355, -0.3995356054720658, -0.3397670817333414, -0.2880716224905017, -0.20353084996997067, -0.4037328052433379, -0.3421931649771607, -0.2893553797814851, -0.20253680906080498, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11116319547908342, 0.11116497253856743, 0.10811510954877712, 0.1012500394660077, 0.8579280651176763, -0.10710710710710707, 0.13330720660437465, -0.6196196196196194, 0.5888710968775019], "score_NOT Homogeneous_10D": 0.5527571737766266, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.160493827170102e-07], [2, [0.8106666666666662, 0.00044444444444512003], 0.3853249501510931], [2, [0.00044444444444512003, 1.5046666666666668], 1.7626875687595056], [2, [0.00044444444444512003, -1.5046666666666664], 1.7626875687595058], [2, [-0.8106666666666658, 0.00044444444444512003], 0.3853249501510931], [3, [0.8106666666666662, -2.1717777777778444], 3.2813409681931813], [6, [0.00044444444444512003, -2.1717777777778444], 2.896016334091471], [12, [-1.8102962581679847, -2.1718507778081677], 3.981340751679319], [6, [-1.8108888888890966, 0.00044444444444512003], 1.0853250234575047], [4, [-1.8107741721213475, 1.5046208637511669], 2.8480129729277204], [4, [-1.8107741322405213, -1.5046204257004778], 2.848012980292114], [11, [0.00044411362400371366, 2.1718947284796903], 2.896015936178313], [6, [1.8100000000003302, 0.00044444444444512003], 1.0853252512087024], [9, [1.8081238038772878, 2.1719286920638416], 3.9813457996138553], [9, [1.8100000810942674, -2.172497069481455], 3.981344143077207], [4, [1.8107742246844378, 1.5046226948538473], 2.8480129421575695], [4, [1.8107741674889597, -1.504622970780705], 2.848012937506889], [10, [-1.8090125823643233, 2.1719288473819836], 3.9813426863599712]], "nr_of_basins": 18, "f_opt_dim_2": 0.0, "x_opt_dim_2": [2.5233094184321248e-163, 1.1434757563583862e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.3359625610751714e-163, -9.690283118339008e-163, -1.3619109388243361e-162, -1.4052250009863622e-162, -1.2331009252834553e-162]}
{"id": "fe2a5188-1eca-4673-8fd3-8c2e806f3e53", "fitness": 0.8451673897604147, "name": "landscape_phase_nonuniform", "description": "A novel separable, non-homogeneous benchmark with three-phase per-dimension transitions. Each dimension has dimension-specific thresholds and curvature, creating phase-transition-like non-uniform regions across the search space. The landscape blends an inner quadratic core, a high-curvature middle region with per-dimension sinusoidal ripples, and an outer high-degree growth with additional ripples. The function remains separable with a global optimum at the origin.", "code": "import numpy as np\n\nclass landscape_phase_nonuniform:\n    \"\"\"\n    Novel separable landscape with per-dimension phase transitions that create a\n    non-homogeneous search space. Each dimension has its own two thresholds\n    (t1, t2) defining three regimes:\n      - inner quadratic: w_q ~ 1\n      - middle high-curvature with ripples: w_m ~ 1\n      - outer high-growth with ripples: w_out ~ 1\n    Weights w_q, w_m, w_out are computed via two logistic functions, giving\n    smooth but region-specific transitions that vary across dimensions.\n    \n    Global optimum at x = 0 with value 0.\n    Domain per-dimension: [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        idx = np.arange(self.dim)\n\n        # Per-dimension phase thresholds (non-homogeneous across dimensions)\n        # t1 in [0.5, 2.5] step ~0.5\n        self.t1 = 0.5 + (idx % 5) * 0.5\n        # t2 slightly further out, creating three zones\n        self.t2 = self.t1 + 0.8 + ((idx // 2) % 5) * 0.25\n\n        # Logistic steepness per dimension (controls sharpness of phase boundaries)\n        self.k = 1.2 + (idx % 4) * 0.6\n\n        # Per-dimension term coefficients\n        self.a_quad = 0.6 + (idx % 4) * 0.25   # inner quadratic coefficient\n        self.a_mid = 0.8 + (idx % 3) * 0.18   # middle-region curvature\n        self.a_out = 0.7 + (idx % 5) * 0.14   # outer-region growth\n\n        # Exponents for the middle and outer regions\n        self.p_mid = 2.5 + (idx % 3) * 0.25   # middle-region exponent\n        self.p_out = 3.0 + (idx % 3) * 0.8    # outer-region exponent\n\n        # Ripples / oscillations parameters per-dimension\n        self.r_mid_amp = 0.25 + (idx % 4) * 0.15   # amplitude of middle ripple\n        self.r_mid_freq = 1.0 + (idx % 4) * 0.9    # frequency of middle ripple\n\n        self.r_out_amp = 0.10 + (idx % 4) * 0.04   # amplitude of outer ripple\n        self.r_out_freq = 1.0 + (idx % 5) * 0.7    # frequency of outer ripple\n\n        # Optional global scaling (kept at 1.0 for comparability)\n        self.global_scale = 1.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the non-uniform, separable landscape at point x.\n\n        x: array-like of length self.dim, real-valued.\n        Returns: float, the sum of per-dimension costs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        di = np.abs(x)\n\n        # Phase weights using two logistic transitions to create three regions per dimension:\n        # w_q (inner quadratic), w_m (middle/high-curvature with ripples), w_out (outer growth)\n        A = 1.0 / (1.0 + np.exp(self.k * (di - self.t1)))  # high for di < t1\n        B = 1.0 / (1.0 + np.exp(self.k * (di - self.t2)))  # high for di < t2\n\n        w_q = A\n        w_m = B - A\n        w_out = 1.0 - B\n\n        # Per-dimension term computations\n        quad_term = self.a_quad * (x ** 2)\n\n        # Middle region: higher curvature with a sinusoidal ripple\n        mid_term = self.a_mid * (di ** self.p_mid) * (1.0 + self.r_mid_amp * np.sin(self.r_mid_freq * di))\n\n        # Outer region: higher-order growth with a cosine ripple\n        outer_term = self.a_out * (di ** self.p_out) + self.r_out_amp * np.cos(self.r_out_freq * di)\n\n        per_dim_cost = w_q * quad_term + w_m * mid_term + w_out * outer_term\n\n        return float(np.sum(per_dim_cost))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_phase_nonuniform scored on:NOT Homogeneous 0.362, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2d203bac-a1d7-4a75-be71-9e11459eb2a4"], "operator": null, "metadata": {"ela_features_2D": [-0.0031038003636420174, 0.2221249753455357, 0.004316854703846377, 0.022519524657128344, 115.54024908300566, 0.002925644725375953, 0.9231960524953026, 4.142093526320496, 0.9235143890494426, 1.2393756174849275, 0.5475411277142671, 1.0, 0.7118220724433677, 0.7175801010929106, 0.5658685528507789, 0.3411911665576636, -0.20934079329589772, 0.13532980304728084, 0.21975514846778305, 0.308425802214115, 0.49846551176090453, 0.13800735538971987, 0.2262085273373991, 0.3101380850779716, 0.4963629162660152, -0.4525284508093619, -0.4083462585188764, -0.36193901820298946, -0.2624807733498426, -0.44356124963245, -0.3981859575564134, -0.3549906268008777, -0.25915726721582855, 1.0, 1.0, 1.0, 1.0, 0.5196421063597062, 0.5196313071007612, 0.38283648302758577, 0.3492067647994704, 0.6028870914154987, 0.7457457457457456, 0.2832029292604915, -0.19919919919919912, 0.36345381526104414], "score_NOT Homogeneous_2D": 0.8807205334305763, "score_Separable_2D": 1.0, "ela_features": [-0.0007848216239320971, 0.21624973944336778, 0.002512701095687053, 0.026200851841007712, 13.895125194785, 0.0012884615719268798, 0.8678117333423735, 16.52690873143314, 0.8688039281224551, 1.3050741318814336, 1.0195205650772987, 1.6, 0.8797713005751124, 0.8696492825841398, 0.6254363526176788, 0.18684206823188634, -0.43086898163765347, 0.45387673997524836, 0.5429439325128372, 0.6249962286084811, 0.7543043926371732, 0.45806079415468226, 0.5430917620673085, 0.6225411440268757, 0.7511010184497089, -0.4804067026092567, -0.40205560097384047, -0.32987733083760407, -0.21613123612707108, -0.4792880498225158, -0.4040824963066164, -0.33381553644277967, -0.22012405131466178, 1.0, 1.0, 0.8666666666666668, 1.0, 0.21645269596465533, 0.21645181647354947, 0.19694761312221964, 0.18161530418438546, 0.7731033596461071, 0.4494494494494493, 0.16275621667320628, -0.3713713713713712, 0.5294871794871795], "score_NOT Homogeneous_5D": 0.8281396329402924, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0008884810716188296, 0.2606121167852752, 0.0018834768136132957, 0.021404319704357647, 20.258253302868308, 0.009145677086529224, 0.8508094101389532, 17.212158181947082, 0.853721785694647, 0.871165625219904, 0.4505649714671292, 1.4, 0.9672861885444682, 0.9302992995421538, 0.6775204684067557, 0.11190935551851314, -0.5289001645973821, 0.6547705155830055, 0.7270998131678345, 0.7782379355455978, 0.852210128451677, 0.6546483632710727, 0.7273528373697783, 0.7787491113280727, 0.8527074180205098, -0.43786626995811584, -0.34612825768649447, -0.2812682829544773, -0.18744657041762394, -0.4391806852720298, -0.3467220743594475, -0.2813621008851884, -0.1873083104969519, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10959751162346207, 0.10959663167051455, 0.10594251759020668, 0.10000654647382039, 0.8476409564031538, 0.009009009009008986, 0.1286730266959189, -0.5795795795795794, 0.610408326661329], "score_NOT Homogeneous_10D": 0.3621441721916199, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 0.022652905182806632]], "nr_of_basins": 1, "f_opt_dim_2": 0.022640969373105325, "x_opt_dim_2": [2.0313890354518655e-16, -7.843211106272531e-17], "f_opt_dim_5": 0.024094563005107667, "x_opt_dim_5": [1.8203992819521159e-16, -2.053635309888014e-17, -2.4154671590382528e-14, 1.1072592164455358e-13, -2.2535035554378973e-15]}
{"id": "eafeffff-4cb7-4301-bb77-6a0a588c5189", "fitness": 0.8249990617235502, "name": "landscape_phase_sep_nonhomogeneous", "description": "Novel separable, non-homogeneous landscape with per-dimension soft phase transitions that create three regimes (inner quadratic, middle high-curvature with ripples, outer high-order growth with ripples). Each dimension has its own thresholds, curvature and ripple periods to ensure a non-homogeneous search space while preserving separability. Global optimum at the origin.", "code": "import numpy as np\n\nclass landscape_phase_sep_nonhomogeneous:\n    \"\"\"\n    Separable, non-homogeneous benchmark landscape with per-dimension\n    soft phase transitions. Each dimension has its own two thresholds\n    (t1, t2) and distinct curvature/ripple parameters, yielding three\n    regimes:\n      - Inner quadratic: ~ a_quad * x^2\n      - Middle high-curvature with ripples: ~ a_mid * |x|^3 * (1 + ripple_mid)\n      - Outer high-order growth with ripples: ~ a_outer * |x|^4 * (1 + ripple_outer)\n    Transitions are smoothed via logistic-like blends to ensure differentiability.\n    Global optimum at x = 0 (value 0). Domain per-dimension: [-5, 5].\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        idx = np.arange(self.dim)\n\n        # Per-dimension thresholds (non-homogeneous)\n        # Two phase transitions: t1 (inner to middle), t2 (middle to outer)\n        self.threshold1 = 0.6 + (idx % 5) * 0.4         # e.g., 0.6, 1.0, 1.4, 1.8, 2.2\n        self.threshold2 = self.threshold1 + 1.0 + ((idx // 2) % 3) * 0.5  # varied spacing\n\n        # Logistic steepness per dimension for the two transitions\n        self.k1 = 2.0 + (idx % 4) * 0.7\n        self.k2 = 2.0 + ((idx + 1) % 4) * 0.9\n\n        # Per-dimension term coefficients\n        self.a_quad = 0.6 + (idx % 4) * 0.25     # ~0.6 to ~1.35\n        self.a_mid = 0.4 + (idx % 5) * 0.15     # ~0.4 to ~1.15\n        self.a_outer = 0.25 + (idx % 6) * 0.12  # ~0.25 to ~0.99\n\n        # Ripple characteristics (dimension-specific)\n        self.mid_period = 0.9 + (idx % 4) * 0.6     # ripple period in middle regime\n        self.outer_period = 1.2 + (idx % 5) * 0.5   # ripple period in outer regime\n        self.mid_amp = 0.25                          # ripple amplitude (middle)\n        self.outer_amp = 0.25                        # ripple amplitude (outer)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable, non-homogeneous landscape at point x.\n\n        x: array-like of length self.dim, real-valued.\n        Returns: float, the sum of per-dimension costs (global minimum at 0).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)\n\n        # Soft phase-transition weights per dimension\n        # s1 transitions from ~1 (near origin) to ~0 (beyond t1)\n        s1 = 1.0 / (1.0 + np.exp((r - self.threshold1) * self.k1))\n        # s2 transitions from ~1 (before t2) to ~0 (beyond t2)\n        s2 = 1.0 / (1.0 + np.exp((r - self.threshold2) * self.k2))\n\n        # Per-dimension term components (non-negative, symmetric in x)\n        quad_term = self.a_quad * (x ** 2)\n\n        # Middle regime with ripples (depends on r)\n        mid_term = self.a_mid * (r ** 3) * (\n            1.0 + self.mid_amp * np.sin(2.0 * np.pi * r / np.maximum(self.mid_period, 1e-12))\n        )\n\n        # Outer regime with ripples (depends on r)\n        outer_term = self.a_outer * (r ** 4) * (\n            1.0 + self.outer_amp * np.sin(2.0 * np.pi * r / np.maximum(self.outer_period, 1e-12))\n        )\n\n        # Weighted combination to ensure a smooth convex-like landscape with phase\n        w_q = s1\n        w_m = (1.0 - s1) * s2\n        w_o = (1.0 - s2)\n\n        wsum = w_q + w_m + w_o\n        wsum = np.maximum(wsum, 1e-12)\n\n        per_dim_cost = (\n            (w_q / wsum) * quad_term +\n            (w_m / wsum) * mid_term +\n            (w_o / wsum) * outer_term\n        )\n\n        return float(np.sum(per_dim_cost))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_phase_sep_nonhomogeneous scored on:NOT Homogeneous 0.472, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2d203bac-a1d7-4a75-be71-9e11459eb2a4"], "operator": null, "metadata": {"ela_features_2D": [-3.5208729401547956e-05, 0.2331687318497468, 0.008559357028707954, 0.04325019250942791, 7.078360350190546, 0.00032727253652951036, 0.9130259617798029, 1.3317945973333445, 0.9131419429745838, 0.9622474191206655, 0.33772627331934385, 2.2, 0.695237227599435, 0.7075915984707641, 0.5297410285195772, 0.34931264813986707, -0.2249197710061417, 0.15613717705018243, 0.23620341405355338, 0.32283027768298195, 0.500873956344015, 0.1558602877259551, 0.23699522495803463, 0.3237865518667329, 0.5024422039695955, -0.44150669011094623, -0.3996176632336331, -0.3542928391035567, -0.2611391006261371, -0.43377962315241325, -0.39210459076223403, -0.3474805484225324, -0.25566874614416957, 1.0, 1.0, 1.0, 1.0, 0.5177726039344331, 0.5177694077501889, 0.40757696177268576, 0.3569540170248678, 0.6556359866622085, 0.8818818818818815, 0.3061678812539414, -0.19119119119119113, 0.39879518072289155], "score_NOT Homogeneous_2D": 0.9363726526498795, "score_Separable_2D": 1.0, "ela_features": [-0.00021281329854916375, 0.2688735472958396, 0.0055821063033331, 0.02868852510639064, 9.738528452488646, 0.003709218826380667, 0.8572859826223784, 2.4792425201108186, 0.8597477917739059, 0.7941731065785572, 0.3444287294387042, 1.4, 0.8998705838735038, 0.8695952106871478, 0.6261345976242744, 0.18907094451115297, -0.4958868918785984, 0.4579181056278756, 0.5420783794765672, 0.6211877062567802, 0.7340535877910961, 0.46541061965668523, 0.5455374051658394, 0.6243207380533934, 0.7366088876965853, -0.4768204536536575, -0.40279319456037965, -0.33320770752682716, -0.23392964784502052, -0.47270367670453, -0.4018526475216582, -0.33219030994067733, -0.232902046077837, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2150669660288617, 0.21505963548904083, 0.1989165569034516, 0.1810709773238607, 0.8189809878751501, 0.3453453453453452, 0.2799837508049419, -0.2872872872872872, 0.5413461538461538], "score_NOT Homogeneous_5D": 0.5419433414936066, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0016342613320620147, 0.31720692157016306, 0.0008748832906346603, 0.016374138219275483, 19.05538951216069, 0.004262430169575037, 0.8667802811539289, 3.8439570812670345, 0.8689889956857264, 0.6129236113654625, 0.32213821337752596, 1.4, 0.9939925867083078, 0.9358391149136984, 0.6846416466769996, 0.10841120896302166, -0.5826472543013785, 0.639575551351943, 0.7038500548762826, 0.7543511234966719, 0.8296381987365373, 0.6443927461216735, 0.7054397151627307, 0.7570886548650175, 0.8322393012555264, -0.45710157056173706, -0.37558715720117275, -0.3115402719467283, -0.21605867028739928, -0.4521280571514826, -0.37451304875134867, -0.30884618064982566, -0.213296758556457, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10931921037525523, 0.10932084901524056, 0.10605099954834343, 0.09954157190899023, 0.8616191861699256, -0.02702702702702704, 0.1413320429397407, -0.6076076076076073, 0.6151321056845476], "score_NOT Homogeneous_10D": 0.47167837619781494, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-4.372991353534326, -4.391691988576707], 193.79790146405963], [8, [-3.0908814841479657, -0.0004373940730763729], 20.013415000751074], [8, [0.00044444444444512003, -4.394000000000067], 120.40748626242328], [8, [-4.388000000000067, 0.00044444444444512003], 73.33899758244115], [1, [4.1752551375335205, 4.374095343521147], 198.7744398541888], [9, [4.388161629056728, -9.995410719855751e-05], 73.33898423808925], [57, [0.00044444444444512003, 0.00044444444444512003], 2.476536739400982e-07], [8, [0.1408637837550503, 4.393180625919031], 120.4164176228793]], "nr_of_basins": 8, "f_opt_dim_2": 0.0, "x_opt_dim_2": [3.716845423088276e-163, -9.651883844799069e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.0161462190164185e-162, 1.032266268786286e-162, -1.3671085312300045e-162, -4.242137942137922e-163, -1.115796005176624e-162]}
{"id": "166dfbdd-ea94-426e-a832-e57e85542bdc", "fitness": 0.903351930346064, "name": "landscape_separable_three_regime_grouped", "description": "A strongly separable, non-homogeneous landscape with grouped per-dimension three-regime phase transitions. Each dimension is independent, but thresholds and curvature vary by dimension-group, enabling effective problem decomposition into subproblems. Global optimum remains at the origin.", "code": "import numpy as np\n\nclass landscape_separable_three_regime_grouped:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be positive.\")\n\n        # Grouping strategy to induce non-homogeneity while keeping separability\n        # Group size at least 1\n        self.group_size = max(1, self.dim // 3)\n        self.num_groups = int(np.ceil(self.dim / self.group_size))\n\n        # Base inner-thresholds per group (non-homogeneous across space)\n        # Use a simple increasing base so far groups have slightly different behavior\n        self.t1_base = 0.25 + (np.arange(self.num_groups) / max(1, (self.num_groups - 1))) * 0.25\n        # Allocate per-dimension thresholds\n        self.t1 = np.zeros(self.dim, dtype=float)\n        self.t2 = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            g = min(i // self.group_size, self.num_groups - 1)\n            # Slight dimension-specific adjustment to break exact symmetry between dims within a group\n            self.t1[i] = self.t1_base[g] + (i % 5) * 0.01\n            # Ensure t2 > t1 and add group- and dimension-specific modulation\n            self.t2[i] = self.t1[i] + 0.65 + (g % 2) * 0.25 + ((i % 3) * 0.03)\n\n        # Per-dimension curvature coefficients (independent across dimensions -> separable)\n        self.c1 = 0.8 + (np.arange(self.dim) % 4) * 0.15  # quadratic in inner region\n        self.c2 = 0.6 + (np.arange(self.dim) % 3) * 0.25  # cubic contribution in middle region\n        self.c3 = 0.4 + (np.arange(self.dim) % 2) * 0.30  # linear growth in outer region\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        absx = np.abs(x)\n\n        # Initialize per-dimension costs\n        per_dim = np.zeros(self.dim, dtype=float)\n\n        # Zone 1: inner quadratic |x| <= t1\n        mask1 = absx <= self.t1\n        if np.any(mask1):\n            per_dim[mask1] = self.c1[mask1] * (x[mask1] ** 2)\n\n        # Zone 2: middle cubic t1 < |x| <= t2\n        mask2 = (absx > self.t1) & (absx <= self.t2)\n        if np.any(mask2):\n            t1_m = self.t1[mask2]\n            per_dim[mask2] = (self.c1[mask2] * (t1_m ** 2) +\n                              self.c2[mask2] * ((absx[mask2] - t1_m) ** 3))\n\n        # Zone 3: outer linear |x| > t2\n        mask3 = absx > self.t2\n        if np.any(mask3):\n            t1_o = self.t1[mask3]\n            t2_o = self.t2[mask3]\n            per_dim[mask3] = (self.c1[mask3] * (t1_o ** 2) +\n                              self.c2[mask3] * ((t2_o - t1_o) ** 3) +\n                              self.c3[mask3] * (absx[mask3] - t2_o))\n\n        return float(np.sum(per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_separable_three_regime_grouped scored on:NOT Homogeneous 0.873, Separable 0.887,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f064e5d3-a062-4908-907c-709de759f55a"], "operator": null, "metadata": {"ela_features_2D": [-0.0019683790547130988, 0.4970761427644078, 0.014106762340817102, 0.032316350902364815, 37.05318964738693, -0.002695958524741937, 0.933645749438497, 1.8019672973999157, 0.9339664363062001, -0.057548152816795727, -0.8572884230382453, 1.4, 0.7016736081530309, 0.7201666025681452, 0.5471494053812072, 0.33741771117654873, -0.19087500753092856, 0.16007471625996705, 0.21853372923320502, 0.3143867650971275, 0.525685294278252, 0.16083632881868448, 0.22530536097169138, 0.303700625963235, 0.5052038688570069, -0.4397313082637032, -0.4091243986356933, -0.35894222655251906, -0.24831879557022427, -0.4312359168965534, -0.39810099747443617, -0.35781795569933206, -0.25426509917284223, 1.0, 1.0, 1.0, 1.0, 0.5100626722358147, 0.5100399231561692, 0.3823315095118719, 0.3493196412002472, 0.7346080876278662, 0.4534534534534533, 0.6398394784148487, -0.07107107107107105, 0.3506024096385542], "score_NOT Homogeneous_2D": 0.9538917243480682, "score_Separable_2D": 0.861328125, "ela_features": [-0.0002841602306303148, 0.5006895414276377, 0.004145287129567285, 0.026430863098467205, 7.740489950576067, 0.0006936734833099311, 0.9339681516503168, 1.827830202975661, 0.9338724192010733, 0.009279425534435374, -0.3449925012769179, 1.2, 0.8891653286702725, 0.866894352337947, 0.6465094904515911, 0.18605219470627582, -0.4548513806863629, 0.45354475318317283, 0.5552958716499115, 0.6268863669000989, 0.7388450027450408, 0.4396484487094388, 0.5478394616414674, 0.6225299468199897, 0.7380426148599667, -0.4806104502658185, -0.3911236693132677, -0.32815866411124806, -0.2296901051748232, -0.4952109545622885, -0.39960523636215306, -0.3335977878818698, -0.23151260153227216, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21351813727900862, 0.21352510289497517, 0.19862086945803348, 0.18053406333709643, 0.8256999483277374, 0.057057057057057034, 0.2670120432957693, -0.38738738738738726, 0.5054487179487179], "score_NOT Homogeneous_5D": 0.9915510257706046, "score_Separable_5D": 0.853173828125, "ela_features_10D": [6.088546255116345e-05, 0.5227933488756221, 0.0005738602854273245, 0.019806617015150987, 110.13839368834067, 0.0016572633217287302, 0.9290045891612534, 1.9798088680642032, 0.9290122774079801, 0.002295575008328067, -0.12482619680891247, 1.2, 0.9896663294576479, 0.9345269546504824, 0.6977323239404325, 0.10762860218405798, -0.6152343323506129, 0.6439005489721448, 0.7018563604277779, 0.7500370042858873, 0.822882203340322, 0.6435383554278451, 0.7025237575490266, 0.7514768632478458, 0.8254229880942502, -0.45163053735120473, -0.37812731640154984, -0.31702145026738104, -0.22463431316220744, -0.4533197466936528, -0.3783080871821272, -0.3160536165825227, -0.22201552399099542, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1105992415245776, 0.11059499403667732, 0.1075775825093559, 0.10112792740338997, 0.8547780612649045, -0.1271271271271271, 0.1330182927707347, -0.6316316316316314, 0.5934347477982386], "score_NOT Homogeneous_10D": 0.8731009066104889, "score_Separable_10D": 0.8870659722222223}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.4567901234672994e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.3194193235036608e-162, 2.4439828270216123e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-3.265191429819793e-163, 1.0101879821411165e-162, 1.648076281317197e-163, -1.0196888969886142e-162, -1.0105664181726212e-162]}
{"id": "e6653185-a62e-4c89-a816-be22a74a92b7", "fitness": 0.9077655291184783, "name": "landscape_piecewise_rugged_separable", "description": "A completely different separable, non-homogeneous landscape using per-dimension piecewise phase transitions with a rugged outer region, based on a smooth inner quadratic well transitioning to a polynomial outer growth plus a sine-based ruggedness term. Each dimension has its own thresholds and curvature parameters, ensuring non-homogeneity while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_piecewise_rugged_separable:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension non-homogeneous parameters to create phase transitions\n        # h: threshold for phase transition (|x| <= h -> inner quadratic region)\n        # a: inner region coefficient\n        # b: outer region polynomial growth coefficient\n        # p: outer region exponent (polynomial degree)\n        # e: amplitude of rugged sine modulation in outer region\n        # q: frequency of ruggedness\n        # phase: phase offset for deterministic richness\n        self.h = np.zeros(self.dim, dtype=float)\n        self.a = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.p = np.zeros(self.dim, dtype=float)\n        self.e = np.zeros(self.dim, dtype=float)\n        self.q = np.zeros(self.dim, dtype=float)\n        self.phase = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            t = i / max(1, self.dim - 1)  # in [0, 1]\n            # Non-homogeneous parameterization across dimensions\n            self.h[i] = 0.3 + 1.5 * t          # thresholds in [0.3, 1.8]\n            self.a[i] = 0.6 + 1.0 * t          # inner quadratic coefficient in [0.6, 1.6]\n            self.b[i] = 0.4 + 0.9 * t          # outer growth coefficient in [0.4, 1.3]\n            self.p[i] = 1.6 + 0.3 * t          # outer exponent in [1.6, 1.9]\n            self.e[i] = 0.05 + 0.25 * t        # ruggedness amplitude in [0.05, 0.30]\n            self.q[i] = 6.0 + 6.0 * t           # ruggedness frequency in [6, 12]\n            # Deterministic phase based on dimension index\n            seed = (i * 99991) % 1000003\n            self.phase[i] = (seed / 1000003.0) * 2.0 * np.pi\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            absx = abs(xi)\n\n            if absx <= self.h[i]:\n                gi = self.a[i] * (xi ** 2)\n            else:\n                # Continuity at boundary is ensured by using a_i * h_i^2 as the base value\n                base = self.a[i] * (self.h[i] ** 2)\n                rugged = self.e[i] * np.sin(self.q[i] * (absx - self.h[i]) + self.phase[i])\n                gi = base + self.b[i] * ((absx - self.h[i]) ** self.p[i]) + rugged\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_piecewise_rugged_separable scored on:NOT Homogeneous 0.543, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82bd2d85-e148-4b41-987f-41e521f34894"], "operator": null, "metadata": {"ela_features_2D": [-0.003006502601109773, 0.3889828684122216, 0.002636846977105238, 0.021963819761599324, 22.676843361594653, -0.003143738971412313, 0.9732543753020003, 3.2445684994044113, 0.9731182757153192, 0.38390555131214293, -0.6640625771053564, 1.0, 0.6927996566106869, 0.7020938787540745, 0.5406310443201644, 0.3554147230113224, -0.19255954754560572, 0.1704595886412895, 0.2746341701090834, 0.3823440823442735, 0.6015680996545949, 0.15119214796417277, 0.2515944502159193, 0.35141240040773347, 0.5515673074160776, -0.4340960742891856, -0.37957792031285165, -0.3232118850653737, -0.20849049070730263, -0.4363083940178365, -0.38469207573060604, -0.33338617480056815, -0.23049589564500442, 1.0, 1.0, 1.0, 1.0, 0.5194822556378647, 0.5194750610977499, 0.39493551025044527, 0.3507266196167689, 0.7453882039455767, 0.5535535535535534, 0.5372321052227886, -0.07907907907907909, 0.39879518072289155], "score_NOT Homogeneous_2D": 0.9846095610409975, "score_Separable_2D": 1.0, "ela_features": [-0.0007657098289131081, 0.442335388170118, 0.001966911683760129, 0.027648766925454565, 38.47935419694041, -0.00039009743803455346, 0.9846715923162572, 3.1729308137894066, 0.9846399440249588, 0.23784553704839073, -0.26980252893780465, 1.2, 0.8973131248457328, 0.870020727591921, 0.6440998871596884, 0.18568594009149325, -0.46988045617291296, 0.48080960579149135, 0.5681170354450524, 0.6290333162022623, 0.7360504959371353, 0.4709351569496277, 0.5618539422701574, 0.6229896444845828, 0.7343141503435302, -0.4567676446515089, -0.3799539811649638, -0.3263616211956156, -0.23221188115876373, -0.4680241735804541, -0.38758666081708465, -0.33350326924865265, -0.23502489472530347, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21390606856153643, 0.21387953742590202, 0.1986578761153642, 0.18125543420817772, 0.8274426270421402, 0.1451451451451451, 0.2893549564752978, -0.3633633633633632, 0.5115384615384616], "score_NOT Homogeneous_5D": 0.9192258045077324, "score_Separable_5D": 1.0, "ela_features_10D": [0.00030377604217481926, 0.444418180679957, 0.0019926169757144676, 0.01934446735764362, 41.4565417422074, 0.004037511838675689, 0.9868149515360601, 3.1728248774147594, 0.9866931326542542, 0.23356765086367814, -0.07027066990932491, 1.2, 1.0106150048958356, 0.936906861283318, 0.707587092413587, 0.10648283884277929, -0.5974289368469724, 0.6468015159107527, 0.7060238340519778, 0.7492724473798933, 0.820903671192412, 0.6485218573443492, 0.7072053678182231, 0.7511680736104822, 0.8238750178216044, -0.4479594954336751, -0.37284869192073744, -0.31799672898038295, -0.22714721320896736, -0.44695713233070844, -0.3723337691610703, -0.3164288536453742, -0.22397043797774066, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11023321913135709, 0.11023257203256823, 0.1071609518569449, 0.1007029532930626, 0.8555696443225778, -0.12312312312312305, 0.1360583413476401, -0.6396396396396394, 0.5909527622097679], "score_NOT Homogeneous_10D": 0.5427578091621399, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [0.00044444444444512003, 3.1000000000002093], 7.174966959365952], [20, [0.00044444444444512003, -3.098888888888976], 7.174976747368888], [10, [0.00044444444444512003, 2.6137777777777966], 5.815564548460693], [10, [0.00044444444444512003, -2.6137777777777957], 5.815564548460693], [40, [0.00044444444444512003, 0.00044444444444512003], 4.3456790123588906e-07]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [9.490040778712352e-163, 3.0640785436555675e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.4613707233691322e-162, 7.387303477468558e-163, -5.1988671190300246e-163, -1.5468987574881204e-162, 1.1424714126786974e-162]}
{"id": "5d85acd6-f74f-4639-b1f5-74060b1519b5", "fitness": 0.9008738572398821, "name": "landscape_rugged_phase_nonhom", "description": "A highly non-homogeneous, separable landscape with four phase-regions per dimension, where per-dimension thresholds and curvature vary across dimensions to create region-specific appearances. It features a near-origin quadratic well, a mid-region cubic-like growth, a smooth transition to a stronger outer growth, and a rugged outer region with phase-shifted cosine modulation. The global optimum remains at the origin.", "code": "import numpy as np\n\nclass landscape_rugged_phase_nonhom:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Per-dimension phase-transition thresholds and curvature\n        # h1: end of inner quadratic region\n        # h2: end of middle region (cubic growth)\n        # h3: end of outer smooth growth, start of rugged outer region\n        self.h1 = np.zeros(self.dim, dtype=float)\n        self.h2 = np.zeros(self.dim, dtype=float)\n        self.h3 = np.zeros(self.dim, dtype=float)\n\n        # Coefficients for each zone per dimension\n        self.a1 = np.zeros(self.dim, dtype=float)  # inner quadratic coeff\n        self.a2 = np.zeros(self.dim, dtype=float)  # middle cubic coeff\n        self.a3 = np.zeros(self.dim, dtype=float)  # outer smooth coeff (before rugged)\n        self.a4 = np.zeros(self.dim, dtype=float)  # outer linear-like growth\n\n        # Rugged outer region modulation\n        self.e = np.zeros(self.dim, dtype=float)   # amplitude of ruggedness\n        self.w = np.zeros(self.dim, dtype=float)   # frequency of ruggedness\n        self.phi = np.zeros(self.dim, dtype=float) # phase offset for ruggedness\n\n        for i in range(self.dim):\n            r = i / max(1, self.dim - 1)  # in [0,1]\n\n            # Phase-transition thresholds (in [0,5] within domain)\n            self.h1[i] = 0.25 + 0.45 * r     # ~0.25 to ~0.70\n            self.h2[i] = 1.0 + 0.8 * r       # ~1.0 to ~1.8\n            self.h3[i] = 2.0 + 1.6 * r       # ~2.0 to ~3.6\n\n            # Zone curvature coefficients (varying across dimensions)\n            self.a1[i] = 0.5 + 0.25 * r      # inner quadratic\n            self.a2[i] = 0.8 + 0.3 * r       # middle cubic\n            self.a3[i] = 0.6 + 0.25 * r      # outer smooth grow\n            self.a4[i] = 0.9 + 0.45 * r      # outer rugged slope\n\n            # Rugged outer region parameters\n            self.e[i] = 0.05 + 0.07 * r        # amplitude\n            self.w[i] = 5.0 + 2.0 * r          # frequency\n            self.phi[i] = np.pi * (0.25 + 0.5 * r)  # phase offset\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        absx = np.abs(x)\n        g = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            xi = x[i]\n            ax = absx[i]\n            h1 = self.h1[i]\n            h2 = self.h2[i]\n            h3 = self.h3[i]\n            a1 = self.a1[i]\n            a2 = self.a2[i]\n            a3 = self.a3[i]\n            a4 = self.a4[i]\n            e = self.e[i]\n            wv = self.w[i]\n            phi = self.phi[i]\n\n            # Precompute continuity bases\n            base2 = a1 * (h1 ** 2)\n            val_h2 = base2 + a2 * ((h2 - h1) ** 3)\n            base3 = val_h2 + a3 * ((h3 - h2) ** 2)\n\n            if ax <= h1:\n                gi = a1 * (xi ** 2)\n            elif ax <= h2:\n                gi = base2 + a2 * ((ax - h1) ** 3)\n            elif ax <= h3:\n                gi = val_h2 + a3 * ((ax - h2) ** 2)\n            else:\n                # Rugged outer region with phase-shifted cosine modulation\n                gi = (base3 +\n                      a4 * (ax - h3) +\n                      e * (np.cos(wv * (ax - h3) + phi) - np.cos(phi))\n                     )\n\n            g[i] = gi\n\n        return float(np.sum(g))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_rugged_phase_nonhom scored on:NOT Homogeneous 0.755, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82bd2d85-e148-4b41-987f-41e521f34894"], "operator": null, "metadata": {"ela_features_2D": [-7.79874424746696e-05, 0.4406086228864005, 0.013524466887462016, 0.0439724753250992, 9.33454417676017, 0.002037993617100331, 0.9773569658644684, 1.8523507170808766, 0.97761280086683, 0.2546404525441365, -0.883129634059577, 1.2, 0.6885533211704067, 0.7037734739360287, 0.5505869615534551, 0.3501641221575324, -0.18160085048010993, 0.1539400812769551, 0.23088831293981693, 0.3208566446725536, 0.4971037662556899, 0.1580712195577961, 0.23492945136290042, 0.3217316761335704, 0.49431308121240924, -0.44252884455408575, -0.4022814820172534, -0.3552237198028302, -0.2630365087832235, -0.4317406474700388, -0.3923326301268618, -0.34781713024440475, -0.2593159817943801, 1.0, 1.0, 1.0, 1.0, 0.5069209988001097, 0.5068487534402395, 0.3737689053007872, 0.3528472163102965, 0.7388811391533077, 0.4494494494494493, 0.5835313317475979, -0.07107107107107107, 0.3662650602409639], "score_NOT Homogeneous_2D": 0.8436684757471085, "score_Separable_2D": 1.0, "ela_features": [0.00073647026730701, 0.4474255568183095, 0.0018767308452445491, 0.028739998618587337, 213.89584522107015, 0.00426740436877906, 0.9759763475650853, 1.8427237742375553, 0.9760915476160902, 0.14979091588548005, -0.29308260459277147, 1.0, 0.9063625292195961, 0.8733984070931685, 0.6472456381489001, 0.18203601281746823, -0.46191118124160163, 0.4388930789891531, 0.5235704839468056, 0.5981878851046216, 0.7199937889326888, 0.43676985182966177, 0.5234001715171159, 0.5977411448215854, 0.7213087471509791, -0.4934054369607055, -0.4189436539315266, -0.3533301483118689, -0.2462205271214152, -0.49745601654920596, -0.42093780755373195, -0.3552815335692473, -0.24614281895803808, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21620029413418645, 0.21617552748448987, 0.20191360582337903, 0.18357526701692084, 0.822885687836601, 0.06906906906906903, 0.2388374830341852, -0.3873873873873873, 0.5028846153846154], "score_NOT Homogeneous_5D": 0.8061174005270004, "score_Separable_5D": 1.0, "ela_features_10D": [0.0005088738746076738, 0.467594812633342, 0.001417434994163872, 0.022287184239434026, 20.588688416353506, 0.0038217726215692195, 0.975265217038579, 1.8647384565361864, 0.9755243162211796, 0.09474837109410125, -0.16864716311668088, 1.6, 1.008646643383853, 0.938465017195403, 0.7117707221078968, 0.10390423763846723, -0.6080207263920718, 0.6327898882232315, 0.6878333978973332, 0.7369536445213946, 0.8133059681851442, 0.6335595981032309, 0.6897532896030559, 0.7403421818246047, 0.8169036759013061, -0.465716409309317, -0.395906435863143, -0.3336093217788002, -0.23677547556160147, -0.4659838559890296, -0.39452368676600214, -0.3301921102855368, -0.2328335532996187, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10975503101776266, 0.10975856761625, 0.10661305434749854, 0.10057300297724832, 0.8498159037413604, -0.12312312312312308, 0.1394804064368762, -0.6396396396396394, 0.5787029623698959], "score_NOT Homogeneous_10D": 0.755457267165184, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.469135802476642e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-7.814899804209255e-163, 1.1249644544311458e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.4981635067751657e-162, 3.637801963346002e-163, -1.1730778255458795e-162, 4.860778868763122e-163, 9.481868011449697e-163]}
{"id": "b88f1332-6e74-425f-8f3c-e46b693e47bd", "fitness": 0.5344748000303904, "name": "phase_transition_landscape_enhanced", "description": "A novel separable, non-homogeneous landscape with multi-phase transitions, implemented with explicit per-dimension modular computation to strengthen separability. Each dimension has three regimes (inner quadratic, middle high-curvature with ripples, outer high-order growth with ripples). The landscape remains additive across dimensions, ensuring easy decomposition into subproblems, while per-dimension parameters create non-homogeneous structure and a global minimum at zero.", "code": "import numpy as np\n\nclass phase_transition_landscape_enhanced:\n    \"\"\"\n    A separable, non-homogeneous landscape with multi-phase transitions per dimension.\n\n    Each coordinate x_i has:\n      - an inner region: |x_i| <= a_i, with quadratic cost alpha_i * x_i^2\n      - a middle region: a_i < |x_i| <= b_i, with cubic cost beta_i * (|x_i|-a_i)^3 plus a ripple term\n      - an outer region: |x_i| > b_i, with quartic cost gamma2_i * (|x_i|-b_i)^4 plus a stronger ripple term\n\n    The parameters a_i, b_i, alpha_i, beta_i, gamma2_i, and ripple parameters are per-dimension\n    to ensure non-homogeneous structure across dimensions. The global optimum is at x = 0\n    with value 0, and the problem is separable (sum of per-dimension terms).\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Seed chosen to produce deterministic but varied per-dimension behavior\n        rng = np.random.default_rng(seed=13579 + 17 * self.dim)\n\n        # Per-dimension regime boundaries (inner and outer)\n        self.a = rng.uniform(0.25, 1.6, size=self.dim)  # inner threshold\n        self.b = rng.uniform(1.8, 4.8, size=self.dim)   # outer threshold\n        self.b = np.maximum(self.b, self.a + 0.2)       # ensure a < b\n\n        # Region coefficients (per-dimension)\n        self.alpha = rng.uniform(0.25, 2.5, size=self.dim)  # inner quadratic coefficient\n        self.beta = rng.uniform(0.6, 4.0, size=self.dim)    # middle region base coefficient\n        self.gamma2 = rng.uniform(0.6, 3.5, size=self.dim)  # outer region base coefficient\n\n        # Ripple-related parameters for middle region\n        self.omega_mid = rng.uniform(0.4, 3.5, size=self.dim)\n        self.phase_mid = rng.uniform(0.0, 2*np.pi, size=self.dim)\n        self.ripple_mid = rng.uniform(0.0, 0.7, size=self.dim)\n\n        # Ripple-related parameters for outer region\n        self.omega_outer = rng.uniform(0.4, 3.0, size=self.dim)\n        self.phase_outer = rng.uniform(0.0, 2*np.pi, size=self.dim)\n        self.ripple_outer = rng.uniform(0.0, 0.8, size=self.dim)\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def _dim_term(self, i, xi):\n        \"\"\"\n        Compute the per-dimension contribution f_i(x_i) for dimension i.\n        This helper emphasizes modular subproblems and preserves separability.\n        \"\"\"\n        x = float(xi)\n        a_i = self.a[i]\n        b_i = self.b[i]\n        absx = abs(x)\n\n        if absx <= a_i:\n            # Inner quadratic\n            return self.alpha[i] * (x * x)\n        elif absx <= b_i:\n            # Middle cubic with ripple\n            delta_mid = absx - a_i\n            return (\n                self.beta[i] * (delta_mid ** 3) +\n                self.ripple_mid[i] * (\n                    np.sin(self.omega_mid[i] * delta_mid + self.phase_mid[i]) ** 2\n                )\n            )\n        else:\n            # Outer quartic with stronger ripple\n            delta_outer = absx - b_i\n            return (\n                self.gamma2[i] * (delta_outer ** 4) +\n                self.ripple_outer[i] * (\n                    np.sin(self.omega_outer[i] * delta_outer + self.phase_outer[i]) ** 2\n                )\n            )\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x (dimension must match self.dim).\n        Returns a scalar value: sum_i f_i(x_i).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        inside = absx <= self.a\n        middle = (absx > self.a) & (absx <= self.b)\n        outer = absx > self.b\n\n        # Inner region: vectorized quadratic\n        if np.any(inside):\n            idx = np.nonzero(inside)[0]\n            val[idx] += self.alpha[idx] * (x[idx] ** 2)\n\n        # Middle region: cubic growth plus ripple\n        if np.any(middle):\n            idx = np.nonzero(middle)[0]\n            delta_mid = absx[middle] - self.a[middle]\n            val[middle] = (\n                self.beta[middle] * (delta_mid ** 3) +\n                self.ripple_mid[middle] * (\n                    np.sin(self.omega_mid[middle] * delta_mid + self.phase_mid[middle]) ** 2\n                )\n            )\n\n        # Outer region: quartic growth plus ripple\n        if np.any(outer):\n            idx = np.nonzero(outer)[0]\n            delta_outer = absx[outer] - self.b[outer]\n            val[outer] = (\n                self.gamma2[outer] * (delta_outer ** 4) +\n                self.ripple_outer[outer] * (\n                    np.sin(self.omega_outer[outer] * delta_outer + self.phase_outer[outer]) ** 2\n                )\n            )\n\n        return float(np.sum(val))", "configspace": "", "generation": 2, "feedback": "The optimization landscape phase_transition_landscape_enhanced scored on:NOT Homogeneous 0.205, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3fc53af3-c7a7-4010-8b0a-d97b6cb54e19"], "operator": null, "metadata": {"ela_features_2D": [-0.0033482774028694706, 0.16379650493358575, 0.004803356006411693, 0.015728009493511018, 4.249690010571939, 0.0010425550848326194, 0.1704608577211002, 1.7007139910919271, 0.176681969193894, 1.6248680575423173, 2.1445739262798384, 1.8, 0.2816443575706164, 0.5913679205635173, 0.25207347644893596, 0.3844877107584423, -0.33282931195347004, 0.8012336430508687, 0.8079234718562678, 0.8301529454963026, 0.8205743429021899, 0.8201293533146033, 0.8177832318622602, 0.8331029077645195, 0.8173356884392525, -0.10402843399177582, -0.10049649850732308, -0.08886072359899108, -0.09386615049966435, -0.09243906557370543, -0.09355469214328135, -0.08568367245611469, -0.0937675784747859, 1.0, 1.0, 1.0, 1.0, 0.5263536682586275, 0.5263520110473453, 0.4271390344819121, 0.35271511542129125, 0.6941947039483718, 1.37037037037037, 0.33794437247831144, 0.12912912912912908, 0.45421686746987955], "score_NOT Homogeneous_2D": 0.0001087188720703125, "score_Separable_2D": 1.0, "ela_features": [0.0012690762650845234, 0.15630929545111005, 0.003768006176186645, 0.038553731802142874, 15.13907465055021, 0.005090674858463351, 0.6758482519278225, 27.088937998623543, 0.6791437252764267, 1.964389115631461, 3.3860186053238683, 2.0, 0.6568606033895428, 0.8307903166651112, 0.4405022819795665, 0.21813603685649988, -0.3759021761220505, 0.7722495402166621, 0.7774564286064953, 0.7794192579009602, 0.8216786360460236, 0.7568846320382537, 0.7670465548010001, 0.771638001421034, 0.8135783882952052, -0.20034720663014144, -0.1957652582489521, -0.19403988299491426, -0.15686588391371784, -0.21500528836501037, -0.20601029664905282, -0.20195481007129668, -0.1648660761930691, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21421756442405818, 0.21424451118981042, 0.19580927086834754, 0.18170647234371196, 0.8056310092342132, 0.5615615615615613, 0.15856838613217877, -0.43143143143143126, 0.5932692307692308], "score_NOT Homogeneous_5D": 0.001570284366607666, "score_Separable_5D": 1.0, "ela_features_10D": [0.0010707357817343333, 0.2631115915649695, 0.0015431484537143459, 0.023800715310909222, 18.838106246850863, 0.006368953818221845, 0.6277339605899913, 57.03925962862833, 0.6375336887219991, 0.8610292648400673, 0.6012021264221754, 2.0, 0.8717699199449067, 0.9194913186494645, 0.6017910207243774, 0.12332822506423884, -0.534831575726854, 0.7562673522232222, 0.7901611168911995, 0.8223844773581132, 0.8750536181911881, 0.7500447887239259, 0.7877366420418082, 0.8211714858035097, 0.8745969993546522, -0.30914205743724227, -0.2661525701319988, -0.2252810378692945, -0.15847741490187478, -0.3178974483660676, -0.2699601156745398, -0.22743622748073072, -0.1594885572494545, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10935562243309105, 0.10935581775817278, 0.10600466855670217, 0.10024226205258298, 0.8603213469486253, 0.02502502502502501, 0.1462977323287086, -0.5715715715715713, 0.6265012009607687], "score_NOT Homogeneous_10D": 0.20516979694366455, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 5.909515975361728e-07], [4, [0.00044444444444512003, 3.9668888888888807], 0.0010851823458559416], [4, [0.00044444444444512003, -3.9668888888888802], 0.0010851823458559442], [2, [1.4786666666666668, 0.00044444444444512003], 0.460525074482265], [2, [1.4786666666666668, 3.9668888888888807], 0.4616096658765234], [2, [1.4786666666666668, -3.9668888888888802], 0.4616096658765234], [2, [-1.4786666666666664, 0.00044444444444512003], 0.46052507448226465], [2, [-1.4786666666666664, 3.9668888888888807], 0.4616096658765231], [2, [1.4785842086777876, -1.5773792672942717], 0.4997217511093621], [2, [-1.4786666666666664, -3.9668888888888802], 0.4616096658765231], [2, [-1.4786535312413838, 1.5773985598522011], 0.49972786696286237], [2, [-1.4781279891616335, -1.5773736714628204], 0.4997235917465814], [2, [1.4788532309351063, 1.5773945319155345], 0.4997257853527617], [6, [2.655777777777792, 0.00044444444444512003], 0.00019392908870483584], [6, [2.655777777777792, 3.9668888888888807], 0.0012785204829632412], [6, [2.655777777777792, -3.9668888888888802], 0.0012785204829632438], [6, [-2.655777777777791, 0.00044444444444512003], 0.0001939290887048406], [6, [-2.655777777777791, 3.9668888888888807], 0.001278520482963246], [6, [-2.655777777777791, -3.9668888888888802], 0.0012785204829632486], [6, [-2.652059888012447, 1.5775755031949903], 0.039521354797346885], [4, [-0.005273573952979083, 1.5775798060550041], 0.03931084688711485], [6, [-2.6520601517631968, -1.5775747624545253], 0.03952109798671027], [4, [-0.005273286424427825, -1.5775784617520496], 0.039310390367128786], [6, [2.6520603274595285, -1.577573782135828], 0.039520763431171085], [6, [2.6540585283684264, 1.577644814686977], 0.03949742346112358]], "nr_of_basins": 25, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.538920781456938e-162, -8.481694964330241e-163], "f_opt_dim_5": 0.0440048234202933, "x_opt_dim_5": [2.852281016649457, 1.0165602390969745e-10, 2.604937720053194e-10, 1.18891170510625e-10, -2.4479587805682005e-10]}
{"id": "ca4ae0ed-5fb2-4d33-b502-96424327530a", "fitness": 0.8761791537205378, "name": "landscape_nh_phase_enhanced2", "description": "A more non-homogeneous, separable benchmark with per-dimension phase transitions. Each dimension has its own two thresholds and transition sharpness, plus dimension-specific scaling of the regime contributions to create a highly non-uniform search space while preserving separability. Global optimum remains at the origin with value 0.", "code": "import numpy as np\n\nclass landscape_nh_phase_enhanced2:\n    def __init__(self, dim=5, seed=None):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"Dimension must be positive.\")\n        # RNG for reproducibility of per-dimension non-homogeneity\n        self.seed = int(seed) if seed is not None else 12345\n        self.rng = np.random.default_rng(self.seed)\n\n        # Per-dimension phase-transition thresholds (two levels -> three regimes)\n        # The values vary by dimension to enforce non-homogeneity\n        self.t1 = self.rng.uniform(0.5, 1.0, size=self.dim)   # inner -> mid\n        self.t2 = self.rng.uniform(1.5, 3.0, size=self.dim)   # mid -> outer\n\n        # Transition sharpness (per-dimension)\n        self.k1 = self.rng.uniform(3.5, 8.0, size=self.dim)\n        self.k2 = self.rng.uniform(3.5, 8.0, size=self.dim)\n\n        # Per-dimension curvature/coefficient terms\n        # Inner (near-origin) quadratic coefficient\n        self.a_quad0 = self.rng.uniform(0.4, 1.0, size=self.dim)\n        # Middle regime (enhanced) quadratic coefficient\n        self.a_quad1 = self.rng.uniform(0.9, 1.8, size=self.dim)\n        # Outer regime quartic coefficient\n        self.a_quartic = self.rng.uniform(0.2, 0.7, size=self.dim)\n\n        # Per-dimension overall scale to further break homogeneity\n        self.scale = self.rng.uniform(0.8, 1.25, size=self.dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        # Distance from origin per-dimension (absolute value to keep phase symmetry)\n        r = np.abs(x)\n\n        # Per-dimension smooth transitions\n        # u: inner -> mid transition\n        # v: mid -> outer transition\n        u = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        v = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        # Per-dimension regime contributions\n        inner = self.a_quad0 * (x ** 2)\n        mid   = self.a_quad1 * (x ** 2)\n        quart = self.a_quartic * (x ** 4)\n\n        # Three-regime blending (per-dimension, preserving separability)\n        #  - small |x|: inner quadratic\n        #  - intermediate |x|: mid quadratic\n        #  - large |x|: quartic growth\n        contrib = (1.0 - v) * ( (1.0 - u) * inner + u * mid ) + v * quart\n\n        # Apply per-dimension scale to amplify non-homogeneity\n        contrib *= self.scale\n\n        # Global minimum at x = 0, so f(0) = 0\n        return float(np.sum(contrib))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_phase_enhanced2 scored on:NOT Homogeneous 0.863, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8b938bce-d3cb-4a77-825c-375d72f6d29b"], "operator": null, "metadata": {"ela_features_2D": [-0.0025194661528797012, 0.22266283530118414, 0.007680469903909202, 0.024835783445274866, 7.71516895203519, 0.004615070012182043, 0.9061271518796845, 1.8248151560985881, 0.9069972563844717, 1.124181957098378, 0.6331771421522263, 1.4, 0.7044096999035662, 0.7096759597422491, 0.5660216807648066, 0.3487354539679824, -0.22774528576710473, 0.1449933349851305, 0.23128114181153073, 0.3192792823102234, 0.4930090853383087, 0.1466652915541317, 0.2290836164845404, 0.3201438166368444, 0.4944280764657907, -0.4472656385475875, -0.4021217087260453, -0.35608794014358414, -0.2652068995437779, -0.4383398328258087, -0.39599019649384326, -0.34920920513898396, -0.25967237351076994, 1.0, 1.0, 1.0, 1.0, 0.5243398701282637, 0.5243287566144994, 0.40973394746474545, 0.3549459239588029, 0.6073095038109064, 0.6696696696696696, 0.3960388848618657, -0.13113113113113112, 0.38353413654618473], "score_NOT Homogeneous_2D": 0.8936905711889267, "score_Separable_2D": 1.0, "ela_features": [-0.0009817364627851878, 0.3023822404045385, 0.002544196678179349, 0.02521494734049015, 15.787192902483056, 0.005785018798095809, 0.9146501247694385, 1.5814865098464865, 0.9151105931615182, 0.66177689835694, 0.20337997762716756, 1.4, 0.910158190452834, 0.8727105386425649, 0.6293035424985582, 0.18553624662434015, -0.5019119617171379, 0.4504981215678628, 0.5329415799136042, 0.6062503845838496, 0.7266630841226448, 0.4482440609262153, 0.5345224895815631, 0.607889970867449, 0.7290435162103489, -0.483293175452835, -0.4107828210029771, -0.346305922797514, -0.2404025052442221, -0.48773233411778705, -0.41146583146034094, -0.34660839549914924, -0.23951567941072865, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21525821641873524, 0.2152810332303669, 0.19971966922351925, 0.18138104986850906, 0.833083242427794, 0.26126126126126115, 0.29640741456911, -0.2952952952952952, 0.5381410256410256], "score_NOT Homogeneous_5D": 0.49988603591918945, "score_Separable_5D": 1.0, "ela_features_10D": [-0.000274855502087612, 0.3426412453932504, 0.0007594135324455622, 0.020700277429476138, 191.6780458940227, 0.005200227703395899, 0.9139994103910727, 2.4300241884833165, 0.9149295062342387, 0.4851477329418238, 0.08031759154568822, 1.2, 1.0031303638022968, 0.9367830902862238, 0.6910661312224041, 0.10745624523063055, -0.6019148935741907, 0.6362220433464941, 0.6979044292687309, 0.7487549699284364, 0.8219221793985693, 0.6386826064794004, 0.7002704100062734, 0.7514300994495986, 0.8255707437443869, -0.46137548730138134, -0.3831439504935472, -0.3186511549555366, -0.22585402524419745, -0.45951158816748655, -0.38118527138668823, -0.316122309570223, -0.22183289018326607, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1095301187340739, 0.10952843145883362, 0.10619735543078734, 0.09993957852419633, 0.8604053154138123, -0.05905905905905908, 0.1397852459208625, -0.6116116116116114, 0.6087269815852683], "score_NOT Homogeneous_10D": 0.8634983152151108, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.962427915680778e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-4.305909629731327e-164, 3.999450044490771e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.879004603851925e-162, -4.1953292999397786e-163, 1.1856053071508286e-163, 3.5551934198748595e-164, 1.777296224450338e-163]}
{"id": "cc06e505-e4d6-4eb3-ae14-2d3e6ff96935", "fitness": 0.8954155194805935, "name": "landscape_piecewise_nonhomogeneous", "description": "A completely different separable, non-homogeneous landscape with per-dimension piecewise phases. Each dimension has its own inner threshold, middle oscillatory region, and outer high-order growth, ensuring non-homogeneous structure across dimensions while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_piecewise_nonhomogeneous:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension parameters to create non-homogeneous phase transitions\n        # h: threshold for inner quadratic region (|x| <= h)\n        # m: threshold for switching to outer high-order growth\n        # a: quadratic region coefficient\n        # b: middle-region quadratic growth coefficient\n        # c: amplitude of oscillatory term in the middle region\n        # d: frequency of the oscillatory term in the middle region\n        # e: outer-region growth coefficient\n        # p: outer-region exponent (to create high-order growth)\n        self.h = np.zeros(self.dim, dtype=float)\n        self.m = np.zeros(self.dim, dtype=float)\n        self.a = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.c = np.zeros(self.dim, dtype=float)\n        self.d = np.zeros(self.dim, dtype=float)\n        self.e = np.zeros(self.dim, dtype=float)\n        self.p = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            ratio = i / max(1, self.dim - 1)  # in [0, 1]\n\n            # Staggered, non-homogeneous parameters across dimensions\n            self.h[i] = 0.25 + 1.25 * ratio         # thresholds in [0.25, 1.5]\n            self.m[i] = self.h[i] + 0.6 + 1.8 * ratio  # middle-to-outer switch, > h\n            self.a[i] = 0.6 + 0.7 * ratio            # quadratic coefficient\n            self.b[i] = 0.1 * self.a[i] + 0.15      # middle-region growth\n            f_in = self.a[i] * (self.h[i] ** 2)\n            self.c[i] = 0.15 * f_in                   # small oscillation amplitude\n            self.d[i] = 3.0 + 2.0 * ratio             # frequency in middle region\n            self.e[i] = 0.6 + 0.4 * ratio             # outer-region growth coefficient\n            # Exponent chosen to be integer for stability\n            self.p[i] = 3 if (i % 2) == 0 else 4\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        t = np.abs(x)  # use absolute value to keep the landscape symmetric and separable\n\n        # Precompute per-dimension base values\n        h = self.h\n        m = self.m\n        a = self.a\n        b = self.b\n        c = self.c\n        d = self.d\n        e = self.e\n        p = self.p\n\n        # Base inner value at threshold: f_in = a * h^2\n        f_in = a * (h ** 2)\n\n        # Initialize per-dimension function values\n        f_i = np.zeros(self.dim, dtype=float)\n\n        # Indices for regions\n        idx_inner = t <= h\n        idx_middle = (t > h) & (t <= m)\n        idx_outer = t > m\n\n        # Inner region: simple quadratic well\n        f_i[idx_inner] = a[idx_inner] * (x[idx_inner] ** 2)\n\n        # Middle region: oscillatory addition on top of rising parabola\n        if np.any(idx_middle):\n            t_mid = t[idx_middle]\n            h_mid = h[idx_middle]\n            a_mid = a[idx_middle]\n            b_mid = b[idx_middle]\n            c_mid = c[idx_middle]\n            d_mid = d[idx_middle]\n\n            # value at start of middle region\n            f_in_mid = f_in[idx_middle]\n            f_i[idx_middle] = f_in_mid + b_mid * ((t_mid - h_mid) ** 2) + \\\n                              c_mid * np.sin(d_mid * (t_mid - h_mid))\n\n        # Outer region: higher-order growth starting from the end of middle region\n        if np.any(idx_outer):\n            t_out = t[idx_outer]\n            m_out = m[idx_outer]\n            h_out = h[idx_outer]\n            a_out = a[idx_outer]\n            b_out = b[idx_outer]\n            c_out = c[idx_outer]\n            d_out = d[idx_outer]\n            e_out = e[idx_outer]\n            p_out = p[idx_outer]\n\n            # value at start of outer region (continuous with middle)\n            f_in_outer = f_in[idx_outer] + b_out * ((m_out - h_out) ** 2) + \\\n                         c_out * np.sin(d_out * (m_out - h_out))\n\n            f_i[idx_outer] = f_in_outer + e_out * ((t_out - m_out) ** p_out)\n\n        # Sum across dimensions to get global scalar objective\n        return float(np.sum(f_i))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_piecewise_nonhomogeneous scored on:NOT Homogeneous 0.507, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["82bd2d85-e148-4b41-987f-41e521f34894"], "operator": null, "metadata": {"ela_features_2D": [-0.002427261834695682, 0.2602874405654142, 0.0038517758509881692, 0.029015187241926792, 14.946108153045966, -0.00021807838986729334, 0.9255276077939276, 8.08927727114624, 0.9255891441699026, 1.2775022578107331, 0.5098969244378712, 1.2, 0.6253188726389087, 0.7001501482226431, 0.5214346069106678, 0.34730320648577273, -0.18541778656283533, 0.1804001064167538, 0.2673713929203975, 0.3478254639780183, 0.511068671358354, 0.1650649325449456, 0.24916638560995913, 0.33436738887007195, 0.5088151918365387, -0.42871947176685604, -0.3832200814014105, -0.3411343808240264, -0.2557424246844161, -0.4287323538494106, -0.3855325133317772, -0.34176981577880755, -0.2521854037494532, 1.0, 1.0, 1.0, 1.0, 0.5125145437119631, 0.5125002704672817, 0.37330013160264947, 0.34731360036490627, 0.6598799966783547, 0.7497497497497496, 0.1629398857719821, -0.3233233233233232, 0.3987951807228916], "score_NOT Homogeneous_2D": 0.9973869461100549, "score_Separable_2D": 1.0, "ela_features": [5.277777087555613e-05, 0.21495229341884858, 0.003943630560318666, 0.03218863466848682, 16.068594829167203, 0.00750761633851289, 0.8147457101995043, 15.541648895104007, 0.8185972649813067, 1.42112137735715, 1.6457358063243936, 1.6, 0.8763128383820525, 0.8677078824405935, 0.6154987468653741, 0.18860418130151949, -0.4360391679187951, 0.45651873115751906, 0.5439312245498119, 0.6138979060962819, 0.7539078511631733, 0.45385462559999884, 0.5416651309474936, 0.6110945236563263, 0.7484260098247015, -0.47799678852466787, -0.40111475119447304, -0.33957803500692274, -0.21643842666609397, -0.48270958936174246, -0.405089113929295, -0.3437227642920539, -0.22234456128417196, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21675725502925816, 0.21674748428639035, 0.19877992889660484, 0.18314175258880663, 0.7731224838723515, 0.4734734734734733, 0.18343636115741993, -0.37537537537537524, 0.5469551282051283], "score_NOT Homogeneous_5D": 0.8682536333799362, "score_Separable_5D": 1.0, "ela_features_10D": [0.0013990961628500553, 0.2221965574439039, 0.0005023970898700946, 0.027640086452778646, 88.02362341883942, 0.006604522102257792, 0.8148526371468849, 34.20312924006394, 0.8173513585321679, 1.1825331449185066, 1.1232727537627356, 1.6, 0.9505412394607828, 0.9289477500597247, 0.6676022749857509, 0.11170171948875837, -0.4936645032866546, 0.654667540593251, 0.7260195555481561, 0.7853492460667961, 0.8626663384843255, 0.6560539064624054, 0.7263561732699483, 0.7846689031519962, 0.8627708383403409, -0.4380075217208813, -0.34750706509177054, -0.2722551574424402, -0.17418900510573976, -0.43746022262020545, -0.34804316575729155, -0.27387564786873203, -0.17453908821152772, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10985672213593392, 0.10985772715008604, 0.10616560890088203, 0.10051363484302209, 0.8389776856059294, 0.06106106106106102, 0.11318791554013644, -0.6236236236236234, 0.6104883907125701], "score_NOT Homogeneous_10D": 0.50685253739357, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [-0.0003138645459348937, 3.586877016370113], 3.7729598865846152], [11, [0.00044444444444512003, 2.3957777777778206], 2.7228336924469234], [10, [-0.0002995148864626137, -2.3957678308047914], 2.7228336876251653], [40, [0.00044444444444512003, 0.00044444444444512003], 3.753086419764496e-07], [20, [-0.0002993646961083011, -3.586877030847503], 3.7729598812662526]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.211944179735388e-162, 1.0806223675602292e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.0095241165190761e-162, 8.421861632459476e-163, -1.4007723869648245e-162, -1.6219761203476515e-163, -7.136643751940143e-163]}
{"id": "5b213c46-7738-4da8-9471-5da91cd68d1c", "fitness": 0.5077536304791769, "name": "phase_transition_landscape_ext", "description": "A novel separable, highly non-homogeneous landscape with four-regime phase transitions per dimension. Each dimension has its own three thresholds (a, b, c) creating four regimes: inner quadratic, two middle regimes with distinct curvatures and ripples, and an outer high-order growth with ripples. The per-dimension parameters ensure diverse, non-uniform appearances across the search space, while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass phase_transition_landscape_ext:\n    \"\"\"\n    A separable, non-homogeneous landscape with four-regime phase transitions per dimension.\n\n    Each coordinate x_i has:\n      - an inner region: |x_i| <= a_i, with quadratic cost alpha_i * x_i^2\n      - a first middle region: a_i < |x_i| <= b_i, with cubic cost beta1_i * (|x_i|-a_i)^3 plus a ripple term\n      - a second middle region: b_i < |x_i| <= c_i, with quartic cost gamma2_i * (|x_i|-b_i)^4 plus a ripple term\n      - an outer region: |x_i| > c_i, with quintic cost gamma3_i * (|x_i|-c_i)^5 plus a ripple term\n\n    The parameters a_i, b_i, c_i and coefficients are per-dimension to ensure non-homogeneous structure\n    across dimensions. The global optimum is at x = 0 with value 0, and the problem is separable\n    (sum of per-dimension terms).\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=2021 + 7 * self.dim)\n\n        # Per-dimension phase boundaries (a < b < c) to induce non-homogeneity\n        self.a = rng.uniform(0.25, 0.9, size=self.dim)\n        self.b = rng.uniform(1.1, 2.8, size=self.dim)\n        self.b = np.maximum(self.b, self.a + 0.25)\n        self.c = rng.uniform(2.6, 4.8, size=self.dim)\n        self.c = np.maximum(self.c, self.b + 0.25)\n\n        # Inner region coefficient\n        self.alpha = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # First middle region (cubic) parameters\n        self.beta1 = rng.uniform(0.4, 2.0, size=self.dim)\n        self.omega1 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase1 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple1 = rng.uniform(0.0, 0.6, size=self.dim)\n\n        # Second middle region (quartic) parameters\n        self.gamma2 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega2 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase2 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple2 = rng.uniform(0.0, 0.7, size=self.dim)\n\n        # Outer region (quintic) parameters\n        self.gamma3 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega3 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase3 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple3 = rng.uniform(0.0, 0.8, size=self.dim)\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        inside1 = absx <= self.a\n        inside2 = (absx > self.a) & (absx <= self.b)\n        inside3 = (absx > self.b) & (absx <= self.c)\n        outer = absx > self.c\n\n        # Inner region: quadratic\n        val[inside1] = self.alpha[inside1] * (x[inside1] ** 2)\n\n        # First middle region: cubic growth with ripple\n        delta1 = absx[inside2] - self.a[inside2]\n        val[inside2] = (\n            self.beta1[inside2] * (delta1 ** 3) +\n            self.ripple1[inside2] * (np.sin(self.omega1[inside2] * delta1 + self.phase1[inside2]) ** 2)\n        )\n\n        # Second middle region: quartic growth with ripple\n        delta2 = absx[inside3] - self.b[inside3]\n        val[inside3] = (\n            self.gamma2[inside3] * (delta2 ** 4) +\n            self.ripple2[inside3] * (np.sin(self.omega2[inside3] * delta2 + self.phase2[inside3]) ** 2)\n        )\n\n        # Outer region: quintic growth with ripple\n        delta3 = absx[outer] - self.c[outer]\n        val[outer] = (\n            self.gamma3[outer] * (delta3 ** 5) +\n            self.ripple3[outer] * (np.sin(self.omega3[outer] * delta3 + self.phase3[outer]) ** 2)\n        )\n\n        return float(np.sum(val))", "configspace": "", "generation": 2, "feedback": "The optimization landscape phase_transition_landscape_ext scored on:NOT Homogeneous 0.000, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3fc53af3-c7a7-4010-8b0a-d97b6cb54e19"], "operator": null, "metadata": {"ela_features_2D": [-0.003151440726074073, 0.11895684563914306, 0.002757745179389472, 0.0198404429086435, 15.206721986895039, -0.0022308235490531734, 0.030467480221351796, 5.289836210497902, 0.029499163201430735, 2.403653751915015, 5.180217475401745, 2.6, 0.24991280085485812, 0.5754193864457494, 0.21753530145229066, 0.38598614171833656, -0.2636802351418101, 0.7973660984132601, 0.8411123175390463, 0.8954903750549208, 0.9130385431632704, 0.8246938333973709, 0.8257224393250688, 0.8829380740485743, 0.9018638772009904, -0.10600717118876508, -0.08312499260747806, -0.054677446072382216, -0.045493706425269384, -0.09003016977660833, -0.0894757034530305, -0.060109366275522345, -0.05038210440371745, 1.0, 1.0, 1.0, 1.0, 0.5138206139663609, 0.5137291556228154, 0.4086067943195159, 0.34789900437066307, 0.6910595033124088, 1.5465465465465469, 0.15067684653993524, -0.17917917917917917, 0.4835341365461847], "score_NOT Homogeneous_2D": 0.0003230571746826172, "score_Separable_2D": 1.0, "ela_features": [-0.0012779779444492823, 0.15484904280853212, 0.002276778646641519, 0.02121698827424446, 43.029884601694164, 0.004849024555518455, 0.45900427412547984, 3.940694557643981, 0.468826989919026, 1.7473399250359574, 3.382813215495952, 2.4, 0.6377313426738458, 0.8189279237957876, 0.4200489585364342, 0.22844592783508938, -0.43299994144115433, 0.7318959186649595, 0.7717089740726923, 0.8023131260173321, 0.8372903892996787, 0.7237616832661518, 0.7644492594362319, 0.7961299794895056, 0.833115352751809, -0.23586637618651282, -0.20083895999123696, -0.17391399637032123, -0.14314455684308883, -0.24427206538979923, -0.20828520323476435, -0.18027075229587158, -0.1475713512511741, 1.0, 1.0, 0.8333333333333334, 1.0, 0.217315230744219, 0.21732763830889373, 0.20427310309836844, 0.18241016634333637, 0.8202946646771722, 0.5055055055055053, 0.231211013746617, -0.3153153153153152, 0.6387820512820513], "score_NOT Homogeneous_5D": 0.04602473974227905, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0009000954528519456, 0.236416385998573, 0.0014214610228723689, 0.016866059215266835, 66.27183248720476, 0.000733895426893616, 0.2863863166183045, 1523.8102038811135, 0.2919682815414263, 1.1424980935784776, 1.5017822512499488, 2.4, 0.7282428368364944, 0.897036926565827, 0.5046533556190637, 0.14221509929019835, -0.508805224395485, 0.8926722916125837, 0.9149925986023202, 0.9248982893506795, 0.9407231475258284, 0.8928655962819094, 0.9158124499789937, 0.9242682871822983, 0.9402979980075296, -0.13611516701091725, -0.10780766493520444, -0.09524569662270847, -0.07517600603859162, -0.13621382206803948, -0.10704238746478958, -0.09629258474639704, -0.07590938915635718, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11043446451864895, 0.11043372116428754, 0.10747072355091, 0.10075288594057141, 0.8623060395662016, 0.08108108108108104, 0.14786665293858955, -0.5595595595595594, 0.6519615692554044], "score_NOT Homogeneous_10D": 0.00017398595809936523, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [-0.8215555555555556, 0.00044444444444512003], 0.10065172935148038], [4, [0.8215555555555556, 0.00044444444444512003], 0.10065172935148038], [3, [-0.8217234766261661, -3.7621782772441166], 0.10067432236841684], [4, [0.8217817833385112, 3.762371740799699], 0.10067438060499069], [3, [0.8215879627747406, -3.7613828813353396], 0.10067459303607573], [4, [-0.8218730034509559, 3.7607874252944344], 0.10067479994363682], [3, [0.8218576896982432, -1.3397921074174524], 0.11335766295444198], [3, [-0.8217955817835699, 1.341569048037112], 0.11335769886345234], [3, [-0.8222040516286196, -1.340040283917555], 0.1133574867253789], [4, [2.280853600794523, -1.3399793885174809], 0.07715332642362793], [4, [-2.2808543796630656, -1.340802467163763], 0.07715328282164467], [3, [0.8221129540449156, 1.3409478212523438], 0.1133573350010485], [2, [4.0948468002670815, -3.7517459787244167], 0.02888856443385149], [2, [4.093805332270395, -0.00044016717945665753], 0.028398284634896805], [2, [4.093699202042973, -1.339832328045731], 0.04106501185444171], [2, [-4.093700209535953, -1.3411102723515012], 0.041065209438683095], [2, [-0.11095090968211685, -1.3676334740932028], 0.027953220799484514], [2, [-0.03384036234426235, -3.940766284662457], 0.027378730450542805], [4, [-2.280853419792841, 1.3403102774736082], 0.07715319194175176], [4, [2.2808556969168037, 1.3401668474942678], 0.07715355375638278], [4, [-2.2818226651338303, 3.6611336987923955], 0.07211823699758159], [4, [2.281346239584859, -3.757863862444372], 0.06455127396289952], [4, [2.2814923759597385, 0.0023827673297094018], 0.06454408391281014], [2, [-4.094023054028079, -0.024528133241574192], 0.029219094680859835], [4, [2.2822621139076036, 3.6640108538629326], 0.07176391972229255], [2, [0.10570281866352552, 1.191365699045294], 0.028783387823194454], [2, [-4.093699366930146, -3.7457474841669693], 0.028577182001227705], [4, [-2.2816909997624504, -0.025473069631461655], 0.06536281987118803], [2, [-4.093700661669486, 1.3404312723332157], 0.041065356047023244], [2, [4.0936990722842115, 1.3397564290501074], 0.041065003572739275], [2, [4.095195504295236, 3.6574877811512025], 0.036998259744033396], [2, [-4.094529943736016, 3.6574739416640565], 0.036750050852322205], [4, [-2.2812709246422935, -3.7797390862188154], 0.06477578413586436]], "nr_of_basins": 33, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.017970151379912e-162, -1.500314151292917e-162], "f_opt_dim_5": 0.03995252373777579, "x_opt_dim_5": [1.3032754789449374e-10, -2.369386843346875, 9.453529377446554e-10, -2.900277712923668e-10, -0.6938302523024752]}
{"id": "9aa4df4e-65fe-47c4-a667-d4acf4800937", "fitness": 0.8247926061352094, "name": "landscape_nonhomogeneous_multi_phase", "description": "A novel separable, non-homogeneous benchmark landscape with per-dimension multi-phase transitions. Each dimension has its own inner, middle, and outer regimes defined by dimension-specific thresholds and sharpness, plus a small, zero-at-origin ripple in the outer regime to enhance non-homogeneity. The global minimum is at x = 0 with value 0, and the landscape remains separable across dimensions.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_multi_phase:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension non-homogeneous phase-transition parameters\n        i = np.arange(self.dim, dtype=int)\n\n        # Thresholds for inner->mid and mid->outer transitions (phase boundaries)\n        # Ensure t1 < t2 and vary across dimensions to create non-homogeneous appearance\n        self.t1 = 0.6 + 0.25 * (i % 8)          # range roughly [0.6, 2.95]\n        self.t2 = 2.0 + 0.28 * ((i * 3) % 7)    # range roughly [2.0, 3.68]\n\n        # Transition sharpness per-dimension\n        self.k1 = 4.0 + (i % 6) * 0.6              # inner->mid smoothness\n        self.k2 = 5.0 + ((i * 2) % 5) * 0.8        # mid->outer smoothness\n\n        # Per-dimension curvature coefficients (separable contributions)\n        self.a0 = 0.4 + (i % 7) * 0.1                 # inner quadratic coefficient\n        self.a1 = self.a0 * 1.6                       # middle (higher curvature) quadratic\n        self.a2 = 0.03 + 0.02 * (((i + 3) % 6))     # outer quartic coefficient\n\n        # Per-dimension ripple in the outer regime (non-homogeneous feature)\n        # Amplitude and frequency vary per dimension\n        self.A = 0.05 + ((i * 5) % 4) * 0.02           # ripple amplitude\n        self.F = 1.0 + ((i * 11) % 7) * 0.6             # ripple frequency\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        # Absolute distance from origin per-dimension\n        r = np.abs(x)\n\n        # Logistic-like transitions for each dimension\n        # u1: inner -> mid, centered at t1\n        # u2: mid -> outer, centered at t2\n        u1 = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        u2 = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        # Per-dimension base shapes (separable)\n        inner = self.a0 * (x ** 2)\n        mid   = self.a1 * (x ** 2)\n        outer = self.a2 * (x ** 4)\n\n        # Outer regime ripple that vanishes at the origin to preserve the global minimum\n        # ripple_i = A_i * (1 - cos(F_i * x_i)) / 2  would be nonzero at 0 if used directly,\n        # so we instead use a cosine-based ripple that is zero at x=0 via sin-like shaping.\n        # We choose a form that keeps ripple zero at x=0: ripple = A_i * (1 - cos(F_i * x_i)) / 2\n        ripple = self.A * (1.0 - np.cos(self.F * x)) / 2.0\n\n        # Three-phase sequestered blend:\n        # - near origin (r < t1): inner quadratic\n        # - middle region (t1 <= r < t2): mid quadratic\n        # - outer region (r >= t2): outer quartic, enhanced by ripple\n        val_per_dim = (1.0 - u1) * inner + (u1 - u2) * mid + u2 * (outer + ripple)\n\n        return float(np.sum(val_per_dim))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nonhomogeneous_multi_phase scored on:NOT Homogeneous 0.610, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8b938bce-d3cb-4a77-825c-375d72f6d29b"], "operator": null, "metadata": {"ela_features_2D": [-0.0025117794644235135, 0.22299492342160518, 0.015978021385131148, 0.021694503830550778, 1.6647745627234642, 0.0024390888357853635, 0.9149159854549112, 1.2212380969948047, 0.9154509389660335, 1.0532094181311513, 0.586951898049113, 1.6, 0.7122639411555227, 0.7178852361193441, 0.5534621592195218, 0.34108198985429017, -0.23041788736730262, 0.13704995251795965, 0.22216164008455141, 0.3073836533516475, 0.4897583560409927, 0.14036704801522307, 0.22934660703763526, 0.30808117012131375, 0.4908434664523914, -0.4514481215137195, -0.4069235098384751, -0.36233871363996634, -0.2669263637238513, -0.44146420253056834, -0.39577065012508417, -0.3553321460979639, -0.26145879855033927, 1.0, 1.0, 1.0, 1.0, 0.5225121940244127, 0.5225073751036473, 0.41299685623199744, 0.35394479091397457, 0.61969119786799, 0.6616616616616615, 0.18148176124834187, -0.1511511511511511, 0.3887550200803213], "score_NOT Homogeneous_2D": 0.7730436474084854, "score_Separable_2D": 1.0, "ela_features": [-8.676843768768982e-05, 0.26422271875401493, 0.003599035371982186, 0.025643440336047697, 10.098660289271997, 0.007370209820312645, 0.9001458333831769, 4.517053256434677, 0.9006290430940315, 0.8138357438908768, 0.4045840445034378, 1.6, 0.8892134532438225, 0.8694489833323573, 0.6307638342084749, 0.1855614315236102, -0.48797862483771903, 0.4472924959021423, 0.5341307834017966, 0.6112537558480131, 0.7390231396204354, 0.4433975346465922, 0.5314673746637886, 0.6097679924731372, 0.7385966355157094, -0.4862284199962016, -0.40983420011981286, -0.3419873173882871, -0.22958505144115646, -0.4921644781732131, -0.4142887678768757, -0.34505232079043785, -0.2311364065498745, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21693881922317484, 0.21694110473034006, 0.20353379481159256, 0.18329054681978388, 0.8108140024387609, 0.2772772772772772, 0.22855700892626318, -0.35535535535535523, 0.5495192307692308], "score_NOT Homogeneous_5D": 0.566191166639328, "score_Separable_5D": 1.0, "ela_features_10D": [0.0003380124737757839, 0.3348333431449839, 0.0015168398997880473, 0.020738168762069065, 23.35761060358187, 0.006839149023785618, 0.9096413296345812, 4.677254455613669, 0.9110781944389021, 0.5249248834790546, 0.056422888927137295, 1.6, 0.9940317777176164, 0.9342833504365773, 0.6925397882980353, 0.10933351675087422, -0.5835829722918519, 0.649566728389707, 0.7060969128508233, 0.7567194431377958, 0.8291300274322639, 0.6514248187735576, 0.7078854888570233, 0.7586382667547327, 0.8310173909958362, -0.44442696805750553, -0.37273438958803784, -0.3085337616321537, -0.21670148042758525, -0.44320975728633777, -0.3714223163738706, -0.30689005146925896, -0.21486135954248695, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11097680256915043, 0.11097496784327479, 0.10786575079076806, 0.10099347678868031, 0.8641510804829526, -0.05905905905905904, 0.13468137661023785, -0.6236236236236234, 0.6135308246597277], "score_NOT Homogeneous_10D": 0.609520822763443, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.828881595539243e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.696461172441772e-162, -2.5611310109372624e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [7.767145150203073e-163, -3.408858056591928e-163, 1.0493324543749804e-162, 1.0790518947385042e-162, -1.3782798390703262e-162]}
{"id": "4c035a1e-8ccc-4709-9d1f-f38936d3db9e", "fitness": 0.8528636743625005, "name": "landscape_nh_phase_two_enhanced", "description": "A novel, highly non-homogeneous separable landscape with per-dimension phase transitions across two regimes. Each dimension has its own transition thresholds, curvature scales, and an outer-region ripple, creating a non-uniform search space while preserving separability. Global optimum remains at the origin with value 0.", "code": "import numpy as np\n\nclass landscape_nh_phase_two_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        indices = np.arange(self.dim, dtype=float)\n\n        # Per-dimension, non-homogeneous phase boundaries (two transitions)\n        # t1: inner -> mid boundary, t2: mid -> outer boundary\n        t1 = 0.6 + 0.25 * (indices % 4) + 0.1 * np.sin(indices)\n        t1 = np.clip(t1, 0.2, 4.0)\n\n        t2 = 1.7 + 0.25 * ((indices * 5) % 6) + 0.1 * np.cos(indices * 1.3)\n        t2 = np.maximum(t2, t1 + 0.25)\n\n        # Per-dimension transition sharpness (logistic blending)\n        k1 = 6.0 + 2.0 * np.sin(indices)\n        k2 = 6.0 + 2.0 * np.cos(indices * 0.7)\n\n        # Per-dimension curvature scalings (non-homogeneous)\n        a_quad0 = 0.4 + 0.6 * (indices / max(1.0, self.dim - 1))       # inner quadratic\n        a_quad1 = a_quad0 * (1.25 + 0.5 * (indices % 3))                 # middle (higher curvature)\n        a_quartic = 0.16 + 0.08 * ((indices * 4) % 5) / 4.0          # outer quartic growth\n\n        # Per-dimension outer-region ripple (to break smoothness in a separable way)\n        ripple_amp = 0.04 + 0.018 * (indices % 4)\n        ripple_freq = 0.5 + 0.3 * (indices % 7)\n\n        self.t1 = t1\n        self.t2 = t2\n        self.k1 = k1\n        self.k2 = k2\n        self.a_quad0 = a_quad0\n        self.a_quad1 = a_quad1\n        self.a_quartic = a_quartic\n        self.ripple_amp = ripple_amp\n        self.ripple_freq = ripple_freq\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)\n\n        # Per-dimension smooth phase blending (inner -> mid -> outer)\n        # u: inner->mid, v: mid->outer\n        u = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        v = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        inner = self.a_quad0 * (x ** 2)\n        mid = self.a_quad1 * (x ** 2)\n        quart = self.a_quartic * (x ** 4) + self.ripple_amp * np.sin(self.ripple_freq * x)\n\n        val = (1.0 - v) * ( (1.0 - u) * inner + u * mid ) + v * quart\n\n        return float(np.sum(val))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_phase_two_enhanced scored on:NOT Homogeneous 0.637, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["8b938bce-d3cb-4a77-825c-375d72f6d29b"], "operator": null, "metadata": {"ela_features_2D": [-0.00233947328370705, 0.22294525871105653, 0.008446262131608998, 0.025911394869971, 4.3146137685298225, -0.0018162991798651885, 0.9109352242866692, 1.476262243036506, 0.9118924128479607, 0.9777069495301133, 0.2981912181028556, 1.2, 0.7076793687116922, 0.7194458860977522, 0.5620492179152727, 0.3375252778157595, -0.23619083951995318, 0.15759180838425907, 0.249050916322504, 0.3344609353559621, 0.5041700139002532, 0.1534620166223473, 0.24620216861690744, 0.32875112681551494, 0.5054824668999099, -0.44093695997032023, -0.39306073641417727, -0.3483543536156546, -0.259522686025505, -0.43578859710273576, -0.3880390505921927, -0.3455385506812244, -0.2545519278982232, 1.0, 1.0, 1.0, 1.0, 0.5095111792633101, 0.5094617852241887, 0.4080985849322765, 0.34657264542742866, 0.6408030177001092, 0.6536536536536535, 0.33055646628944285, -0.07907907907907906, 0.3795180722891566], "score_NOT Homogeneous_2D": 0.8412082195281982, "score_Separable_2D": 1.0, "ela_features": [-0.0017817254854341157, 0.28038303538417547, 0.004033871279190566, 0.017634346409323383, 4.63617211491749, 0.001143573085866456, 0.9133528970569149, 1.4797318243671487, 0.9139638290513659, 0.6505408833852598, 0.2476381765875743, 2.2, 0.9127985527049619, 0.8757251679316665, 0.647336131420096, 0.18261247481643192, -0.5019355903075029, 0.43310615470273417, 0.5233798015899118, 0.6030475216140778, 0.7270059784955432, 0.43227254850165614, 0.5271252251078711, 0.6058596812735624, 0.7304577533624297, -0.4985969148785462, -0.4191957099263213, -0.3491263798716265, -0.24010264255112962, -0.5018068460865427, -0.41795598385032423, -0.34835638010415815, -0.23823208935782736, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2153019462625791, 0.2153222037599042, 0.20163429388532647, 0.18039071801115886, 0.8267226415092355, 0.23723723723723716, 0.2717524461410457, -0.3353353353353353, 0.5479166666666666], "score_NOT Homogeneous_5D": 0.6394001543521881, "score_Separable_5D": 1.0, "ela_features_10D": [0.000543592286463257, 0.3592880270776819, 0.0013503657926126921, 0.0202374336426841, 66.95864766422565, 0.009957563236787204, 0.9121347694255295, 1.5541040380476883, 0.9133139057731823, 0.4625376544361014, 0.0969972252906877, 2.0, 1.0058372668498792, 0.9355918279747801, 0.6830004658670982, 0.10923569322722337, -0.5982735599384859, 0.6382330225678138, 0.6962086442387179, 0.7465653579685617, 0.8210371122592264, 0.6424119362874539, 0.6978426837144919, 0.7493680733988454, 0.8246250573749292, -0.45883544711410024, -0.38530342377225735, -0.3214349356374998, -0.22698102256219888, -0.4547489980656453, -0.38425653841790125, -0.3187301039242375, -0.22302455679291655, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11126245869034553, 0.11125773854890653, 0.10820654678681493, 0.10198450739870624, 0.8654814476143642, -0.06706706706706708, 0.13869099707644375, -0.6356356356356354, 0.6112089671737391], "score_NOT Homogeneous_10D": 0.6365736722946167, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [3.2863989307685415e-13, 3.2863989307685415e-13], 3.666575429516755e-21]], "nr_of_basins": 1, "f_opt_dim_2": -7.715795580358881e-17, "x_opt_dim_2": [-1.3842718646739333e-08, -4.27533880005471e-12], "f_opt_dim_5": -1.0336463124399718e-11, "x_opt_dim_5": [-1.384272855388059e-08, -7.780105406002803e-12, -3.782575541323177e-09, -5.449074178031444e-07, -3.0770480548062445e-06]}
{"id": "87608efa-b841-4d9d-be89-8dd67a4a1945", "fitness": 0.8816710089643797, "name": "tiered_exponential_landscape", "description": "A completely different, non-homogeneous, separable landscape with three non-uniform regimes per dimension. Each dimension has an inner quadratic region, a middle region with linear-plus-ripple behavior, and an outer region with an exponential-plus-ripple growth. Phase boundaries vary across dimensions to create a highly non-homogeneous search space, while the problem remains separable and the global minimum is at the origin.", "code": "import numpy as np\n\nclass tiered_exponential_landscape:\n    \"\"\"\n    A separable, non-homogeneous landscape with three regimes per dimension.\n\n    Per dimension i (x_i):\n      - Inner region: |x_i| <= a_i -> quadratic cost k_i * x_i^2\n      - Middle region: a_i < |x_i| <= b_i -> k_i * a_i^2\n                                        + m_i * (|x_i| - a_i)\n                                        + ripple_mid_i * ( sin(t_mid_i*(|x_i| - a_i) + phase_mid_i)^2 - sin(phase_mid_i)^2 )\n      - Outer region: |x_i| > b_i -> boundary_at_b_i\n                                        + gamma_outer_i * (|x_i| - b_i)^(p_exp_i)\n                                        + ripple_outer_i * ( cos(t_outer_i*(|x_i| - b_i) + phase_outer_i)^2 - cos(phase_outer_i)^2 )\n\n    All phase boundaries are dimension-specific, ensuring a non-homogeneous search space.\n    The global minimum is at x = 0 with value 0, and the landscape is separable.\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=202425 + self.dim)\n\n        # Inner and outer region boundaries (per-dimension)\n        self.a = rng.uniform(0.25, 1.6, size=self.dim)       # inner threshold\n        self.b = rng.uniform(2.0, 4.8, size=self.dim)        # outer threshold\n        self.b = np.maximum(self.b, self.a + 0.2)            # ensure a < b\n\n        # Inner quadratic coefficient\n        self.k = rng.uniform(0.5, 2.0, size=self.dim)\n\n        # Middle region linear growth and ripple\n        self.m = rng.uniform(0.8, 3.0, size=self.dim)        # linear slope in middle\n        self.r_mid = rng.uniform(0.0, 0.8, size=self.dim)     # ripple amplitude in middle\n        self.t_mid = rng.uniform(0.5, 3.0, size=self.dim)     # ripple frequency\n        self.phase_mid = rng.uniform(0.0, 2*np.pi, size=self.dim)\n\n        # Precompute sin(phi)^2 for continuity at a\n        self.sin_phase_mid_sq = np.sin(self.phase_mid) ** 2\n\n        # Outer region exponential growth and ripple\n        self.gamma_outer = rng.uniform(0.3, 1.8, size=self.dim)   # outer growth coefficient\n        self.p_exp = rng.uniform(1.5, 3.0, size=self.dim)           # outer exponent\n        self.r_outer = rng.uniform(0.0, 0.6, size=self.dim)         # outer ripple amplitude\n        self.t_outer = rng.uniform(0.5, 3.0, size=self.dim)         # outer ripple frequency\n        self.phase_outer = rng.uniform(0.0, 2*np.pi, size=self.dim)\n\n        # Precompute cos(phase_outer)^2 for continuity at b\n        self.cos_phase_outer_sq = np.cos(self.phase_outer) ** 2\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        inside = absx <= self.a\n        middle = (absx > self.a) & (absx <= self.b)\n        outer = absx > self.b\n\n        # Inner region: quadratic\n        val[inside] = self.k[inside] * (x[inside] ** 2)\n\n        # Middle region: linear growth with a ripple, continued smoothly from inner\n        delta_mid = absx[middle] - self.a[middle]\n        # Ensure continuity at a: value at boundary equals k*a^2\n        middle_value = (\n            self.k[middle] * (self.a[middle] ** 2)\n            + self.m[middle] * delta_mid\n            + self.r_mid[middle] * (\n                np.sin(self.t_mid[middle] * delta_mid + self.phase_mid[middle]) ** 2\n                - self.sin_phase_mid_sq[middle]\n            )\n        )\n        val[middle] = middle_value\n\n        # Outer region: exponential growth with an outer ripple, continuing from middle\n        delta_outer = absx[outer] - self.b[outer]\n        # Boundary value at b to ensure continuity with middle\n        boundary_outer = (\n            self.k[outer] * (self.a[outer] ** 2)\n            + self.m[outer] * (self.b[outer] - self.a[outer])\n            + self.r_mid[outer] * (\n                np.sin(self.t_mid[outer] * (self.b[outer] - self.a[outer]) + self.phase_mid[outer]) ** 2\n                - self.sin_phase_mid_sq[outer]\n            )\n        )\n\n        outer_term = (\n            boundary_outer\n            + self.gamma_outer[outer] * (delta_outer ** self.p_exp[outer])\n            + self.r_outer[outer] * (\n                np.cos(self.t_outer[outer] * delta_outer + self.phase_outer[outer]) ** 2\n                - self.cos_phase_outer_sq[outer]\n            )\n        )\n        val[outer] = outer_term\n\n        total = float(np.sum(val))\n        return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape tiered_exponential_landscape scored on:NOT Homogeneous 0.497, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3fc53af3-c7a7-4010-8b0a-d97b6cb54e19"], "operator": null, "metadata": {"ela_features_2D": [-0.00210632742331609, 0.5318963648446535, 0.00866153043840622, 0.03013463332697683, 3.5592295896625523, -0.0038790032608870817, 0.8952764345750317, 1.28999910850205, 0.8955413663761039, -0.05031507043180653, -0.7417518086220161, 1.2, 0.6966143182173521, 0.7084692335069752, 0.556488063030089, 0.34587242003794694, -0.182827491310143, 0.15151664363850298, 0.22682430435669682, 0.32437527258588916, 0.49517793654184317, 0.15588531857138568, 0.2278908408401465, 0.3214851718646151, 0.4976547459799786, -0.4438944354624376, -0.40449288242408504, -0.3534578597457462, -0.26410171925970916, -0.4339006814823219, -0.3968765813480457, -0.3487640578437857, -0.2582107620076452, 1.0, 1.0, 1.0, 1.0, 0.5081860989486527, 0.5081282214923469, 0.3768435992558589, 0.3490199604274843, 0.7254022080758808, 0.3613613613613612, 0.6752680119880381, -0.09909909909909911, 0.3710843373493976], "score_NOT Homogeneous_2D": 0.8671827614307404, "score_Separable_2D": 1.0, "ela_features": [0.0009559604834213254, 0.3798377933392673, 0.005391896424837448, 0.03075137323158387, 6.52766497184624, 0.0030536234151693044, 0.9513437887034986, 3.1380313748562108, 0.9513224237974871, 0.5091360561368082, -0.03736219831390697, 1.0, 0.8629494301684497, 0.8668898663244808, 0.6164333212531554, 0.18792367998641404, -0.4674659704138996, 0.49272956400085366, 0.5647568879578089, 0.6362300326352559, 0.7383657653235496, 0.4830952790867391, 0.5585902386170207, 0.6318284409235292, 0.7360877009393074, -0.446139479053714, -0.38279320853381565, -0.31993559867870136, -0.23010925467245008, -0.4568159323155978, -0.3900977987799883, -0.32538247265071235, -0.23324569438681966, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21714667022338677, 0.21712189559582992, 0.20299371829620033, 0.1838424654810536, 0.8284495477105533, 0.22522522522522515, 0.2526456936963485, -0.35935935935935925, 0.520673076923077], "score_NOT Homogeneous_5D": 0.9257007390260696, "score_Separable_5D": 1.0, "ela_features_10D": [0.0001003352687665826, 0.4805196980835711, 0.0013878376460672256, 0.02261577270009458, 30.983622375608093, 0.00020401722514049592, 0.8990363173511948, 2.8127082919146105, 0.8989806270344542, 0.02373262109794414, -0.14643777313305603, 1.6, 0.9758910867165419, 0.9328603417682283, 0.6868015292749827, 0.10832147195461417, -0.6070850560387944, 0.651965641957196, 0.7150432159604255, 0.7578552945400654, 0.8238619855901028, 0.653848982750571, 0.7157238384279703, 0.7590027682903349, 0.8263085454869514, -0.4413782042896405, -0.36138156306259034, -0.3070877069766395, -0.22337833625084186, -0.44015897541721516, -0.36147717879815294, -0.3064453914354668, -0.22086146166711512, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10894020976081231, 0.10893233540556808, 0.1060447132844757, 0.10003441661507088, 0.8580692536252321, -0.13113113113113112, 0.12877863710687065, -0.6356356356356354, 0.5871897518014412], "score_NOT Homogeneous_10D": 0.4971425533294678, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[20, [0.00044444444444512003, 3.8888888888888893], 8.504362541608993], [20, [0.00044444444444512003, -3.888888888888889], 8.504362541608993], [60, [0.00044444444444512003, 0.00044444444444512003], 5.770777129322518e-07]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1461781446253405e-162, 1.0479587863163938e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.0333850829865421e-162, 8.011251793286817e-164, -1.0191642503395206e-162, -4.8792319121437205e-163, -1.138893787195367e-162]}
{"id": "968d7bfb-eab0-4605-a96d-9c4e9fc4505c", "fitness": 0.9319878319899241, "name": "landscape_nh_four_region", "description": "A highly non-homogeneous, separable benchmark with four-region per-dimension phase transitions. Each dimension has its own non-uniform thresholds (a1, a2, a3) and region-specific curvature, plus a dimension-dependent outer-region ripple that is continuity-corrected to keep the origin as the global optimum. This creates strong non-homogeneity across the search space while preserving separability.", "code": "import numpy as np\n\nclass landscape_nh_four_region:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic, per-dimension heterogeneity\n        rng = np.random.default_rng(seed=2029 + self.dim)\n\n        # Per-dimension phase boundaries (four regions)\n        # Region 0: |x| <= a1 -> inner quadratic\n        self.a1 = rng.uniform(0.2, 0.9, size=self.dim)\n        # Region 1: a1 < |x| <= a2 -> higher curvature\n        self.a2 = rng.uniform(0.9, 2.4, size=self.dim)\n        self.a2 = np.maximum(self.a2, self.a1 + 0.25)\n        # Region 2: a2 < |x| <= a3 -> outer mid/high curvature\n        self.a3 = rng.uniform(1.9, 3.8, size=self.dim)\n        self.a3 = np.maximum(self.a3, self.a2 + 0.5)\n\n        # Region 0-2 curvature parameters\n        self.alpha1 = rng.uniform(0.4, 2.0, size=self.dim)  # inside a1\n        self.alpha2 = rng.uniform(0.8, 3.0, size=self.dim)  # between a1 and a2\n        self.alpha3 = rng.uniform(0.6, 3.5, size=self.dim)  # between a2 and a3\n\n        # Region 3 (outer) base growth parameter\n        self.beta = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # Outer-region ripple (ruggedness) parameters\n        self.gamma = rng.uniform(0.0, 0.6, size=self.dim)  # ripple amplitude\n        self.omega = rng.uniform(0.5, 3.0, size=self.dim)  # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim)  # ripple phase\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        # Region 0: inner quadratic\n        inside0 = absx <= self.a1\n        if np.any(inside0):\n            val[inside0] = self.alpha1[inside0] * (x[inside0] ** 2)\n\n        # Region 1: middle regime with higher curvature\n        region1 = (absx > self.a1) & (absx <= self.a2)\n        if np.any(region1):\n            idx = region1\n            val[idx] = (\n                self.alpha2[idx] * ((absx[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n\n        # Region 2: outer mid regime\n        region2 = (absx > self.a2) & (absx <= self.a3)\n        if np.any(region2):\n            idx = region2\n            val[idx] = (\n                self.alpha3[idx] * ((absx[idx] - self.a2[idx]) ** 2) +\n                self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n\n        # Region 3: outer rugged region with a ripple\n        region3 = absx > self.a3\n        if np.any(region3):\n            idx = region3\n            base3 = (\n                self.beta[idx] * ((absx[idx] - self.a3[idx]) ** 2) +\n                self.alpha3[idx] * ((self.a3[idx] - self.a2[idx]) ** 2) +\n                self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            # Continuity correction so the ripple is zero at the boundary a3\n            ripple = (\n                self.gamma[idx] * (np.sin(self.omega[idx] * (absx[idx] - self.a3[idx]) + self.phase[idx]) ** 2)\n                - self.gamma[idx] * (np.sin(self.phase[idx]) ** 2)\n            )\n            val[idx] = base3 + ripple\n\n        return float(np.sum(val))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_four_region scored on:NOT Homogeneous 0.882, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["142a822a-aa92-4aea-b8c1-5df68f83caaa"], "operator": null, "metadata": {"ela_features_2D": [-4.056123188884708e-05, 0.45498059027680304, 0.012453492016470759, 0.041979737828840964, 4.594791175132809, 0.0019474533366021785, 0.9323793776283248, 1.5440587769187268, 0.9325148690802278, 0.16786908983041435, -0.6688457868965043, 1.0, 0.7210373951153338, 0.7214802278108087, 0.5704268847143252, 0.3383911824618621, -0.19153937379316285, 0.14962527232235026, 0.2326388858656761, 0.325394497627041, 0.5097163307461351, 0.1490622096430026, 0.23111730770341912, 0.3277799122352293, 0.5080800524482368, -0.4448831991322718, -0.40145646959890885, -0.35292738785995886, -0.2564978694912539, -0.43796922587206516, -0.39574082436075975, -0.34598938691580894, -0.2531902022873961, 1.0, 1.0, 1.0, 1.0, 0.5183127666552344, 0.5183005073080866, 0.39380953858899825, 0.35905294895466955, 0.72343853481799, 0.48948948948948934, 0.5631843429518337, -0.09909909909909906, 0.3686746987951807], "score_NOT Homogeneous_2D": 0.7823708951473236, "score_Separable_2D": 1.0, "ela_features": [-0.0016658902793030394, 0.4642564044041495, 0.0006917001294713529, 0.021751638439662165, 39.43399650165979, 0.005021684433327067, 0.9417266782130203, 1.5398125213416318, 0.9414729578639112, 0.10783425482177704, -0.2098573304552324, 1.2, 0.887769524829882, 0.8699402398507313, 0.6351584911178316, 0.18449186292199823, -0.46961214053021305, 0.4534691512263997, 0.5394839120494707, 0.6158746368972664, 0.7281353269978383, 0.4511575954831062, 0.5373905518017408, 0.614926798520594, 0.7302269436419933, -0.480791627777893, -0.4051241497432951, -0.3379221827864817, -0.23916393051785173, -0.48530092791363905, -0.40905262141313425, -0.3404926139534553, -0.23853932271257744, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21481536286706432, 0.2147967254196225, 0.20181199419761958, 0.1815102228502386, 0.8289847890367337, 0.08108108108108103, 0.24959806701287784, -0.4074074074074073, 0.5054487179487179], "score_NOT Homogeneous_5D": 0.9275200590491295, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0014879621468363523, 0.46611774060843186, 0.0010653150827065149, 0.01620526537830952, 23.661131100033188, 0.004116635619819053, 0.9335055722499925, 2.3132109739103197, 0.9335499225783632, 0.13135205111645198, -0.12716119568898457, 1.0, 0.9933471581119317, 0.9355119728388275, 0.6994741814646691, 0.10659320053297383, -0.6036998539432477, 0.6487630339016772, 0.7024478037049366, 0.7478392440953626, 0.8192231164544201, 0.6517124617733592, 0.7039220440823836, 0.7506338628564191, 0.822670180190932, -0.44544551862839227, -0.37736129657341777, -0.31979487123485867, -0.2292644487498678, -0.4428217679292491, -0.37643956886989105, -0.31704821686913054, -0.2254596963744128, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1101075701372685, 0.11010978069301199, 0.10701331120249295, 0.10039308981044792, 0.8556820584182736, -0.11111111111111108, 0.13753545293958513, -0.6436436436436435, 0.5939151321056846], "score_NOT Homogeneous_10D": 0.8820360377430916, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[47, [0.00044444444444512003, 0.00044444444444512003], 6.510331118293907e-07], [11, [0.00044444444444512003, 3.372888888888946], 8.607720518959121], [14, [-2.8908888888889988, 0.00044444444444512003], 6.507168622211555], [18, [0.00044444444444512003, -3.3728888888889457], 8.607720518959121], [10, [2.892000000000232, 0.00044444444444512003], 6.507168328108789]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [7.080899111934265e-163, 8.683640889170855e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2366199552153497e-162, -5.52424086365889e-163, -1.5590494984417465e-162, 1.386558926945121e-162, -6.479111290815939e-163]}
{"id": "19db330f-d7a2-48ec-b7af-635ae9c12f0c", "fitness": 0.7905572081605593, "name": "landscape_three_phase_separable_nonuniform", "description": "A novel separable, non-homogeneous benchmark with three-phase per-dimension transitions. Each dimension has its own thresholds and curvature, creating phase-transition-like regions across the search space. The landscape sums independent per-dimension costs, blending an inner quadratic core, a middle high-curvature region with small sinusoidal ripples, and an outer high-growth region with additional ripples. This preserves separability (easy subproblem decomposition) while introducing non-homogeneity across dimensions. Global optimum at the origin with value 0.", "code": "import numpy as np\n\nclass landscape_three_phase_separable_nonuniform:\n    \"\"\"\n    Novel separable benchmark with three-phase per-dimension transitions.\n    Each dimension i has its own thresholds t1[i], t2[i] and curvature parameters,\n    producing non-homogeneous, phase-transition-like behavior while remaining\n    additive across dimensions (sum of per-dimension costs).\n    The per-dimension functions are designed to be nonnegative and vanish at x_i = 0,\n    ensuring a global optimum at the origin with value 0.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        idx = np.arange(self.dim)\n\n        # Per-dimension phase thresholds (non-homogeneous across dimensions)\n        # t1 in a range, t2 pushed further out to create 3 phases\n        self.t1 = 0.4 + (idx % 6) * 0.4  # values ~ [0.4, 2.0]\n        self.t2 = self.t1 + 0.8 + ((idx // 2) % 5) * 0.25  # values extended per-dim\n\n        # Logistic steepness per dimension (controls smoothness of phase transitions)\n        self.k = 1.2 + (idx % 4) * 0.6\n\n        # Per-dimension term coefficients (affecting the scale of each phase)\n        self.a_q = 0.5 + (idx % 3) * 0.2     # inner quadratic coefficient\n        self.a_m = 0.6 + (idx % 3) * 0.25    # middle-region curvature\n        self.a_out = 0.7 + (idx % 4) * 0.15  # outer-region growth\n\n        # Exponents for the middle and outer regions\n        self.p_mid = 2.0 + (idx % 3) * 0.25\n        self.p_out = 3.0 + (idx % 4) * 0.4\n\n        # Ripple parameters (kept small to ensure nonnegativity and stability)\n        self.r_mid_amp = 0.25  # amplitude of middle-region ripple (0.25 means 25%)\n        self.r_mid_freq = 0.8 + (idx % 5) * 0.3  # frequency for middle ripple\n\n        self.r_out_amp = 0.12  # amplitude of outer-region ripple\n        self.r_out_freq = 0.6 + (idx % 5) * 0.7  # frequency for outer ripple\n\n        # Optional global scale (kept at 1.0)\n        self.global_scale = 1.0\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the separable landscape at point x.\n\n        x: array-like of length self.dim, real-valued.\n        Returns: float, the sum of per-dimension costs (minimization objective).\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        di = np.abs(x)\n\n        # Phase weights using logistic transitions to create three regions per dimension\n        A = 1.0 / (1.0 + np.exp(self.k * (di - self.t1)))  # inner quadratic weight (dominant near origin)\n        B = 1.0 / (1.0 + np.exp(self.k * (di - self.t2)))  # combined middle+outer weight\n\n        w_q = A\n        w_m = B - A\n        w_out = 1.0 - B\n\n        # Per-dimension cost components (nonnegative, vanish at x_i = 0)\n        quad_term = self.a_q * (x ** 2)\n\n        mid_term = self.a_m * (di ** self.p_mid) * (1.0 + self.r_mid_amp * np.sin(self.r_mid_freq * di))\n\n        outer_term = self.a_out * (di ** self.p_out) * (1.0 + self.r_out_amp * np.sin(self.r_out_freq * di))\n\n        per_dim_cost = w_q * quad_term + w_m * mid_term + w_out * outer_term\n\n        return float(np.sum(per_dim_cost) * self.global_scale)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_three_phase_separable_nonuniform scored on:NOT Homogeneous 0.299, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fe2a5188-1eca-4673-8fd3-8c2e806f3e53"], "operator": null, "metadata": {"ela_features_2D": [-0.0032626552359103387, 0.2562532685414588, 0.0035431452616704238, 0.014037289364351304, 6.258064342527412, -0.0008134617135178823, 0.9356269561121142, 2.0750781749309852, 0.9356940907323013, 1.0787811828443075, 0.47816782479700626, 1.2, 0.7209925281070144, 0.7238435874191792, 0.5882266587174731, 0.3341294458340624, -0.22970394828476262, 0.1475056902290451, 0.23571844063518235, 0.3251656569681648, 0.5015187194032211, 0.1512522464582565, 0.23432152321803607, 0.3294400946286871, 0.5032666439021285, -0.4462255361361618, -0.4000497982853307, -0.3532266747024703, -0.26091616172165266, -0.43666017595463746, -0.39391519179276446, -0.3449757085174589, -0.25554638533970947, 1.0, 1.0, 1.0, 1.0, 0.5152325626509155, 0.5152091722918181, 0.3921702305136022, 0.34716106739919933, 0.6316914296713858, 0.7377377377377374, 0.4934184934065013, -0.05905905905905906, 0.35261044176706824], "score_NOT Homogeneous_2D": 0.8638616651296616, "score_Separable_2D": 1.0, "ela_features": [-2.7635537451020654e-05, 0.22404835152906472, 0.004945417835155182, 0.03121155629237677, 20.75781588344909, 0.002070857336465881, 0.8765717143371816, 11.94082129380761, 0.8777837003265644, 1.2486372342254985, 1.1756552690956266, 1.2, 0.8795590936960318, 0.8638170196590206, 0.6199125718300234, 0.19137612616446226, -0.44508204212363056, 0.44689427033666745, 0.536821470751873, 0.6255861757877168, 0.7587030436319626, 0.45034094962777116, 0.5353635174169239, 0.6225419383121593, 0.7540853334936981, -0.48657307266595656, -0.40746232853862097, -0.3293760789432289, -0.2122717088724902, -0.48608862472700476, -0.4108960644039025, -0.3338031624943426, -0.21747329002546487, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21674054636280707, 0.21672951177879565, 0.19919527881147703, 0.18207677818309403, 0.7759799278705202, 0.4094094094094093, 0.18706529448796866, -0.3633633633633632, 0.5229166666666666], "score_NOT Homogeneous_5D": 0.5799978077411652, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0006577622284342777, 0.2663976454119146, 0.0023769206057166876, 0.018402127718634677, 8.503299976904179, 0.0074665663518457045, 0.8945685500492966, 11.968285121256658, 0.8958059690268755, 0.7847225197473712, 0.30361080636851356, 1.4, 0.9726322911785082, 0.9327038675777892, 0.6757617712120864, 0.10978924298721857, -0.5412485709490034, 0.6584391218052161, 0.7208759023579042, 0.7735265037639123, 0.8502714667054713, 0.6607570647354303, 0.7221732831977407, 0.7742351523266217, 0.8510433167533513, -0.4331920048463941, -0.35400566737291955, -0.2872295894759113, -0.18989599795784934, -0.43143577021718976, -0.3533293680433401, -0.2871162903940917, -0.18943506662466328, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1103482304999627, 0.11034926718797462, 0.10680948858619961, 0.10058044275777918, 0.8478823619287317, -0.0030030030030030095, 0.13336644611160559, -0.5995995995995994, 0.600320256204964], "score_NOT Homogeneous_10D": 0.2994837760925293, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 1.9876657865797308e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1093463921787227e-162, 4.477012393950613e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [9.60975640670638e-163, 3.2381015750233116e-165, -6.384999616334808e-163, -7.390485979634721e-163, 3.5066002806603164e-163]}
{"id": "781babf0-7059-49c2-9a42-d2d2c3d9573e", "fitness": 0.8975180263320605, "name": "landscape_nh_phase_three_enhanced", "description": "A four-regime, highly non-homogeneous separable landscape with per-dimension phase transitions across inner quadratic, mid high-curvature with ripples, outer quartic growth with ripples, and far outer quintic growth with ripples. Each dimension has its own transition thresholds and curvature parameters to create a non-uniform search space while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_nh_phase_three_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        indices = np.arange(self.dim, dtype=float)\n\n        # Deterministic per-dimension non-homogeneous phase boundaries (three transitions -> four regimes)\n        # t1: inner -> mid boundary, t2: mid -> outer boundary, t3: outer -> far-outer boundary\n        t1 = 0.25 + 0.28 * (indices % 5) + 0.05 * np.sin(indices)\n        t1 = np.clip(t1, 0.15, 3.8)\n\n        t2 = 0.95 + 0.32 * ((indices * 3) % 7) + 0.08 * np.cos(indices * 0.7)\n        t2 = np.maximum(t2, t1 + 0.25)\n\n        t3 = 1.9 + 0.34 * ((indices * 5) % 6) - 0.1 * np.sin(indices * 1.2)\n        t3 = np.maximum(t3, t2 + 0.25)\n\n        # Per-dimension transition sharpness for each phase (logistic blending)\n        k1 = 6.0 + 1.0 * np.sin(indices)\n        k2 = 5.5 + 1.0 * np.cos(indices * 0.7)\n        k3 = 5.0 + 0.8 * np.sin(indices * 0.9)\n\n        # Per-dimension curvature scalings (non-homogeneous across dims)\n        a_quad0 = 0.20 + 0.28 * ((indices % 3) / 3.0)          # inner quadratic\n        a_quad1 = a_quad0 * (1.05 + 0.60 * ((indices % 4) / 4.0))  # middle (higher curvature)\n        a_quartic = 0.08 + 0.14 * ((indices * 5) % 4) / 4.0       # outer quartic growth\n        a_quintic = 0.04 + 0.02 * ((indices % 5) / 5.0)          # far-outer quintic growth\n\n        # Per-dimension ripple parameters (outer region ruggedness)\n        ripple1_amp = 0.02 + 0.04 * ((indices % 4) / 4.0)          # inner->mid ripple\n        ripple1_freq = 0.40 + 0.60 * ((indices % 7) / 7.0)         # frequency for sine in mid\n\n        ripple2_amp = 0.012 + 0.04 * ((indices % 5) / 5.0)         # mid->outer ripple\n        ripple2_freq = 0.45 + 0.60 * ((indices * 2) % 6) / 6.0\n\n        ripple3_amp = 0.008 + 0.03 * ((indices % 3) / 3.0)        # outer->far-outer ripple\n        ripple3_freq = 0.50 + 0.70 * ((indices * 3) % 8) / 8.0\n\n        self.t1 = t1\n        self.t2 = t2\n        self.t3 = t3\n        self.k1 = k1\n        self.k2 = k2\n        self.k3 = k3\n        self.a_quad0 = a_quad0\n        self.a_quad1 = a_quad1\n        self.a_quartic = a_quartic\n        self.a_quintic = a_quintic\n        self.ripple1_amp = ripple1_amp\n        self.ripple1_freq = ripple1_freq\n        self.ripple2_amp = ripple2_amp\n        self.ripple2_freq = ripple2_freq\n        self.ripple3_amp = ripple3_amp\n        self.ripple3_freq = ripple3_freq\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)\n\n        # Phase blending across three transitions (inner -> mid -> outer -> far-outer)\n        u12 = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        u23 = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n        u34 = 1.0 / (1.0 + np.exp(-self.k3 * (r - self.t3)))\n\n        # Regime definitions per dimension\n        inner  = self.a_quad0 * (x ** 2)\n        mid    = self.a_quad1 * (x ** 2) + self.ripple1_amp * np.sin(self.ripple1_freq * x)\n        outer1 = self.a_quartic * (x ** 4) + self.ripple2_amp * np.sin(self.ripple2_freq * x)\n        outer2 = self.a_quintic * (np.abs(x) ** 6) + self.ripple3_amp * np.sin(self.ripple3_freq * x)\n\n        # Sequential blending to create phase transitions\n        f12 = (1.0 - u12) * inner + u12 * mid\n        f23 = (1.0 - u23) * f12 + u23 * outer1\n        f34 = (1.0 - u34) * f23 + u34 * outer2\n\n        return float(np.sum(f34))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_phase_three_enhanced scored on:NOT Homogeneous 0.857, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c035a1e-8ccc-4709-9d1f-f38936d3db9e"], "operator": null, "metadata": {"ela_features_2D": [-0.002465470546374604, 0.15825019190793266, 0.010020846947166965, 0.02318783066294596, 2.737889979763538, -0.001538889904713825, 0.772302516671614, 1.0666157969566452, 0.7725669891043302, 1.3708655255529534, 1.3701316727165207, 1.4, 0.7267387406007402, 0.7171776002607546, 0.5599523630716213, 0.34599015338632544, -0.2649885630239283, 0.1337419344868366, 0.21234479681580729, 0.288668173759035, 0.48756726269832384, 0.1342685290301598, 0.21032916562660686, 0.28701907443574715, 0.48448734839314167, -0.45304153022553556, -0.41193433490599435, -0.3720151737421666, -0.26799365828923416, -0.4445916735372917, -0.4055398078221074, -0.36614562371783477, -0.2647357062183131, 1.0, 1.0, 1.0, 1.0, 0.5088977555064209, 0.5088827732953611, 0.40797387123945644, 0.34715381737596657, 0.5474703292711505, 0.7737737737737735, 0.7602176869712032, -0.05905905905905904, 0.3823293172690763], "score_NOT Homogeneous_2D": 0.9376307278871536, "score_Separable_2D": 1.0, "ela_features": [-0.0016936035715701791, 0.23724856019748852, 0.0031374024674860447, 0.019766295902815506, 8.96676807463927, 0.003164745245177758, 0.7944344449887248, 1.4817595925224767, 0.7978396109627767, 0.8974870422429551, 0.5770801996425213, 1.6, 0.8910864146810805, 0.8676094108300146, 0.6152502568919573, 0.1916803934719028, -0.5047284397486889, 0.46308159352420886, 0.5515650832037471, 0.6291561291527579, 0.740983943140803, 0.464840296680627, 0.5532593604635354, 0.6309509904348187, 0.7438418352003261, -0.4722613764151767, -0.3944331930564875, -0.326185957029568, -0.22782446886445334, -0.47298803410029766, -0.39484009131323816, -0.32617520135652106, -0.2263988184456795, 1.0, 1.0, 0.8333333333333334, 1.0, 0.219531107404047, 0.21952006149770834, 0.20355092628202365, 0.1849297829130499, 0.8144287659508196, 0.35735735735735724, 0.3122798481721075, -0.2432432432432432, 0.5612179487179487], "score_NOT Homogeneous_5D": 0.5901037752628326, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0015620052814714568, 0.27915966423695926, 0.0009688461561731504, 0.015672264454659145, 50.50890727397499, 0.004712409232311132, 0.7854403068669127, 1.4526611872665625, 0.7888332834894897, 0.6188978809071186, 0.3099838108104306, 1.4, 0.9814772089070283, 0.9360334456345001, 0.6737613348029814, 0.10855876862393135, -0.5949464294222034, 0.655770163897768, 0.7144581385186467, 0.7620940908710574, 0.8319186004160001, 0.6590480884153213, 0.7163546894180757, 0.7646113301965329, 0.8344549681938647, -0.43656644507343556, -0.3621356670095365, -0.30172189017501905, -0.2131677007604984, -0.43355240589883576, -0.36068115503531295, -0.2993181982305339, -0.2105058767869839, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11222192877605427, 0.1122193849271774, 0.10882023905208862, 0.10215208887969802, 0.8620248259071017, -0.02702702702702704, 0.1445897903392826, -0.5835835835835834, 0.6240992794235389], "score_NOT Homogeneous_10D": 0.8573736548423767, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-0.00355555555555488, -0.00044444444444512003], -2.818941279286689e-06]], "nr_of_basins": 1, "f_opt_dim_2": -2.8282332681243972e-06, "x_opt_dim_2": [-0.0037677519434224102, -0.0004875195386622746], "f_opt_dim_5": -2.8335148858497703e-06, "x_opt_dim_5": [-0.0037677519519459415, -0.00048751952461328267, -7.990879125791801e-05, -0.00011500925746776157, -2.412968748620372e-05]}
{"id": "619f9ca1-b90f-4b9f-bdc3-3ad337c63eea", "fitness": 0.885322684092292, "name": "landscape_piecewise_rugged_separable_enhanced", "description": "An enhanced non-homogeneous, separable benchmark with per-dimension multi-regime transitions. Each dimension has its own inner quadratic region, a middle curved region with added sine-based ruggedness, and an outer high-order growth with its own ruggedness. Phase-transition-like behavior arises from dimension-specific thresholds (h1, h2) and curvature parameters, ensuring a non-homogeneous search space while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_piecewise_rugged_separable_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension non-homogeneous parameters to create multi-regime, phase-transition-like regions\n        # h1: inner boundary for quadratic region\n        # h2: outer boundary for transition to outer growth\n        self.h1 = np.zeros(self.dim, dtype=float)\n        self.h2 = np.zeros(self.dim, dtype=float)\n\n        # a1: inner quadratic coefficient\n        # a2: middle-region curvature (affects how fast the middle region grows)\n        # b: outer-growth coefficient\n        # p: outer region exponent (polynomial degree)\n        self.a1 = np.zeros(self.dim, dtype=float)\n        self.a2 = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.p = np.zeros(self.dim, dtype=float)\n\n        # Ruggedness terms\n        # e_mid / q_mid: amplitude and frequency of sine-based ruggedness in the middle region\n        # e_outer / q_outer: amplitude and frequency of sine-based ruggedness in the outer region\n        self.e_mid = np.zeros(self.dim, dtype=float)\n        self.q_mid = np.zeros(self.dim, dtype=float)\n        self.e_outer = np.zeros(self.dim, dtype=float)\n        self.q_outer = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            t = i / max(1, self.dim - 1)  # in [0, 1], for diverse per-dimension settings\n\n            # Phase-transition-like thresholds per dimension\n            self.h1[i] = 0.25 + 0.75 * t          # [0.25, 1.0]\n            self.h2[i] = self.h1[i] + 0.5 + 0.8 * t  # ensure h2 > h1; up to ~2.3\n\n            # Coefficients driving shapes\n            self.a1[i] = 0.5 + 1.0 * t             # [0.5, 1.5]\n            self.a2[i] = 0.4 + 1.6 * t             # [0.4, 2.0]\n            self.b[i]  = 0.25 + 0.95 * t            # [0.25, 1.2]\n            self.p[i]  = 1.3 + 1.0 * t              # [1.3, 2.3]\n\n            # Middle-region ruggedness (sinusoidal ripples within the middle zone)\n            self.q_mid[i] = 6.0 + 8.0 * t            # [6, 14]\n            # Ensure middle ruggedness is always non-dominant at the inner boundary to preserve non-negativity\n            self.e_mid[i] = min(0.25, self.a1[i] * (self.h1[i] ** 2) * 0.9)\n\n            # Outer-region ruggedness (further non-homogeneity)\n            self.q_outer[i] = 3.0 + 14.0 * t           # [3, 17]\n            self.e_outer[i] = 0.0 + 0.15 * (1.0 - t)  # Decreasing ruggedness across dimensions\n\n        # Optional: ensure origin is a perfect global minimum\n        # (Handled by construction: inner region at xi=0 gives 0)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            absx = abs(xi)\n\n            # Inner regime: purely quadratic\n            if absx <= self.h1[i]:\n                gi = self.a1[i] * (xi ** 2)\n\n            # Middle regime: curved growth with sinusoidal ruggedness\n            elif absx <= self.h2[i]:\n                # Base: smooth quadratic growth from inner boundary plus offset to keep continuity\n                base_mid = self.a2[i] * ((absx - self.h1[i]) ** 2) + self.a1[i] * (self.h1[i] ** 2)\n                # Ruggedness that is zero at the inner boundary (absx == h1)\n                rugged_mid = self.e_mid[i] * np.sin(self.q_mid[i] * (absx - self.h1[i]))\n                gi = base_mid + rugged_mid\n\n            # Outer regime: high-order growth with additional ruggedness\n            else:\n                # Continuity value at h2\n                mid_at_h2 = self.a2[i] * ((self.h2[i] - self.h1[i]) ** 2) + self.a1[i] * (self.h1[i] ** 2)\n                outer_growth = self.b[i] * ((absx - self.h2[i]) ** self.p[i])\n                rugged_outer = self.e_outer[i] * np.sin(self.q_outer[i] * (absx - self.h2[i]))\n                gi = mid_at_h2 + outer_growth + rugged_outer\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_piecewise_rugged_separable_enhanced scored on:NOT Homogeneous 0.375, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6653185-a62e-4c89-a816-be22a74a92b7"], "operator": null, "metadata": {"ela_features_2D": [-0.0013555900461570181, 0.3429579751561519, 0.0018538858779497199, 0.03630212568715012, 29.535868708441313, -0.0004339882286049868, 0.9776391115374844, 8.721185902471593, 0.9776289841191955, 0.7814217122159409, -0.20966491639904525, 2.0, 0.6422159325609295, 0.6999817069303029, 0.5156314919851571, 0.350440617429597, -0.20162022783507466, 0.22128766273671135, 0.3378667377925265, 0.45908949047415126, 0.6320699469978505, 0.2097920898173839, 0.3003059108463756, 0.41348257787506004, 0.5695381342859974, -0.4075233718688606, -0.3465139888597214, -0.28308836225713946, -0.1925546168892452, -0.4061949938087547, -0.3596494406442131, -0.30150350111588853, -0.22127565284772288, 1.0, 1.0, 1.0, 1.0, 0.5278276783882458, 0.5278127800026827, 0.39090155764221557, 0.3587068700048478, 0.7097415494240817, 0.6816816816816814, 0.4884214196476856, -0.07107107107107107, 0.3710843373493976], "score_NOT Homogeneous_2D": 0.998510884004645, "score_Separable_2D": 1.0, "ela_features": [-0.0006015316383272129, 0.38249925411722263, 0.003913533854350986, 0.026945874531614178, 9.033622635450929, -0.0007340260526905506, 0.9832730799350339, 8.828308780435993, 0.9833313724062218, 0.4563543056651939, -0.10136169234457597, 1.6, 0.8885540724689751, 0.871646478187162, 0.6355099254082734, 0.183073538256129, -0.4719236878864811, 0.5098467227323379, 0.5934741373211891, 0.653276959607086, 0.748286677647884, 0.4883226178183378, 0.5732695251121241, 0.6387230809626285, 0.7420298041139187, -0.43117530007111127, -0.3576084338545232, -0.3050029624870332, -0.22142581395645458, -0.45233168498415566, -0.3772319109281702, -0.3193743516551911, -0.2280505219513997, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21614595645247947, 0.21616100067648536, 0.20101124843882925, 0.18124476482812418, 0.8274013436596694, 0.20920920920920913, 0.24263114908122035, -0.33933933933933924, 0.5084935897435898], "score_NOT Homogeneous_5D": 0.9382365718483925, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0006114205701054143, 0.40238551349635954, 0.002525230208873588, 0.01914952389611375, 23.827158435970812, 0.002183794114400661, 0.9843986413237756, 8.49415821261725, 0.9845124499170985, 0.34878662974816954, -0.0017042824955817437, 1.2, 0.9992240306598024, 0.9348798947984223, 0.6981491501800668, 0.1088659998085781, -0.5850282788618841, 0.6590552369809057, 0.7144006761664101, 0.7600970127620492, 0.8301272691465671, 0.656215882723461, 0.71378583698556, 0.7602059751667929, 0.8318459292505949, -0.4323416414504062, -0.3621586625364941, -0.3042123183893888, -0.2154092255667514, -0.4369599116702737, -0.3637835980277996, -0.30478049886690217, -0.21372430091611067, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10991409667298455, 0.10991345465460142, 0.10696175994564325, 0.10100827503487861, 0.8544102401079249, -0.11111111111111109, 0.1320515156129733, -0.6516516516516514, 0.5799839871897519], "score_NOT Homogeneous_10D": 0.3751886487007141, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [8, [-2.024666666666664, 0.00044444444444512003], 0.3793835994772671], [12, [-2.024666666666664, 1.716666666666667], 2.7636848312218087], [8, [0.00044444444444512003, -1.7168888888890965], 2.384301308281393], [16, [-2.024666666666664, -1.7166666666666666], 2.763684831221809], [16, [2.0246666666666644, -1.7166666666666666], 2.763684831221809], [8, [2.0246666666666644, 0.00044444444444512003], 0.3793835994772671], [15, [0.00043517780498951805, 1.7167071458235936], 2.3843014467735046], [13, [2.0246666666666644, 1.716666666666667], 2.7636848312218087]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.9228096919592928e-162, 1.421363958083183e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.2794219120005467e-162, -8.608933148985963e-163, 3.710000493497634e-163, -1.0375623342463047e-162, -1.0757052278650045e-162]}
{"id": "caabd63c-52f3-41c6-9571-f7c34980c8a4", "fitness": 0.9041944141887749, "name": "landscape_nh_phase_two_enhanced_adv", "description": "A novel, highly non-homogeneous separable landscape with per-dimension two-phase transitions and per-dimension envelopes (phase masks) that modulate the local landscape shape. Each dimension has its own thresholds, curvature, and outer-region ripples, and the per-dimension envelope introduces non-uniform appearance across the search space while preserving separability. The global optimum remains at the origin with value 0.", "code": "import numpy as np\n\nclass landscape_nh_phase_two_enhanced_adv:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        indices = np.arange(self.dim, dtype=float)\n\n        # Per-dimension two-phase boundaries (inner -> mid -> outer)\n        # t1: inner->mid boundary\n        t1 = 0.40 + 0.28 * (indices % 5) + 0.15 * np.sin(indices * 1.23)\n        t1 = np.clip(t1, 0.15, 5.0)\n\n        # t2: mid->outer boundary\n        t2 = t1 + 0.75 + 0.25 * ((indices * 9) % 5) + 0.12 * np.cos(indices * 0.77)\n        t2 = np.maximum(t2, t1 + 0.20)\n\n        # Phase blending sharpness per dimension\n        k1 = 5.0 + 2.0 * np.sin(indices * 0.9) + 0.6 * (indices % 3)\n        k2 = 5.0 + 2.0 * np.cos(indices * 1.4) + 0.4 * (indices % 4)\n\n        # Curvature per segment per dimension\n        a_quad0 = 0.25 + 0.75 * (indices / max(1.0, self.dim - 1))       # inner quadratic\n        a_quad1 = a_quad0 * (1.1 + 0.6 * (indices % 4) / 4.0)             # middle higher curvature\n        a_quartic = 0.12 + 0.18 * ((indices * 3) % 6) / 6.0            # outer quartic growth\n\n        # Outer-region ripple per dimension\n        ripple_amp = 0.03 + 0.02 * (indices % 5)\n        ripple_freq = 0.5 + 0.25 * (indices % 7)\n\n        # Per-dimension envelope (phase mask) to enforce non-homogeneous appearance\n        # This modulates the per-dimension contribution with x_i, preserving separability\n        env_amp = 0.15 + 0.15 * (indices % 3)      # envelope amplitude\n        env_freq = 0.6 + 0.25 * (indices % 5)      # envelope frequency\n        env_phase = 0.4 * indices                   # envelope phase shift\n\n        self.t1 = t1\n        self.t2 = t2\n        self.k1 = k1\n        self.k2 = k2\n        self.a_quad0 = a_quad0\n        self.a_quad1 = a_quad1\n        self.a_quartic = a_quartic\n        self.ripple_amp = ripple_amp\n        self.ripple_freq = ripple_freq\n        self.env_amp = env_amp\n        self.env_freq = env_freq\n        self.env_phase = env_phase\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)\n\n        # Per-dimension smooth phase blending (inner -> mid -> outer)\n        u = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        v = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        inner = self.a_quad0 * (x ** 2)\n        mid = self.a_quad1 * (x ** 2)\n        quart = self.a_quartic * (x ** 4) + self.ripple_amp * np.sin(self.ripple_freq * x)\n\n        # Base landscape contribution per dimension\n        base = (1.0 - v) * ( (1.0 - u) * inner + u * mid ) + v * quart\n\n        # Per-dimension envelope that depends on x_i (still separable)\n        env_term = 1.0 + self.env_amp * np.abs(np.sin(self.env_freq * x + self.env_phase))\n\n        # Final per-dimension contribution (separable, non-homogeneous)\n        val_per_dim = env_term * base\n\n        return float(np.sum(val_per_dim))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_phase_two_enhanced_adv scored on:NOT Homogeneous 0.928, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c035a1e-8ccc-4709-9d1f-f38936d3db9e"], "operator": null, "metadata": {"ela_features_2D": [-1.7240248357586196e-05, 0.1902373751661544, 0.019952355307933826, 0.03947634831956395, 4.219250476225495, 0.009047114512504617, 0.8974190209151306, 1.9570779453711602, 0.899976292134917, 1.2035655334172446, 0.9083618581898776, 1.2, 0.7001329584824312, 0.7154706392140265, 0.5450323317808206, 0.33950090753932466, -0.23100653024283102, 0.1736670578643317, 0.2406900653531455, 0.3310895595466589, 0.4966482127534528, 0.1622367254551818, 0.2298383927836261, 0.32217605702013774, 0.4974549074697904, -0.43252212628009257, -0.3974385429107007, -0.3501212616397272, -0.2634634455165256, -0.4309843743599734, -0.3962179313679809, -0.34870681669315357, -0.25853580250567376, 1.0, 1.0, 1.0, 1.0, 0.5212889086383353, 0.5212251600576697, 0.4130645920768668, 0.3558653295277721, 0.6307985827109993, 0.7337337337337335, 0.17904429861544663, -0.16716716716716712, 0.37269076305220883], "score_NOT Homogeneous_2D": 0.9967738438863307, "score_Separable_2D": 1.0, "ela_features": [0.0006857936287105071, 0.27917992493072835, 0.006152430693510434, 0.02800761624135758, 5.035687725069283, 0.002574331622900594, 0.9020377424734292, 1.9710019109523322, 0.9049567074137188, 0.7439361371268418, 0.3586902830368567, 1.6, 0.9137519697477359, 0.8719177489383064, 0.6378028269226581, 0.18885192337553658, -0.49470159420413823, 0.4294506711277447, 0.5253751575064138, 0.6066551570333247, 0.7279147613614734, 0.43218858259964366, 0.5276244479158402, 0.6078691649909211, 0.7301429480354344, -0.5018596603701388, -0.41748256753706264, -0.34598808532162656, -0.23932674763159428, -0.5020700056924062, -0.4176807668275579, -0.3467265965317238, -0.23860819126850658, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2180873455879989, 0.2180954691062341, 0.20361158379833294, 0.18531467788416922, 0.820234031421798, 0.28128128128128116, 0.24201496936635394, -0.3273273273273272, 0.5349358974358973], "score_NOT Homogeneous_5D": 0.5007110238075256, "score_Separable_5D": 1.0, "ela_features_10D": [0.0023753619987514573, 0.318446327871054, 0.0007148078252805316, 0.030191478718761006, 91.07445580754796, 0.0039251108507865505, 0.9055987217320588, 2.2803245160340717, 0.9075909524047396, 0.523774837175852, 0.13589065503115316, 1.8, 1.001211848288018, 0.9372567389227674, 0.6951975551574301, 0.10565975083371933, -0.5880749614488154, 0.6317758911823935, 0.692415874956034, 0.7429289856237157, 0.8227156081130689, 0.6354754409377689, 0.6948783072875789, 0.7456719148167869, 0.8258743417615891, -0.46695900683000113, -0.3900595306627934, -0.3260021522954144, -0.2248214001806149, -0.46342655408250993, -0.3879058230544635, -0.32333170977751713, -0.22136854296736322, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10960656020759507, 0.10960181382726783, 0.10628736421542673, 0.10019409691149521, 0.8599942152863086, -0.05905905905905906, 0.1423501461012727, -0.6156156156156154, 0.6121697357886309], "score_NOT Homogeneous_10D": 0.9276816174387932, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [3.2863989307685415e-13, 3.2863989307685415e-13], 6.822723248251619e-19]], "nr_of_basins": 1, "f_opt_dim_2": -4.219370609818264e-12, "x_opt_dim_2": [-4.084338969611126e-06, -4.44603032461377e-09], "f_opt_dim_5": -9.507960453275527e-12, "x_opt_dim_5": [-4.084339010224684e-06, -1.0162299712073783e-08, -2.4999733117158666e-06, -3.599521743374433e-07, -3.199296973190226e-08]}
{"id": "9c71ab4c-065a-465e-a43b-1e67a02e889e", "fitness": 0.9120878453056017, "name": "landscape_rugged_phase_nonhom_separable_v2", "description": "A strongly separable, non-homogeneous landscape with explicit per-dimension phase transitions and a rugged outer region. Each dimension contributes independently via its own fi(xi), preserving additivity across dimensions and improving separability for lower-dimensional subproblem decomposition.", "code": "import numpy as np\n\nclass landscape_rugged_phase_nonhom_separable_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension phase-transition thresholds and curvature\n        # h1: end of inner quadratic region\n        # h2: end of middle region (cubic growth)\n        # h3: end of outer smooth growth, start of rugged outer region\n        self.h1 = np.zeros(self.dim, dtype=float)\n        self.h2 = np.zeros(self.dim, dtype=float)\n        self.h3 = np.zeros(self.dim, dtype=float)\n\n        # Coefficients for each zone per dimension\n        self.a1 = np.zeros(self.dim, dtype=float)  # inner quadratic coeff\n        self.a2 = np.zeros(self.dim, dtype=float)  # middle cubic coeff\n        self.a3 = np.zeros(self.dim, dtype=float)  # outer smooth coeff (before rugged)\n        self.a4 = np.zeros(self.dim, dtype=float)  # outer rugged slope\n\n        # Rugged outer region modulation\n        self.e = np.zeros(self.dim, dtype=float)   # amplitude of ruggedness\n        self.w = np.zeros(self.dim, dtype=float)   # frequency of ruggedness\n        self.phi = np.zeros(self.dim, dtype=float) # phase offset for ruggedness\n\n        for i in range(self.dim):\n            r = i / max(1, self.dim - 1)  # in [0,1]\n\n            # Phase-transition thresholds (within domain)\n            self.h1[i] = 0.25 + 0.45 * r     # ~0.25 to ~0.70\n            self.h2[i] = 1.0 + 0.8 * r       # ~1.0 to ~1.8\n            self.h3[i] = 2.0 + 1.6 * r       # ~2.0 to ~3.6\n\n            # Zone curvature coefficients (varying across dimensions)\n            self.a1[i] = 0.5 + 0.25 * r      # inner quadratic\n            self.a2[i] = 0.8 + 0.3 * r       # middle cubic\n            self.a3[i] = 0.6 + 0.25 * r      # outer smooth growth\n            self.a4[i] = 0.9 + 0.45 * r      # outer rugged slope\n\n            # Rugged outer region parameters\n            self.e[i] = 0.05 + 0.07 * r        # amplitude\n            self.w[i] = 5.0 + 2.0 * r          # frequency\n            self.phi[i] = np.pi * (0.25 + 0.5 * r)  # phase offset\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n\n        for i in range(self.dim):\n            xi = x[i]\n            ax = np.abs(xi)\n            h1 = self.h1[i]\n            h2 = self.h2[i]\n            h3 = self.h3[i]\n            a1 = self.a1[i]\n            a2 = self.a2[i]\n            a3 = self.a3[i]\n            a4 = self.a4[i]\n            e = self.e[i]\n            wv = self.w[i]\n            phi = self.phi[i]\n\n            # Precompute continuity bases for the per-dimension fi\n            base2 = a1 * (h1 ** 2)\n            val_h2 = base2 + a2 * ((h2 - h1) ** 3)\n            base3 = val_h2 + a3 * ((h3 - h2) ** 2)\n\n            if ax <= h1:\n                fi = a1 * (xi ** 2)\n            elif ax <= h2:\n                fi = base2 + a2 * ((ax - h1) ** 3)\n            elif ax <= h3:\n                fi = val_h2 + a3 * ((ax - h2) ** 2)\n            else:\n                # Rugged outer region with phase-shifted cosine modulation\n                fi = (base3 +\n                      a4 * (ax - h3) +\n                      e * (np.cos(wv * (ax - h3) + phi) - np.cos(phi))\n                     )\n\n            total += fi\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_rugged_phase_nonhom_separable_v2 scored on:NOT Homogeneous 0.773, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5d85acd6-f74f-4639-b1f5-74060b1519b5"], "operator": null, "metadata": {"ela_features_2D": [-0.0010334641722639093, 0.42664431944499553, 0.016616225160893432, 0.03789544172913116, 3.1889946821493553, 0.002690949001985676, 0.9759690895720781, 1.8394484643340843, 0.9764129031317358, 0.2532115759535411, -0.8362059604185191, 1.8, 0.7029993567359195, 0.7078756852046705, 0.5457580332363874, 0.3516709661990695, -0.18739189458780375, 0.16195543007690755, 0.23824707863902123, 0.3344433367273259, 0.5208987172867159, 0.162720079283115, 0.23968237848374274, 0.33186536592376525, 0.5163626247082462, -0.4386520125215491, -0.39871568756945924, -0.34836660592549806, -0.2507669973918782, -0.4309634833268617, -0.39134872013615796, -0.3439091383137859, -0.24893323957249197, 1.0, 1.0, 1.0, 1.0, 0.5268473738232815, 0.5268419689825924, 0.3924019828528131, 0.35919272426865, 0.72247555676146, 0.4574574574574573, 0.5902976385282909, -0.06706706706706708, 0.3578313253012048], "score_NOT Homogeneous_2D": 0.8732268810272217, "score_Separable_2D": 1.0, "ela_features": [-0.00030170405866660757, 0.4455964841485497, 0.003291022060549763, 0.027696231557495954, 25.518552940232233, 0.0025507968511554015, 0.9751292176258662, 1.8721486551639952, 0.9752591548572953, 0.15831637598841686, -0.2880668350351363, 1.4, 0.9014093662492149, 0.8720317292740122, 0.6595996257624683, 0.18155708418098407, -0.4681869208544823, 0.43625945926081877, 0.5350357635666394, 0.6138429196148729, 0.725635446318716, 0.4357369513416347, 0.5355158067671081, 0.6131094565241673, 0.7276524556177564, -0.4958427094991816, -0.408963536580797, -0.3396484331144425, -0.24132013524618384, -0.4988700645019562, -0.4106551837308266, -0.3420544277349062, -0.2407864056344436, 1.0, 1.0, 0.8333333333333334, 1.0, 0.219394077532505, 0.21939881877724673, 0.20489779708007996, 0.18545325080703717, 0.8150788643356297, 0.07307307307307304, 0.2638908932148932, -0.38738738738738726, 0.49535256410256406], "score_NOT Homogeneous_5D": 0.8261558264493942, "score_Separable_5D": 1.0, "ela_features_10D": [0.0003235650430667869, 0.4893281630406487, 0.0023261741036527685, 0.025059742955708914, 39.49030365312651, 0.0035048230678461413, 0.9752400382464517, 1.8570011231186672, 0.9754625503264404, 0.08299449877182404, -0.20165249256221243, 1.4, 1.0147509783966275, 0.9389290595474516, 0.7084758929268828, 0.10414966880058292, -0.6123799029122321, 0.6309660653742208, 0.6902425232782141, 0.7366080895587849, 0.812386510515467, 0.6340812649055374, 0.6938367324972173, 0.7398503138911126, 0.8161920490429203, -0.468016581294898, -0.3928406825531824, -0.3340391057216922, -0.2379353105836644, -0.4652910539027747, -0.38930749037510537, -0.3307983300563987, -0.23372440922946974, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10968607255188863, 0.10967989724980283, 0.10655069719558774, 0.1004250043063886, 0.852511301265096, -0.1191191191191191, 0.1339975776607571, -0.6396396396396394, 0.5811849479583666], "score_NOT Homogeneous_10D": 0.7731443643569946, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 2.469135802476642e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.369907581171569e-162, 5.791676300698513e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.5945319114558817e-162, 4.4017393807044113e-166, -1.071688085215117e-163, -4.755959353346355e-163, 1.929214045976618e-163]}
{"id": "a05b336c-cc1f-48b9-91e3-909506e0689d", "fitness": 0.501790722211202, "name": "phase_transition_landscape_four_regimes_sep_v2", "description": "A novel separable landscape with four-regime phase transitions per dimension, enhanced separability via optional block-based per-dimension modulation. Each dimension has its own thresholds and region parameters, but the overall function remains a sum over independent per-dimension terms, enabling straightforward decomposition into subproblems for divide-and-conquer optimization. Global optimum is at the origin with value 0.", "code": "import numpy as np\n\nclass phase_transition_landscape_four_regimes_sep_v2:\n    \"\"\"\n    A separable, non-homogeneous landscape with four-regime phase transitions per-dimension.\n    Each dimension has its own a, b, c thresholds and region-specific parameters.\n    An optional block_size creates per-block modulation to emphasize easy subproblem decomposition\n    while preserving strict separability (no cross-dimension coupling).\n    Regions:\n      - inner: |x| <= a  -> quadratic\n      - middle1: a < |x| <= b -> cubic + sine-based ripple\n      - middle2: b < |x| <= c -> quartic + sine-based ripple\n      - outer: |x| > c -> quintic + sine-based ripple\n    Global optimum at x = 0 with value 0.\n    \"\"\"\n    def __init__(self, dim, seed=None, block_size=None):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed if seed is not None else 1234 + 7 * self.dim)\n\n        # Per-dimension phase boundaries (a < b < c)\n        self.a = rng.uniform(0.25, 0.9, size=self.dim)\n        self.b = rng.uniform(1.1, 2.8, size=self.dim)\n        self.b = np.maximum(self.b, self.a + 0.25)\n        self.c = rng.uniform(2.6, 4.8, size=self.dim)\n        self.c = np.maximum(self.c, self.b + 0.25)\n\n        # Inner region coefficient\n        self.alpha = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # First middle region (cubic) parameters\n        self.beta1 = rng.uniform(0.4, 2.0, size=self.dim)\n        self.omega1 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase1 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple1 = rng.uniform(0.0, 0.6, size=self.dim)\n\n        # Second middle region (quartic) parameters\n        self.gamma2 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega2 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase2 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple2 = rng.uniform(0.0, 0.7, size=self.dim)\n\n        # Outer region (quintic) parameters\n        self.gamma3 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega3 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase3 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple3 = rng.uniform(0.0, 0.8, size=self.dim)\n\n        # Optional block-based per-dimension modulation to enhance decomposability\n        self.block_id = None\n        if block_size is not None:\n            bs = int(block_size)\n            if bs > 0:\n                nb = int(np.ceil(self.dim / bs))\n                self.block_id = np.repeat(np.arange(nb), bs)[:self.dim]\n            else:\n                self.block_id = None\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        inside1 = absx <= self.a\n        inside2 = (absx > self.a) & (absx <= self.b)\n        inside3 = (absx > self.b) & (absx <= self.c)\n        outer = absx > self.c\n\n        # Per-dimension phase adjustments to promote block-wise separability\n        if self.block_id is not None:\n            phase1_eff = self.phase1 + 0.2 * self.block_id\n            omega1_eff = self.omega1 + 0.2 * self.block_id\n            phase2_eff = self.phase2 + 0.25 * self.block_id\n            omega2_eff = self.omega2 + 0.25 * self.block_id\n            phase3_eff = self.phase3 + 0.3 * self.block_id\n            omega3_eff = self.omega3 + 0.3 * self.block_id\n        else:\n            phase1_eff = self.phase1\n            omega1_eff = self.omega1\n            phase2_eff = self.phase2\n            omega2_eff = self.omega2\n            phase3_eff = self.phase3\n            omega3_eff = self.omega3\n\n        # Inner region: quadratic\n        val[inside1] = self.alpha[inside1] * (x[inside1] ** 2)\n\n        # First middle region: cubic growth with ripple\n        delta1 = absx[inside2] - self.a[inside2]\n        val[inside2] = (\n            self.beta1[inside2] * (delta1 ** 3) +\n            self.ripple1[inside2] * (np.sin(omega1_eff[inside2] * delta1 + phase1_eff[inside2]) ** 2)\n        )\n\n        # Second middle region: quartic growth with ripple\n        delta2 = absx[inside3] - self.b[inside3]\n        val[inside3] = (\n            self.gamma2[inside3] * (delta2 ** 4) +\n            self.ripple2[inside3] * (np.sin(omega2_eff[inside3] * delta2 + phase2_eff[inside3]) ** 2)\n        )\n\n        # Outer region: quintic growth with ripple\n        delta3 = absx[outer] - self.c[outer]\n        val[outer] = (\n            self.gamma3[outer] * (delta3 ** 5) +\n            self.ripple3[outer] * (np.sin(omega3_eff[outer] * delta3 + phase3_eff[outer]) ** 2)\n        )\n\n        return float(np.sum(val))", "configspace": "", "generation": 3, "feedback": "The optimization landscape phase_transition_landscape_four_regimes_sep_v2 scored on:NOT Homogeneous 0.000, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5b213c46-7738-4da8-9471-5da91cd68d1c"], "operator": null, "metadata": {"ela_features_2D": [-0.0016339664870170135, 0.14530369407544919, 0.008785716351886566, 0.028643037613425508, 4.677255402893015, 0.0008762702308482862, 0.23353391653718622, 18.723801850271837, 0.237426424985511, 2.1192986113560814, 4.602380636682781, 2.6, 0.2623001341281634, 0.5693858077277457, 0.22531013347960993, 0.3929010951108273, -0.34353262022124953, 0.6146570708641792, 0.7632108380631544, 0.8223051066661814, 0.9061306459878878, 0.6483463756371934, 0.7444645120680484, 0.8154983592133848, 0.8813832862930562, -0.2015283155632066, -0.12384060669468173, -0.0929321523771344, -0.049095510729702474, -0.1803824851337882, -0.13111276231140043, -0.0946649535575849, -0.060872566400715054, 1.0, 1.0, 1.0, 1.0, 0.519615154335544, 0.5195918477388766, 0.4228894411756666, 0.35440001500954255, 0.7000091534698611, 1.4984984984984988, 0.6438786303978906, 0.23723723723723716, 0.48995983935742976], "score_NOT Homogeneous_2D": 0.0005224347114562988, "score_Separable_2D": 1.0, "ela_features": [0.001809273494907493, 0.1599873747093135, 0.0022971446307686826, 0.027600753032323268, 29.19025831822421, 0.006799966297517046, 0.4727916837772154, 11.141762294736541, 0.48304980949521914, 1.9455751412654567, 4.0425692667805295, 2.8, 0.6249286313816482, 0.8181138945273156, 0.42186006025128187, 0.2279442356542644, -0.4080813763083978, 0.7751134939100087, 0.7966781701430443, 0.8053073043712065, 0.8490719306886685, 0.7638920439363209, 0.7859578170625238, 0.7962525834466619, 0.8434720860851384, -0.1978745051808535, -0.17890102241884487, -0.17130654956758665, -0.13279727567513927, -0.20885708592975893, -0.18934023242985495, -0.18023013124498716, -0.13845614937387846, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21460984197796132, 0.21459463846612653, 0.20207931938659401, 0.183638864699817, 0.7938612551972015, 0.5255255255255253, 0.19090052243169603, -0.3313313313313312, 0.6294871794871795], "score_NOT Homogeneous_5D": 0.010028600692749023, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0016561690245427752, 0.2138978903745336, 0.0022354218818252834, 0.01557836494133665, 15.270540488028573, 0.00289868216331064, 0.24169099447001569, 83.08987127639172, 0.25088185450538336, 1.1274025886719754, 1.0445082135769073, 2.0, 0.7542622857725483, 0.9003020392882093, 0.5264009048285838, 0.13826906025457567, -0.4947884266830317, 0.8456902635942685, 0.8764633841160556, 0.8979249830884315, 0.9317329696078487, 0.8399193195111911, 0.8735749820203427, 0.896563128550547, 0.9306789519884031, -0.19571605262451186, -0.15668403649351906, -0.1294640352397304, -0.08658548912678095, -0.2036117506692316, -0.16079577414702, -0.13155843421480284, -0.08816984980811253, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11044648828080264, 0.11044998968030421, 0.10681816591936077, 0.10079655613020258, 0.852979674664806, 0.13313313313313307, 0.15326761949950576, -0.5115115115115113, 0.6531625300240191], "score_NOT Homogeneous_10D": 0.0001932978630065918, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [2.8068888888890084, 0.00044444444444512003], 0.0036958505100901273], [4, [2.8068888888890084, 2.7988888888890093], 0.17736999551416263], [4, [2.8068888888890084, -2.798888888889009], 0.1773699955141626], [4, [-2.806888888889008, 0.00044444444444512003], 0.003695850510090126], [4, [-2.806888888889008, 2.7988888888890093], 0.17736999551416263], [4, [-2.806888888889008, -2.798888888889009], 0.1773699955141626], [2, [-2.763900760534934, 0.7488606213101964], 0.013299516189482231], [2, [2.763900059678388, 0.7488608714990678], 0.01329956070231431], [2, [-2.7638711425670106, -0.7488598861003049], 0.013301459829259264], [2, [2.8068888888890084, -0.7526666666666657], 0.011803989067967527], [8, [0.00044444444444512003, 0.00044444444444512003], 4.2957086164758824e-07], [8, [0.00044444444444512003, 2.7988888888890093], 0.17367457457493415], [8, [0.00044444444444512003, -2.798888888889009], 0.17367457457493413], [4, [-0.00025839657172377524, -0.7526227842237206], 0.00810850459970072], [4, [-0.0002814661328268105, 0.7526213443610601], 0.008108509972134003], [1, [3.9237669860584887, -0.697503070518232], 0.12757714293124867], [1, [-3.9236178356815605, 0.694693626016879], 0.12771409788041818], [1, [3.9236562548407194, 0.6946692668458074], 0.12772671509199196], [1, [-3.923615971922871, -0.6946921324418013], 0.12771365984428817], [2, [-3.923344372047958, 2.7999274312409073], 0.2911054841559541], [2, [3.923343645813696, -2.7999261388456396], 0.29110527478053383], [2, [3.923343430305001, 2.7999285366539945], 0.2911052145006908], [2, [-3.923343366965101, -2.7999263455953485], 0.2911051948553518], [2, [2.780925203856818, -4.662125430154654], 0.050023194840964486], [2, [-2.746673303112345, -4.6620849475268376], 0.05222939533267248], [4, [-0.04400156504171097, 4.663105000090787], 0.04724963838708813], [1, [3.92398516148797, -4.662000000340511], 0.16329423350862102], [1, [-3.9239781245858367, 4.662000000789219], 0.16329221273529992], [1, [-3.923980354693133, -4.6620000007068825], 0.1632928531885878], [1, [3.923982246708401, 4.662000000571242], 0.16329339650514213], [4, [0.10201181321661884, -4.66190056052518], 0.05021909515738531], [2, [2.7397331458043697, 4.662010868708844], 0.05281103222870544], [2, [-2.741660836878455, 4.662167051818487], 0.05273134631103098], [2, [3.923523782675991, -0.0014980325979419278], 0.11748622078809791], [2, [-3.923510352544486, -0.001494690767238837], 0.11748234709049521]], "nr_of_basins": 35, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.5551407915349297e-162, 4.423034540589892e-163], "f_opt_dim_5": 0.05180763345089248, "x_opt_dim_5": [-1.7050304311965085, -9.006317573963002e-10, -1.526154025571373e-09, 7.2315574367673014e-12, -0.7168244564967562]}
{"id": "2fdc9fcd-443f-4af0-ba01-6f07db85a4ae", "fitness": 0.8018379372855028, "name": "landscape_nh_four_region_enhanced", "description": "A highly non-homogeneous, separable benchmark with four-region phase transitions per dimension, enhanced with per-dimension heterogeneity: region-specific scaling, additional nonnegative ripple overlays, and dimension-specific phase-shifted ripples. This strengthens phase transitions across the space while preserving separability and keeping the global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_nh_four_region_enhanced:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic, per-dimension heterogeneity\n        rng = np.random.default_rng(seed=2029 + self.dim)\n\n        # Per-dimension phase boundaries (four regions)\n        # Region 0: |x| <= a1 -> inner quadratic\n        self.a1 = rng.uniform(0.2, 0.9, size=self.dim)\n        # Region 1: a1 < |x| <= a2 -> higher curvature\n        self.a2 = rng.uniform(0.9, 2.4, size=self.dim)\n        self.a2 = np.maximum(self.a2, self.a1 + 0.25)\n        # Region 2: a2 < |x| <= a3 -> outer mid/high curvature\n        self.a3 = rng.uniform(1.9, 3.8, size=self.dim)\n        self.a3 = np.maximum(self.a3, self.a2 + 0.5)\n\n        # Region 0-2 curvature parameters\n        self.alpha1 = rng.uniform(0.4, 2.0, size=self.dim)  # inside a1\n        self.alpha2 = rng.uniform(0.8, 3.0, size=self.dim)  # between a1 and a2\n        self.alpha3 = rng.uniform(0.6, 3.5, size=self.dim)  # between a2 and a3\n\n        # Region 3 (outer) base growth parameter\n        self.beta = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # Outer-region ripple (ruggedness) parameters\n        self.gamma = rng.uniform(0.0, 0.6, size=self.dim)  # ripple amplitude\n        self.omega = rng.uniform(0.5, 3.0, size=self.dim)  # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim)  # ripple phase\n\n        # Per-dimension region scaling to increase non-homogeneity\n        self.scale0 = rng.uniform(0.5, 2.0, size=self.dim)  # inner region scaling\n        self.scale1 = rng.uniform(0.5, 2.0, size=self.dim)  # region1 scaling\n        self.scale2 = rng.uniform(0.5, 2.0, size=self.dim)  # region2 scaling\n        self.scale3 = rng.uniform(0.5, 2.0, size=self.dim)  # region3 scaling (outer)\n\n        # Extra nonnegative ripples to enhance phase transitions in each region\n        self.eta1 = rng.uniform(0.0, 0.6, size=self.dim)\n        self.omega_eta1 = rng.uniform(0.5, 2.5, size=self.dim)\n        self.phase_eta1 = rng.uniform(0.0, 2*np.pi, size=self.dim)\n\n        self.eta2 = rng.uniform(0.0, 0.6, size=self.dim)\n        self.omega_eta2 = rng.uniform(0.5, 2.5, size=self.dim)\n        self.phase_eta2 = rng.uniform(0.0, 2*np.pi, size=self.dim)\n\n        self.eta3 = rng.uniform(0.0, 0.6, size=self.dim)\n        self.omega_eta3 = rng.uniform(0.5, 2.5, size=self.dim)\n        self.phase_eta3 = rng.uniform(0.0, 2*np.pi, size=self.dim)\n\n        # Optional small per-dimension phase-tilt for added non-homogeneity (non-negative impact)\n        # (kept purely non-negative via squared sine terms)\n        # No extra state needed; handled in f()\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        # Region 0: inner quadratic\n        inside0 = absx <= self.a1\n        if np.any(inside0):\n            idx = inside0\n            val[idx] = self.scale0[idx] * (x[idx] ** 2)\n\n        # Region 1: middle regime with higher curvature\n        region1 = (absx > self.a1) & (absx <= self.a2)\n        if np.any(region1):\n            idx = region1\n            base1 = (\n                self.alpha2[idx] * ((absx[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            extra1 = (\n                self.eta1[idx] * (\n                    np.sin(self.omega_eta1[idx] * (absx[idx] - self.a1[idx]) + self.phase_eta1[idx])\n                ** 2)\n            )\n            val[idx] = self.scale1[idx] * base1 + extra1\n\n        # Region 2: outer mid regime\n        region2 = (absx > self.a2) & (absx <= self.a3)\n        if np.any(region2):\n            idx = region2\n            base2 = (\n                self.alpha3[idx] * ((absx[idx] - self.a2[idx]) ** 2) +\n                self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            extra2 = (\n                self.eta2[idx] * (\n                    np.sin(self.omega_eta2[idx] * (absx[idx] - self.a2[idx]) + self.phase_eta2[idx])\n                ** 2)\n            )\n            val[idx] = self.scale2[idx] * base2 + extra2\n\n        # Region 3: outer rugged region with a ripple\n        region3 = absx > self.a3\n        if np.any(region3):\n            idx = region3\n            base3 = (\n                self.beta[idx] * ((absx[idx] - self.a3[idx]) ** 2) +\n                self.alpha3[idx] * ((self.a3[idx] - self.a2[idx]) ** 2) +\n                self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2) +\n                self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            ripple = (\n                self.gamma[idx] * (np.sin(self.omega[idx] * (absx[idx] - self.a3[idx]) + self.phase[idx]) ** 2)\n                - self.gamma[idx] * (np.sin(self.phase[idx]) ** 2)\n            )\n            extra3 = (\n                self.eta3[idx] * (\n                    np.sin(self.omega_eta3[idx] * (absx[idx] - self.a3[idx]) + self.phase_eta3[idx])\n                ** 2)\n            )\n            val[idx] = base3 + ripple + extra3\n\n        return float(np.sum(val))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_four_region_enhanced scored on:NOT Homogeneous 0.935, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["968d7bfb-eab0-4605-a96d-9c4e9fc4505c"], "operator": null, "metadata": {"ela_features_2D": [-0.0020259823523922195, 0.49998820205861316, 0.010043883865131867, 0.030077509871297425, 4.835942765275235, 0.0003858928264314443, 0.7914191321252717, 1.3916696686689316, 0.790112352591789, -0.10431728227017927, -0.7015636610876037, 1.4, 0.6655135754349112, 0.7048884162859139, 0.5241985491667377, 0.347830349113727, -0.22994750273486772, 0.1401436524932846, 0.22941426159340464, 0.3106158598984635, 0.5184336838125795, 0.1370372815632282, 0.22896666311570452, 0.30858055179370514, 0.5061869300374229, -0.44990165615278005, -0.40319480041293004, -0.3607073671103538, -0.25197170204519204, -0.44360107566027107, -0.3963463375859967, -0.3554190205593965, -0.2538367892044681, 1.0, 1.0, 1.0, 1.0, 0.5283509683674541, 0.5283354899633941, 0.4049838529623013, 0.35603676747605745, 0.7500090233385617, 0.9139139139139136, 0.7549499946833095, 0.10110110110110107, 0.40522088353413654], "score_NOT Homogeneous_2D": 0.8417525887489319, "score_Separable_2D": 1.0, "ela_features": [-0.0015320899298995716, 0.4701583564426358, 0.005658768971671058, 0.018254030715523374, 4.745230366287972, 0.0017031870267117054, 0.7921265884254277, 1.9606742053914332, 0.7909986617095403, 0.05936551408850575, -0.24359193842401536, 1.2, 0.8486887553494409, 0.8556821842836955, 0.5857796328339939, 0.19839619051469085, -0.488200462195131, 0.46242871968297816, 0.5643711630904136, 0.6487743148401602, 0.7553024085483385, 0.45659729013069833, 0.559555115608598, 0.647488111970889, 0.754839172290078, -0.47287423929829925, -0.38319600025247647, -0.3089527457737562, -0.21524651710501833, -0.4805697191526657, -0.3895056706685144, -0.3117440080583179, -0.21680933501785432, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21804163349213518, 0.21806310856542804, 0.20357936796098972, 0.18331750200549368, 0.8435635155087124, 0.24924924924924916, 0.2784925004504343, -0.3353353353353352, 0.548397435897436], "score_NOT Homogeneous_5D": 0.034056127071380615, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0011961023820841854, 0.47574180455689774, 0.0008297730785175239, 0.015956967041101926, 88.08537456859736, 0.001779095690587873, 0.7736206679452017, 2.6443595203326127, 0.7744346711992012, 0.06255250701429194, -0.1553219421963501, 1.0, 0.9549885255033885, 0.9283171315264926, 0.6572025549278135, 0.11388836572297392, -0.6017946000888333, 0.6716367003635262, 0.7268031609239382, 0.7716306435148235, 0.8377838952875856, 0.6734849094505319, 0.7274063244096641, 0.7721055708502383, 0.840077518878721, -0.41647994905022967, -0.34650928750950666, -0.2896522815499619, -0.20574679890262196, -0.4152772591835558, -0.3466985914677792, -0.28984712434774007, -0.20339700426509727, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10978837204598593, 0.1097936125768669, 0.10668332426066587, 0.10035888812963452, 0.8591968566764342, -0.05905905905905906, 0.14670536394535638, -0.5995995995995994, 0.6012810248198559], "score_NOT Homogeneous_10D": 0.935218907892704, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-2.293564616256998, -1.8741266646719126], 10.364025326316213], [2, [-2.2997777777778303, 0.00044444444444512003], 5.329078149956358], [2, [2.2980493916488833, -1.872673835791552], 10.363961632000954], [1, [-2.293564619551683, 1.8741226669640614], 10.364025268776846], [1, [2.2988048541594015, 1.8729914697750378], 10.363959927603535], [4, [-3.2008888888889646, 0.00044444444444512003], 6.688089241468262], [2, [-3.2010172156305283, -1.8733551817207013], 11.722972620197563], [2, [-3.201024591834337, 1.8733374996563388], 11.722972494633026], [4, [-3.1679125568266295, 3.3674344215894956], 15.542623470576295], [2, [-2.2931103124707533, 3.3680484001592608], 14.182987271720316], [4, [2.299777777777831, 0.00044444444444512003], 5.329078149956358], [3, [-2.297652426616032, 0.5906591368150493], 6.312485330653347], [2, [0.00044444444444512003, 0.590666666666666], 0.9834028639209996], [3, [-2.297650364470261, -0.5906578176851067], 6.312485334670302], [4, [0.00044444444444512003, -1.873777777777863], 5.0348876051744265], [4, [0.00044444444444512003, 1.873777777777864], 5.0348876051744265], [3, [0.00044444444444512003, -0.5906666666666656], 0.9834028639209997], [11, [0.00044444444444512003, 0.00044444444444512003], 3.404899850919412e-07], [5, [2.90389522600391, 0.16188757490981254], 6.760515974914788], [6, [-2.295260710539698, -3.367672037194727], 14.182809370654446], [3, [2.2976503494765455, -0.5906628437083232], 6.312485364362118], [6, [2.292441416093597, 3.367719721199865], 14.182878509263453], [6, [2.293203916535608, -3.3677646606566345], 14.182878902897487], [2, [3.198144157169928, 1.8734191778727074], 11.72298079076335], [8, [0.0017189160548155482, -3.367347551121174], 8.853585373560346], [8, [-0.0008303196670808241, 3.367347793025619], 8.853583092164564], [1, [3.200052399770487, -1.872588996756109], 11.722970977712569]], "nr_of_basins": 27, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.244754533498556e-162, -7.429207218647584e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-6.482791539405944e-163, 9.766804264153722e-163, -2.391971558166271e-163, -1.1123371495246302e-162, -1.9222859742063925e-163]}
{"id": "3b536c71-be03-4fe5-92c7-82323d3ad1d6", "fitness": 0.9179079855481783, "name": "landscape_nh_five_region_phase_ext", "description": "A five-region, highly non-homogeneous, separable landscape with per-dimension phase transitions and dimension-specific outer-ruggedness. Each dimension has its own four phase boundaries (a1..a4) creating five regions with distinct curvature, plus a dimension-offset outer ripple to enhance non-homogeneity. The landscape remains separable (sum over dimensions) and preserves a global minimum at the origin, with search bounds [-5, 5].", "code": "import numpy as np\n\nclass landscape_nh_five_region_phase_ext:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic seeding per dimension for reproducibility\n        rng = np.random.default_rng(seed=2029 + 17 * self.dim)\n\n        # Per-dimension region boundaries to create five regions\n        # Ensure ordering a1 < a2 < a3 < a4 and all within [-5, 5]\n        self.a1 = rng.uniform(0.15, 0.60, size=self.dim)\n        self.a2 = rng.uniform(0.80, 2.10, size=self.dim)\n        self.a2 = np.maximum(self.a2, self.a1 + 0.35)\n        self.a3 = rng.uniform(1.80, 3.20, size=self.dim)\n        self.a3 = np.maximum(self.a3, self.a2 + 0.40)\n        self.a4 = rng.uniform(2.70, 4.60, size=self.dim)\n        self.a4 = np.maximum(self.a4, self.a3 + 0.40)\n\n        # Region curvature parameters for each region\n        self.alpha1 = rng.uniform(0.4, 2.0, size=self.dim)   # inner quadratic\n        self.alpha2 = rng.uniform(0.8, 3.0, size=self.dim)   # between a1 and a2\n        self.alpha3 = rng.uniform(0.6, 3.5, size=self.dim)   # between a2 and a3\n        self.alpha4 = rng.uniform(0.5, 3.2, size=self.dim)   # between a3 and a4\n        self.beta   = rng.uniform(0.3, 2.0, size=self.dim)   # outer-most growth\n\n        # Outer-region ripple (ruggedness) parameters\n        self.gamma = rng.uniform(0.0, 0.8, size=self.dim)    # ripple amplitude\n        self.omega = rng.uniform(0.5, 3.5, size=self.dim)    # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim)  # ripple phase\n\n        # Per-dimension phase offset to boost non-homogeneity\n        self.phi = rng.uniform(-0.6, 0.6, size=self.dim)\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        val = np.zeros(self.dim, dtype=float)\n\n        # Region 0: inner quadratic (|x| <= a1)\n        inside0 = absx <= self.a1\n        if np.any(inside0):\n            idx = inside0\n            val[idx] = self.alpha1[idx] * (x[idx] ** 2)\n\n        # Region 1: a1 < |x| <= a2\n        region1 = (absx > self.a1) & (absx <= self.a2)\n        if np.any(region1):\n            idx = region1\n            val[idx] = (\n                self.alpha2[idx] * ((absx[idx] - self.a1[idx]) ** 2)\n                + self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n\n        # Region 2: a2 < |x| <= a3\n        region2 = (absx > self.a2) & (absx <= self.a3)\n        if np.any(region2):\n            idx = region2\n            val[idx] = (\n                self.alpha3[idx] * ((absx[idx] - self.a2[idx]) ** 2)\n                + self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2)\n                + self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n\n        # Region 3: a3 < |x| <= a4\n        region3 = (absx > self.a3) & (absx <= self.a4)\n        if np.any(region3):\n            idx = region3\n            base3 = (\n                self.alpha4[idx] * ((absx[idx] - self.a3[idx]) ** 2)\n                + self.alpha3[idx] * ((self.a3[idx] - self.a2[idx]) ** 2)\n                + self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2)\n                + self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            ripple = (\n                self.gamma[idx] * (np.sin(self.omega[idx] * (absx[idx] - self.a3[idx]) + self.phase[idx]) ** 2)\n                - self.gamma[idx] * (np.sin(self.phase[idx]) ** 2)\n            )\n            val[idx] = base3 + ripple\n\n        # Region 4: |x| > a4 (outer rugged region with additional phase-offset ripple)\n        region4 = absx > self.a4\n        if np.any(region4):\n            idx = region4\n            base4 = (\n                self.beta[idx] * ((absx[idx] - self.a4[idx]) ** 2)\n                + self.alpha4[idx] * ((self.a4[idx] - self.a3[idx]) ** 2)\n                + self.alpha3[idx] * ((self.a3[idx] - self.a2[idx]) ** 2)\n                + self.alpha2[idx] * ((self.a2[idx] - self.a1[idx]) ** 2)\n                + self.alpha1[idx] * (self.a1[idx] ** 2)\n            )\n            ripple4 = (\n                self.gamma[idx] * (np.sin(self.omega[idx] * (absx[idx] - self.a4[idx] - self.phi[idx]) + self.phase[idx]) ** 2)\n                - self.gamma[idx] * (np.sin(-self.omega[idx] * self.phi[idx] + self.phase[idx]) ** 2)\n            )\n            val[idx] = base4 + ripple4\n\n        return float(np.sum(val))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_five_region_phase_ext scored on:NOT Homogeneous 0.730, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["968d7bfb-eab0-4605-a96d-9c4e9fc4505c"], "operator": null, "metadata": {"ela_features_2D": [-0.0018059161226247511, 0.42518160453630716, 0.01467933929187804, 0.037811757643939486, 3.4449987974992857, -0.002281872032190768, 0.9062400899985752, 1.71796516023734, 0.9063965921245568, 0.09798825888574535, -1.044701814331767, 2.0, 0.7132269343250667, 0.7154296727638404, 0.5930985496810139, 0.3426530330271963, -0.17471129666519455, 0.11147854173462128, 0.20321744762901064, 0.306074701575636, 0.5137118884249491, 0.11549146861072905, 0.1982456902836944, 0.30202202158131036, 0.5009237511469312, -0.46478299968073883, -0.4167940485671842, -0.3629885202198279, -0.2543691371234292, -0.4546259369501751, -0.4120944794518547, -0.35875171122399074, -0.2565064452168332, 1.0, 1.0, 1.0, 1.0, 0.5159873678282773, 0.5159559219209082, 0.367808401538501, 0.35141920950867933, 0.7015953294712391, 0.6016016016016014, 0.41493595351885776, -0.15115115115115113, 0.378714859437751], "score_NOT Homogeneous_2D": 0.818294569849968, "score_Separable_2D": 1.0, "ela_features": [0.00012990762670725964, 0.5155246861437324, 0.004111225340313675, 0.025668810052869577, 20.87701251268766, 0.007667611806329755, 0.906130392061949, 3.736966654789169, 0.90601459093747, -0.01391362023143095, -0.44260722358419446, 1.0, 0.880286731920053, 0.8633951290269192, 0.632731440281677, 0.19161757328401824, -0.4556962421238847, 0.5327668173687463, 0.5836855123171905, 0.6602675583440053, 0.7550981418660425, 0.5147403997589002, 0.570133172938865, 0.6485369842960358, 0.7500296048143958, -0.41094976257179683, -0.3661658365354875, -0.2988072676396967, -0.21539978559914, -0.4289699555122549, -0.3800066941572052, -0.31069254490216325, -0.22097151256230338, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2174194636786552, 0.2174151248169926, 0.2016074536040537, 0.1838172600372224, 0.8231877263492402, 0.11711711711711707, 0.260488674950414, -0.3713713713713712, 0.5089743589743589], "score_NOT Homogeneous_5D": 0.9590462148189545, "score_Separable_5D": 1.0, "ela_features_10D": [0.0005581864524773827, 0.4710649203258258, 0.0007721185468336559, 0.022358368126599693, 129.52579162529003, 0.005509853525848785, 0.9379184686275762, 3.202142884933044, 0.9377783453662953, 0.14615149760159124, -0.15982857548290993, 1.2, 0.9945053324914197, 0.9342686080811833, 0.7035969412307702, 0.10776668425708066, -0.5948804479379248, 0.6426253836345285, 0.7039726140051498, 0.7513930408364337, 0.8242530433452891, 0.6431284891784304, 0.7036378517171323, 0.7526476254987771, 0.826829420545469, -0.4532310711184039, -0.3754301538118507, -0.3152903438566043, -0.2228874321253774, -0.4537564266714642, -0.37682339162241757, -0.3145072348848789, -0.2201858702734938, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10980711147383311, 0.10979722615451104, 0.10669707604909281, 0.1010265801189355, 0.8506426239445363, -0.09109109109109108, 0.14499119196456964, -0.6276276276276274, 0.5835868694955966], "score_NOT Homogeneous_10D": 0.7301071286201477, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [2.946888888888993, 3.7348888888889062], 20.270687981399544], [8, [0.00044444444444512003, 3.7348888888889062], 15.459122275726564], [12, [-2.9468764556451505, -0.00041916210872027177], 4.8115660291583024], [12, [2.946876415554109, -0.0004219475895663894], 4.811566030011104], [6, [-4.922000000000009, 0.00044444444444512003], 12.142268382413977], [24, [0.00044444444444512003, 0.00044444444444512003], 3.680314485466754e-07], [2, [4.921846536970638, 3.7348907109919023], 27.601390448285215], [6, [4.922000006944843, 0.00041152943964565614], 12.14226837079412], [2, [-4.921869911177834, 3.7345424881496987], 27.601390606275505], [2, [4.9124176488902265, -3.734293341998438], 27.601630959284186], [2, [-4.912417858294247, -3.7342936865781566], 27.6016309484754], [8, [0.00044444444444512003, -3.734888888888906], 15.459122275726564], [4, [2.944920467598622, -3.731276672819227], 20.270707467633045], [4, [-2.9449204898224237, -3.7312747314181065], 20.270707481477544], [4, [-2.9433477289380012, 3.7295686649939945], 20.270744138081938]], "nr_of_basins": 15, "f_opt_dim_2": 0.0, "x_opt_dim_2": [3.454967551972495e-163, 2.6091249356636538e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-4.0200655668103e-163, 3.742531057926007e-163, -2.5809807185500582e-163, -1.5028265107519012e-162, 1.3178770894963213e-162]}
{"id": "ce2f4a52-38e3-4249-8528-8bf8f5f3ab00", "fitness": 0.8097436092793941, "name": "landscape_piecewise_rugged_separable_enhanced", "description": "A novel separable, non-homogeneous landscape with multi-phase, piecewise transitions per dimension. Each dimension has its own inner quadratic well, a middle transitional region, and a rugged outer growth with sine-based modulation. The function remains additive across dimensions, ensuring strong separability, with a global minimum at the origin. ", "code": "import numpy as np\n\nclass landscape_piecewise_rugged_separable_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension non-homogeneous parameters to create multi-phase transitions\n        # h1: end of inner quadratic region\n        # h2: end of middle region (start of rugged outer region)\n        # a: inner region coefficient\n        # c: middle region curvature coefficient\n        # b: outer region growth coefficient\n        # p: outer region exponent (polynomial degree)\n        # e: amplitude of rugged sine modulation in outer region\n        # q: frequency of ruggedness in outer region\n        # phase: deterministic phase offset per dimension for richness\n        self.h1 = np.zeros(self.dim, dtype=float)\n        self.h2 = np.zeros(self.dim, dtype=float)\n        self.a = np.zeros(self.dim, dtype=float)\n        self.c = np.zeros(self.dim, dtype=float)\n        self.b = np.zeros(self.dim, dtype=float)\n        self.p = np.zeros(self.dim, dtype=float)\n        self.e = np.zeros(self.dim, dtype=float)\n        self.q = np.zeros(self.dim, dtype=float)\n        self.phase = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            t = i / max(1, self.dim - 1)  # in [0, 1]\n\n            # Create non-homogeneous per-dimension parameters\n            self.h1[i] = 0.2 + 0.3 * t          # [0.2, 0.5]\n            self.h2[i] = 0.8 + 0.7 * t          # [0.8, 1.5]\n            self.a[i] = 0.3 + 0.6 * t            # [0.3, 0.9]\n            self.c[i] = 0.5 + 0.8 * t            # [0.5, 1.3]\n            self.b[i] = 0.2 + 0.9 * t            # [0.2, 1.1]\n            self.p[i] = 2.0 + 0.6 * t            # [2.0, 2.6]\n            self.e[i] = 0.05 + 0.25 * t          # [0.05, 0.30]\n            self.q[i] = 6.0 + 6.0 * t             # [6, 12]\n\n            # Deterministic phase for richness in outer region\n            seed = (i * 99991) % 1000003\n            self.phase[i] = (seed / 1000003.0) * 2.0 * np.pi\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            absx = abs(xi)\n\n            h1i = self.h1[i]\n            h2i = self.h2[i]\n            ai = self.a[i]\n            ci = self.c[i]\n            bi = self.b[i]\n            pi = self.p[i]\n            ei = self.e[i]\n            qi = self.q[i]\n            ph = self.phase[i]\n\n            if absx <= h1i:\n                # Inner quadratic region\n                gi = ai * (xi ** 2)\n            elif absx <= h2i:\n                # Middle region: smooth transition with higher curvature\n                gi = ai * (h1i ** 2) + ci * ((absx - h1i) ** 2)\n            else:\n                # Outer rugged growth with continuity enforced at h2\n                base = ai * (h1i ** 2) + ci * ((h2i - h1i) ** 2)\n                outer = bi * ((absx - h2i) ** pi)\n                rugged = ei * np.sin(qi * (absx - h2i) + ph) - ei * np.sin(ph)\n                gi = base + outer + rugged\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_piecewise_rugged_separable_enhanced scored on:NOT Homogeneous 0.149, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6653185-a62e-4c89-a816-be22a74a92b7"], "operator": null, "metadata": {"ela_features_2D": [-0.001980158652090247, 0.25733288627969186, 0.0033921331267796145, 0.03384450846919482, 29.90691314047449, 0.0021704561122037, 0.9301728930492393, 7.722644942568569, 0.9304419307670442, 1.2747049120607725, 0.5018574680768071, 1.6, 0.6748022909919572, 0.7021406413356646, 0.5159797197578998, 0.35084923368743415, -0.18759900987287031, 0.15370217995211471, 0.24142493806894474, 0.3489006824880502, 0.511195945403734, 0.15053129102408053, 0.22944827204246657, 0.3268457701427562, 0.4974379493311515, -0.4426004749155464, -0.39672391934356777, -0.3405130518424141, -0.2556333442082711, -0.4356928842214975, -0.395213265569781, -0.34525424041419955, -0.2577576894464331, 1.0, 1.0, 1.0, 1.0, 0.5222380356544485, 0.5221843666559574, 0.37623445044651216, 0.3551280601799372, 0.6872160289716474, 0.7457457457457455, 0.24570781215404208, -0.28328328328328317, 0.4028112449799196], "score_NOT Homogeneous_2D": 0.7957813441753387, "score_Separable_2D": 1.0, "ela_features": [-0.0009845669907658783, 0.31812424214507573, 0.0038783073703764583, 0.02547445977881401, 9.814732132156795, -0.0006813191803968222, 0.943560856297983, 7.058389458338262, 0.9446382508047464, 0.7553940408463213, 0.13691627721273686, 1.4, 0.9007208711276252, 0.8702255164631731, 0.6307415604035337, 0.18800425234043913, -0.4743271626686673, 0.47436558134194673, 0.5562371394718124, 0.6326314573714953, 0.7450745876384272, 0.4671536076383678, 0.5539478047991444, 0.6280092152619755, 0.7429259095590764, -0.4623820091654688, -0.3903597878664714, -0.32315711475940584, -0.22424631415953247, -0.4711662015008472, -0.39440551844725424, -0.3289140414237769, -0.22730591847285866, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21476941556132728, 0.21476226162324813, 0.1982934832405492, 0.18066696112605335, 0.8078915048173135, 0.2932932932932932, 0.2689105537792251, -0.3273273273273273, 0.5262820512820514], "score_NOT Homogeneous_5D": 0.9132233932614326, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00047871298881039246, 0.3523888518882094, 0.0019484195365017053, 0.019351408124675954, 10.793452301782354, 0.0056195413842330625, 0.9525707130103251, 7.219277468218008, 0.9531140372371324, 0.47543280049315284, 0.0022340199735158884, 1.4, 1.0032251727791366, 0.9352370380530394, 0.6973307274173643, 0.1075443380226447, -0.5862412865759837, 0.646352774226626, 0.7055152862506537, 0.7548371176274431, 0.8293788623482176, 0.6454923373924162, 0.7064298258967897, 0.7563687472255005, 0.8309733739435341, -0.44850943816991934, -0.3734774407826781, -0.3109253823381617, -0.2163885505121838, -0.45080831726159126, -0.37331753897402287, -0.30981244354129417, -0.21494157388304197, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10980438164237538, 0.10980558396718229, 0.10653983883819843, 0.10055195143169711, 0.8557155686376576, -0.055055055055055056, 0.13869099707644372, -0.6156156156156154, 0.5903923138510808], "score_NOT Homogeneous_10D": 0.1494569182395935, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 2.3703703703775764e-07], [6, [0.0022662356490788516, -2.312952504001001], 1.7451500600971683], [8, [-1.4226666666666663, 0.00044444444444512003], 0.24154204078779865], [12, [-1.4148706498397545, -2.306438457493666], 1.9876445669352005], [11, [0.002266601337079214, 2.3129533117332737], 1.745150048899912], [5, [0.325510766273434, 1.6794347606094113], 1.4869040205864068], [4, [-1.4294161290395142, 1.7376469563193602], 1.5168853989755615], [5, [0.32951700239076165, -1.6799750667382958], 1.4856914784413786], [4, [-1.4233872830912269, -1.7388030781067088], 1.513266925984478], [8, [1.4226666666666667, 0.00044444444444512003], 0.24154204078779865], [10, [1.4159578118040421, 2.3078810103713594], 1.987291669067909], [13, [1.415920039112874, -2.3078237824750936], 1.9873040992952136], [10, [-1.4215554175381855, 2.312962683334056], 1.9866905235510723]], "nr_of_basins": 13, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.978064015965626e-162, -8.455857477028221e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [8.055491331652566e-163, 1.0307895840672857e-162, -1.5343669248717737e-162, -1.5215513404338512e-162, -6.963072656770531e-163]}
{"id": "c8f3bf92-93fb-44d2-9ffd-83c4d0501f03", "fitness": 0.5703224241733551, "name": "landscape_perdim_piecewise_phase_ripple", "description": "A completely different separable, non-homogeneous benchmark with per-dimension piecewise phase regions and an outer-region ripple. Each dimension has its own transition thresholds and curvature, ensuring non-uniform appearances across the space while preserving separability and a global minimum at the origin.", "code": "import numpy as np\n\nclass landscape_perdim_piecewise_phase_ripple:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=1000 + self.dim)\n\n        # Per-dimension phase boundaries (four regions)\n        # Region 0: inner quadratic\n        self.a1 = rng.uniform(0.15, 0.65, size=self.dim)\n        # Region 1: middle cubic-like growth\n        self.a2 = rng.uniform(self.a1 + 0.4, self.a1 + 2.2, size=self.dim)\n        # Region 2: outer mid/high-curvature region\n        self.a3 = rng.uniform(self.a2 + 0.4, self.a2 + 2.4, size=self.dim)\n\n        # Per-dimension curvature parameters\n        self.c0 = rng.uniform(0.4, 2.0, size=self.dim)   # inside a1\n        self.c1 = rng.uniform(0.5, 3.0, size=self.dim)   # between a1 and a2\n        self.c2 = rng.uniform(0.2, 2.5, size=self.dim)   # between a2 and a3\n\n        # Outer-region ripple parameters (for non-homogeneous ruggedness)\n        self.r = rng.uniform(0.0, 0.6, size=self.dim)     # ripple amplitude\n        self.omega = rng.uniform(0.5, 3.0, size=self.dim) # ripple frequency\n        self.phase = rng.uniform(0.0, 2*np.pi, size=self.dim) # ripple phase\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        absx = np.abs(x)\n        total = 0.0\n\n        for i in range(self.dim):\n            ai1 = self.a1[i]\n            ai2 = self.a2[i]\n            ai3 = self.a3[i]\n            xi = x[i]\n            ax = absx[i]\n\n            # Region 0: inner quadratic\n            if ax <= ai1:\n                gi = self.c0[i] * (xi ** 2)\n\n            # Region 1: middle cubic-like growth\n            elif ax <= ai2:\n                g0_at_a1 = self.c0[i] * (ai1 ** 2)\n                gi = g0_at_a1 + self.c1[i] * ((ax - ai1) ** 3)\n\n            # Region 2: outer mid/high-curvature\n            elif ax <= ai3:\n                g0_at_a1 = self.c0[i] * (ai1 ** 2)\n                g1_at_a2 = g0_at_a1 + self.c1[i] * ((ai2 - ai1) ** 3)\n                gi = g1_at_a2 + self.c2[i] * ((ax - ai2) ** 4)\n\n            # Region 3: outer rugged region with ripple\n            else:\n                g0_at_a1 = self.c0[i] * (ai1 ** 2)\n                g1_at_a2 = g0_at_a1 + self.c1[i] * ((ai2 - ai1) ** 3)\n                g2_at_a3 = g1_at_a2 + self.c2[i] * ((ai3 - ai2) ** 4)\n                # Ripple is zero at the boundary ai3, ensuring continuity\n                ripple = (\n                    self.r[i] * (np.sin(self.omega[i] * (ax - ai3) + self.phase[i]) ** 2)\n                    - self.r[i] * (np.sin(self.phase[i]) ** 2)\n                )\n                gi = g2_at_a3 + ripple\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_perdim_piecewise_phase_ripple scored on:NOT Homogeneous 0.029, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["968d7bfb-eab0-4605-a96d-9c4e9fc4505c"], "operator": null, "metadata": {"ela_features_2D": [2.3299597050341348e-05, 0.6043491351977395, 0.014607306560821504, 0.06100792214283164, 11.829169642728425, 0.0005903836078499757, 0.7108975937666633, 2.408272697581731, 0.7117974662363442, -0.4291199727698384, -1.1511897040450148, 2.0, 0.5428317515987875, 0.6855085890216849, 0.49130074045227506, 0.349240160672061, -0.1628321649688204, 0.1453915288925894, 0.21982138748408758, 0.3195732416611078, 0.5995541062585644, 0.1395094455259504, 0.222507426326454, 0.31106114474445823, 0.5458198609989575, -0.4467552423925123, -0.40784536008098404, -0.3557006354385924, -0.20934262746290583, -0.4411955809920817, -0.3986383349312247, -0.35323584745578407, -0.23287001885478792, 1.0, 1.0, 1.0, 1.0, 0.5180281566613549, 0.5180136817418075, 0.37830230166294676, 0.3567206957884372, 0.6526176682222358, 0.8578578578578575, 0.07875796910959139, -0.17117117117117112, 0.37389558232931724], "score_NOT Homogeneous_2D": 0.3797774314880371, "score_Separable_2D": 1.0, "ela_features": [-0.00045528951846243173, 0.3723009998904773, 0.003977027631460936, 0.03211162453747256, 12.69758620823327, 0.004897657385702891, 0.9077461868790785, 69.17643805134969, 0.9083633376244625, 1.0072353916733356, 0.518300469295842, 2.0, 0.8422363261878221, 0.8588179544675498, 0.613479335465273, 0.19307553529853477, -0.44359654475956223, 0.5734558736367287, 0.6411711534227245, 0.6994486254436362, 0.7983912232866304, 0.5423185395787764, 0.6153950459149721, 0.6786449836183671, 0.788102016838794, -0.3752545753022288, -0.3156801858205144, -0.2644098330878836, -0.17736545088129935, -0.40495378042954594, -0.34029393497634575, -0.2843299601861381, -0.18748455012532472, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21618564993599118, 0.2161795330670091, 0.19491695362656233, 0.18274258368043067, 0.8120755686543785, 0.4574574574574573, 0.2517814152950168, -0.39539539539539537, 0.5209935897435898], "score_NOT Homogeneous_5D": 0.012733936309814453, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0009277101368287965, 0.4998150107888047, 0.0005172724616037962, 0.023877583516301377, 576.0304430655477, 0.0008741157621901863, 0.8398007711145674, 1835.1276052467024, 0.8399082378533567, 0.19198576124910133, -0.7237427050281526, 1.0, 0.9192378643216628, 0.9227957508256746, 0.6561723352855905, 0.1164732721523635, -0.558348451867218, 0.7390805626989655, 0.7863751696870158, 0.8198049763048907, 0.8741333435716918, 0.731219004827049, 0.7833792976272216, 0.8169453574041956, 0.8730131822046786, -0.33091462977346103, -0.27093337926024325, -0.22853608726233957, -0.15963303935506676, -0.3418313398535247, -0.2754950493953325, -0.232807794624912, -0.16150091173313608, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10937256924446825, 0.10936794278441272, 0.10413971965546462, 0.09971582780908002, 0.8607006116878143, 0.057057057057057006, 0.15927022822389653, -0.5035035035035034, 0.5902321857485988], "score_NOT Homogeneous_10D": 0.029423177242279053, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-5.0, 0.00044444444444512003], 17.16437616252166], [6, [5.0, 0.00044444444444512003], 17.16437616252166], [16, [0.00044444444444512003, -4.920000000000009], 6.777905504913214], [48, [0.00044444444444512003, 0.00044444444444512003], 2.550110121730884e-07], [16, [-0.00027851773249381847, 4.91994793923433], 6.77790542414327], [2, [-5.000321008864931, 4.900003352995266], 23.942279518540175], [2, [5.000389608067925, -4.898004507651851], 23.94227869426355], [2, [5.000459340236421, 4.896005731500224], 23.94227917304226], [2, [-5.0003854264104115, -4.898004418101522], 23.94227977408037]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.4430188110315814e-162, -3.143119127775291e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.36590138903533e-163, 6.542570120719836e-163, 7.688091903566117e-163, 9.243098696413397e-163, 1.029272318358498e-162]}
{"id": "5612eac1-dfed-42e7-a077-33b2a02c5b69", "fitness": 0.977645892354, "name": "landscape_piecewise_rugged_separable_improved", "description": "A three-region separable, non-homogeneous landscape with per-dimension phase transitions. Each dimension has an inner quadratic well, a middle rugged growth region, and an outer rugged/high-order growth region. Non-homogeneity is introduced by dimension-specific thresholds and curvature parameters, preserving separability and a global minimum at the origin. The outer regions include sine-based ruggedness to complicate search while keeping the landscape additive across dimensions.", "code": "import numpy as np\n\nclass landscape_piecewise_rugged_separable_improved:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Per-dimension parameters to induce non-homogeneity and phase transitions\n        # h1: threshold for inner quadratic region\n        # h2: threshold for outer region (two-regime piecewise: inner, middle, outer)\n        self.h1 = np.zeros(self.dim, dtype=float)\n        self.h2 = np.zeros(self.dim, dtype=float)\n\n        # Inner region curvature\n        self.a = np.zeros(self.dim, dtype=float)\n\n        # Middle region (first outer regime) parameters\n        self.b1 = np.zeros(self.dim, dtype=float)\n        self.p1 = np.zeros(self.dim, dtype=float)\n        self.e1 = np.zeros(self.dim, dtype=float)\n        self.qm = np.zeros(self.dim, dtype=float)\n\n        # Outer region parameters\n        self.b2 = np.zeros(self.dim, dtype=float)\n        self.p2 = np.zeros(self.dim, dtype=float)\n        self.e2 = np.zeros(self.dim, dtype=float)\n        self.qo = np.zeros(self.dim, dtype=float)\n\n        # Phase offset per dimension (deterministic)\n        self.phase = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            t = i / max(1, self.dim - 1)  # in [0, 1]\n\n            # Non-homogeneous per-dimension settings\n            self.h1[i] = 0.30 + 0.95 * t        # inner threshold in [0.30, 1.25]\n            self.h2[i] = 1.20 + 2.80 * t        # outer threshold in [1.20, 4.0]\n\n            self.a[i]  = 0.6 + 1.0 * t            # inner curvature in [0.6, 1.6]\n\n            self.b1[i] = 0.30 + 0.90 * t          # middle-region growth coefficient\n            self.p1[i] = 1.4 + 0.4 * t            # middle-region exponent in [1.4, 1.8]\n            self.e1[i] = 0.04 + 0.26 * t           # middle-region ruggedness amplitude\n            self.qm[i] = 5.0 + 4.0 * t             # middle-region ruggedness frequency\n\n            self.b2[i] = 0.25 + 0.80 * t          # outer-region growth coefficient\n            self.p2[i] = 1.6 + 0.9 * t            # outer-region exponent\n            self.e2[i] = 0.05 + 0.25 * t           # outer-region ruggedness amplitude\n            self.qo[i] = 6.0 + 6.0 * t             # outer-region ruggedness frequency\n\n            seed = (i * 7919) % 10000\n            self.phase[i] = (seed / 10000.0) * 2.0 * np.pi  # deterministic phase offset\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.size}\")\n\n        total = 0.0\n        for i in range(self.dim):\n            xi = x[i]\n            absx = abs(xi)\n\n            h1i = self.h1[i]\n            h2i = self.h2[i]\n            ai = self.a[i]\n\n            b1i = self.b1[i]\n            p1i = self.p1[i]\n            e1i = self.e1[i]\n            qmi = self.qm[i]\n            phasei = self.phase[i]\n\n            b2i = self.b2[i]\n            p2i = self.p2[i]\n            e2i = self.e2[i]\n            qi = self.qo[i]\n\n            if absx <= h1i:\n                gi = ai * (xi ** 2)\n            elif absx <= h2i:\n                base1 = ai * (h1i ** 2)\n                rugged_mid = e1i * np.sin(qmi * (absx - h1i) + phasei)\n                gi = base1 + b1i * ((absx - h1i) ** p1i) + rugged_mid\n            else:\n                # Continuity at h2: compute value from middle region at h2\n                base1 = ai * (h1i ** 2)\n                gi_mid_at_h2 = base1 + b1i * ((h2i - h1i) ** p1i) + e1i * np.sin(qmi * (h2i - h1i) + phasei)\n                rugged_outer = e2i * np.sin(qi * (absx - h2i) + phasei)\n                gi = gi_mid_at_h2 + b2i * ((absx - h2i) ** p2i) + rugged_outer\n\n            total += gi\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_piecewise_rugged_separable_improved scored on:NOT Homogeneous 0.874, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e6653185-a62e-4c89-a816-be22a74a92b7"], "operator": null, "metadata": {"ela_features_2D": [-0.0014839549038467847, 0.469326489816145, 0.00669605263729012, 0.046068596831196955, 8.58935737588531, 0.00019298713474800167, 0.9503426293101468, 4.775849276109755, 0.9500790972670732, 0.17696859021224365, -1.2778790691067374, 2.0, 0.676396886052196, 0.7032157168462903, 0.5198816712396239, 0.35048476608382706, -0.16588932853310037, 0.20743495930302328, 0.30269359326680634, 0.411469140843345, 0.6017183976719787, 0.19915328778388916, 0.2689752259502972, 0.36470874427386046, 0.5450346344514235, -0.4147461883427736, -0.3648959378388918, -0.30797265603275326, -0.20842009947066548, -0.4113721372440656, -0.3755081708414577, -0.32633150492112006, -0.23370451999487124, 1.0, 1.0, 1.0, 1.0, 0.5169877399651773, 0.5169808142939346, 0.35566128439265077, 0.35359633854045236, 0.7525224832652435, 0.6536536536536535, 0.5841329578057669, -0.06706706706706707, 0.41566265060240964], "score_NOT Homogeneous_2D": 0.9995201640704181, "score_Separable_2D": 1.0, "ela_features": [-0.00011724427008450445, 0.45397699034398464, 0.0035528109404519607, 0.02987258622192231, 12.336884090115072, 0.0034881544086068804, 0.9609554696938621, 5.208349700583385, 0.9612148136162084, 0.17682731894349848, -0.4936668436338777, 1.0, 0.8731247726180706, 0.8678885031597456, 0.6138108110952819, 0.18763611554689583, -0.4528719610039477, 0.5157588045301432, 0.5794013026636845, 0.6507536029536327, 0.7539208895362361, 0.5033563311545196, 0.5657963934783962, 0.6388757117441026, 0.7481069480494168, -0.42593307580329026, -0.36995419922716916, -0.3071936682812101, -0.21644924069271304, -0.43915767625203833, -0.3839472667680317, -0.3193256700138063, -0.22273895441351063, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21706243989185053, 0.21709247475688062, 0.20074450900718194, 0.18206486965967328, 0.822583504960652, 0.14114114114114112, 0.25961214231309765, -0.3633633633633632, 0.5022435897435897], "score_NOT Homogeneous_5D": 0.9920627567917109, "score_Separable_5D": 1.0, "ela_features_10D": [-0.00045123466652774447, 0.46307791536499987, 0.0007813552403372066, 0.018030489388510453, 176.54112531531467, 0.002174133186603133, 0.9561467371433071, 4.955061838814923, 0.9560622115538372, 0.09734504370986381, -0.20017531644048397, 1.4, 0.9882217991477807, 0.9353679191674502, 0.6978435787920174, 0.10614022758848488, -0.6023680990342558, 0.6659322781173042, 0.7142895172766828, 0.7596770155408753, 0.8277871766915401, 0.6617767106523944, 0.7136367060514366, 0.7602929317828806, 0.8295118719400657, -0.42366410174292035, -0.36233793178047835, -0.3047771197868353, -0.21840010396016757, -0.43004507126883185, -0.3641072351983456, -0.30478220846657306, -0.21677231892574506, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10960929915599385, 0.10960254233666426, 0.10642300608559774, 0.10040558260617165, 0.8565896758363742, -0.11911911911911907, 0.13708762937520452, -0.6196196196196194, 0.5815052041633307], "score_NOT Homogeneous_10D": 0.8742924332618713, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [0.00044444444444512003, -1.6666666666666665], 2.941263801019462], [2, [0.00044444444444512003, 1.666666666666667], 2.9412638010194616], [4, [0.00044444444444512003, 0.00044444444444512003], 4.3456790123588906e-07], [2, [0.00044444444444512003, -4.962000000000004], 10.350340519943446], [4, [0.00044444444444512003, -2.4797777777778105], 4.142455922627777], [4, [0.00044444444444512003, 2.4797777777778114], 4.142455922627777], [8, [-1.773777777777863, 2.4797777777778114], 4.5041698583447864], [8, [-1.773777777777863, -2.4797777777778105], 4.5041698583447864], [8, [-1.773777777777863, 0.00044444444444512003], 0.3617143702849109], [4, [-1.773777777777863, -4.962000000000004], 10.712054455660457], [7, [-0.0017682082238052396, 4.961992389051708], 10.350342285805953], [8, [1.7737777777778638, -2.4797777777778105], 4.5041698583447864], [8, [1.7737777777778638, 2.4797777777778114], 4.5041698583447864], [8, [1.7737777777778638, 0.00044444444444512003], 0.3617143702849108], [4, [1.7737777777778638, -4.962000000000004], 10.712054455660455], [4, [1.7237977511564704, 1.6684942584904652], 3.301959095656485], [4, [1.729802593442333, -1.6687653238037676], 3.3015165093734264], [4, [-1.698910031146089, 1.6690592856949082], 3.3021636914539068], [4, [-1.708904600360405, -1.6689607874515915], 3.301937623146239], [2, [-1.7677552771884602, 4.957001662912486], 10.712505533152418], [1, [1.7563871335451378, 4.951444922330935], 10.714068175364927]], "nr_of_basins": 21, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.3827530177965347e-162, -5.0834227284075024e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-8.034180819165271e-163, -5.919823276230206e-164, -3.8623862801804066e-163, -7.210350599202666e-163, -1.253723313038683e-162]}
{"id": "3439c40a-ec4a-426d-9a80-fd4b10e17e84", "fitness": 0.5001528163750967, "name": "phase_transition_landscape_ext2", "description": "A novel separable, highly non-homogeneous landscape with four-regime phase transitions per dimension, enhanced by explicit per-dimension phase patterns that tilt contributions in different regions. Each dimension carries its own thresholds and curvature, and a small per-region asymmetry is selected by a per-dimension pattern to create non-uniform appearances across the search space while preserving a global minimum at the origin.", "code": "import numpy as np\n\nclass phase_transition_landscape_ext2:\n    \"\"\"\n    A separable, non-homogeneous landscape with four-regime phase transitions per dimension.\n\n    Each coordinate x_i has:\n      - an inner region: |x_i| <= a_i, with quadratic cost alpha_i * x_i^2\n      - a first middle region: a_i < |x_i| <= b_i, with cubic cost beta1_i * (|x_i|-a_i)^3 plus a ripple term\n      - a second middle region: b_i < |x_i| <= c_i, with quartic cost gamma2_i * (|x_i|-b_i)^4 plus a ripple term\n      - an outer region: |x_i| > c_i, with quintic cost gamma3_i * (|x_i|-c_i)^5 plus a ripple term\n\n    In addition, per-dimension phase patterns (0..3) selectively add a small asymmetric tilt\n    in one of the regions to enhance non-homogeneity across the space while keeping the\n    global optimum at the origin (f(0) = 0).\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=2021 + 11 * self.dim)\n\n        # Per-dimension phase boundaries (a < b < c) to induce non-homogeneity\n        self.a = rng.uniform(0.25, 0.9, size=self.dim)\n        self.b = rng.uniform(1.1, 3.0, size=self.dim)\n        self.b = np.maximum(self.b, self.a + 0.25)\n        self.c = rng.uniform(2.6, 5.0, size=self.dim)\n        self.c = np.maximum(self.c, self.b + 0.25)\n\n        # Inner region coefficient\n        self.alpha = rng.uniform(0.3, 2.0, size=self.dim)\n\n        # First middle region (cubic) parameters\n        self.beta1 = rng.uniform(0.4, 2.0, size=self.dim)\n        self.omega1 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase1 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple1 = rng.uniform(0.0, 0.6, size=self.dim)\n\n        # Second middle region (quartic) parameters\n        self.gamma2 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega2 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase2 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple2 = rng.uniform(0.0, 0.7, size=self.dim)\n\n        # Outer region (quintic) parameters\n        self.gamma3 = rng.uniform(0.4, 2.5, size=self.dim)\n        self.omega3 = rng.uniform(0.5, 3.5, size=self.dim)\n        self.phase3 = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n        self.ripple3 = rng.uniform(0.0, 0.8, size=self.dim)\n\n        # Per-dimension phase pattern (0..3) to tilt in different regions\n        # 0: base (no tilt)\n        # 1: tilt applied in inner-middle (region 2)\n        # 2: tilt applied in second-middle (region 3)\n        # 3: tilt applied in outer region (region 4)\n        self.pattern = rng.integers(low=0, high=4, size=self.dim)\n\n        # Per-pattern asymmetry amplitudes (per-dimension)\n        self.asym1 = rng.uniform(0.0, 0.8, size=self.dim)  # for region 2 (delta1 term)\n        self.asym2 = rng.uniform(0.0, 0.8, size=self.dim)  # for region 3 (delta2 term)\n        self.asym3 = rng.uniform(0.0, 0.8, size=self.dim)  # for region 4 (delta3 term)\n\n        # Bounds\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n\n        val = np.zeros(self.dim, dtype=float)\n\n        for i in range(self.dim):\n            xi = x[i]\n            ai = self.a[i]\n            bi = self.b[i]\n            ci = self.c[i]\n\n            absx = abs(xi)\n\n            # Inner region: quadratic\n            if absx <= ai:\n                val[i] = self.alpha[i] * (xi ** 2)\n                continue\n\n            # First middle region: cubic growth with ripple\n            delta1 = absx - ai\n            term = (\n                self.beta1[i] * (delta1 ** 3) +\n                self.ripple1[i] * (np.sin(self.omega1[i] * delta1 + self.phase1[i]) ** 2)\n            )\n\n            # Apply per-pattern tilt in region 2 (only if pattern == 1)\n            if self.pattern[i] == 1:\n                term += self.asym1[i] * delta1 * np.sign(xi)\n\n            if absx <= bi:\n                val[i] = term\n                continue\n\n            # Second middle region: quartic growth with ripple\n            delta2 = absx - bi\n            term2 = (\n                self.gamma2[i] * (delta2 ** 4) +\n                self.ripple2[i] * (np.sin(self.omega2[i] * delta2 + self.phase2[i]) ** 2)\n            )\n\n            # Apply per-pattern tilt in region 3 (only if pattern == 2)\n            if self.pattern[i] == 2:\n                term2 += self.asym2[i] * (delta2 ** 2) * np.sign(xi)\n\n            if absx <= ci:\n                val[i] = term2\n                continue\n\n            # Outer region: quintic growth with ripple\n            delta3 = absx - ci\n            term3 = (\n                self.gamma3[i] * (delta3 ** 5) +\n                self.ripple3[i] * (np.sin(self.omega3[i] * delta3 + self.phase3[i]) ** 2)\n            )\n\n            # Apply per-pattern tilt in outer region (only if pattern == 3)\n            if self.pattern[i] == 3:\n                term3 += self.asym3[i] * delta3 * np.sign(xi)\n\n            val[i] = term3\n\n        return float(np.sum(val))", "configspace": "", "generation": 3, "feedback": "The optimization landscape phase_transition_landscape_ext2 scored on:NOT Homogeneous 0.000, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["5b213c46-7738-4da8-9471-5da91cd68d1c"], "operator": null, "metadata": {"ela_features_2D": [0.002026262853233063, 0.1398555165800936, 0.012156339411862328, 0.03568037040833126, 4.026381435210052, 0.0019162904154640613, 0.05586474023966004, 5.756247092928317, 0.05358865275583515, 2.398491433436848, 6.367579226172995, 3.0, 0.2635360433536921, 0.5709873764834501, 0.21573122070962789, 0.3992635372734429, -0.3454224452974659, 0.8253337166123164, 0.80503248065415, 0.8287219320513832, 0.8572196507940062, 0.8295478341622318, 0.8003798486383019, 0.8118036458830218, 0.8349795253326734, -0.09134241267099721, -0.10201089086034369, -0.08964287927672918, -0.07473877958948864, -0.08736790333893409, -0.10247635425063026, -0.09668567610621107, -0.0848061325482975, 1.0, 1.0, 1.0, 1.0, 0.5181190629222364, 0.5180088820143569, 0.43961123925828793, 0.36005924066447725, 0.7428863965739725, 1.4424424424424422, 0.5239216391494139, 0.1611611611611611, 0.5048192771084338], "score_NOT Homogeneous_2D": 0.0003565549850463867, "score_Separable_2D": 1.0, "ela_features": [-0.0021230199738503596, 0.15977622949321474, 0.0036485773021609643, 0.01865019852836481, 10.373377918380589, -0.003022692116934422, 0.18675001721795362, 156.57347762537955, 0.1935816204488128, 1.649429119780344, 2.462976595074546, 2.2, 0.5434461592970579, 0.7922145686379946, 0.43446670013056526, 0.2421449342592214, -0.4205317390989197, 0.8498613665718775, 0.8580151873319357, 0.8677340689956793, 0.8906270415434794, 0.8348336138082072, 0.8440212446653316, 0.8544226828205383, 0.8807369983549347, -0.13201460905274567, -0.12483939034634964, -0.11629517129588544, -0.09616803659936242, -0.1458661275950856, -0.13774204392912834, -0.12855357826879846, -0.10531970439551411, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21888526290218452, 0.21887738955481328, 0.2037214420201639, 0.18348504057176654, 0.7886735042131108, 0.6056056056056054, 0.20693819741072303, -0.2632632632632632, 0.6200320512820513], "score_NOT Homogeneous_5D": 0.00033080577850341797, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0011334904812638769, 0.2071989422374781, 0.001217702065935579, 0.018513058730758397, 21.595302945073705, 0.008653456678021709, 0.6912316369413536, 848.4991490650018, 0.6953469072752709, 1.3752590923740455, 1.4303911500761615, 1.8, 0.7814013672027718, 0.9075190559949702, 0.5429657102186984, 0.13306122016045024, -0.452109409436548, 0.8734233623275613, 0.8813425348782562, 0.8950341662485458, 0.9151015854336018, 0.8718984483387165, 0.8796740605027736, 0.8930622726624371, 0.9139524306929978, -0.16051982527041112, -0.1504746831310249, -0.1331111102825008, -0.10766278918035388, -0.1628888284445134, -0.15299545655092522, -0.13597006183846058, -0.10940864172146166, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11021562492418517, 0.11022249869579426, 0.10626345550545561, 0.10045824078016852, 0.8301188524136768, 0.10910910910910906, 0.12495730698872894, -0.6076076076076073, 0.6273018414731786], "score_NOT Homogeneous_10D": 0.0002295374870300293, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, -2.9748888888889895], -0.02857171917176109], [4, [0.00044444444444512003, -0.7246666666666657], 0.010216582462608068], [4, [0.00044444444444512003, 0.7246666666666661], 0.010216582462608093], [2, [1.989777777777864, -2.9748888888889895], 0.5120857507949432], [2, [1.989777777777864, -0.7246666666666657], 0.5508740524293123], [2, [1.3926666666666667, -2.9748888888889895], 0.07905345259085486], [3, [-1.3926666666666663, -2.9748888888889895], 0.07905345259085485], [3, [-1.3926666666666663, -0.7246666666666657], 0.117841754225224], [2, [-2.1186140822355086, 0.7244148559622949], 0.5124800909014647], [1, [-2.119299082365528, -2.973664021522968], 0.47369204355486766], [2, [-2.1189864677084183, 2.286956201563379], 0.5112458682245787], [1, [-2.1200706231799256, -0.7242198250902194], 0.5124803711089546], [2, [1.3927943835718264, -0.7244143532032933], 0.11784147213028542], [2, [-1.3929027193271795, 0.7241579615392904], 0.11784167317220547], [2, [-1.3923533087482123, -4.419417453172855], 0.3596223765635181], [4, [1.3940012669041215, 0.7246033820353144], 0.1178436745926924], [2, [-3.468586371636026, 4.385093155394204], 0.267141274615116], [2, [3.4685912789578444, 4.385127664366907], 0.26713585125654815], [2, [3.468077036573778, -4.2563559356505545], 0.31363262934774744], [2, [-0.006246654733229598, -4.231875051302947], 0.3136020997436246], [4, [3.469329869730642, -2.93365598836416], -0.01512051919549737], [4, [-3.468914306181574, -2.931877037733269], -0.01504866726500987], [4, [3.4688639120927944, 2.288511581107049], 0.021002738207825854], [4, [1.392522911141598, 2.286993623105087], 0.11661313440015986], [4, [3.4676705577852966, -0.7246458172998147], 0.021898145189155824], [4, [3.4676512264497186, 0.7253366331191148], 0.021896202123074818], [4, [-3.4688639226612064, 2.2885222294038643], 0.021003931256904113], [4, [-3.467666216622156, 0.7254045796437024], 0.02189845779370021], [4, [-3.46765218889126, -0.72403139170986], 0.02189671857479331], [2, [-0.0014735764528693606, 4.419246489255904], 0.25200100720002516], [2, [-3.467929972422671, -4.2590988914682635], 0.31232719164306516], [2, [-1.3929016226528863, 2.287164200713007], 0.11663035172325492], [4, [0.00044444444444512003, 2.2877777777778325], 0.009073940096149747], [2, [0.7950919347483593, 4.425776399783032], 0.5401113396621515], [2, [0.7950015742335261, -4.4124632909371995], 0.5401634499897403], [2, [-0.7950805850690575, 4.428006463913383], 0.5401709668349752]], "nr_of_basins": 36, "f_opt_dim_2": -0.028572127828652857, "x_opt_dim_2": [-2.9878931920762754e-10, -2.9747483085938513], "f_opt_dim_5": -0.11134801012796727, "x_opt_dim_5": [-0.7762440012528247, 1.4018284540167035e-09, -1.064645885135245, 8.124836494309297e-10, -3.988121662853245e-10]}
{"id": "92164774-59c4-44d0-84d4-6fa4c038530b", "fitness": 0.9137139456967512, "name": "landscape_phased_nonuniform_separable", "description": "A completely different separable, non-homogeneous landscape with per-dimension phase boundaries creating three regions (inner quadratic, middle higher-curvature, and outer curved growth with a per-dimension ripple). Each dimension has its own thresholds and curvature, ensuring non-uniform appearances while preserving separability. The global optimum is at the origin (value 0).", "code": "import numpy as np\n\nclass landscape_phased_nonuniform_separable:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed=3031 + self.dim)\n\n        # Per-dimension phase boundaries (three regions per dimension)\n        # t1 defines inner region, t2 defines outer boundary for the middle region\n        self.t1 = rng.uniform(0.25, 1.0, size=self.dim)\n        self.t2 = rng.uniform(2.0, 4.0, size=self.dim)\n        # Ensure t2 is strictly larger than t1 to form three distinct regions\n        self.t2 = np.maximum(self.t2, self.t1 + 0.5)\n\n        # Curvature parameters per dimension for the three regions\n        self.alpha1 = rng.uniform(0.4, 1.8, size=self.dim)  # inner quadratic\n        self.alpha2 = rng.uniform(0.6, 3.0, size=self.dim)  # middle regime\n        self.alpha3 = rng.uniform(0.8, 4.0, size=self.dim)  # outer growth\n\n        # Outer-region ripple (ruggedness) parameters\n        self.ripple_amp = rng.uniform(0.0, 0.5, size=self.dim)\n        self.ripple_freq = rng.uniform(0.5, 3.0, size=self.dim)\n        self.ripple_phase = rng.uniform(0.0, 2 * np.pi, size=self.dim)\n\n        # Bounds for the domain\n        self.lb = -5.0\n        self.ub = 5.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input vector has incorrect dimension.\")\n        absx = np.abs(x)\n\n        # Per-dimension accumulation\n        val = np.zeros(self.dim, dtype=float)\n\n        # Region 0: inner quadratic (|x| <= t1)\n        inside0 = absx <= self.t1\n        if np.any(inside0):\n            idx = inside0\n            val[idx] = self.alpha1[idx] * (x[idx] ** 2)\n\n        # Region 1: middle regime (t1 < |x| <= t2)\n        region1 = (absx > self.t1) & (absx <= self.t2)\n        if np.any(region1):\n            idx = region1\n            val[idx] = (\n                self.alpha2[idx] * ((absx[idx] - self.t1[idx]) ** 2) +\n                self.alpha1[idx] * (self.t1[idx] ** 2)\n            )\n\n        # Region 2: outer regime (|x| > t2) with a per-dimension ripple\n        region2 = absx > self.t2\n        if np.any(region2):\n            idx = region2\n            base2 = (\n                self.alpha3[idx] * ((absx[idx] - self.t2[idx]) ** 2) +\n                self.alpha2[idx] * ((self.t2[idx] - self.t1[idx]) ** 2) +\n                self.alpha1[idx] * (self.t1[idx] ** 2)\n            )\n            # Continuity-corrected ripple so the contribution is zero at the boundary\n            ripple = (\n                self.ripple_amp[idx] * (\n                    np.sin(self.ripple_freq[idx] * (absx[idx] - self.t2[idx]) + self.ripple_phase[idx])\n                    ** 2\n                )\n                - self.ripple_amp[idx] * (np.sin(self.ripple_phase[idx]) ** 2)\n            )\n            val[idx] = base2 + ripple\n\n        return float(np.sum(val))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_phased_nonuniform_separable scored on:NOT Homogeneous 0.695, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["968d7bfb-eab0-4605-a96d-9c4e9fc4505c"], "operator": null, "metadata": {"ela_features_2D": [-0.0022201198629489215, 0.4301109246642853, 0.017931902667664704, 0.027821222396686367, 1.7604540695988475, 0.003622564626494529, 0.9426433017357079, 1.6209876737981321, 0.9429172293836775, 0.1024271370227191, -0.996735908020573, 2.6, 0.7087064116234126, 0.7242389897697714, 0.5585840578657326, 0.3321421156306722, -0.1825384391237914, 0.13270920982626325, 0.20523355047050823, 0.2988415760079944, 0.4815582077714504, 0.13667472180818377, 0.20643387267788493, 0.2992471958715825, 0.48000453752337735, -0.4537615513430147, -0.4158114890718035, -0.3668351379633704, -0.27123878985267585, -0.44313724441328695, -0.4073176470176721, -0.3596759984265968, -0.2668963499229308, 1.0, 1.0, 1.0, 1.0, 0.5213338486309407, 0.5213261360708739, 0.3726485472346602, 0.3549839784091733, 0.7086401758778562, 0.5015015015015013, 0.5851001318194822, -0.09509509509509509, 0.3698795180722892], "score_NOT Homogeneous_2D": 0.8775112181901932, "score_Separable_2D": 1.0, "ela_features": [-0.001443293280497282, 0.44064046291628217, 0.004160383730820769, 0.022644937087077342, 6.834289319924079, -0.0017308621681347614, 0.9618595595718317, 3.1602713281586583, 0.9623230332249809, 0.15488306428087706, -0.4593882493575482, 1.0, 0.887065843644551, 0.8690074607384062, 0.6326334527309948, 0.18455941075078347, -0.4569858474899579, 0.4495589253327784, 0.5400212124926513, 0.6215734666936175, 0.7362452875367961, 0.4475601735881168, 0.5341276184255247, 0.6156483051306273, 0.7331282869482819, -0.4842567255625454, -0.40466874915286366, -0.3329222831096789, -0.2320392699106873, -0.4887231060809382, -0.4121305616100478, -0.3400142083372347, -0.2360848127927179, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21299115598008211, 0.2129872496481963, 0.19584563074040343, 0.17977522906205032, 0.8201624406315144, 0.1731731731731731, 0.23805358628726273, -0.3513513513513512, 0.4950320512820513], "score_NOT Homogeneous_5D": 0.9098563864827156, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0012891686481214081, 0.4380907161955017, 0.0006944534635012489, 0.016306745500919487, 154.2045376141253, 0.005716975369279132, 0.9527114507767862, 3.62562886886409, 0.953424272303066, 0.1745877878332884, -0.15858593695223303, 1.0, 0.9978861997748266, 0.9359342551289265, 0.700048851870217, 0.10659545896700628, -0.6061082061013765, 0.6518014308920888, 0.7073751120249094, 0.7550741035230477, 0.8264201618431757, 0.6517832348049607, 0.7083663891911305, 0.7566884798511664, 0.8290458320696306, -0.4416237730005507, -0.37113903193685316, -0.31064177668242554, -0.22015285920598432, -0.4428663977639088, -0.3709017901826289, -0.30944350412415755, -0.2174196250779729, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1108413557345258, 0.11085006182350599, 0.10765069867659575, 0.1009610268788105, 0.8559784537636673, -0.11111111111111112, 0.14360583709267405, -0.6196196196196194, 0.5811048839071258], "score_NOT Homogeneous_10D": 0.6949160695075989, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[36, [0.00044444444444512003, 0.00044444444444512003], 3.5364361436498905e-07], [14, [0.00044444444444512003, -2.7768888888890113], 9.024461895486468], [10, [0.00044444444444512003, 2.776000000000245], 9.024463015943065], [4, [3.859697746356848, 2.777453089283037], 28.702054414515576], [5, [3.858899679512453, -2.775777806887379], 28.702054452091343], [11, [3.859877620720529, 0.00028536033713256], 19.67759249512948], [6, [-3.858844768325113, -2.774904798918153], 28.702059351286984], [8, [-3.858888888888892, 0.00044444444444512003], 19.677591036830727], [6, [-3.858800365430212, 2.77401737227383], 28.702067375057716]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [4.4372122995393304e-163, -8.46420887843848e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [5.3004053295306354e-163, 4.548104675704533e-163, -1.679595057157281e-163, -1.200727406460711e-162, 1.287017532859532e-163]}
{"id": "2431cda6-2e6f-457e-9e74-0663192c1633", "fitness": 0.8512428076937795, "name": "landscape_nh_phase_blend_two_regs", "description": "A novel separable, non-homogeneous landscape with two-regime phase transitions per dimension. Each dimension has its own thresholds and curvature parameters, creating non-uniform regions across the search space. The function is additive across dimensions, remains separable, and has a global minimum at the origin with value 0.", "code": "import numpy as np\n\nclass landscape_nh_phase_blend_two_regs:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        i = np.arange(self.dim, dtype=float)\n\n        # Per-dimension phase boundaries (two transitions: inner->mid, mid->outer)\n        t1 = 0.25 + 0.15 * (i % 4) + 0.05 * np.sin(i)\n        t1 = np.clip(t1, 0.15, 2.5)\n\n        t2 = 0.9 + 0.20 * ((i * 2) % 5) + 0.05 * np.cos(i)\n        t2 = np.maximum(t2, t1 + 0.2)\n\n        # Per-dimension logistic sharpness for the two transitions\n        k1 = 4.5 + 2.0 * np.sin(i)\n        k2 = 4.5 + 2.0 * np.cos(i * 0.5)\n\n        # Per-dimension curvature scales and ripple parameters\n        a0 = 0.08 + 0.12 * (i / max(1.0, self.dim - 1))          # inner quadratic scale\n        a1 = a0 * (1.3 + (i % 3) * 0.4)                         # middle quadratic scale\n        b1 = 0.25 + 0.15 * ((i * 2) % 4)                        # middle ripple amplitude\n        p1 = 0.8 + 0.4 * (i % 5)                                # middle ripple frequency\n\n        a2 = 0.03 + 0.04 * ((i * 3) % 5)                        # outer quartic scale\n        b2 = 0.15 + 0.1 * ((i + 1) % 4)                         # outer ripple amplitude\n        p2 = 0.6 + 0.25 * ((i * 7) % 6)                         # outer ripple frequency\n\n        self.t1 = t1\n        self.t2 = t2\n        self.k1 = k1\n        self.k2 = k2\n        self.a0 = a0\n        self.a1 = a1\n        self.b1 = b1\n        self.p1 = p1\n        self.a2 = a2\n        self.b2 = b2\n        self.p2 = p2\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        absx = np.abs(x)\n\n        # Per-dimension regime components\n        inner = self.a0 * (x ** 2)\n        mid = self.a1 * (x ** 2) + self.b1 * (1.0 - np.cos(self.p1 * x))\n        outer = self.a2 * (x ** 4) + self.b2 * (1.0 - np.cos(self.p2 * x))\n\n        # Smooth phase transitions (two regimes) per dimension\n        p = 1.0 / (1.0 + np.exp(-self.k1 * (absx - self.t1)))\n        q = 1.0 / (1.0 + np.exp(-self.k2 * (absx - self.t2)))\n\n        # Blend: mostly inner in small x, mid in intermediate x, outer in large x\n        val_i = (1.0 - p) * (1.0 - q) * inner + p * (1.0 - q) * mid + q * outer\n\n        return float(np.sum(val_i))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_phase_blend_two_regs scored on:NOT Homogeneous 0.516, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c035a1e-8ccc-4709-9d1f-f38936d3db9e"], "operator": null, "metadata": {"ela_features_2D": [-0.001131980612837702, 0.21065067267478602, 0.004621369747755375, 0.037407794622071916, 9.365208113543643, -0.0013578106411263225, 0.9221954898437609, 5.215892424952188, 0.9234081145852869, 1.2716097698451372, 0.5786872940720309, 1.6, 0.719705790259068, 0.7227195670099855, 0.5742007269391552, 0.3349211288357152, -0.2075735530572172, 0.16517182824461604, 0.2368972295356247, 0.3298005466730345, 0.5073334087348897, 0.1595674096744307, 0.22521820376852605, 0.31863013506709226, 0.4980830023478527, -0.43685149644436566, -0.399312841314357, -0.3507024602067773, -0.25780261332493937, -0.4319822214150307, -0.3982375593151941, -0.3502204295121355, -0.2579814406919332, 1.0, 1.0, 1.0, 1.0, 0.5192807915296347, 0.5192774795794718, 0.3858090849209626, 0.356479968797048, 0.6190839203351345, 0.7697697697697696, 0.29956801634200625, -0.2472472472472472, 0.3670682730923695], "score_NOT Homogeneous_2D": 0.9752434622496367, "score_Separable_2D": 1.0, "ela_features": [-0.0015858077789840496, 0.28696409884148577, 0.002848060070904356, 0.023115448149297068, 16.912497296573793, 0.0014608775071851098, 0.9200288562171671, 6.254187495640759, 0.9203842571410379, 0.7500616939576362, 0.12109107071530953, 1.4, 0.9107024156689599, 0.8769210388590019, 0.6514524662896671, 0.17991093550035234, -0.48457717929172867, 0.4610357537541381, 0.5427260610304342, 0.6179888143265816, 0.7420392954830641, 0.4598293404766875, 0.5391921500843659, 0.6164990986247425, 0.7404801125820137, -0.4741458351226531, -0.40228040500720086, -0.33606989408849336, -0.2269375857701328, -0.4776754555233995, -0.40749770365476595, -0.33913633096261275, -0.2294977287247991, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2166085636099336, 0.2165683227086989, 0.19981574677170472, 0.1815244349063214, 0.8080618140745488, 0.30130130130130117, 0.24812547718735112, -0.28328328328328317, 0.5309294871794872], "score_NOT Homogeneous_5D": 0.6163283288478851, "score_Separable_5D": 1.0, "ela_features_10D": [0.00032412269047199516, 0.35540521876635883, 0.0013146465142330984, 0.020476823321720735, 28.26646954415433, 0.005288654476347632, 0.9198215908951471, 6.362232563434592, 0.9210111378213564, 0.5368286992914685, 0.10663072947282162, 1.4, 0.9960334769919553, 0.9354573466776165, 0.6938327330062356, 0.10804067182578647, -0.5810511143809907, 0.6389405142988014, 0.7062960964632383, 0.7607309120155236, 0.8352355079705485, 0.6386233675668485, 0.7059462753987555, 0.7607172047639679, 0.8367318310402464, -0.4579255265907028, -0.3724992663394856, -0.30346056213880573, -0.2089679671785535, -0.4595619328631423, -0.37394662882046276, -0.3042937672534096, -0.20762679018249322, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10923866460035067, 0.10922676022033843, 0.10570101030748653, 0.09982009031341843, 0.8578549199499438, -0.027027027027027018, 0.13690978494684258, -0.5915915915915914, 0.6007205764611689], "score_NOT Homogeneous_10D": 0.515885055065155, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 6.679991533184563e-08]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [5.616637373768089e-162, 2.8982094735451506e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-5.421691567589243e-162, 3.507543896530397e-163, -4.030691145842072e-162, 1.4704780720598501e-162, -3.493427111400401e-162]}
{"id": "2429e51f-9980-455f-8dae-4945a32f3df4", "fitness": 0.9032935931657752, "name": "landscape_nh_phase_two_enhanced_separable", "description": "A novel, highly non-homogeneous, explicitly block-separable landscape with per-dimension phase transitions across two regimes. Each dimension has its own transition thresholds and curvature, and the function is computed additively across blocks of dimensions to emphasize clear, block-wise separability. The global optimum remains at the origin with value 0. The per-dimension contributions follow inner quadratic to mid/high-curvature and outer quartic growth with small ripples, while no cross-dimension terms exist. The explicit block structure encourages solver approaches to exploit block-wise decomposition while preserving non-homogeneous, phase-transition behavior.", "code": "import numpy as np\n\nclass landscape_nh_phase_two_enhanced_separable:\n    def __init__(self, dim=5, blocks=None):\n        self.dim = int(dim)\n        if self.dim <= 0:\n            raise ValueError(\"dim must be a positive integer\")\n\n        # Determine block structure to emphasize explicit separability\n        if blocks is None:\n            # Choose a reasonable number of blocks (up to 4 or as many as dims allow)\n            self.blocks = int(min(max(1, self.dim // 2), 4))\n        else:\n            self.blocks = int(blocks)\n            if self.blocks <= 0:\n                raise ValueError(\"blocks must be a positive integer\")\n\n        # Build a partition of dimensions into blocks as evenly as possible\n        base = self.dim // self.blocks\n        rem = self.dim % self.blocks\n        self.block_indices = []\n        start = 0\n        for b in range(self.blocks):\n            size = base + (1 if b < rem else 0)\n            idx = np.arange(start, start + size, dtype=int)\n            self.block_indices.append(idx)\n            start += size\n\n        # Per-dimension, non-homogeneous phase boundaries (two transitions)\n        # t1: inner -> mid boundary, t2: mid -> outer boundary\n        indices = np.arange(self.dim, dtype=float)\n        t1 = 0.6 + 0.25 * (indices % 4) + 0.1 * np.sin(indices)\n        t1 = np.clip(t1, 0.2, 4.0)\n\n        t2 = 1.7 + 0.25 * ((indices * 5) % 6) + 0.1 * np.cos(indices * 1.3)\n        t2 = np.maximum(t2, t1 + 0.25)\n\n        # Per-dimension transition sharpness (logistic blending)\n        k1 = 6.0 + 2.0 * np.sin(indices)\n        k2 = 6.0 + 2.0 * np.cos(indices * 0.7)\n\n        # Per-dimension curvature scalings (non-homogeneous)\n        a_quad0 = 0.4 + 0.6 * (indices / max(1.0, self.dim - 1))       # inner quadratic\n        a_quad1 = a_quad0 * (1.25 + 0.5 * (indices % 3))                 # middle (higher curvature)\n        a_quartic = 0.16 + 0.08 * ((indices * 4) % 5) / 4.0          # outer quartic growth\n\n        # Per-dimension outer-region ripple (to break smoothness in a separable way)\n        ripple_amp = 0.04 + 0.018 * (indices % 4)\n        ripple_freq = 0.5 + 0.3 * (indices % 7)\n\n        self.t1 = t1\n        self.t2 = t2\n        self.k1 = k1\n        self.k2 = k2\n        self.a_quad0 = a_quad0\n        self.a_quad1 = a_quad1\n        self.a_quartic = a_quartic\n        self.ripple_amp = ripple_amp\n        self.ripple_freq = ripple_freq\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension {x.shape[0]} does not match landscape dimension {self.dim}.\")\n\n        r = np.abs(x)\n\n        # Per-dimension smooth phase blending (inner -> mid -> outer)\n        u = 1.0 / (1.0 + np.exp(-self.k1 * (r - self.t1)))\n        v = 1.0 / (1.0 + np.exp(-self.k2 * (r - self.t2)))\n\n        inner = self.a_quad0 * (x ** 2)\n        mid = self.a_quad1 * (x ** 2)\n        quart = self.a_quartic * (x ** 4) + self.ripple_amp * np.sin(self.ripple_freq * x)\n\n        val = (1.0 - v) * ( (1.0 - u) * inner + u * mid ) + v * quart\n\n        # Explicit block-based aggregation to highlight separability\n        total = 0.0\n        for idx in self.block_indices:\n            total += float(np.sum(val[idx]))\n\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_phase_two_enhanced_separable scored on:NOT Homogeneous 0.935, Separable 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["4c035a1e-8ccc-4709-9d1f-f38936d3db9e"], "operator": null, "metadata": {"ela_features_2D": [-0.0028778953530784524, 0.22309805963524654, 0.0070620380468806865, 0.022288426993220582, 5.13955803642727, -0.003057316595609594, 0.9141929616374271, 1.485976836635217, 0.9144995968331655, 1.0320977386626877, 0.42542772050847155, 2.2, 0.728785647944729, 0.7238429950803636, 0.5814429050352043, 0.3380584760560744, -0.23932259948060927, 0.1624919436129244, 0.25324214932190103, 0.3382507656191197, 0.4950808574088693, 0.15988427586182846, 0.2464453236358617, 0.3326105680023905, 0.4985123223556752, -0.43832621902840013, -0.39082660401727254, -0.34633717401066305, -0.2642568495500096, -0.4317179889896736, -0.38721401309904946, -0.3429284531156134, -0.2576818937414621, 1.0, 1.0, 1.0, 1.0, 0.5158698781617359, 0.5158604552497666, 0.41284973192753915, 0.3484437445019262, 0.6280062070682444, 0.6416416416416414, 0.17558890834615576, -0.14314314314314314, 0.38835341365461845], "score_NOT Homogeneous_2D": 0.9846597220748663, "score_Separable_2D": 1.0, "ela_features": [-0.0007355914662615203, 0.27839303877848715, 0.0027788777265902297, 0.02344794446513161, 23.152599391560205, 0.005852565407993504, 0.910700601226717, 1.515933182921379, 0.9112139602231357, 0.629798461421543, 0.1484680323599851, 1.4, 0.909307300862943, 0.8729640515368959, 0.6442080491677649, 0.18487508115558224, -0.49820471995358406, 0.4482053667318217, 0.5316741848370556, 0.6060920098766315, 0.7267727408771085, 0.45423174116666437, 0.5363543907779595, 0.6113673667764891, 0.7299870660982098, -0.48544063108109636, -0.4120085587361437, -0.3465392245790836, -0.24037101565219396, -0.48263421363378284, -0.41001148670750476, -0.34367508597742685, -0.23877864067561633, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21534913819507703, 0.21531329147177636, 0.20078450736205142, 0.18232286967694708, 0.8307394392960624, 0.26526526526526517, 0.2668510656915746, -0.28728728728728725, 0.5410256410256411], "score_NOT Homogeneous_5D": 0.49988603591918945, "score_Separable_5D": 1.0, "ela_features_10D": [-0.0012883927687259878, 0.34344695026147676, 0.0007389455442138542, 0.01672906825014083, 39.73482755480001, 0.0027372473230961036, 0.9159413606363389, 1.5554267867471565, 0.9166538896806584, 0.47106044115160595, 0.09678764206010575, 1.8, 1.0096872715508611, 0.9379592379214341, 0.7027336686453707, 0.10658407213083018, -0.6024172355116741, 0.6304789011499629, 0.6901325402355456, 0.740610304530525, 0.8169559262408361, 0.6333620271586429, 0.6937387767311659, 0.7438342688526662, 0.8205410216752009, -0.468627524004534, -0.3929745978632974, -0.3289582995084689, -0.23213657339714885, -0.4661165220128186, -0.38935826472133805, -0.32566973429437535, -0.2281499838315993, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10900243146269646, 0.1090073916820072, 0.10598779135845413, 0.09926777562288401, 0.864628802406779, -0.07507507507507506, 0.1345655664206459, -0.6236236236236234, 0.6075260208166534], "score_NOT Homogeneous_10D": 0.9352158010005951, "score_Separable_10D": 1.0}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- Separable, meaning independent functions per dimension. Meaning, a problem may be partitioned into subproblems which are then of lower dimensionality and should be considerably easier to solve. (Separable)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [3.2863989307685415e-13, 3.2863989307685415e-13], 3.666575429516755e-21]], "nr_of_basins": 1, "f_opt_dim_2": -7.715795580358877e-17, "x_opt_dim_2": [-1.3842718420850586e-08, -4.275149432327648e-12], "f_opt_dim_5": -1.0336463124399725e-11, "x_opt_dim_5": [-1.3842669798945253e-08, -7.797666853618431e-12, -3.782576891668935e-09, -5.449073686730655e-07, -3.0770481316306606e-06]}
