{"id": "b7269e5e-67b9-41d3-a48d-17c997c42919", "fitness": 0.5504541455690438, "name": "landscape", "description": "A non-homogeneous, phase-transition landscape with strong global-local contrast. The function has three radial zones: an inner smooth bowl (global minimum at 0), a middle oscillatory shell that creates many nonzero local minima due to per-dimension cos modulation, and an outer rugged region with quartic growth. The result is a minimization problem with a clear global minimum at the origin and numerous challenging local minima whose depths depend on tunable parameters, producing a pronounced global-local contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Phase transition radii (in the same units as x, per-dimension bounds are [-5,5])\n        self.r1 = 1.0  # inner region radius\n        self.r2 = 3.0  # middle region radius\n        self.r3 = 5.0  # outer region radius (domain edge)\n\n        # Middle-region oscillation parameters (control local minima depth and frequency)\n        self.a = 0.8   # amplitude factor for cos modulation (0 < a < 1 for positivity)\n        self.b = 3.0   # frequency inside cos(b * x_i)\n\n        # Outer-region ruggedness and cross-term\n        self.e = 0.2    # weight for sum(x)^2 term in outer region\n        self.d = 2.0    # frequency for sin(d * x_i) in outer region (optional, currently unused in f_outer but kept for extensibility)\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region (global minimum at 0)\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: separable oscillatory term that creates many local minima\n        f_mid = float(np.sum(x**2 * (1.0 + self.a * np.cos(self.b * x))))\n\n        # Outer region: rugged growth to enforce phase transition and large values away from origin\n        f_outer = float(np.sum(x**4) + self.e * (np.sum(x))**2)\n\n        # Phase-transition weights (three-region partition of unity along the radial coordinate)\n        s1 = self._smoothstep(self.r1, self.r2, r)   # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)   # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        # Blended landscape Value\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.859, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0024386691898631964, 0.20046722828636399, 0.006358094852361626, 0.02760774600308922, 25.187490687692595, 0.007669770486846095, 0.8817104631233089, 1.0148315466718505, 0.8843611753709647, 1.0299960803264296, 0.1506017244577124, 2.0, 0.5723668308173162, 0.6954766712870759, 0.4578367947252249, 0.35102572167916396, -0.20940510200322607, 0.1532981001714068, 0.22888323162474594, 0.35096107616643896, 0.5298717436606826, 0.1626201560201992, 0.23628755110022742, 0.34061619895564765, 0.5257408187799386, -0.4431133873393473, -0.4035562670547453, -0.3396721892712587, -0.24603292086371553, -0.43061525912524223, -0.3927231096655208, -0.3390772127762204, -0.24386500029562613, 1.0, 1.0, 1.0, 1.0, 0.5203361900730097, 0.5203288978682703, 0.39617860109560166, 0.350537043939627, 0.5757111462156537, 0.6816816816816814, 0.2617014057795083, -0.21521521521521514, 0.3899598393574297], "score_NOT Homogeneous_2D": 0.9278313517570496, "score_GlobalLocal_2D": 0.978923499584198, "ela_features": [-0.000922150016106138, 0.2796432080945267, 0.0019068705894929208, 0.02463885889485417, 32.80273254245183, 0.0010338765531169968, 0.9268202958344313, 1.0375574026025842, 0.9277791306550245, 0.6306771825239867, 0.3140582235498279, 1.4, 0.9183304123370346, 0.87434539924071, 0.647555793174394, 0.1842315762800612, -0.4950461244385621, 0.42657395996216, 0.5088025488550415, 0.591021962087436, 0.7193804654977825, 0.42524192793138926, 0.5126677208656953, 0.5943799630881689, 0.723299645719355, -0.5042330426075027, -0.4319271686781259, -0.35962952568455875, -0.2467592182283888, -0.5074901578316651, -0.4302959464788664, -0.3581479557752897, -0.2443167077102244, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21924267448962026, 0.2192406354604428, 0.20460026466202508, 0.18440389401305418, 0.8271099713702508, 0.23323323323323314, 0.2623718658730608, -0.3233233233233232, 0.539423076923077], "score_NOT Homogeneous_5D": 0.535590410232544, "score_GlobalLocal_5D": 0.0009350752807222307, "ela_features_10D": [0.00022405248951429257, 0.38002297236890314, 0.001703526761097706, 0.0221768347831399, 57.826676807704, 0.010710817213920532, 0.918025520304521, 1.0516839701069007, 0.9205528641539222, 0.41693318501037746, 0.04198808007224528, 1.2, 1.0084113112096758, 0.9383765918293591, 0.7097987249281097, 0.10458184112466898, -0.6051568014100834, 0.6201024822253616, 0.6842072042774918, 0.7349680406767215, 0.8125302839166935, 0.623684773750079, 0.6872381527382334, 0.7384559055870678, 0.8161210224369844, -0.481748385404935, -0.40045791825745036, -0.336088020067735, -0.23773091912265837, -0.478396721233415, -0.39760699519185255, -0.3324950432648051, -0.23376088017115393, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11135381945295866, 0.11135037601257555, 0.10803777924900719, 0.1021098268783462, 0.8610189602534606, -0.055055055055055056, 0.1461256092099701, -0.6036036036036034, 0.6039231385108086], "score_NOT Homogeneous_10D": 0.8590807169675827, "score_GlobalLocal_10D": 0.000363819592166692}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [18, [-3.0401993273612304, 0.0004122333097595129], 2.2897573838131224], [23, [-0.00039767825587574577, -3.04033947675619], 2.289755543798905], [23, [3.040096013271867, -0.014255807098259417], 2.290274441917825], [20, [-0.0018697600697304983, 3.040489116309936], 2.289761953038164]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-8.78781884370627e-163, 5.419660094846802e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [3.512361740657392e-163, 1.076145143596189e-162, -1.286265669066241e-162, 9.678783371812999e-163, 3.863645921768625e-163]}
{"id": "1a166baf-2a6f-4dc9-8f77-5abb43906884", "fitness": 0.5075101170417232, "name": "landscape", "description": "A non-homogeneous, multi-well landscape built as the lower envelope of a grid of quadratic wells. Each well is centered at grid points inside [-5,5]^dim. The origin is assigned the deepest well, making it the global minimum, while other grid centers create local minima with shallower depths. The landscape exhibits phase-transition-like boundaries where the controlling well switches, creating non-homogeneous regions and a clear global-local minima contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        \n        # Grid of centers per dimension. These are inside [-5, 5].\n        grid_vals = [-2.0, 0.0, 2.0]  # can be adjusted to alter density of wells\n        grids = [np.array(grid_vals) for _ in range(self.dim)]\n        \n        # Build centers as the cartesian product of grid_vals\n        meshes = np.meshgrid(*grids, indexing='ij')\n        centers = np.stack([m.flatten() for m in meshes], axis=-1)  # shape (M, dim)\n        self.centers = centers\n        self.M = centers.shape[0]\n        \n        # Depths for each center: origin center has the deepest well.\n        origin_mask = np.all(np.isclose(self.centers, 0.0), axis=1)\n        if not origin_mask.any():\n            raise ValueError(\"Origin center (0,...,0) not found in the grid.\")\n        \n        # Depths: deeper for origin, shallower for others\n        depth_origin = 4 * self.dim + 2  # ensure origin is the global minimum\n        depth_other = 1.0\n        depths = np.full(self.M, fill_value=depth_other, dtype=float)\n        depths[origin_mask] = depth_origin\n        self.depths = depths\n        self.depth_origin = depth_origin\n        self.grid_min = -5.0\n        self.grid_max = 5.0\n\n    def f(self, x):\n        \"\"\"\n        Black-box minimization target.\n        f(x) = min_j ( ||x - c_j||^2 - depth_j ), where c_j are grid centers.\n        The global minimum is at the origin with value -depth_origin.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n        \n        # Compute squared distances to all centers\n        diff = x - self.centers  # shape (M, dim)\n        dist2 = np.sum(diff**2, axis=1)  # shape (M,)\n        \n        # Evaluate the lower envelope (min over centers)\n        values = dist2 - self.depths  # shape (M,)\n        return float(np.min(values))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.571, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0030877945283524165, 0.45022239967471844, 0.00685922192558477, 0.020500241226879053, 5.718875585071406, -0.0012223859461640175, 0.9154154793691356, 1.033572525961778, 0.9631802897220055, -0.22048932882304859, -0.519244263520518, 2.0, 0.7497739164088498, 0.7335695776077212, 0.5957333815561068, 0.329594760056634, -0.22243950129319406, 0.14031871487913908, 0.2236439572764203, 0.3074974077735493, 0.4856041992847163, 0.1390884044447793, 0.22087844887050173, 0.309699846633368, 0.4872577048908548, -0.4497194771373042, -0.4061327557100073, -0.36226403540876895, -0.2690884611131373, -0.44210941293641054, -0.4001150587431419, -0.3544865331364037, -0.26329563675584805, 1.0, 1.0, 1.0, 1.0, 0.5156916558853428, 0.5156707927438302, 0.40482101020812494, 0.34797059458076757, 0.7158747830608055, 0.42142142142142125, 0.5967069510156655, -0.023023023023023025, 0.35180722891566263], "score_NOT Homogeneous_2D": 0.8165392726659775, "score_GlobalLocal_2D": 0.9842461347579956, "ela_features": [-0.0010060498402401751, 0.5247176324891927, 0.0031715738192369947, 0.017331975395863456, 6.938572799693397, -0.0018197996406374762, 0.8774056546854256, 1.0471751435173493, 0.9291128523676464, -0.5831343137751721, 1.1354637435011605, 1.6, 0.9057674779463658, 0.8721030503990816, 0.6356220856009377, 0.18561418464949864, -0.5269685950837547, 0.42348033163839205, 0.5199676237501822, 0.5962324912775595, 0.7267884801046881, 0.4266258743879526, 0.5222939107085776, 0.5983176824454247, 0.729046415314898, -0.5072083662731146, -0.4223202650216539, -0.35522415199556, -0.24036445917633392, -0.5071533411723239, -0.42253013984643895, -0.355286491419856, -0.2396569097148297, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2128297341852609, 0.21281092129084533, 0.20295074224266835, 0.17974612661777817, 0.8400052495251936, 0.11711711711711707, 0.2245571621591156, -0.42742742742742734, 0.5421474358974359], "score_NOT Homogeneous_5D": 0.6729117929935455, "score_GlobalLocal_5D": 0.0003771189658436924, "ela_features_10D": [0.00025025238941902563, 0.5888768258428914, 0.0005787229702042445, 0.016332906946451814, 52.231915375961954, 0.002712243630340727, 0.8758912768494038, 1.0609070364279707, 0.9011925781702944, -0.4322404245944287, 1.7534898686482805, 2.0, 1.0167400487876703, 0.9368331704836008, 0.7031792919339781, 0.1079949879360014, -0.660070994138614, 0.6106999884328314, 0.6754774788235921, 0.7348733923512123, 0.8196195513464406, 0.6155329141582072, 0.679309871135116, 0.7380344529719702, 0.8226222017718474, -0.4937353181225845, -0.41158049356291215, -0.3362506077308522, -0.22876996208884956, -0.48892522871086336, -0.40782050624014926, -0.3331404037240972, -0.22557022805985372, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.110703169805758, 0.1107022728993318, 0.10892812602256138, 0.10152270500966838, 0.8531362018659557, -0.1551551551551551, 0.09675219639457185, -0.7837837837837835, 0.6036829463570856], "score_NOT Homogeneous_10D": 0.5705487728118896, "score_GlobalLocal_10D": 0.00043761005508713424}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], -9.999999604938271]], "nr_of_basins": 1, "f_opt_dim_2": -10.0, "x_opt_dim_2": [1.1745357805700754e-08, -4.106996395996541e-09], "f_opt_dim_5": -22.0, "x_opt_dim_5": [-1.3586591362081065e-08, 2.939283669849769e-08, 1.1329400229060738e-08, 1.3748037434797679e-08, -7.660073892263405e-09]}
{"id": "cf3cc324-d950-4701-91fb-e48e97d3fea2", "fitness": 0.6105608946333329, "name": "landscape", "description": "A non-homogeneous optimization landscape with phase-transition regions. The domain is partitioned into cells along the axes; cells with even parity use a simple convex quadratic basin, while cells with odd parity use a multi-modal Rastringin-like landscape. The transitions between cells create non-homogeneous search regions (phase transitions). The global minimum is at the origin with f(0)=0, while the odd-parity regions introduce pronounced local minima, yielding a strong global-local minima contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # cell width that defines phase regions along each axis\n        self.cell_size = 2.0\n\n    def _region_parity(self, x):\n        # Determine a global parity for the region containing x\n        # by XOR-ing the parity of cell indices across dimensions.\n        parity = 0\n        for i in range(self.dim):\n            # map x[i] from [-5,5] to a cell index in [0, ..., floor(10/cell_size)]\n            cell_i = int(np.floor((x[i] + 5.0) / self.cell_size))\n            parity ^= (cell_i & 1)\n        return parity\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).flatten()\n        if x.size != self.dim:\n            raise ValueError(f\"x must be of length {self.dim}\")\n\n        region = self._region_parity(x)\n        if region == 0:\n            # Region 0: simple convex quadratic basin\n            return float(np.sum(x**2))\n        else:\n            # Region 1: multi-modal Rastringin-like landscape\n            A = 10.0\n            return float(A * self.dim + np.sum(x**2 - A * np.cos(2 * np.pi * x)))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.491, GlobalLocal 0.133,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [-0.0002135507693359351, 0.4080737906607569, 0.015693456912894865, 0.04217625598031806, 2.791388169712991, -0.0012962370777609643, 0.38664135240214714, 1.0997443966214537, 0.40238340938456485, 0.28051829100987835, -0.8241927958877568, 1.8, 0.5306460729225445, 0.6454357953660899, 0.47370552045601766, 0.3849614053405302, -0.40121473135836255, 0.16571538951579942, 0.2698959124660322, 0.4255067335601872, 0.6451155749253907, 0.1675475827622653, 0.27164767732830797, 0.43021820498719776, 0.6455676283862978, -0.436486961891994, -0.3819907449545584, -0.30057489288823774, -0.18567533037838277, -0.4280292661455255, -0.3745187130148975, -0.2929827363021208, -0.18224624417320023, 1.0, 1.0, 1.0, 1.0, 0.5143627915937887, 0.5143506602987256, 0.3858959957440365, 0.3541718770658468, 0.7533170855669036, 1.1581581581581577, 0.8546078650755188, 0.44144144144144126, 0.4734939759036144], "score_NOT Homogeneous_2D": 0.946600366383791, "score_GlobalLocal_2D": 0.9950548410415649, "ela_features": [-0.0006190995950708933, 0.4062446662232767, 0.00814327427344515, 0.029708557501983257, 7.188283819171515, -5.345658093669492e-06, 0.27498586925282614, 1.3536197791726265, 0.2722847985428702, 0.28953752788970083, -0.7808008678253708, 1.6, 0.7829361885858188, 0.8388960350727392, 0.5513593361487777, 0.20859555595893758, -0.6167741831695175, 0.4872226940696394, 0.5875871900230102, 0.6750118445990292, 0.8159347397643251, 0.4920413373396908, 0.5897397946854683, 0.6792688842797554, 0.8190430717221495, -0.451040493376419, -0.36276030615006016, -0.2858606385434005, -0.16190443173536992, -0.44909422397472404, -0.3627132083432953, -0.2835593788150073, -0.15998413673993148, 1.0, 1.0, 0.8666666666666668, 1.0, 0.2195823823858402, 0.21958599278826813, 0.19949828074009518, 0.1837934084675617, 0.8733443312254767, 0.6096096096096094, 0.49661165883693076, 0.05305305305305301, 0.6479166666666666], "score_NOT Homogeneous_5D": 0.5547144412994385, "score_GlobalLocal_5D": 0.5421562194824219, "ela_features_10D": [0.0003775438590634783, 0.43599125036794123, 0.0020248941909429452, 0.03190212671288104, 20.932742667290064, 0.0011048928198367004, 0.17635914917498774, 1.4945524159979893, 0.17465482008805983, 0.20408299149409168, -1.167116858109327, 2.0, 0.9021469930984211, 0.9166468432711558, 0.6367196590368656, 0.12218789436169868, -0.5963580408212691, 0.6614802385309394, 0.7265036737489641, 0.7846417482037892, 0.8782325513103458, 0.6657826349349122, 0.7310837830482118, 0.7892282616321289, 0.8826288578793161, -0.42933198091213853, -0.3468646479954289, -0.2731306658744061, -0.15443313297907418, -0.4249811222785529, -0.341945107668373, -0.26801112293862717, -0.14924600538676064, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10998797839993471, 0.10999498287230994, 0.10412984440170989, 0.10047968891911929, 0.8852291697465506, 0.1691691691691691, 0.24531116175195694, -0.26726726726726724, 0.6568454763811049], "score_NOT Homogeneous_10D": 0.49136388301849365, "score_GlobalLocal_10D": 0.13347561657428741}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [2.984956478547319, -4.974000087853257], 33.828419781481934], [2, [-4.974000087852449, 2.984956478235707], 33.828419781469755], [2, [-1.7026666666666666, -5.000000000360287], 27.899073781380647], [1, [-0.9964433759345136, -1.8792845279495773], 7.2682672693935135], [1, [-3.817501487736891, -2.9276428552894784], 30.044960542573577], [1, [-2.979219715942648, -3.9168506724222802], 25.63655721515434], [1, [2.978994692097993, 3.913775877221242], 25.711004866101504], [1, [-3.9062968301325864, 2.9802755937227454], 25.901564637076675], [1, [2.9802655928819632, -3.906125971385229], 25.90621431897751], [1, [-4.881441644755756, 1.9159122706528644], 31.51134209422306], [1, [1.915903608263214, -4.88143539674828], 31.511788421758247], [5, [0.44224604766246406, -3.0001911501319034], 9.196728504002863], [1, [1.963926114060245, -3.893412524880483], 21.431416064984795], [1, [3.903492779556352, -1.9510790397326598], 21.29546257147191], [1, [-3.89340230359537, 1.963922776914589], 21.431769168436695], [1, [-1.952398645812217, 3.9027624221769868], 21.296392308465983], [1, [-3.811598370401426, -1.939977052900695], 25.22012466374248], [1, [3.885934146810245, 1.9464702024746106], 21.909737111557305], [9, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [10, [-1.0005442900942696, 1.4281601374233874], 3.040730254565435], [10, [1.4233665993334854, -1.0000533528277915], 3.0260791846002784], [1, [1.9415491004947913, 3.919827373766806], 21.043668718839363], [1, [0.9947015607760404, 2.985669797169765], 9.949704317204642], [8, [1.4028041136467377, 1.0009334191968586], 2.969727090929324], [1, [2.9368630568749086, 0.9531492040288385], 10.740407044615381], [1, [-4.803648060281716, -1.8744356721850925], 36.235257834524084], [1, [3.889919908178624, 2.910924928344617], 27.428761043780014], [1, [2.9431097400331088, -0.9481017979170205], 10.719844410017782], [9, [3.0011873596103076, 0.4302369835988375], 9.192229429540916], [1, [-0.949376711742364, 2.942872510860991], 10.700736376578234], [9, [0.29599758315247404, 3.001130314588168], 9.09439773437218], [1, [-2.8124827192715713, -0.7606981066467415], 23.99121369016708], [1, [-4.869668619847405, -2.8289552510336424], 40.12647256080187], [1, [-1.8456410314970852, -0.964970493902246], 8.924695256753584], [9, [-2.9827873933238553, -0.001974762691409314], 8.95621942033056], [1, [-1.847846767889368, -3.9315228785948007], 24.014948558379125]], "nr_of_basins": 36, "f_opt_dim_2": 0.0, "x_opt_dim_2": [6.892164168839169e-163, 1.3953781359537198e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.5671603260363358e-162, 5.859820797864131e-163, 6.012068703835826e-163, 1.322162289406312e-162, -9.497545442526048e-164]}
{"id": "41d63599-42ee-4f09-88d6-a1445b3e691c", "fitness": 0.579624617593557, "name": "landscape", "description": "A non-homogeneous benchmark landscape with region-dependent, nonconvex per-dimension wells and a cross-dimension coupling term. The search space is partitioned into regions (phase-transition-like behavior) by the per-dimension region index, causing the appearance of different landscapes across space. The combination yields a global minimum at the origin (0, ..., 0) but with multiple, nontrivial local minima induced by the region-dependent modulation and the coupling term. The function is designed for minimization on [-5, 5]^dim and emphasizes non-homogeneity and perceptible local-global minima contrast.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        # problem dimensionality\n        self.dim = int(dim)\n        # region width along each axis to induce non-homogeneous, phase-transition-like behavior\n        self.region_width = 2.0\n        # maximum region index per axis (based on domain [-5, 5])\n        self.max_region = int(np.floor((10.0) / self.region_width))\n\n    def _region_index(self, xi):\n        # compute discrete region index for a coordinate\n        ri = int(np.floor((float(xi) + 5.0) / self.region_width))\n        if ri < 0:\n            ri = 0\n        if ri > self.max_region:\n            ri = self.max_region\n        return ri\n\n    def f(self, x):\n        # evaluation: x should be a 1-D array of length dim\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input vector length must be equal to dim\")\n\n        # region indices per dimension\n        ri = np.array([self._region_index(float(xi)) for xi in x], dtype=int)\n\n        total = 0.0\n        # per-dimension nonnegative, nonconvex term (zero at origin)\n        for i in range(self.dim):\n            # region-dependent amplitude for nonconvex modulation\n            a = 0.20 + 0.22 * np.sin(ri[i] * 1.37 + i * 0.43)\n            if a < 0:\n                a = 0.0  # keep nonnegative\n            # region-dependent frequency\n            freq = 1.0 + 0.20 * (ri[i] % 6)\n            term = x[i]**2 * (1.0 + a * np.sin(freq * x[i]))**2\n            total += term\n\n        # cross-term coupling, nonnegative and gently modulated to keep phase-transition flavor\n        for i in range(self.dim - 1):\n            rsum = ri[i] + ri[i + 1]\n            cross = 0.5 * (x[i] - x[i + 1])**2 * (\n                1.0 + 0.30 * np.cos(rsum * 1.7 + (x[i] + x[i + 1]) * 0.8)\n            )\n            total += cross\n\n        return float(total)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Homogeneous 0.909, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.005927822058889265, 0.26723935333384735, 0.018266477916407047, 0.05884629419803713, 99.9936308003333, 0.13497163175140975, 0.8007180824021374, 1.0763038679884622, 0.9768857687927543, 1.3015222758815899, 2.1696128485183985, 2.6, 0.7118791913908573, 0.7122186939561008, 0.5779708990924431, 0.34434864827286565, -0.18764590297115713, 0.14168395533136713, 0.22836267518677017, 0.3151718654592876, 0.494309345201167, 0.14250877239211074, 0.2235880190151367, 0.3084616264507994, 0.48718166093258547, -0.4487039767974377, -0.4033878426302753, -0.35800484463167387, -0.26435962914961186, -0.43963041538930697, -0.398048922877006, -0.35453211279770164, -0.2629062328869028, 1.0, 1.0, 1.0, 1.0, 0.5166096304580543, 0.5165764281281332, 0.4317456381867964, 0.3714917365419731, 0.700188255422389, 0.5295295295295294, 0.34598864551042113, -0.2352352352352352, 0.39959839357429716], "score_NOT Homogeneous_2D": 0.7066733539104462, "score_GlobalLocal_2D": 0.9707778692245483, "ela_features": [0.0034337683865788724, 0.3106885743721664, 0.0040077452183748495, 0.0316941277912846, 9.69176634049164, 0.15418743749031044, 0.8126281180615456, 1.5914742962480584, 0.968886581987128, 0.9007876889465974, 1.1302971847399115, 2.2, 0.8992520468648806, 0.8704501205444851, 0.6365400348629711, 0.18586306741570174, -0.4445553417600059, 0.4538929736840469, 0.5378785873675208, 0.6149558884866968, 0.7348191640347321, 0.45475683571764625, 0.5357955659811069, 0.6121512589100497, 0.7336327558653936, -0.48034023180213986, -0.40646417904866494, -0.33867174689037965, -0.2332439363580588, -0.48185670723447044, -0.4102244422007323, -0.34275363912979045, -0.23539704049575577, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21600246597631845, 0.21600063124824592, 0.2050936334180315, 0.18520506204371143, 0.8292662165736673, 0.1491491491491491, 0.20212568046760548, -0.44744744744744736, 0.5230769230769231], "score_NOT Homogeneous_5D": 0.8909819349646568, "score_GlobalLocal_5D": 0.000428960396675393, "ela_features_10D": [0.0024815711024557484, 0.3636221152768817, 0.0010876117820359792, 0.023499442557177876, 43.07184322872134, 0.16740626890429094, 0.8106341114518928, 1.6995479601699963, 0.964544860519632, 0.6095703625641606, 0.424839096442802, 2.0, 1.0054661461139986, 0.9368244389672375, 0.6949975755051757, 0.10712953199271187, -0.5623851692441203, 0.6390008962721366, 0.6982897822292172, 0.7502824994164402, 0.8261044557937745, 0.6392235580987546, 0.6990974835148316, 0.7513601173741442, 0.8278000923696645, -0.4578326398294882, -0.38263977798249477, -0.31670095753737165, -0.22054066922352805, -0.458737522946875, -0.38260618456721224, -0.31615284490421686, -0.21895683700078114, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10961989285724164, 0.10962665940205321, 0.10691280134694232, 0.10110043466039875, 0.8536095814113512, -0.1271271271271271, 0.11461032088391851, -0.6956956956956956, 0.5923939151321058], "score_NOT Homogeneous_10D": 0.9085391014814377, "score_GlobalLocal_10D": 0.0003464855835773051}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], 32.725199224646744], [1, [3.000888888888987, 5.0], 25.488794154460948], [2, [3.000888888888987, 1.666666666666667], 11.836680020984675], [4, [-0.041838598696102604, 0.00040310015958466296], 0.0028216415640951627], [4, [1.0006669235496133, 1.0012516179801554], 2.0416696926457023], [4, [-1.000892856612742, -0.6543542976765262], 0.728043324041162], [8, [-1.0695055942887062, -1.0012906115039792], 0.7935710403198273], [8, [0.23548956246310293, 1.0003204797651084], 1.2717580895060645], [2, [1.5495179112687918, 3.0008798004598525], 10.61547289308248], [2, [0.8870025018542949, 3.000024295957058], 11.406857539157468], [4, [5.0, 0.5555555555555554], 24.987409322068785], [4, [0.5555555555555554, 5.0], 23.568512046807637], [2, [1.9906983324392438, 5.002968764405919], 25.34674913757326], [10, [1.0010380933007132, 0.22682149430846707], 1.307738815546855], [1, [3.001252471676151, 3.001237444888858], 15.85720576109987], [1, [5.000898037629852, 3.000899071805937], 25.92402609239096], [2, [5.03489199130726, 2.0778616881558465], 26.456363623469173], [2, [-1.000666704838114, 3.0006634020221417], 13.922030466526593], [8, [-3.000510608529125, -2.0777841401553245], 11.266269467986774], [2, [3.000888888888987, -1.000666666666666], 14.944026224314008], [6, [-3.0008867606122, 1.000751661973362], 15.26586627802642], [2, [5.0, -3.0008888888889866], 49.886709606871094], [2, [-3.0008888888889866, 5.0], 48.64479184801031], [4, [-3.00067248373552, -3.000494817277287], 16.78473349728365], [6, [1.0006666670294202, -3.000910870822832], 15.079868701441752], [8, [-2.6061498503513487, -3.0003581474764864], 15.045895748523828]], "nr_of_basins": 26, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.0148386087147108e-162, 1.1931456089461288e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.3774945592950673e-163, 1.2754346411124771e-163, -1.3058682502749195e-162, -1.2174325327436076e-162, -3.523781159577358e-163]}
{"id": "3aced7d6-db59-4bb7-aafe-9943a44cfda2", "fitness": 0.561711968514525, "name": "landscape_globlocal_adv", "description": "A non-homogeneous phase-transition landscape with region-dependent per-dimension wells and a radial amplification of the outer-region rugged term. This strengthens the global-local minima contrast by making outer local minima much deeper relative to the global minimum at the origin, while preserving non-homogeneity and phase-transition behavior.", "code": "import numpy as np\n\nclass landscape_globlocal_adv:\n    \n    def __init__(self, dim=5):\n        # problem dimensionality\n        self.dim = int(dim)\n        # region width along each axis to induce non-homogeneous, phase-transition-like behavior\n        self.region_width = 2.0\n        # maximum region index per axis (based on domain [-5,5])\n        self.max_region = int(np.floor((10.0) / self.region_width))\n        # radial amplification factor to boost outer-region minima (enhances GlobalLocal)\n        self.gamma = 2.0\n        # parameters controlling per-dimension modulation\n        self.amp_base = 0.15\n        self.amp_var = 0.25\n\n    def _region_index(self, xi):\n        # compute discrete region index for a coordinate\n        ri = int(np.floor((float(xi) + 5.0) / self.region_width))\n        if ri < 0:\n            ri = 0\n        if ri > self.max_region:\n            ri = self.max_region\n        return ri\n\n    def f(self, x):\n        # evaluation: x should be a 1-D array of length dim\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input vector length must be equal to dim\")\n\n        # region indices per dimension\n        ri = np.array([self._region_index(float(xi)) for xi in x], dtype=int)\n\n        total = 0.0\n        # per-dimension nonnegative, nonconvex term (zero at origin is ensured by x_i^2 factor)\n        for i in range(self.dim):\n            # region-dependent amplitude for nonconvex modulation\n            a = self.amp_base + self.amp_var * np.sin(ri[i] * 1.37 + i * 0.43)\n            if a < 0:\n                a = 0.0  # keep nonnegative\n            # region-dependent frequency\n            freq = 1.0 + 0.20 * (ri[i] % 6)\n            term = x[i]**2 * (1.0 + a * np.sin(freq * x[i]))**2\n            total += term\n\n        # cross-term coupling, nonnegative and gently modulated to keep phase-transition flavor\n        for i in range(self.dim - 1):\n            rsum = ri[i] + ri[i + 1]\n            cross = 0.5 * (x[i] - x[i + 1])**2 * (\n                1.0 + 0.30 * np.cos(rsum * 1.7 + (x[i] + x[i + 1]) * 0.8)\n            )\n            total += cross\n\n        # radial amplification to emphasize outer-region ruggedness, boosting Local minima depth\n        r = np.linalg.norm(x)\n        radial_weight = 1.0 + self.gamma * np.tanh(r / 5.0)\n\n        return float(radial_weight * total)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_globlocal_adv scored on:NOT Homogeneous 0.898, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["41d63599-42ee-4f09-88d6-a1445b3e691c"], "operator": null, "metadata": {"ela_features_2D": [0.005437818434313013, 0.25215416890353415, 0.021086862366824128, 0.05784869552714487, 3.5929093696014065, 0.15742159748576018, 0.8094986317021619, 1.067185303686807, 0.9751647475868497, 1.367530400621702, 2.2829971862989167, 2.2, 0.7005010567401422, 0.7160240987867265, 0.5583494421089346, 0.33871915463823826, -0.18463282084017882, 0.1464568814427179, 0.22491227327807267, 0.32022534703754696, 0.493860155507014, 0.1428183692009582, 0.22241476949930056, 0.3136196547422417, 0.48863186448433116, -0.44648962557374305, -0.40545160651195217, -0.3555927149570781, -0.26476069452031503, -0.4398691637313913, -0.39903107693995693, -0.35222550462037144, -0.26240617589977233, 1.0, 1.0, 1.0, 1.0, 0.5176185195393218, 0.5176087779481092, 0.4309139762462122, 0.3671928969110663, 0.6865049181864771, 0.5055055055055053, 0.3465447404971922, -0.2552552552552553, 0.3879518072289157], "score_NOT Homogeneous_2D": 0.7310855984687805, "score_GlobalLocal_2D": 0.9468320608139038, "ela_features": [0.00493955152806882, 0.3051915153606325, 0.006765756486089583, 0.03605402162531205, 8.04770158860633, 0.15286894969287834, 0.8218741047149469, 1.601087800988091, 0.972601862356304, 0.8794790427851849, 1.05924718959397, 1.8, 0.903083353122982, 0.8705766813205008, 0.629613890874533, 0.18716864550680246, -0.4498140527100284, 0.444930609008882, 0.5377775206464139, 0.6119625256984887, 0.7316791744880465, 0.4421054186402322, 0.536171415596289, 0.6116482481856502, 0.7311579727883851, -0.48824130602602817, -0.4065718481399091, -0.3413197004770027, -0.23601728242227277, -0.4932882957687488, -0.41011263941958764, -0.3433787871001749, -0.23771237488889674, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21777817358880122, 0.21779194439872868, 0.20677923511218915, 0.18669937969790878, 0.8114281682157376, 0.12912912912912908, 0.2033601666645019, -0.46746746746746737, 0.5165064102564102], "score_NOT Homogeneous_5D": 0.7940726280212402, "score_GlobalLocal_5D": 0.0002996006514877081, "ela_features_10D": [0.0007024750425667303, 0.3552624806621648, 0.0016316044078285154, 0.020926954746597427, 69.3786152223838, 0.15192044206790797, 0.8088582238999112, 1.7163937478338216, 0.9684188289139094, 0.5878559120273936, 0.4065566537023397, 2.0, 1.0155578028044956, 0.9378614903513434, 0.7106421487938028, 0.10534841841706263, -0.5702262315482409, 0.6377295236729206, 0.6980539487753025, 0.7474255445689655, 0.8239211032492216, 0.6370986353836996, 0.6987183305997406, 0.748770014492355, 0.8254249953128788, -0.4594559939106254, -0.3829483949581144, -0.3203319360000493, -0.22331519047273818, -0.4615181663210306, -0.38315268083528176, -0.31949966171652405, -0.222014520529219, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10945909913697786, 0.10945979444319087, 0.10688823090974184, 0.1002825132903236, 0.8539731017668892, -0.1151151151151151, 0.1205761853678465, -0.6916916916916914, 0.5951961569255404], "score_NOT Homogeneous_10D": 0.8976354375481606, "score_GlobalLocal_10D": 0.0003464855835773051}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], 94.50502197569992], [1, [3.000888888888987, 5.0], 70.3800369893815], [1, [3.000101407874144, 1.6627449484652583], 27.14901248652299], [2, [0.8470815581612463, 3.0000158117026032], 25.557010061411635], [4, [-0.0335037827400041, -0.00016080838904744283], 0.0018237490084834116], [3, [1.6627369743151283, 3.000142217594334], 25.39714791169634], [1, [5.0, 3.000888888888987], 72.75847721835993], [4, [-1.000310916966717, -0.9705429905215242], 1.6930843939814644], [4, [-1.0007238638274014, -1.2784961470202254], 1.6926989554191376], [5, [1.00066666725213, 1.0006945918299641], 3.1070728809862493], [6, [1.0004024664645492, 0.9329478567222311], 3.2665714250715197], [8, [0.22079154957755306, 1.0007272917399619], 1.7846319862486186], [8, [-0.36564189437371136, -1.0012368797645963], 0.948095892862053], [4, [5.0, 0.5555555555555554], 65.06315544464339], [2, [5.001345117015461, 1.793792243369901], 71.35181595481568], [4, [0.5555555555555554, 5.0], 60.899798975029604], [2, [1.7617971832956978, 5.00194561433026], 66.97204051159686], [8, [-3.0009806130191565, -1.000000987354512], 23.478693999936223], [2, [-1.000666706837031, 3.000657573212572], 31.233194574789596], [8, [-1.31804261749397, -3.000074106914138], 22.23584204068841], [4, [-3.000917083485015, -3.0008888893365753], 40.48748847396004], [2, [3.000731364857168, -1.0006666852956942], 32.93385747178118], [6, [-3.0000055346707826, 1.000445844689772], 32.594100960410756], [6, [1.0019455012138963, -3.000475649259239], 32.08261339692096], [2, [5.0, -3.0008888888889866], 134.28862664065346], [2, [-3.0008888888889866, 5.0], 130.4714645617146]], "nr_of_basins": 26, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.2124764686825983e-163, 1.5661073732569872e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.5340011700217602e-162, 1.1564506802757207e-162, 3.4043482169421923e-163, -1.3963671277246843e-162, -1.3331663216931784e-162]}
{"id": "1f844945-94f0-460d-8946-a21dca1419aa", "fitness": 0.526830279850401, "name": "landscape_phase_transition_enhanced", "description": "A non-homogeneous, phase-transition landscape with three radial zones and enhanced non-separable features to maximize global-local minima contrast. The inner region is a smooth paraboloid, the middle region adds radius-dependent, non-separable oscillations and cross-terms, and the outer region introduces rugged, high-frequency coupling. The transition between regions is governed by smooth radial blending to create distinct, region-dependent appearances.", "code": "import numpy as np\n\nclass landscape_phase_transition_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Radial transition radii (in the same units as x, domain [-5,5])\n        self.r1 = 0.8\n        self.r2 = 2.5\n        self.r3 = 5.0\n\n        # Middle-region modulation parameters\n        self.a = 0.75      # amplitude for cos modulation in middle region (0 < a < 1)\n        self.b = 3.2       # frequency for cos modulation per coordinate\n        self.c_mid = 0.6    # cross-term weight for sum(x)^2 in middle region\n        self.d_mid = 1.8    # weight for a small per-dimension sine term in middle\n\n        # Outer-region ruggedness/coupling\n        self.e_outer = 0.25  # weight for the sum(x)^2 term in outer region\n        self.g_outer = 0.6   # weight for a high-frequency per-dimension cosine term in outer\n        self.freq_out = 4.0   # frequency for outer rugged term\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region: global minimum at origin\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: non-separable, phase-transition-modulated landscape\n        f_mid = float(np.sum((1.0 + self.a * np.cos(self.b * x)) * (x**2)))\n        # radius-dependent cross-term across all coordinates\n        f_mid += self.c_mid * (np.sum(x))**2 / max(self.dim, 1)\n        # small per-dimension sine modulation to break separability\n        f_mid += self.d_mid * float(np.sum(np.sin(0.5 * x)))\n\n        # Outer region: highly rugged with cross-term coupling\n        f_outer = float(np.sum(x**4))\n        f_outer += self.e_outer * (np.sum(x))**2\n        f_outer += self.g_outer * float(np.sum(1.0 + np.cos(self.freq_out * x)))\n\n        # Phase-transition weights\n        s1 = self._smoothstep(self.r1, self.r2, r)  # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)  # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_phase_transition_enhanced scored on:NOT Homogeneous 0.705, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b7269e5e-67b9-41d3-a48d-17c997c42919"], "operator": null, "metadata": {"ela_features_2D": [-0.002288801363860493, 0.20473785762529614, 0.006993259441838212, 0.028034815874846897, 13.464751433646914, -0.0018099468755198745, 0.8970367008772857, 1.0218604260430004, 0.8987374924427909, 0.9856136790194338, 0.12655610577604817, 2.0, 0.6787672049493488, 0.7143077033514608, 0.5353826709165269, 0.3401173788777029, -0.22440927722293086, 0.13555690222438174, 0.21396269978746738, 0.30927622542539274, 0.49318641104900046, 0.13857789028409692, 0.21346253964352044, 0.3109093232803763, 0.4933534498818414, -0.45226633966323515, -0.411246187578877, -0.36137921177935983, -0.26515759216221746, -0.44244468964900674, -0.40398947204379443, -0.3539395453603212, -0.2602261461904067, 1.0, 1.0, 1.0, 1.0, 0.5082463229330461, 0.5082383245085541, 0.395601416413986, 0.34846255328618403, 0.5788425486416027, 0.6416416416416414, 0.4152519390458509, -0.13513513513513511, 0.3823293172690763], "score_NOT Homogeneous_2D": 0.9392381347715855, "score_GlobalLocal_2D": 0.9794366955757141, "ela_features": [-0.001083774531774151, 0.27902518879780713, 0.00463643105073548, 0.024988624116363756, 24.19490980930791, 0.006929928712829847, 0.9235410022612358, 1.0505410314253874, 0.925283665424903, 0.5623505320940779, 0.09661276847271702, 1.6, 0.9087714021498472, 0.8749092682918989, 0.6439529443066168, 0.1824974532730747, -0.4990481539096727, 0.4228992255096977, 0.5124777694404212, 0.5925790864257786, 0.7223342816268439, 0.42573949086609897, 0.5145615065805125, 0.5959373748741246, 0.72547907607941, -0.5075635421985696, -0.42877691011503993, -0.35832697947331044, -0.24420706996474154, -0.507457852039833, -0.42895809843217475, -0.3570496642763613, -0.24258022991205466, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21750977365670265, 0.21753132387580884, 0.20366161511634034, 0.18284622411482251, 0.8266429647361161, 0.23323323323323314, 0.2662851077267118, -0.3313313313313313, 0.5423076923076924], "score_NOT Homogeneous_5D": 0.535590410232544, "score_GlobalLocal_5D": 0.0009350752807222307, "ela_features_10D": [-0.0009303903730850882, 0.3569893573182921, 0.0007003944268305581, 0.017412403284058825, 123.03568817393516, 0.008664797045175953, 0.9162123135207677, 1.058239013597079, 0.9193902608456334, 0.42876930734718527, 0.05176834264816303, 1.4, 1.007238240131139, 0.937618412873422, 0.6944074982754094, 0.10762379609510334, -0.6046417807471758, 0.6304262933335014, 0.6900713282662726, 0.7395206532760563, 0.8146006031418699, 0.6342843645453662, 0.6933510921764067, 0.7428724313989571, 0.8184308823868085, -0.46870339196644933, -0.3930603796977413, -0.3303473327660294, -0.23512857200108947, -0.465000008609579, -0.38989896483546643, -0.3269333807263094, -0.2308612733138488, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10875174991430214, 0.1087484111802497, 0.10552767920166406, 0.09935490532351487, 0.8607961533779255, -0.055055055055055035, 0.14278797186369804, -0.6276276276276274, 0.611609287429944], "score_NOT Homogeneous_10D": 0.7054175436496735, "score_GlobalLocal_10D": 0.000363819592166692}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[41, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [16, [-2.672471505966778, 0.0873227305237104], 4.740809253455823], [16, [0.0873227305237104, -2.672471505966778], 4.740809253455823], [13, [2.654996713434977, -0.3717967419933649], 7.711074635942102], [14, [-0.37179633270344914, 2.654997334722431], 7.711074551133118]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.7488317712984066e-163, -4.813610514219834e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [4.8730515181438527e-163, -1.3740043178483069e-162, -6.149325815316561e-163, -1.1118831818126939e-162, 1.363372346353901e-162]}
{"id": "cab0b393-58a1-4bfc-bf8c-3f93da3e7a33", "fitness": 0.8323143796684841, "name": "LandscapeNovelPT", "description": "A novel non-homogeneous phase-transition landscape that blends three radial regions (inner paraboloid, mildly rugged middle, and outer rugged cross-term) via a smooth radial weight scheme. The global minimum remains at the origin (0) with f(0)=0, while the middle and outer regions introduce controlled nonlinearity and ruggedness to create a clear global-local minima contrast without reuse of the same grid-well concept.", "code": "import numpy as np\n\nclass LandscapeNovelPT:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Phase-transition shaping parameters\n        self.s1 = 2.0          # width of inner region influence\n        self.r1 = 1.0          # radius where middle region starts to dominate\n        self.d1 = 0.7          # smoothing scale for the radial transition\n        self.A = 0.6             # maximum weight for the middle region (as r -> large)\n        self.beta = 0.8          # modulation strength for per-dimension in f2\n        self.gamma = 1.9         # frequency for per-dimension modulation in f2\n        self.sin_phase = 1.2      # frequency for sin^2 term in outer region\n        self.omega = 1.5          # frequency for cross-term in the outer region\n        self.epsilon = 0.5         # amplitude of cos modulation in the outer cross-term\n\n        # Domain bounds (for reference; function is defined on [-5,5]^dim)\n        self.grid_min = -5.0\n        self.grid_max = 5.0\n\n    def _f1(self, x):\n        # Inner region: simple paraboloid\n        return float(np.sum(x ** 2))\n\n    def _f2(self, x):\n        # Middle region: mildly rugged, per-dimension modulation\n        x2 = x ** 2\n        return float(np.sum(x2 * (1.0 + self.beta * np.cos(self.gamma * x))))\n\n    def _f3(self, x):\n        # Outer region: rugged cross-term with a global coupling (sum of coordinates)\n        s = float(np.sum(x))\n        term1 = s ** 2 * (1.0 + self.epsilon * np.cos(self.omega * s))\n        term2 = 0.5 * float(np.sum(np.sin(self.sin_phase * x) ** 2))\n        return float(term1 + term2)\n\n    def f(self, x):\n        \"\"\"\n        Black-box minimization target.\n        The function blends three region-specific landscapes using smooth\n        radial weights:\n          w1(r) = exp(-(r/s1)^2)        (inner region)\n          w2(r) = (1 - w1) * A * sigmoid((r - r1)/d1)  (middle region)\n          w3(r) = 1 - w1 - w2             (outer region)\n        with r = ||x||_2. All components are nonnegative, and f(0)=0.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array of length {self.dim}.\")\n\n        r = float(np.linalg.norm(x))\n\n        # Radial weights (smooth transitions)\n        w1 = np.exp(- (r / self.s1) ** 2)\n        t = (r - self.r1) / self.d1\n        a = 1.0 / (1.0 + np.exp(-t))  # sigmoid -> transitions from 0 to 1\n        w2 = (1.0 - w1) * self.A * a\n        w3 = 1.0 - w1 - w2\n        # Guard against numerical issues (should not be negative by construction)\n        w1 = max(0.0, min(1.0, w1))\n        w2 = max(0.0, min(1.0 - w1, w2))\n        w3 = max(0.0, 1.0 - w1 - w2)\n\n        val = w1 * self._f1(x) + w2 * self._f2(x) + w3 * self._f3(x)\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape LandscapeNovelPT scored on:NOT Homogeneous 0.995, GlobalLocal 0.510,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1a166baf-2a6f-4dc9-8f77-5abb43906884"], "operator": null, "metadata": {"ela_features_2D": [-0.0010195051164229474, 0.28339570573879735, 0.0161885479349702, 0.026459698888269222, 2.759356089183206, 0.29579724492354104, 0.4696904944168928, 1.1115269666327454, 0.7611382064129941, 1.491594838467678, 2.720653366079842, 2.6, 0.3209031600809806, 0.6290210266223175, 0.3331725798097167, 0.3615365723734195, -0.21132516174027938, 0.16814430698901492, 0.2401846885120734, 0.34419274656164534, 0.5403656836609186, 0.17245496627545462, 0.24657253299653142, 0.3410086352863686, 0.5233900366569362, -0.4352356325407619, -0.3975435499945262, -0.34312584881851016, -0.2404792001804988, -0.4253239175656252, -0.3872329653318811, -0.3386918853983385, -0.24494415791131186, 1.0, 1.0, 1.0, 1.0, 0.5204797713947942, 0.5204459873030202, 0.4159778287959961, 0.3561906905490858, 0.6932914882805367, 0.7137137137137135, 0.5612920254754791, -0.09109109109109108, 0.38433734939759034], "score_NOT Homogeneous_2D": 0.9745865613222122, "score_GlobalLocal_2D": 0.7520601153373718, "ela_features": [-3.6471624971290415e-05, 0.16785557985090097, 0.0017096896623320056, 0.018233401374976407, 32.67050191662113, 0.5730300754094396, 0.22736503860863508, 1.3049492123663475, 0.8000486909981213, 2.132855873836519, 7.487665180369968, 4.2, 0.6938926088766559, 0.8249240090943332, 0.5350879132989601, 0.21680453732713856, -0.3695207660515043, 0.5091495566056535, 0.6712314451703005, 0.7245975489982166, 0.812566357501251, 0.4869822247873845, 0.6490215397754782, 0.7080144858322737, 0.8021810858758707, -0.4318062201439372, -0.28922064443287515, -0.2422717858354037, -0.16488607933773236, -0.45375254482119354, -0.3104271811703126, -0.2582403545804405, -0.17496242643511623, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21355570662170886, 0.21354681099220704, 0.2066721916471499, 0.18094653812836964, 0.836716504075237, 0.22122122122122118, 0.12886461299049096, -0.6636636636636635, 0.5674679487179486], "score_NOT Homogeneous_5D": 0.994776064530015, "score_GlobalLocal_5D": 0.767362654209137, "ela_features_10D": [-0.00019088201024179962, 0.14466060415573503, 0.0009011827800203022, 0.01245162647945164, 19.174650429244473, 0.6996384263967588, 0.13051593397485955, 1.9736385135272916, 0.8250190550061498, 2.719609173205344, 11.264035688771411, 5.4, 0.8567624304171646, 0.9163306201210231, 0.6169279880291636, 0.1221686484804954, -0.36808715535366765, 0.7321268045482394, 0.7856113246812411, 0.8286872055446832, 0.8917252369298174, 0.7283006526067146, 0.7804960583538417, 0.8255433001180273, 0.8899434793639998, -0.3397339354191541, -0.271901403244482, -0.21726891120035635, -0.13732045715952418, -0.34549877876002133, -0.2791270420398754, -0.22184159282840882, -0.13994981280277835, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.10945973009017158, 0.1094627495147849, 0.10812478413395699, 0.09990076103481728, 0.829050806096028, -0.1591591591591591, 0.04907585312495842, -1.0560560560560561, 0.6015212169735789], "score_NOT Homogeneous_10D": 0.9954154854640365, "score_GlobalLocal_10D": 0.5096853971481323}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [5.0, 5.0], 30.910747398626], [3, [-5.0, -5.0], 30.910747398626], [4, [4.937193664004428, -4.936005079715159], 5.92129116483205], [4, [-4.936005079715159, 4.937193664004428], 5.92129116483205], [3, [1.2504145539451021, 4.864224551714615], 11.429569807900405], [5, [4.864224551714615, 1.2504145539451021], 11.429569807900405], [6, [-1.1952742003200045, -4.933574820492637], 11.334031685956672], [4, [1.6487451953280738, -1.6487989514870784], 2.1177904540567067], [4, [-1.6487989514870784, 1.6487451953280738], 2.1177904540567067], [5, [-4.864224551714615, -1.2504145539451021], 11.429569807900405], [39, [4.420847381702715e-05, -0.0006907574033909918], 4.791002370085854e-07], [5, [4.837098005735338, -2.070337936439608], 6.623330458986647], [5, [-2.0703379312687225, 4.837098095109955], 6.623330430695743], [5, [-4.837097303444623, 2.07033795728714], 6.623330680630052], [5, [2.0703379858891418, -4.837096808484242], 6.623330837325563]], "nr_of_basins": 15, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.4619221844275637e-162, 6.638839149264721e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [4.4687836868904085e-163, -1.3597326333294846e-162, 1.255810268168181e-162, -5.580424282960192e-163, 6.1226254870163594e-164]}
{"id": "5d12a6e7-fadf-4ff1-8c0c-73248527f7a6", "fitness": 0.5625007818913824, "name": "landscape_globallocal_enhanced", "description": "A non-homogeneous phase-transition landscape with an amplified outer-well structure to boost global-local minima contrast. The inner region provides a smooth global basin at the origin, while axis-aligned outer wells are activated by a smooth radial transition. The depth of the outer local minima is scaled by a depth_factor to improve the GlobalLocal score. A Monte Carlo estimate of the GlobalLocal score is stored during initialization for benchmarking.", "code": "import numpy as np\n\nclass landscape_globallocal_enhanced:\n    def __init__(self, dim, depth_factor=3.0, shells=4, R1=2.0, R2=4.0):\n        \"\"\"\n        dim: int, problem dimension\n        depth_factor: float, scales the depth of outer local minima (larger -> deeper wells)\n        shells: int, how many axis-aligned centers to place (up to dim)\n        R1, R2: float, inner/out radial transition radii\n        \"\"\"\n        self.dim = int(dim)\n        self.R1 = float(R1)\n        self.R2 = float(R2)\n        self.a = 3.0  # distance along axis for the centers\n        self.max_centers = min(self.dim, int(shells))\n        self.depth_factor = float(depth_factor)\n        self.centers = []\n        self.offsets = []\n        self._build_centers()\n        # Estimate a GlobalLocal score (higher means more pronounced contrast)\n        self.global_local_score = None\n        self._estimate_global_local_score()\n\n    def _build_centers(self):\n        self.centers = []\n        for i in range(self.max_centers):\n            c = np.zeros(self.dim, dtype=float)\n            c[i] = self.a\n            self.centers.append(c)\n        # Outer well depths amplified by depth_factor\n        base_offset = 2.0\n        self.offsets = [base_offset * self.depth_factor for _ in range(len(self.centers))]\n\n    def _radial_transition(self, r):\n        if r <= self.R1:\n            return 0.0\n        if r >= self.R2:\n            return 1.0\n        # Smooth cosine-based transition from 0 to 1\n        return 0.5 * (1.0 - np.cos(np.pi * (r - self.R1) / (self.R2 - self.R1)))\n\n    def f(self, x):\n        \"\"\"\n        Objective function to be minimized.\n        Global minimum at origin with f(0) = 0.\n        Outer wells introduce non-homogeneous, phase-transition-like structure.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input vector x must be one-dimensional with length equal to the landscape dimension.\")\n\n        # Inner global basin: smooth paraboloid\n        inner = float(np.dot(x, x))\n\n        # Radial transition controlling outer-well influence\n        r = np.linalg.norm(x)\n        t = self._radial_transition(r)\n\n        if len(self.centers) == 0:\n            return inner\n\n        # Outer wells: W_j(x) = offset_j + t * ||x - c_j||^2\n        outer_min = None\n        for c, off in zip(self.centers, self.offsets):\n            diff = x - c\n            w = off + t * float(np.dot(diff, diff))\n            if outer_min is None or w < outer_min:\n                outer_min = w\n\n        if outer_min is None:\n            return inner\n        return inner if inner <= outer_min else outer_min\n\n    def _estimate_global_local_score(self, samples=1000):\n        \"\"\"\n        Rough proxy for GlobalLocal: ratio between the deepest local well value\n        and the average function value over the domain, estimated via Monte Carlo.\n        Higher ratio indicates stronger global-local contrast.\n        \"\"\"\n        rng = np.random.default_rng(12345)\n        xs = rng.uniform(-5.0, 5.0, size=(samples, self.dim))\n        vals = np.empty(samples, dtype=float)\n        for i in range(samples):\n            vals[i] = self.f(xs[i])\n        A = float(np.mean(vals)) if vals.size > 0 else 1.0\n        local_min = min(self.offsets) if self.offsets else 0.0\n        self.global_local_score = float(local_min / max(A, 1e-9))\n        return self.global_local_score", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_globallocal_enhanced scored on:NOT Homogeneous 0.736, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fbfe4fd4-bdac-4de7-983f-6d701027bf81"], "operator": null, "metadata": {"ela_features_2D": [0.14117941628578326, 0.45650343248196956, 0.16279070559926528, 0.1797152333763712, 1.1147939208561881, 0.14401473242001164, 0.9328844384476511, 1.0142295095989213, 0.9879231162359001, 0.8040332142253005, 0.3322820199432409, 1.4, 0.6907065798962189, 0.7138525427924944, 0.551612052006302, 0.34168255387882973, -0.1828124295254064, 0.16042006494574335, 0.22973497162783318, 0.3164720418700477, 0.5125852624100833, 0.16573002181457475, 0.23004034754171193, 0.3211023232448528, 0.5124204286965128, -0.43941999177947366, -0.4031448824922679, -0.35774703778758404, -0.2551056775512129, -0.42954260190987725, -0.39643341094921125, -0.3495523303782697, -0.25104705797041593, 1.0, 1.0, 1.0, 1.0, 0.5107549125896357, 0.5107369572958472, 0.4528168376416333, 0.4605286432662553, 0.709689735513307, 0.3533533533533532, 0.4448415206947301, -0.19119119119119116, 0.3738955823293173], "score_NOT Homogeneous_2D": 0.9468939751386642, "score_GlobalLocal_2D": 0.8968393802642822, "ela_features": [0.04316453758856782, 0.5027601293043574, 0.009829153905264074, 0.08104840292354272, 19.246060185109016, 0.0527788830851178, 0.9595535260917636, 1.274380927804712, 0.9888193054082756, 0.38712048016787204, -0.1278708195505013, 1.4, 0.9094451053098155, 0.8743211529607621, 0.6500201509106509, 0.18071205211093452, -0.464593826777442, 0.4493573606647063, 0.5395123646697677, 0.6082760140416943, 0.7210667717555443, 0.4490553011327322, 0.5395475293274414, 0.6083870768844639, 0.7236678812942078, -0.4843438991164561, -0.40504277243217557, -0.34455820782408497, -0.2453470602673697, -0.48692157313428924, -0.40694287430663234, -0.3461019140544993, -0.2442170515530247, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21584295482764096, 0.21584386245801968, 0.201899371872616, 0.20210742472005688, 0.8202779329407077, 0.12112112112112108, 0.23056972739437992, -0.39539539539539525, 0.5041666666666667], "score_NOT Homogeneous_5D": 0.7950362116098404, "score_GlobalLocal_5D": 0.00019275592057965696, "ela_features_10D": [0.01979077394354025, 0.5091807263676706, 0.0013281983046001644, 0.04843099106440907, 97.47726973043338, 0.025614182362736115, 0.9814665061287476, 1.2641612630796568, 0.9950066177255279, 0.24341946091373753, -0.10843501807009384, 1.0, 1.0244534593717216, 0.9371533806048491, 0.7143861710699956, 0.10723780151957148, -0.5988604273116499, 0.6290140507553643, 0.6862451878475515, 0.7364075514675549, 0.81367225480617, 0.6337347082848898, 0.6905914200757758, 0.7400892540644437, 0.8177526675558608, -0.4705280934945618, -0.39794054525626854, -0.3343189018325847, -0.23632243633911484, -0.4657412387710732, -0.393440137560087, -0.33049910465281174, -0.23174268205781368, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10957330751609731, 0.1095674788551116, 0.10637041327030192, 0.10589776629086253, 0.854914607807369, -0.10310310310310308, 0.1421668381165018, -0.6356356356356354, 0.5848678943154524], "score_NOT Homogeneous_10D": 0.7358424365520477, "score_GlobalLocal_10D": 0.00019993186288047582}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[21, [2.999999984430602, 0.00024994681004442], 6.000000031236704], [22, [0.00024838042777293587, 2.99999998430656], 6.000000030846419], [57, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 3, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.4936618429023186e-162, -9.136081260698995e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.023522974271086e-163, -3.9801438593534236e-163, -1.338181206250177e-163, -9.813660288455076e-163, -1.4047245717718428e-162]}
{"id": "0824c97e-e509-4791-974b-f29b3a101da8", "fitness": 0.5239380628336221, "name": "landscape_phase_transition_ext", "description": "A phase-transition, non-homogeneous landscape with multiple radial shells and directional (angular) modulation to amplify non-homogeneity and global-local minima contrast. It preserves a global minimum at the origin while introducing pronounced phase transitions across radius and orientation, yielding a clear non-homogeneous search space.", "code": "import numpy as np\n\nclass landscape_phase_transition_ext:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Phase-transition boundary\n        self.R0 = 2.0\n        # Maximum radius in the domain [-5,5]^dim\n        self.r_max = 5.0 * np.sqrt(self.dim)\n        # Number of radial shells to create non-homogeneous regions\n        self.M = 8\n\n        # Shell thickness (ensure non-zero)\n        self.shell_thickness = max((self.r_max - self.R0) / self.M, 1e-9)\n\n        # Shell index baseline\n        s = np.arange(self.M, dtype=float)\n\n        # Amplitude for per-dimension sinusoidal term (increases with shell index)\n        # Stronger outer shells to enhance global-local contrast\n        self.A = 0.9 + 0.9 * (s / float(self.M - 1))\n\n        # Amplitude for the cross-term on the sum of coordinates (decreases with shell index)\n        self.B = 0.3 + 0.7 * (1.0 - (s / float(self.M - 1)))\n\n        # Per-shell frequency multiplier for per-dimension sine term\n        self.f_s = 0.6 * (s + 1.0)\n\n        # Cross-term frequency multiplier on sum of coordinates\n        self.k_s = (np.pi * (s + 1.0)) / 3.0\n\n        # Centers of shells in radius; used to compute soft weights\n        self.r_center = self.R0 + (s + 0.5) * self.shell_thickness\n\n        # Width of the radial weighting (sharper shells to emphasize phase transitions)\n        self.sigma = max(self.shell_thickness * 0.4, 1e-9)\n\n        # Directional (angular) modulation per shell to break isotropy\n        # Deterministic unit vectors per shell (no randomness)\n        self.dir_vectors = np.zeros((self.M, self.dim))\n        for si in range(self.M):\n            v = np.array([np.sin((si + 1) * (i + 1) * 0.7 + (i + 1) * 0.31) for i in range(self.dim)], dtype=float)\n            n = np.linalg.norm(v)\n            if n < 1e-9:\n                n = 1.0\n            self.dir_vectors[si, :] = v / n\n\n        # Amplitude for directional term and its frequency\n        self.D = 0.25 + 0.25 * (s / float(self.M - 1))\n        self.dir_freqs = 0.6 + 0.6 * (s / float(self.M - 1))\n\n        # Global-local contrast proxy (rough estimate)\n        self.global_local_contrast = (np.max(self.A) + np.max(self.B)) / max(1e-9, (self.dim * 25.0 / 3.0))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length 'dim'.\")\n\n        r = np.linalg.norm(x)\n        base = np.dot(x, x)\n\n        # Inner smooth region (global basin)\n        if r <= self.R0:\n            return base\n\n        # Soft radial weights for shell contributions\n        diffs = r - self.r_center\n        W_num = np.exp(- (diffs ** 2) / (2 * (self.sigma ** 2)))\n        W_den = np.sum(W_num)\n        if W_den <= 0:\n            W = np.ones(self.M) / self.M\n        else:\n            W = W_num / W_den\n\n        idx = np.arange(1, self.dim + 1)\n        sum_x = np.sum(x)\n\n        rug = 0.0\n        for s in range(self.M):\n            # Dimensional sin term and cross-term on sum of coordinates\n            term = self.A[s] * np.sum(np.sin(self.f_s[s] * idx * x))\n            term += self.B[s] * np.sin(self.k_s[s] * sum_x)\n\n            rug += W[s] * term\n\n            # Angular modulation (directional term) to break homogeneity\n            dir_term = self.D[s] * np.sin(self.dir_freqs[s] * (np.dot(self.dir_vectors[s], x)))\n            rug += W[s] * dir_term\n\n        return base + rug", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_phase_transition_ext scored on:NOT Homogeneous 0.586, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ded73e9e-3625-4a25-95ee-277995e67832"], "operator": null, "metadata": {"ela_features_2D": [-0.0008714937930542011, 0.33427189764570076, 0.022282923398192985, 0.03443319943164096, 1.6352773397450768, 0.008527244819687318, 0.9893035782289182, 1.0097084626097126, 0.9896399382650343, 0.4647761459901073, -0.42941281357212757, 1.4, 0.6890634667094128, 0.7089474274501506, 0.5630166482280583, 0.3464665549048497, -0.2085921778968382, 0.15244924035788884, 0.22832643402898395, 0.3162572203207769, 0.48879077203288757, 0.15479493234822117, 0.23131452195503485, 0.31849259481830605, 0.4895503011227026, -0.44330205688652324, -0.4036091888233947, -0.3576185906390108, -0.2673720108701854, -0.4339121468698763, -0.3946010336275575, -0.3498520697778851, -0.2620237543089055, 1.0, 1.0, 1.0, 1.0, 0.5223235345753116, 0.5223036113921922, 0.4063115961639553, 0.3568181586262549, 0.7285476976410167, 0.5975975975975973, 0.44398221373775987, -0.11111111111111112, 0.3791164658634538], "score_NOT Homogeneous_2D": 0.8833897188305855, "score_GlobalLocal_2D": 0.9819226264953613, "ela_features": [-0.0009645367412097095, 0.40544973703772164, 0.0018666336187206165, 0.023649419821291328, 25.081333655663023, 0.003012257507894156, 0.9886310085127968, 1.0139011839804275, 0.9887474586830163, 0.29049014286290564, -0.14303533154810477, 1.4, 0.9070404592530918, 0.8715184118305487, 0.6443631883863732, 0.18479741854620824, -0.47999509188393824, 0.4296188404214418, 0.5153030014868529, 0.5987884902317404, 0.7186150523554391, 0.42518471197678165, 0.5158951236430834, 0.6007212632703411, 0.7217937705561808, -0.5017912708595278, -0.4264134139018722, -0.3529680411159032, -0.24755003549450336, -0.5084228352349239, -0.4281917899315584, -0.353165815430431, -0.24607558653549777, 1.0, 1.0, 0.8333333333333334, 1.0, 0.211222837219443, 0.211221020168606, 0.1974643086074021, 0.18008702316245537, 0.8277605989347565, 0.12912912912912908, 0.2662851077267119, -0.37537537537537535, 0.5213141025641026], "score_NOT Homogeneous_5D": 0.6920130252838135, "score_GlobalLocal_5D": 0.00016289895575027913, "ela_features_10D": [-0.0006235979655841994, 0.4665603372114894, 0.000695287083272435, 0.02043466910000142, 34.25623389286391, 0.007998730510003837, 0.9884583764561092, 1.0216111255012617, 0.9885516101725755, 0.19163528767973412, -0.0817435301927377, 1.0, 1.0222482733757055, 0.9386405999554217, 0.7101866301442767, 0.10438263554178343, -0.6150865387564106, 0.6180495771978555, 0.6798093683722516, 0.7295692624555074, 0.8082544781024096, 0.6205021993363949, 0.6836229922709315, 0.7338735901113087, 0.8126642352953999, -0.4843960424962298, -0.4060713914035376, -0.3429650509115799, -0.2431751408905129, -0.48259317186055456, -0.4023242304463032, -0.3384222230748487, -0.23822764117519596, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11216698866825325, 0.11215662186633017, 0.10898252474019876, 0.10252923907863606, 0.8608630381391729, -0.1071071071071071, 0.14474571789448346, -0.6316316316316314, 0.5924739791833467], "score_NOT Homogeneous_10D": 0.585986465215683, "score_GlobalLocal_10D": 0.00015364222053904086}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-4.198000769343662, 5.000055468751604], 40.316517270976846], [2, [-3.891097788842707, 3.3631036220026393], 26.16207591793321], [15, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [1, [-3.2709099476747765, 4.953364347182762], 32.46898560729718], [2, [-2.0872784705133016, 4.896574522247226], 25.522031912676887], [1, [-4.333202580757322, 1.7429146368970816], 20.449398396105984], [10, [-1.8887858724840045, -0.6609032604877606], 1.8763408356704376], [9, [-2.985003951991611, -2.87072241149591], 16.03157573447474], [8, [-0.6226013045706137, 2.606661283956033], 6.42521514804752], [3, [2.7216798321301403, 4.903188987054036], 29.24735378584272], [11, [2.738736276619857, -0.548387736192162], 6.559277585102122], [6, [-0.19447375867334987, -1.9908366418396595], 2.3311759060373722], [10, [1.1047546668014252, -1.667253400435353], 3.116537371477098], [7, [-1.6666666666666665, 1.1066666666666665], 3.5133431845970136], [8, [2.1232377396441446, 2.829265502195566], 11.043850038065097], [2, [4.845281613781705, -2.0258327353105456], 26.314130953497756], [4, [3.720241457552821, 2.8788776903134106], 20.251284278128843]], "nr_of_basins": 17, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.977199008641914e-163, 8.668672826462557e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2843959121984426e-162, -1.3027504891940378e-164, 3.5167033627330655e-163, -3.911201957272998e-164, -1.0887497721333417e-162]}
{"id": "d8fe6c1c-b81f-431f-b901-1f00960933bb", "fitness": 0.5550979687929308, "name": "landscape_spread_phase", "description": "A three-zone, non-homogeneous minimization landscape with an inner smooth basin, a non-separable middle quadratic form, and an outer multi-modal shell activated by a radial transition. The origin is the unique global minimum (f(0)=0). Outer wells create pronounced local minima, yielding a global-local minima contrast, while the radial transition induces phase-change-like regions across the search space. Domain for evaluation is each dimension in [-5, 5].", "code": "import numpy as np\n\nclass landscape_spread_phase:\n    def __init__(self, dim):\n        self.dim = int(dim)\n\n        # Phase transition radii (non-homogeneous regions)\n        self.R1 = 0.9   # end of inner smooth basin\n        self.R2 = 4.5   # full activation of outer wells\n\n        # Outer well configuration\n        self.a = 2.0  # base offset distance for centers\n        self.max_centers = min(self.dim, 6)  # up to six centers (dim-dependent)\n        self.centers = []\n        self.offsets = []\n\n        self._build_components()\n\n    def _build_components(self):\n        # Build a symmetric positive definite matrix M for the non-separable (coupled) middle region\n        rng = np.random.default_rng(1234)  # fixed seed for reproducibility\n        A = rng.standard_normal((self.dim, self.dim))\n        M = A.T @ A  # SPD\n        M += np.eye(self.dim) * 0.5  # ensure positive definiteness and bounds\n\n        self.M = M\n\n        # Build a small set of axis-spread centers for outer wells\n        self.centers = []\n        for i in range(self.max_centers):\n            c = np.zeros(self.dim, dtype=float)\n            idx = i % max(self.dim, 1)\n            sign = 1.0 if ((i // max(self.dim, 1)) % 2 == 0) else -1.0\n            c[idx] = sign * self.a\n            # Add a light secondary shift along another axis for variety\n            if self.dim > 1:\n                j = (i + 1) % self.dim\n                c[j] += 0.5 * self.a * (1 if (i % 3) == 0 else -1)\n            self.centers.append(c)\n\n        # Depths of outer wells (positive offsets) to ensure they are above the global minimum\n        self.offsets = [0.5 + 0.25 * i for i in range(self.max_centers)]\n\n    def _radial_transition(self, r):\n        \"\"\"\n        Smooth radial transition 0 -> 1 between R1 and R2.\n        Uses a cosine-based smooth step for non-linearity.\n        \"\"\"\n        if r <= self.R1:\n            return 0.0\n        if r >= self.R2:\n            return 1.0\n        return 0.5 * (1.0 - np.cos(np.pi * (r - self.R1) / (self.R2 - self.R1)))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input vector x must be one-dimensional with length equal to the landscape dimension.\")\n\n        # Inner region: isotropic paraboloid (global basin)\n        inner = float(np.dot(x, x))\n\n        # Radius and radial transition factor for outer wells\n        r = float(np.linalg.norm(x))\n        t = self._radial_transition(r)\n\n        # Outer wells: W_j(x) = offset_j + t * ||x - c_j||^2\n        if len(self.centers) > 0:\n            outer_min = None\n            for c, off in zip(self.centers, self.offsets):\n                diff = x - c\n                w = off + t * float(np.dot(diff, diff))\n                if outer_min is None or w < outer_min:\n                    outer_min = w\n        else:\n            outer_min = float('inf')\n\n        # Middle non-separable region: quadratic form x^T M x (SPD)\n        mid = float(np.dot(x, self.M @ x))\n\n        # Global minimum at origin: f(0) = 0; take the minimum among the three regions\n        return min(inner, mid, outer_min)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_spread_phase scored on:NOT Homogeneous 0.639, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fbfe4fd4-bdac-4de7-983f-6d701027bf81"], "operator": null, "metadata": {"ela_features_2D": [0.23619555463747863, 0.4388185648145549, 0.10606674995786894, 0.318919178937448, 3.104106814899201, 0.24779498749089973, 0.9151304355086806, 1.0244187228186887, 0.9776412207268137, 1.1526003128218758, 1.0041785139860373, 1.8, 0.6788928485594343, 0.7049215359304007, 0.5078336457830032, 0.35193432628110577, -0.17674410812857458, 0.15329675200684617, 0.2569236259774576, 0.34168711567281623, 0.5071917549282181, 0.16504157410383585, 0.24304895741128396, 0.33713689942206887, 0.5042492205213449, -0.4430383475035097, -0.3888158606059483, -0.3444628914560713, -0.2578617931481115, -0.42915363005266194, -0.38905860835016404, -0.34069993592397585, -0.25480807352514606, 1.0, 1.0, 1.0, 1.0, 0.5236752828949272, 0.5236307630684335, 0.48491423541143347, 0.5052060408393475, 0.6547138138734644, 0.40140140140140124, 0.5173287632682643, -0.24724724724724725, 0.3738955823293173], "score_NOT Homogeneous_2D": 0.962627362459898, "score_GlobalLocal_2D": 0.8350858092308044, "ela_features": [0.06932374816482281, 0.4623210431687462, 0.010831532442891373, 0.11051832609063317, 13.413914108106681, 0.11631644067171779, 0.9279064570420891, 1.1199437407451118, 0.9835251264926527, 0.42431463178471385, 0.0811430528980738, 1.8, 0.9000060596193038, 0.8746546261333659, 0.6437235150164491, 0.18065998762433205, -0.4527104707866242, 0.458587016426167, 0.5433886147474174, 0.6137971810611875, 0.7269444953517198, 0.4580062726789699, 0.5441297044165624, 0.6148779400088195, 0.7280452027971279, -0.476308981298913, -0.4017051497357912, -0.33976328659669247, -0.24022141225983074, -0.4795362561953601, -0.4033388630730325, -0.34074404898834915, -0.24061794162423408, 1.0, 1.0, 0.8333333333333334, 1.0, 0.216445525994834, 0.21646712494051856, 0.2055197810186073, 0.21456573013159802, 0.8235749912649725, 0.09309309309309305, 0.22190556588240837, -0.4274274274274273, 0.5054487179487179], "score_NOT Homogeneous_5D": 0.8938504830002785, "score_GlobalLocal_5D": 0.00015811958292033523, "ela_features_10D": [0.01993307632520298, 0.49759255581086254, 0.0015123300511164937, 0.04988638598204172, 138.6747842164118, 0.04104284306746002, 0.9645340873196464, 1.2536381341511817, 0.9906141632885956, 0.2520263474833449, -0.07260671117668922, 1.4, 1.0184585157642236, 0.9377993124970392, 0.7129394442944172, 0.10484373820777677, -0.5971699602437708, 0.6337514280437244, 0.6892402926990462, 0.7388961017420519, 0.8139140813245636, 0.636055711679799, 0.692165726419204, 0.742131505130415, 0.8181555319304193, -0.4645278914081675, -0.3941484010965738, -0.3311679402350216, -0.23601981860992324, -0.46291272610367357, -0.3915430790581384, -0.327989906903423, -0.23129238568603888, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10952246121962228, 0.10953081244901708, 0.10668531628995999, 0.10622777687491056, 0.8564553135282136, -0.11911911911911906, 0.1332506359220136, -0.6556556556556554, 0.587590072057646], "score_NOT Homogeneous_10D": 0.6386494636535645, "score_GlobalLocal_10D": 0.00021657483011949807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-0.5555555555555554, -0.5555555555555554], 0.5], [1, [0.5555555555555554, -0.5555555555555554], 0.5], [1, [-0.5555555555555554, 0.5555555555555554], 0.5], [1, [0.5555555555555554, 0.5555555555555554], 0.5], [1, [0.5555555555555554, 0.7066666666666661], 0.5], [2, [0.7066730852568274, 0.5556529242448947], 0.5], [14, [-0.7066666666666657, 0.5555555555555554], 0.5], [17, [-0.9433588087782285, 1.9986230221049457], 0.750939544868731], [16, [-0.6357049796966434, -0.6357049796966434], 0.5], [20, [0.44256980391107864, -0.7833483575799316], 0.5], [26, [1.964709620965047, 1.025792111988324], 0.5005640012613228]], "nr_of_basins": 11, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-9.81015210403579e-163, -4.1742016771573314e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.689132018033141e-163, 8.081137553221883e-164, -2.8808912627236534e-163, 1.441840294575422e-162, 9.78922384418442e-164]}
{"id": "72199281-4c48-471a-8bda-bf7281fda8ff", "fitness": 0.5544316529218728, "name": "landscape_phase_transition_enhanced_glocal", "description": "A phase-transition, non-homogeneous landscape with three radial zones and an enhanced global-local minima contrast. The inner region is a smooth paraboloid, the middle region adds radius-dependent, non-separable oscillations and cross-terms to amplify distinct local minima, and the outer region introduces rugged, high-frequency coupling with cross-term interactions. Smooth radial blending preserves a global minimum at the origin while creating pronounced, well-separated local minima in outer regions for stronger GlobalLocal Contrast.", "code": "import numpy as np\n\nclass landscape_phase_transition_enhanced_glocal:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Radial transition radii (in the same units as x, domain [-5,5])\n        self.r1 = 0.9\n        self.r2 = 2.7\n        self.r3 = 5.0\n\n        # Inner region parameters (paraboloid-like)\n        # (kept simple to preserve global minimum at origin)\n        # Middle-region modulation (enhanced non-separable and phase-transition boosted)\n        self.a = 0.90       # amplitude for cos modulation in middle region (0 < a < 1)\n        self.b = 2.5        # base frequency for cos modulation per coordinate\n        self.c_mid = 0.65   # cross-term weight for sum(x)^2 in middle region\n        self.d_mid = 1.5    # weight for a small per-dimension sine term in middle\n        self.gl_local = 0.90  # additional non-separable, cross-term boost in middle\n\n        # Outer-region ruggedness/coupling (nonnegative contributions)\n        self.e_outer = 0.25   # weight for the sum(x)^2 term in outer region\n        self.g_outer = 0.60   # weight for a high-frequency per-dimension cosine term in outer\n        self.freq_out = 4.0     # frequency for outer rugged term\n        self.freq_out2 = 6.0    # frequency for outer non-separable cross-term (enhanced GL contrast)\n        self.outer_rug = 0.80    # weight for outer non-separable cross-term\n\n        # Ensure a smooth blend exists\n        # Helper: clamp is not required; smoothstep handles bounds.\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region: global minimum at origin\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: enhanced non-separable, phase-transition modulated\n        f_mid = float(np.sum((1.0 + self.a * np.cos(self.b * x)) * (x**2)))\n        # radius-dependent cross-term across all coordinates\n        f_mid += self.c_mid * (np.sum(x))**2 / max(self.dim, 1)\n        # small per-dimension sine modulation to break separability\n        f_mid += self.d_mid * float(np.sum(np.sin(0.5 * x)))\n        # enhanced non-separable cross-term (squared sum of cos terms)\n        f_mid += self.gl_local * float((np.sum(np.cos(self.b * x)))**2)\n\n        # Outer region: rugged with cross-term coupling (nonnegative contributions)\n        f_outer = float(np.sum(x**4))\n        f_outer += self.e_outer * (np.sum(x))**2\n        f_outer += self.g_outer * float(np.sum(1.0 + np.cos(self.freq_out * x)))\n        # outer non-separable cross-term to boost local minima contrast\n        f_outer += self.outer_rug * float((np.sum(np.cos(self.freq_out2 * x)))**2)\n\n        # Phase-transition weights\n        s1 = self._smoothstep(self.r1, self.r2, r)  # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)  # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_phase_transition_enhanced_glocal scored on:NOT Homogeneous 0.895, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1f844945-94f0-460d-8946-a21dca1419aa"], "operator": null, "metadata": {"ela_features_2D": [-0.003032828927955711, 0.2028235433913473, 0.006230064909344046, 0.01850534872173191, 5.108071789712853, -0.0008098944968345956, 0.8915804831967492, 1.0112207130392004, 0.8925696904539449, 1.0019423383899748, 0.1464318434814782, 2.0, 0.703200207508217, 0.7191531868246086, 0.5699340177143944, 0.33991824838878426, -0.23359687950664632, 0.1522989360147542, 0.22791678327760795, 0.3145846362331909, 0.4960218892910411, 0.14966671537391135, 0.23280942527810694, 0.31505961620267525, 0.4988475242494584, -0.4436175521968802, -0.4040418499581456, -0.3586890184616699, -0.2637410726683044, -0.4367606398121288, -0.3940545605635724, -0.35181137542207275, -0.25741051584513647, 1.0, 1.0, 1.0, 1.0, 0.5194899654170577, 0.5194859460996929, 0.4050363202307617, 0.35189566647023873, 0.5676640086025992, 0.6416416416416414, 0.5226346418834755, -0.13913913913913914, 0.3755020080321285], "score_NOT Homogeneous_2D": 0.9142003282904625, "score_GlobalLocal_2D": 0.9807450771331787, "ela_features": [-0.0004256693096672759, 0.31517422779343884, 0.005236403227149219, 0.027671274853806094, 11.510707032358834, 0.0025702625362963973, 0.9235891870560655, 1.0391459945240897, 0.9258104837484094, 0.5804245462204323, 0.12226030868342574, 1.2, 0.9079059451901428, 0.8768708010764982, 0.6409075136301907, 0.17943991705105256, -0.502651140043498, 0.4225145415940549, 0.5075325025865217, 0.5914024896871982, 0.7250558249650297, 0.42208417398574916, 0.5096307907264783, 0.5934629110389033, 0.7275805599742222, -0.5078959351676253, -0.43312265354831386, -0.3593592291726564, -0.24181198216177072, -0.5106951714675068, -0.4333318058009425, -0.35924934484808196, -0.24073226739217182, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21328167655767566, 0.21327089781906552, 0.19729266283498123, 0.1810401012595377, 0.8270866517962945, 0.26126126126126115, 0.2935268127663019, -0.2992992992992992, 0.5410256410256411], "score_NOT Homogeneous_5D": 0.535590410232544, "score_GlobalLocal_5D": 0.0009350752807222307, "ela_features_10D": [-0.0006423560245479853, 0.3519413504825554, 0.0009366010750877417, 0.019959482353913625, 318.5356254118534, 0.010061066213878322, 0.918534767697893, 1.06939576030015, 0.9220696737531711, 0.47278614589520485, 0.11712392845792748, 1.2, 1.0140065750224765, 0.9382565388264045, 0.6973429127083878, 0.10641112642023072, -0.5991157199633879, 0.6314698976073366, 0.692004337105373, 0.7407935975727489, 0.8140551145928632, 0.636347878889692, 0.6956728746899743, 0.744337427690382, 0.8180073716994339, -0.4673565400330256, -0.39058883562047264, -0.3287160306405994, -0.23580828190529587, -0.4622780283879225, -0.38686343220252395, -0.3250003202089595, -0.23135018651543385, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.111423174616377, 0.11142429779891258, 0.1081110985824307, 0.10157594939432732, 0.8660042146154765, -0.05905905905905906, 0.1369663556292036, -0.6156156156156154, 0.6073658927141713], "score_NOT Homogeneous_10D": 0.8947552070021629, "score_GlobalLocal_10D": 0.000363819592166692}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [5.15173858805248e-163, 9.446882954323678e-164], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.777885756290512e-163, -1.0906611721051758e-162, -1.4364489154906644e-162, -1.7544793355583644e-164, -7.607940721057848e-163]}
{"id": "5b67342f-30c3-4900-933d-8b27997a5444", "fitness": 0.5539271539795058, "name": "landscape_globlocal_adv_enhanced", "description": "This enhanced non-homogeneous phase-transition landscape amplifies the global-local minima contrast by adding a radius-gated outer-shell multi-modal term. Outer regions feature cosine-squared wells that create pronounced outer local minima, while a strong radial amplification boosts their depth relative to the global minimum at the origin. The global minimum remains at x=0 with f(0)=0, preserving a distinct non-homogeneous search space with phase transitions across radii.", "code": "import numpy as np\n\nclass landscape_globlocal_adv_enhanced:\n    \n    def __init__(self, dim=5):\n        # problem dimensionality\n        self.dim = int(dim)\n        # region width along each axis to induce non-homogeneous, phase-transition-like behavior\n        self.region_width = 2.0\n        # maximum region index per axis (based on domain [-5,5])\n        self.max_region = int(np.floor((10.0) / self.region_width))\n        # stronger radial amplification to heighten outer-region ruggedness and depth of local minima\n        self.gamma = 3.5\n\n        # parameters controlling per-dimension modulation (base nonconvex term)\n        self.amp_base = 0.15\n        self.amp_var = 0.25\n\n        # Outer-shell modulation to create pronounced outer local minima\n        self.shell_amp = 0.90           # amplitude of outer-shell contribution\n        self.shell_freq = 0.80          # frequency for per-dimension cosine-squared wells\n        self.shell_phase = np.array([0.12 * i for i in range(self.dim)], dtype=float)  # deterministic phases\n\n        # radial gating for outer-shell: turns on after radius ~2.0, with smooth rise\n        self.r_shell_on = 2.0\n\n    def _region_index(self, xi):\n        # compute discrete region index for a coordinate\n        ri = int(np.floor((float(xi) + 5.0) / self.region_width))\n        if ri < 0:\n            ri = 0\n        if ri > self.max_region:\n            ri = self.max_region\n        return ri\n\n    def f(self, x):\n        # evaluation: x should be a 1-D array of length dim\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input vector length must be equal to dim\")\n\n        # region indices per dimension\n        ri = np.array([self._region_index(float(xi)) for xi in x], dtype=int)\n\n        total = 0.0\n        # per-dimension nonnegative, nonconvex term (zero at origin is ensured by x_i^2 factor)\n        for i in range(self.dim):\n            # region-dependent amplitude for nonconvex modulation\n            a = self.amp_base + self.amp_var * np.sin(ri[i] * 1.37 + i * 0.43)\n            if a < 0:\n                a = 0.0  # keep nonnegative\n            # region-dependent frequency\n            freq = 1.0 + 0.20 * (ri[i] % 6)\n            term = x[i]**2 * (1.0 + a * np.sin(freq * x[i]))**2\n            total += term\n\n        # cross-term coupling, nonnegative and gently modulated to keep phase-transition flavor\n        for i in range(self.dim - 1):\n            rsum = ri[i] + ri[i + 1]\n            cross = 0.5 * (x[i] - x[i + 1])**2 * (\n                1.0 + 0.30 * np.cos(rsum * 1.7 + (x[i] + x[i + 1]) * 0.8)\n            )\n            total += cross\n\n        # radial amplification to emphasize outer-region ruggedness, boosting Local minima depth\n        r = np.linalg.norm(x)\n        radial_weight = 1.0 + self.gamma * np.tanh(r / 6.0)\n\n        # Outer-shell term: radius-gated multi-modal wells (nonnegative, zero at origin)\n        # Each dimension contributes a cos^2 term; the sum is scaled to be moderate\n        cos_terms = np.cos(self.shell_freq * x + self.shell_phase)\n        sumcos2 = np.sum(cos_terms**2)\n        # radially gated amplitude; starts rising after r > 2.0\n        r_blend = max(0.0, np.tanh((r - self.r_shell_on) / 2.0))\n        outer_shell = self.shell_amp * r_blend * (sumcos2 / float(self.dim))\n\n        return float(radial_weight * (total + outer_shell))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_globlocal_adv_enhanced scored on:NOT Homogeneous 0.941, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3aced7d6-db59-4bb7-aafe-9943a44cfda2"], "operator": null, "metadata": {"ela_features_2D": [0.0069856047952273626, 0.24144204931359498, 0.023825822359112726, 0.05661681242158793, 3.96938673429755, 0.17062609196159373, 0.8123539422102446, 1.0909270456133462, 0.9744965058923771, 1.4942157679310877, 2.7184088648906415, 2.0, 0.7295427295807594, 0.7149322985769325, 0.557552677287151, 0.3448177648342756, -0.1869001775030888, 0.15439339154336346, 0.22622019041287172, 0.31455256767781214, 0.4993527669414699, 0.15648479198602455, 0.22715245528226116, 0.3137078922514868, 0.49668809737170516, -0.44254971906413554, -0.40496126810256294, -0.35873247584383355, -0.2620175585135588, -0.43361460625887194, -0.3972903332231377, -0.35279219452709487, -0.25873231331594404, 1.0, 1.0, 1.0, 1.0, 0.5131406517876645, 0.5130981953130279, 0.4288261593801139, 0.36693635545907377, 0.6798896282803656, 0.5295295295295294, 0.4242126729170307, -0.2152152152152152, 0.3811244979919678], "score_NOT Homogeneous_2D": 0.7318976819515228, "score_GlobalLocal_2D": 0.8043587803840637, "ela_features": [0.004954591393679419, 0.3145640652475366, 0.008347634183572202, 0.039805740216933415, 8.955188507643811, 0.15644440463731385, 0.8288450653007052, 1.536622360615356, 0.9724250989647049, 0.9608096134977361, 1.1730903091433422, 1.8, 0.911794502263868, 0.871760285491552, 0.644345866848745, 0.1872208731545829, -0.43840999285565757, 0.46087187799835555, 0.5491613329718463, 0.6199723777044202, 0.7349715863989433, 0.46464138836476393, 0.548091046765763, 0.6206539945017723, 0.7359719478933899, -0.4743452415126086, -0.3966664782706985, -0.3343637920687321, -0.23318236454928742, -0.47371287343889756, -0.39987839707004175, -0.33566880879255345, -0.23362654286458806, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21782250075256374, 0.21782855906971754, 0.2057892929503299, 0.18599433333008014, 0.8252495361439621, 0.18118118118118112, 0.19234084944948554, -0.4634634634634634, 0.5326923076923077], "score_NOT Homogeneous_5D": 0.8455161303281784, "score_GlobalLocal_5D": 0.0002748002880252898, "ela_features_10D": [0.0029778420944829077, 0.35286186942603914, 0.0006727767218845486, 0.021284537176331213, 51.45131080770894, 0.1569478111969297, 0.8214375498041144, 1.6601699525128137, 0.970332998251665, 0.6479421275847479, 0.5973805526792104, 2.4, 1.008110641415229, 0.935928806871997, 0.7066688818902096, 0.10721286126331409, -0.566491070190509, 0.6293496335944513, 0.6951997176813121, 0.7438635246231586, 0.8212809000496026, 0.6303690524338356, 0.6953223234097907, 0.7454365082303587, 0.8234389205104076, -0.47007590170370916, -0.38656194473722294, -0.32484417633709073, -0.22665991438248687, -0.47004529639197273, -0.38744701674845267, -0.3237185025541291, -0.22452582527526915, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10945490798155388, 0.10944999489301313, 0.10680091282468815, 0.10133516551053375, 0.8577802011825872, -0.12712712712712704, 0.1182835551607176, -0.6916916916916914, 0.5851881505204164], "score_NOT Homogeneous_10D": 0.9411314465105534, "score_GlobalLocal_10D": 0.00038408441469073296}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], 133.82271267612543], [1, [3.000888888888987, 5.0], 97.70841654451817], [1, [3.000101407874144, 1.6627449484652583], 35.23092165839409], [2, [0.856298645623019, 3.0000073462001096], 33.17248495247186], [4, [-0.032966369661908634, -0.001449792270731158], 0.0017249181728099677], [3, [1.6627362797791774, 3.0001458822169775], 33.109328752883485], [4, [-1.0003749147112935, -0.9689389618819388], 1.9685717962372011], [4, [-1.0009303745144416, -1.265373173104573], 1.9664820096459392], [1, [5.0000796861783385, 3.0008889219613053], 101.32540837741108], [5, [1.000666676809355, 1.000550434012275], 3.6253846268831], [8, [0.21479944607278822, 1.0004132817065376], 2.020933860996108], [8, [-0.3617678806069719, -1.0002716358943686], 1.0763610058239124], [4, [5.0, 0.5555555555555554], 89.01323391406358], [2, [5.001202028766753, 1.7277914182841974], 97.20438409494668], [4, [0.5555555555555554, 5.0], 83.39897094480685], [2, [1.7246856861509146, 5.001789495875972], 91.1377022565676], [8, [-3.0009809836554826, -1.0000006520627165], 30.538904399160852], [6, [1.0003034893199634, 0.9274669222343719], 3.771134413814063], [2, [-1.0006667073211217, 3.000656183590968], 40.38235118506277], [8, [-1.3069155155158456, -3.000593950337369], 28.844148258547666], [4, [-3.00091719740973, -3.0008888893401244], 54.3558471655573], [2, [3.000731364857168, -1.0006666852956942], 42.543180719424306], [6, [-3.0000049709154117, 1.0004461562562097], 41.95928022735269], [6, [1.0019454836561654, -3.0006525782035296], 41.317486218828044], [2, [5.0, -3.0008888888889866], 185.2121572972288], [2, [-3.0008888888889866, 5.0], 179.99179057856838]], "nr_of_basins": 26, "f_opt_dim_2": 0.0, "x_opt_dim_2": [2.1443606241172344e-164, 1.2974424959292193e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [9.050605010175446e-163, -1.2569268112317735e-162, -1.2314570287519995e-162, -3.618007794635181e-163, 2.6749786620546187e-163]}
{"id": "499d873c-a37f-46a0-809b-7394a76aaff3", "fitness": 0.5155335351325144, "name": "SectorPhaseTransitionLandscape", "description": "This landscape introduces angular-sector phase transitions to create a non-homogeneous search space with a strong global-local minima contrast. The inner region is a smooth anisotropic bowl, the middle region adds sector-based ruggedness through angular modulation and cross-terms, and the outer region features amplified, multi-modal ruggedness guided by both angular and radial terms. The global minimum sits at the origin with f(0)=0, while outer regions contain pronounced local minima to deepen the GlobalLocal contrast.", "code": "import numpy as np\n\nclass SectorPhaseTransitionLandscape:\n    \"\"\"\n    A non-homogeneous, three-zone landscape using angular-sector phase transitions.\n    - Inner zone (r <= R1): anisotropic convex bowl (quadratic, positive definite)\n    - Middle zone (R1 < r <= R2): smoothly blended region with angular modulation and cross-term ruggedness\n    - Outer zone (r > R2): amplified, multi-modal rugged region with strong radial & angular oscillations\n    The global minimum is at the origin (f(0) = 0). The outer region introduces pronounced\n    local minima to create a strong GlobalLocal contrast.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Phase radii (non-homogeneous zones)\n        self.R1 = 1.0\n        self.R2 = 3.0\n\n        # Maximum radius within domain [-5, 5]^dim\n        self.dmax = 5.0 * np.sqrt(self.dim)\n\n        # Anisotropic weights for the inner zone (dim-vector)\n        i = np.arange(self.dim)\n        # Vary weights with dimension to avoid perfect isotropy\n        self.w = 0.35 + 0.65 * (np.abs(np.cos(np.pi * i / max(1.0, self.dim))))\n\n        # Middle zone parameters\n        self.gamma = 0.4      # cross-term weight in middle zone\n        self.a_ang = 0.9       # angular modulation strength in middle zone\n        self.angular_freq = max(1, int(self.dim * 1.2))  # freq for theta-based modulation\n\n        # Outer zone parameters\n        self.kappa = 0.9       # radial amplification factor in outer zone\n        self.delta = 0.6        # cross-term weight for angular term in outer\n        self.K_theta = self.angular_freq  # reuse freq for outer angular term\n        self.K_r = 6.0            # radial oscillation frequency for outer\n\n    def _smoothstep(self, t):\n        t = np.clip(t, 0.0, 1.0)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).flatten()\n        if x.size != self.dim:\n            raise ValueError(f\"x must be of length {self.dim}\")\n\n        # Radial distance (Euclidean norm)\n        r = np.linalg.norm(x)\n\n        # Inner zone: smooth anisotropic bowl\n        if r <= self.R1:\n            fA = float(np.sum(self.w * (x ** 2)))\n            return fA\n\n        # Angle theta using first two dimensions (projection)\n        if self.dim >= 2:\n            theta = float(np.arctan2(x[1], x[0]))\n        else:\n            theta = 0.0\n\n        # Baseline inner-zone value (to be used for blending)\n        fA = float(np.sum(self.w * (x ** 2)))\n\n        # Cross-term (nonnegative, depends on sum of coordinates)\n        cross = self.gamma * (1.0 - np.cos(np.sum(x)))\n        # Middle-zone angular modulation: ensure a lower bound of 1.0\n        angular_mod = 1.0 + self.a_ang * (1.0 - np.cos(self.angular_freq * theta)) / 2.0\n        # Middle-zone ruggedness term\n        fB = fA + cross\n        fM = fB * angular_mod  # blended middle-ground rugged landscape\n\n        # Normalized blend parameter for middle zone\n        t = (r - self.R1) / (self.R2 - self.R1)\n        t = np.clip(t, 0.0, 1.0)\n        s = self._smoothstep(t)\n\n        # Middle zone blending\n        if r <= self.R2:\n            f = (1.0 - s) * fA + s * fM\n            return float(f)\n\n        # Outer zone: amplified, multi-modal rugged region\n        t2 = (r - self.R2) / (self.dmax - self.R2)\n        t2 = np.clip(t2, 0.0, 1.0)\n        s2 = self._smoothstep(t2)\n\n        # Outer-base ruggedness with angular and radial oscillations\n        # Angular term in outer zone (nonnegative, oscillatory)\n        angular_outer = self.delta * (1.0 - np.cos(self.K_theta * theta))\n        # Radial term to create multiple wells in radius\n        radial_outer = self.delta * (1.0 - np.cos(self.K_r * r))\n        fC0 = float(np.sum(x ** 2)) + angular_outer + radial_outer\n\n        # Radial amplification to boost outer-region contrast\n        amp = 1.0 + self.kappa * (r / max(1e-9, self.dmax)) ** 2\n        fC = fC0 * amp\n\n        # Blend between the middle-ground ruggedness and the outer ruggedness\n        f = (1.0 - s2) * fM + s2 * fC\n        return float(f)", "configspace": "", "generation": 3, "feedback": "The optimization landscape SectorPhaseTransitionLandscape scored on:NOT Homogeneous 0.525, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["f96d6870-a25c-4768-8a2c-1785c53ebc94"], "operator": null, "metadata": {"ela_features_2D": [-0.0014108954021256226, 0.2177459186852831, 0.016015517615704546, 0.025518645540594926, 2.173676869962101, 0.0006541077605873413, 0.9437418310332205, 1.1062261748611468, 0.9896719058398931, 1.3515038964156794, 1.8458916467766397, 2.2, 0.7336394524720387, 0.7203734449729333, 0.5849703552242279, 0.34054987052806546, -0.20284900919277526, 0.1405949425318516, 0.22518407847136138, 0.31173559618019586, 0.485099999344241, 0.13510256989554761, 0.22224257733815, 0.31166764845030337, 0.487929078404114, -0.44950238014403715, -0.4052599448305318, -0.35998972778787064, -0.2693099340601467, -0.44326370288073375, -0.39861550733790274, -0.35277958196414533, -0.26243780824091784, 1.0, 1.0, 1.0, 1.0, 0.5161571830139499, 0.5161540691255556, 0.42253272369419426, 0.3552181208527975, 0.6849451145994296, 0.5655655655655654, 0.3496165411962281, -0.30330330330330324, 0.3618473895582329], "score_NOT Homogeneous_2D": 0.7378838956356049, "score_GlobalLocal_2D": 0.9498986601829529, "ela_features": [-0.000575908621980914, 0.3022664404478802, 0.0030510039723940447, 0.01933813736647585, 24.464283014208608, 0.0027466727698717275, 0.9359620993609351, 1.3485806357781303, 0.9513998767513823, 0.7441677440272823, 0.5351992623948532, 1.6, 0.8790259500176895, 0.8692471192562665, 0.6215633810286747, 0.18541917231934715, -0.4679690008734128, 0.4790860866854148, 0.5530673024085835, 0.6174825680016769, 0.729669108873893, 0.4767906002879692, 0.552953039108256, 0.6181946919387316, 0.7323484834786832, -0.4581679008346738, -0.39309758401030753, -0.33644116786277645, -0.2377679441399967, -0.46247634268358667, -0.39515265803464006, -0.3374833651904171, -0.23658211796318773, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21693273151174827, 0.2169496053487853, 0.2038757827342431, 0.18180943245049133, 0.8271797650698023, 0.1691691691691691, 0.23036443123917505, -0.39139139139139123, 0.5318910256410257], "score_NOT Homogeneous_5D": 0.879473552107811, "score_GlobalLocal_5D": 0.0002219458547187969, "ela_features_10D": [-0.0008321806672371812, 0.33209939144580586, 0.001877058654709017, 0.01656885454126826, 13.316522891773861, 0.008940854872225734, 0.913292299606379, 1.5340507033467718, 0.9232735347849804, 0.5660081182317936, 0.44597788929171855, 1.8, 0.9913642490065794, 0.9346754776098463, 0.6850702704625842, 0.1091690371094696, -0.5860837633558683, 0.644435459605084, 0.6993648939370296, 0.7490489559083287, 0.8210062519740908, 0.6453132092318475, 0.7011261110417768, 0.7516820104468691, 0.8243125249556617, -0.4509523018589512, -0.3812868389604479, -0.3182740857146149, -0.2270125826021633, -0.4510251626476244, -0.3800518858597385, -0.3157648611075921, -0.22340605789933096, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1106159497161893, 0.1106060349673645, 0.10772660659918162, 0.10088417505402517, 0.8583243331034837, -0.0950950950950951, 0.12286183825174483, -0.6436436436436435, 0.5996797437950361], "score_NOT Homogeneous_10D": 0.5254284739494324, "score_GlobalLocal_10D": 0.00029468306456692517}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-1.2289368078066687e-05, 0.00038053511053109945], 5.083346818917884e-08]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [3.473857523480265e-164, -1.0237157897512335e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [6.9935875570898e-163, 8.56538282577849e-163, -1.387094714682158e-162, 7.290582675173963e-163, 3.7108079281555186e-163]}
{"id": "2ca08b03-e72f-4d20-9b1e-dd2db67c4a0f", "fitness": 0.5385969496322408, "name": "landscape_phase_transition_enhanced_glocal_v2", "description": "A novel three-zone, non-homogeneous phase-transition landscape with enhanced global-local minima contrast. The inner region remains a smooth paraboloid (global minimum at the origin), the middle region adds non-separable, oscillatory, and cross-term components with nonnegative contributions to create pronounced outer local minima, and the outer region introduces multi-modal ruggedness. Smooth radial blending preserves the origin as the global minimum while amplifying the separation between global and outer local minima for stronger GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_phase_transition_enhanced_glocal_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Radial transition radii (domain [-5, 5])\n        self.r1 = 0.9\n        self.r2 = 2.8\n        self.r3 = 5.0\n\n        # Inner region: smooth paraboloid-like (keeps global minimum at origin)\n        # Middle region: enhanced non-separable and phase-transition boosted\n        self.a = 0.92       # weight for non-separable middle cross-term\n        self.b = 2.7        # base frequency for middle region cos modulation\n        self.c_mid = 0.70   # cross-term weight for sum(x)^2 in middle region\n        self.d_mid = 1.8    # weight for a nonnegative sin^2 term in middle\n        self.gl_local = 0.95  # additional non-separable cross-term boost in middle\n\n        # Outer region: rugged multi-modal wells (nonnegative contributions)\n        self.e_outer = 0.28   # weight for (sum x)^2 term in outer\n        self.g_outer = 0.65   # weight for outer radial oscillation term\n        self.freq_out = 5.0     # frequency for outer per-dimension cosine term\n        self.freq_out2 = 7.0    # frequency for outer cross-term (cos) term\n        self.outer_rug = 0.90    # weight for outer cross-term ruggedness\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region: pure paraboloid (global minimum at origin)\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: enhanced non-separable, phase-transition boosted\n        f_mid = 0.0\n        # Non-separable cross-term with diminishing separability\n        f_mid += (1.0 - self.a) * float(np.sum(x**2))\n        f_mid += float(self.a * np.sum((np.cos(self.b * x) * x)**2))\n        # Cross-term: radial (sum x)^2\n        f_mid += float(self.c_mid * (np.sum(x))**2 / max(self.dim, 1))\n        # Nonnegative sine-based modulation to break separability\n        f_mid += float(self.d_mid * np.sum(np.sin(0.4 * x))**2)\n        # Additional non-separable boost (cos-based cross-term)\n        f_mid += float(self.gl_local * (np.sum(np.cos(self.b * x) * x))**2)\n\n        # Outer region: rugged, multi-modal wells with radial phase transition\n        f_outer = 0.0\n        f_outer += float(np.sum(x**4))\n        f_outer += float(self.e_outer * (np.sum(x))**2)\n        # Nonnegative radial-well term using (1 - cos)\n        f_outer += float(self.g_outer * np.sum(1.0 - np.cos(self.freq_out * x)))\n        # Outer cross-term ruggedness (squared sum of cos terms)\n        f_outer += float(self.outer_rug * (np.sum(np.cos(self.freq_out2 * x)))**2)\n\n        # Phase-transition weights based on radius\n        s1 = self._smoothstep(self.r1, self.r2, r)  # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)  # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_phase_transition_enhanced_glocal_v2 scored on:NOT Homogeneous 0.778, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["72199281-4c48-471a-8bda-bf7281fda8ff"], "operator": null, "metadata": {"ela_features_2D": [-0.0018336544158932266, 0.18709487585404905, 0.014907780596262975, 0.030792287864109074, 2.9882087270798445, 0.0013211274067098434, 0.8923494882524805, 1.0113357663853004, 0.8951715185982587, 1.0699009021074755, 0.3797371002358293, 2.0, 0.6169357107050166, 0.6885538555601742, 0.4884824821949464, 0.3595165214605653, -0.21102919709483642, 0.14505499721078807, 0.252835964863599, 0.33422768555241256, 0.5146369886209652, 0.1535091364908777, 0.24328788714307645, 0.32655701537195286, 0.5125601154674507, -0.44776173217390625, -0.39131019201492045, -0.3486847372066187, -0.25419678732998807, -0.4356301377228956, -0.38943202727941373, -0.34658725578979627, -0.2508549558414702, 1.0, 1.0, 1.0, 1.0, 0.5123946132516561, 0.5123771827176464, 0.40001084208210697, 0.34968621404162603, 0.5863064714370329, 0.6376376376376374, 0.3721258333976033, -0.18718718718718713, 0.4028112449799197], "score_NOT Homogeneous_2D": 0.9376182779669762, "score_GlobalLocal_2D": 0.978923499584198, "ela_features": [-0.0009676472512017531, 0.29869420064441893, 0.0028985025520773017, 0.023747083459602893, 19.48002067709026, 0.0038380499538785084, 0.9241323874201006, 1.0358313391712746, 0.9257091571394438, 0.6076118740819363, 0.24082038864848992, 1.4, 0.9009492907886469, 0.8717240316571473, 0.6237283053167035, 0.1858957936863849, -0.5090227353690912, 0.4497568765385841, 0.524158977048218, 0.5992324630822233, 0.7246291057506341, 0.45215133132706564, 0.5268320685752115, 0.6025521566238318, 0.7284853220494472, -0.4840291344819477, -0.4185781742841016, -0.3525389860266891, -0.2422326630188984, -0.48443731593518946, -0.4183978997086027, -0.35144232345779713, -0.24008578180881898, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21428955493572813, 0.21427462247536638, 0.19897426243749639, 0.17990723329531805, 0.8216221061995373, 0.24524524524524516, 0.27611966645518116, -0.2952952952952952, 0.5354166666666667], "score_NOT Homogeneous_5D": 0.535590410232544, "score_GlobalLocal_5D": 0.0010596117936074734, "ela_features_10D": [-0.00011067157627455692, 0.34471578988482193, 0.0019519994296235289, 0.01799069677727219, 50.2199056959969, 0.009676651042074135, 0.9162448864644507, 1.0504150240126329, 0.9202782579565933, 0.47416454738187774, 0.17007901947668094, 1.8, 1.0129264676775325, 0.9370984407774176, 0.6947622564405845, 0.10781926253066418, -0.5970177797032712, 0.6349943129629049, 0.6962426366105297, 0.7439054374742398, 0.816168087759672, 0.638206070174694, 0.7001346116080202, 0.7474592494261686, 0.8200416167491753, -0.4629246099988246, -0.3852455087328445, -0.32479634559714815, -0.23314808461794495, -0.46007265544806497, -0.3813216862280321, -0.3211414091028212, -0.2288428853432995, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10854329850081652, 0.10853922216902667, 0.10550789717842379, 0.09940957846217263, 0.858958904989316, -0.08308308308308308, 0.13713618791067955, -0.6196196196196194, 0.6027221777421937], "score_NOT Homogeneous_10D": 0.7779979705810547, "score_GlobalLocal_10D": 0.0003919276350643486}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [1.666666666666667, -1.6666666666666665], 1.3442043908623154], [1, [-1.6666666666666665, 1.666666666666667], 1.3442043908623154], [4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [2, [1.6667392681288329, -0.7375546413651128], 2.1921667669134908], [2, [-0.7375546465659603, 1.66673933004398], 2.19216671552264], [2, [0.7375546361130721, -1.666739438549795], 2.1921666247935843], [2, [-1.666742274239303, 0.7375545878102541], 2.192164261442329], [7, [1.6189564525637108, -2.747765386737547], 10.726192783225649], [7, [-2.747711927756013, 1.6189536030508542], 10.726305021322485], [11, [-2.8496467768689353, 0.5037871341906022], 4.163516343775977], [12, [0.5066591818182227, -2.8497660307023294], 4.161310689969625], [17, [2.8530880356511363, -0.5523993124820156], 4.142926259707011], [8, [-1.616911198871405, 2.7492123232965944], 10.723766768356604], [11, [-0.5037871341906022, 2.849646776868936], 4.163516343775975], [5, [-1.6991935786012489, -1.6991935786012489], 7.3942013960891515], [6, [2.7442103254390346, -1.6239537370420347], 10.732467922202588], [2, [1.6992255454213923, 1.6992255454213923], 7.394200194086663]], "nr_of_basins": 17, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.258269148617767e-162, 1.4087224356004223e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [8.144023060561418e-163, -1.6299929811468663e-163, -1.3994775950195574e-162, -1.482417367981702e-162, -1.147079939491131e-163]}
{"id": "5530e001-9648-4d8c-85bb-2f457568c7a4", "fitness": 0.5509486848507853, "name": "landscape_phase_transition_enhanced_glocal_v2", "description": "A sharper, non-homogeneous (phase-transition) three-zone landscape with a strongly enhanced middle layer and highly coupled outer region to boost GlobalLocal contrast. The inner zone is a smooth paraboloid, the middle zone introduces strong non-separable and anisotropic terms with radius gating, and the outer zone adds rugged, high-frequency, cross-coupled wells. The radial blending preserves a global minimum at the origin while producing pronounced outer local minima for clearer global-local separation.", "code": "import numpy as np\n\nclass landscape_phase_transition_enhanced_glocal_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Radial transition radii\n        self.r1 = 0.8\n        self.r2 = 2.0\n        self.r3 = 5.0\n\n        # Middle region (enhanced non-separable and phase-transition boosted)\n        self.a_mid = 1.0      # amplitude for cos modulation in middle region\n        self.b = 3.0            # base frequency for cos modulation\n        self.c_mid = 0.95       # cross-term weight (sum(x))^2 contribution\n        self.d_mid = 2.0        # per-dimension sine modulation weight\n        self.gl_local_mid = 1.4   # non-separable cross-term boost for middle\n        # Anisotropy across coordinates to break symmetry in the middle\n        idx = np.arange(self.dim)\n        self.aniso = 1.0 + 0.5 * np.cos((idx + 1) * np.pi / (self.dim + 1))\n\n        # Outer region ruggedness and cross-term coupling\n        self.e_outer = 0.32       # sum(x)^2 term\n        self.g_outer = 0.72       # high-frequency per-dimension cosine term\n        self.freq_out = 4.0         # frequency for outer rugged term\n        self.freq_out2 = 6.0        # frequency for outer cross-term\n        self.outer_rug = 0.92        # weight for the outer non-separable term\n        self.p_cross_outer = 0.75    # cross-term on outer with anisotropy\n\n        # Ensure a smooth blend exists (three zones with radius-based gating)\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region: smooth paraboloid (global minimum at origin)\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: enhanced non-separable, anisotropy, and cross-terms\n        # Per-coordinate oscillations with anisotropic scaling\n        f_mid = float(np.sum((1.0 + self.a_mid * np.cos(self.b * x)) * (x**2)))\n        # Additional anisotropic quadratic contribution\n        f_mid += float(np.sum(self.aniso * (x**2)))\n        # Radius-dependent cross-term across all coordinates\n        f_mid += self.c_mid * (np.sum(x))**2\n        # Small per-dimension sine modulation to break separability\n        f_mid += self.d_mid * float(np.sum(np.sin(0.5 * x)))\n        # Enhanced non-separable cross-term (squared sum of cos terms)\n        f_mid += self.gl_local_mid * float((np.sum(np.cos(self.b * x)))**2)\n\n        # Outer region: rugged with cross-term coupling and directional modulation\n        f_outer = float(np.sum(x**4))                       # strong nonlinearity\n        f_outer += self.e_outer * (np.sum(x))**2             # radial amplification\n        f_outer += self.g_outer * float(np.sum(1.0 + np.cos(self.freq_out * x)))  # high-frequency ruggedness\n        f_outer += self.outer_rug * float((np.sum(np.cos(self.freq_out2 * x)))**2)  # outer non-separable term\n        f_outer += self.p_cross_outer * float((np.sum(x * self.aniso))**2)  # cross-term with anisotropy\n\n        # Phase-transition weights to create non-homogeneous zones\n        s1 = self._smoothstep(self.r1, self.r2, r)  # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)  # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_phase_transition_enhanced_glocal_v2 scored on:NOT Homogeneous 0.913, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["72199281-4c48-471a-8bda-bf7281fda8ff"], "operator": null, "metadata": {"ela_features_2D": [-0.003083315924625607, 0.19355242477049767, 0.008705074534226745, 0.017462995706043257, 1.9192683100697736, 0.0009139275365078525, 0.9092766934097355, 1.0593769753766162, 0.9160005778325226, 1.0678715843671802, 0.5266843064213602, 2.0, 0.7089583118465337, 0.7187581489482227, 0.5678312398049478, 0.3365413759317001, -0.2279266637866888, 0.13809789108833512, 0.22335660889990133, 0.3193092788020625, 0.49646345352463206, 0.14352490400313125, 0.22279270522153255, 0.3173799420548379, 0.49684462861603135, -0.45094377626311316, -0.40633596658914195, -0.35613287400813803, -0.26344758744413177, -0.4397810499947855, -0.39907764754269814, -0.3505073625177043, -0.25835748287792826, 1.0, 1.0, 1.0, 1.0, 0.5319852957069131, 0.5319838419634778, 0.42430027505671697, 0.35643130331564105, 0.5932247104075612, 0.6056056056056054, 0.3750082789034582, -0.16316316316316312, 0.3654618473895582], "score_NOT Homogeneous_2D": 0.8783317655324936, "score_GlobalLocal_2D": 0.9774941802024841, "ela_features": [-0.000358517839374084, 0.309413345489189, 0.0031523314909504274, 0.025478844228381935, 23.269470512761423, 0.024049651912418278, 0.9098450069442781, 1.0764434560635188, 0.9310928922770232, 0.6234857257221149, 0.27039616418814727, 1.6, 0.9169737356611485, 0.8772878200859034, 0.6400858776460123, 0.18049119829340443, -0.500584533669985, 0.4364973027563158, 0.5224782272885118, 0.6003327054878764, 0.7267726914735815, 0.4385466460809283, 0.523850612332251, 0.6029938595517177, 0.7298346949206149, -0.495627019065792, -0.42000439698827396, -0.35152764665634795, -0.24031609294868703, -0.4962410127460652, -0.4208413689555851, -0.3508917197971777, -0.23878067336578948, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2175937008354299, 0.21758648028117192, 0.20302810383894937, 0.18209258276456927, 0.8291557779531036, 0.24124124124124116, 0.2665163392674064, -0.3073073073073072, 0.5387820512820513], "score_NOT Homogeneous_5D": 0.535590410232544, "score_GlobalLocal_5D": 0.0008712378330528736, "ela_features_10D": [-0.0012797199790944846, 0.34503946618383025, 0.0007284548026135039, 0.014536221887754752, 36.46414153411512, 0.05221920024493931, 0.8798607627964007, 1.0905685963132399, 0.9292774915234914, 0.48759371913450644, 0.2573237292633167, 1.8, 1.0108858457249774, 0.937905723269324, 0.6991562057448738, 0.10665866713693462, -0.5920545116313862, 0.6311283496290622, 0.6903086786329035, 0.7404599780555587, 0.8167850985274738, 0.6339260972166552, 0.6921741953497519, 0.7436495399356886, 0.8201064260400178, -0.46781189806473195, -0.3927574066529489, -0.3291544503073921, -0.2323571436408111, -0.46551892290775587, -0.3914462914836509, -0.32598769465529787, -0.22876089049248166, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10954489146464734, 0.10954786768698195, 0.10657200472827874, 0.09977532554212912, 0.8601752058598956, -0.08708708708708708, 0.12719591510397388, -0.6396396396396394, 0.60080064051241], "score_NOT Homogeneous_10D": 0.9131499975919724, "score_GlobalLocal_10D": 0.00025451771216467023}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [0.00044023657652235296, -0.00031205423312753635], 2.911860877209363e-07]], "nr_of_basins": 1, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-1.333115450478124e-162, 7.433141108275675e-163], "f_opt_dim_5": 0.0, "x_opt_dim_5": [6.962846837946336e-163, 1.4567231957477155e-162, 1.1720420255713145e-162, -9.24417473307294e-163, 4.56932561499284e-163]}
{"id": "65cd5354-68f9-4dc0-a9d0-bf91b313ed9d", "fitness": 0.6218666672551384, "name": "PhaseTransitionRadialLandscape_NonHomogV3", "description": "Non-homogeneous three-zone phase-transition landscape with strengthened outer-region GlobalLocal contrast, including angular (sector) modulation and radial amplification to create distinct, non-uniform search space regions and pronounced outer local minima relative to the global minimum at the origin.", "code": "import numpy as np\n\nclass PhaseTransitionRadialLandscape_NonHomogV3:\n    \"\"\"\n    Enhanced non-homogeneous, three-zone phase-transition landscape with stronger outer-region\n    global-local contrast. Inner zone: anisotropic convex basin. Middle zone: blended ruggedness\n    with sector-based angular modulation. Outer zone: highly multi-modal rugged region with radial\n    amplification and angular modulation to produce pronounced outer local minima while keeping\n    f(0)=0.\n    \"\"\"\n    def __init__(self, dim):\n        self.dim = int(dim)\n\n        # Phase boundaries in radius\n        self.R1 = 1.8\n        self.R2 = 4.0\n\n        # Maximum radius within the domain [-5, 5]^dim\n        self.dmax = np.sqrt(self.dim) * 5.0\n\n        # Anisotropic weights for the inner zone (dim-vector)\n        i = np.arange(self.dim)\n        self.w = 0.8 + 0.4 * np.cos(2.0 * np.pi * i / max(1.0, self.dim))\n\n        # Middle zone ruggedness weight (cross-term in middle zone)\n        self.gamma = 0.6\n\n        # Middle/outer zone base ruggedness depth\n        self.delta = 0.7\n\n        # Outer zone ruggedness mix\n        self.alpha = 0.25\n        self.beta = 0.6\n\n        # Radial amplification in the outer region\n        self.kappa = 1.0\n\n        # Angular (sector) modulation\n        self.sectors = 8\n        # Predefined angular modulation factors per sector to induce non-homogeneity\n        self.sector_weights = np.array([1.0, 1.15, 0.95, 1.25, 0.9, 1.10, 0.98, 1.20])\n\n        # Outer-zone angular amplification\n        self.outer_amp_amp = 0.25\n\n    def _smoothstep(self, t):\n        t = np.clip(t, 0.0, 1.0)\n        return t * t * (3.0 - 2.0 * t)\n\n    def _angle(self, x):\n        if self.dim >= 2:\n            return np.arctan2(x[1], x[0])\n        else:\n            return 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).flatten()\n        if x.size != self.dim:\n            raise ValueError(f\"x must be of length {self.dim}\")\n\n        r = np.linalg.norm(x)\n\n        # Inner zone: anisotropic convex quadratic\n        if r <= self.R1:\n            fA = float(np.sum(self.w * (x ** 2)))\n            return fA\n\n        # Middle zone: blended region with sector-based ruggedness\n        elif r <= self.R2:\n            t = (r - self.R1) / (self.R2 - self.R1)\n            s = self._smoothstep(t)\n\n            # Baseline inner-like basin\n            fA = float(np.sum(self.w * (x ** 2)))\n\n            # Per-dimension ruggedness with sector modulation\n            mod = 2.0 - np.cos(0.8 * x)  # >= 1\n\n            angle = self._angle(x)\n            sector_idx = int(np.floor(((angle + np.pi) / (2 * np.pi)) * self.sectors)) % self.sectors\n            sector_scale = self.sector_weights[sector_idx]\n\n            fB = float(np.sum(self.w * (x ** 2) * (mod * sector_scale)))\n\n            # Cross-term that adds nonnegative ruggedness with global influence\n            cross = self.gamma * (1.0 - np.cos(np.sum(x)))\n            fB_total = fB + cross\n\n            f = (1.0 - s) * fA + s * fB_total\n            return float(f)\n\n        # Outer zone: amplified, multi-modal rugged region with angular modulation\n        else:\n            t2 = (r - self.R2) / (self.dmax - self.R2)\n            s2 = self._smoothstep(t2)\n\n            fC0 = (\n                float(np.sum(x ** 2)) +\n                self.delta * float(np.sum(1.0 - np.cos(2.0 * np.pi * x))) +\n                self.alpha * (np.sum(x)) ** 2 +\n                self.beta * float(np.sum(np.cos(4.0 * np.pi * x) ** 2))\n            )\n\n            # Radial amplification\n            amp = 1.0 + self.kappa * (r / max(1e-9, self.dmax)) ** 2\n\n            # Angular modulation on outer zone\n            angle = self._angle(x)\n            outer_ang = 1.0 + self.outer_amp_amp * np.sin(3.0 * angle)\n            fC = fC0 * amp * outer_ang\n\n            # Middle-zone proxy baseline used for smooth transition into outer zone\n            fA_mid = float(np.sum(self.w * (x ** 2)))\n            cross_mid = self.gamma * (1.0 - np.cos(np.sum(x)))\n            fB = fA_mid + cross_mid\n\n            f = (1.0 - s2) * fB + s2 * fC\n            return float(f)", "configspace": "", "generation": 4, "feedback": "The optimization landscape PhaseTransitionRadialLandscape_NonHomogV3 scored on:NOT Homogeneous 0.904, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3df567e7-78c7-4497-9aaa-56827aafde37"], "operator": null, "metadata": {"ela_features_2D": [0.005914456468429874, 0.1332166972632325, 0.02058398469926696, 0.04110183256549969, 2.8647406899975905, 0.03723361492504895, 0.7011255078079419, 1.7858093486029087, 0.8172023311848864, 1.9594056399619273, 5.60254374963038, 3.2, 0.5548289918088694, 0.6809861294886037, 0.461687740415426, 0.3566693080813706, -0.24239938815905476, 0.16653113242341183, 0.2527293826863991, 0.3413292716071194, 0.515649995567269, 0.1688314941616315, 0.2500166338801875, 0.335809559170016, 0.5052201259464824, -0.4359946706277613, -0.39090097054953954, -0.34455623238125843, -0.25336669719248145, -0.42669257336549543, -0.3850062640544378, -0.34096393610751297, -0.2539962758713873, 1.0, 1.0, 0.9333333333333332, 1.0, 0.524536197037738, 0.5245331475982469, 0.4673955997456022, 0.3688093106583471, 0.6892831809832392, 0.8418418418418415, 0.41901754135385316, -0.1551551551551551, 0.4100401606425703], "score_NOT Homogeneous_2D": 0.9924466018564999, "score_GlobalLocal_2D": 0.8641716241836548, "ela_features": [0.00611863457682722, 0.1526306834829375, 0.0013262305509141518, 0.02862031991212226, 55.545236393962114, 0.08036678962785833, 0.8057787907273026, 1.3337324978221523, 0.9548269398954392, 1.8140273352904905, 5.464682100773079, 4.0, 0.8915629212858229, 0.8680646059059856, 0.6167089037396283, 0.18883587601110144, -0.40343788363329025, 0.5068320291183432, 0.6051923648915306, 0.6530420059864142, 0.7353844104710303, 0.498421217048183, 0.5985233355329358, 0.6534602127851644, 0.7393246746785618, -0.43377918023570333, -0.34726466197779793, -0.3051763968676617, -0.23275017282029148, -0.4434452348864502, -0.3549485354332519, -0.3063791415222999, -0.23046537383290538, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21578423596955137, 0.21582789014984058, 0.20846582775136993, 0.187017574599304, 0.8030192297522252, 0.1451451451451451, 0.11888519887884597, -0.6356356356356354, 0.5312500000000001], "score_NOT Homogeneous_5D": 0.9699844140559435, "score_GlobalLocal_5D": 0.0005744016962125897, "ela_features_10D": [0.005569894983323409, 0.17432460676766398, 0.0007064122978824708, 0.026903899241098622, 131.70884213131166, 0.13863714278582392, 0.7630603944463337, 1.3391533046122055, 0.9550277496592562, 1.601041917320194, 5.076490447845302, 4.0, 1.012915161109837, 0.9378566712148171, 0.7124990174421564, 0.10551706054113574, -0.5086815158889697, 0.6286740789324476, 0.6835950563888435, 0.7334924074276182, 0.8121792752804522, 0.6323880499483044, 0.6874525551512727, 0.736748767382883, 0.815764017282351, -0.4708964437221379, -0.40124903940425155, -0.3379718185435572, -0.2381851288355314, -0.46735498697738664, -0.3973502849416162, -0.33467891179927545, -0.2342248699871429, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.10944089224226775, 0.10944250162735562, 0.1077884879370278, 0.10142731478984897, 0.8466395255230796, -0.1751751751751751, 0.07697206673961268, -0.8558558558558556, 0.5851881505204164], "score_NOT Homogeneous_10D": 0.9036010503768921, "score_GlobalLocal_10D": 0.0004219113616272807}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [-3.661755745584307, -1.6103946912918399], 17.408904283302064], [7, [-3.635518516953254, 1.6683501068967472], 17.80539525911768], [6, [3.636888888888917, 1.666666666666667], 17.24906877596891], [8, [3.311889755440646, -2.24366580011491], 15.486942255721143], [7, [-1.8800272055662375, 3.5307360746125354], 9.875738178703374], [8, [0.9366666666666663, -3.888888888888889], 8.291469880757914], [43, [7.138691496960344e-05, 0.00020823128340855652], 2.3459416910642708e-08], [8, [-1.2071331799151284, -3.814523742473955], 7.986232853939543], [8, [1.2434857302066045, 3.802539313902286], 8.042744765360034]], "nr_of_basins": 9, "f_opt_dim_2": 0.0, "x_opt_dim_2": [-2.3521586939407205e-163, 2.27948562226319e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.2071510752095224e-162, -8.705367476845624e-163, -7.543097785223421e-163, 3.271279522024068e-163, -1.4746639232125856e-162]}
{"id": "4108e6fd-2ae8-409d-a112-09e1058be416", "fitness": 0.5485175057741193, "name": "landscape_globallocal_enhanced_nh3", "description": "A novel non-homogeneous phase-transition landscape with radial shells and angular sector modulation to maximize GlobalLocal contrast. It places dense, directionally biased wells on multiple radial shells, with a smooth inner basin and radius-dependent cross-term coupling that increases non-separability with distance from the origin. The resulting search space exhibits clear phase transitions across radii and sectors, creating strong global-local minima contrast while preserving a global minimum at f(0)=0.", "code": "import numpy as np\n\nclass landscape_globallocal_enhanced_nh3:\n    def __init__(self, dim, depth_factor=6.0, shells=4, R1=0.8, R2=5.0,\n                 angular_freq=8.0, cross_strength=0.9, seed=2024):\n        \"\"\"\n        Novel non-homogeneous, phase-transition landscape with multiple radial shells of wells.\n        - dim: problem dimension\n        - depth_factor: scales depth of outer wells (more non-homogeneity -> larger depths)\n        - shells: number of radial shells to place wells on (outer shells concentrate more wells)\n        - R1, R2: inner/middle transition radii\n        - angular_freq: controls angular sector count for heterogeneity (higher -> more sectors)\n        - cross_strength: strength of the cross-term coupling that grows with radius\n        - seed: RNG seed for deterministic center placement\n        \"\"\"\n        self.dim = int(dim)\n        self.R1 = float(R1)\n        self.R2 = float(R2)\n        self.depth_factor = float(depth_factor)\n        self.angular_freq = float(angular_freq)\n        self.cross_strength = float(cross_strength)\n\n        # Sector-based angular heterogeneity\n        self.sector_count = max(4, min(24, int(round(self.angular_freq))))  # at least 4 sectors\n        self._rng = np.random.default_rng(seed)\n        self.sector_weights = self._rng.uniform(0.6, 1.4, size=self.sector_count)\n\n        # Centers and their offsets (outer wells)\n        self.max_centers = max(0, min(self.dim, int(shells * 2 + 6)))\n        self.centers = []\n        self.offsets = []\n        self.shells = int(shells)\n\n        self._build_centers()\n        self.global_local_score = None\n        self._estimate_global_local_score()\n\n    def _build_centers(self):\n        self.centers = []\n        self.offsets = []\n\n        # 1) Axis-aligned, near-origin centers (to seed inner basin with mild heterogeneity)\n        axis_centers = min(self.max_centers, self.dim, 4)\n        axis_distance = 0.6  # distance from origin along axis\n        for i in range(axis_centers):\n            c = np.zeros(self.dim, dtype=float)\n            c[i] = axis_distance\n            self.centers.append(c)\n\n        # 2) Radial shells: distribute centers on several shells with increasing radius\n        remaining = self.max_centers - len(self.centers)\n        if remaining > 0:\n            for s in range(self.shells):\n                if remaining <= 0:\n                    break\n                # radius for this shell\n                if self.shells > 1:\n                    radius = self.R1 + (float(s + 1) / float(self.shells + 1)) * max(0.0, self.R2 - self.R1)\n                else:\n                    radius = (self.R1 + self.R2) / 2.0\n                # number of centers on this shell (non-uniform, increasing with shell index)\n                per_shell = max(1, int(np.ceil((self.dim / (self.shells + 2)) * (1.0 + 0.5 * (s / max(1, self.shells))))))\n                per_shell = min(per_shell, remaining)\n\n                for _ in range(per_shell):\n                    dir = self._rng.normal(size=self.dim)\n                    norm = np.linalg.norm(dir)\n                    if norm <= 0.0:\n                        dir = np.zeros(self.dim, dtype=float); dir[0] = 1.0\n                        norm = 1.0\n                    dir = dir / norm\n                    c = dir * radius\n                    self.centers.append(c)\n                remaining -= per_shell\n\n        # 3) Final safety: if due to rounding we have more centers than allowed, trim\n        if len(self.centers) > self.max_centers:\n            self.centers = self.centers[:self.max_centers]\n\n        # Offsets (well depths) scale with radius; outer wells deeper\n        self.offsets = []\n        for c in self.centers:\n            radius_j = float(np.linalg.norm(c))\n            # base offset scales with depth_factor and radius (outer wells are deeper)\n            off = 0.8 * self.depth_factor * (1.0 + radius_j / (self.R2 + 1e-9))\n            self.offsets.append(float(off))\n\n    def _radial_transition(self, r):\n        \"\"\"\n        Phase-transition-like transition from inner to outer influence with\n        mild radial oscillations to break homogeneity.\n        Three-zone feeling: inner (0), middle (R1..R2), outer (>R2).\n        \"\"\"\n        if r <= self.R1:\n            return 0.0\n        if r >= self.R2:\n            return 1.0\n        # Smooth base transition\n        base = 0.5 * (1.0 - np.cos(np.pi * (r - self.R1) / (self.R2 - self.R1)))\n        # Stronger radial oscillations to introduce non-homogeneity\n        osc = 0.25 * np.sin(3.0 * r) + 0.12 * np.sin(7.0 * r)\n        t = base + osc\n        return float(min(1.0, max(0.0, t)))\n\n    def _angular_sector(self, x):\n        \"\"\"\n        Angular sector modulation to create non-axis-aligned heterogeneity.\n        Only first two dimensions are used for the angular sector effect.\n        \"\"\"\n        if self.dim < 2:\n            return 1.0\n        theta = np.arctan2(float(x[1]), float(x[0] if x[0] != 0.0 else 1e-9))\n        # map angle [-pi, pi] to sector index\n        sector_width = (2.0 * np.pi) / float(self.sector_count)\n        idx = int(np.floor((theta + np.pi) / sector_width)) % self.sector_count\n        return float(self.sector_weights[idx])\n\n    def _cross_term(self, x, r):\n        \"\"\"\n        Non-separable cross-term that grows with radius and introduces\n        directional coupling. Weighted by angular sector modulation.\n        \"\"\"\n        if self.dim < 2:\n            return 0.0\n        s = 0.0\n        for i in range(self.dim):\n            for j in range(i + 1, self.dim):\n                s += (x[i] * x[j])**2  # non-negative contribution\n        gain = (r / (self.R2 + 1e-9))\n        cross = float(self.cross_strength * gain * s)\n        # Multiply by angular sector to enforce directional non-homogeneity\n        cross *= self._angular_sector(x)\n        return cross\n\n    def f(self, x):\n        \"\"\"\n        Objective function to be minimized.\n        - Global minimum at origin: f(0) = 0\n        - Inner region: smooth paraboloid\n        - Middle region: radius-dependent, non-homogeneous ruggedness\n        - Outer region: shells of wells with angular modulation\n        - Cross-term adds non-separable coupling that grows with radius\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input vector x must be a one-dimensional array of length dim.\")\n        # Inner global basin\n        inner = float(np.dot(x, x))\n\n        # Radial gating for outside influence\n        r = float(np.linalg.norm(x))\n        t = self._radial_transition(r)\n\n        # Angular sector modulation\n        ang = self._angular_sector(x)\n        t *= ang\n\n        # Outer wells\n        if len(self.centers) == 0:\n            val = inner\n        else:\n            outer_min = None\n            for c, off in zip(self.centers, self.offsets):\n                diff = x - c\n                w = off + t * float(np.dot(diff, diff))\n                if outer_min is None or w < outer_min:\n                    outer_min = w\n            val = inner if inner <= outer_min else outer_min\n\n        # Cross-term\n        cross = self._cross_term(x, r)\n        return float(val + cross)\n\n    def _estimate_global_local_score(self, samples=1000):\n        \"\"\"\n        Rough proxy for GlobalLocal: ratio of deepest local well (approx via offsets)\n        to the average fitness over the domain, estimated by Monte Carlo.\n        Higher ratio indicates stronger global-local contrast.\n        \"\"\"\n        rng = np.random.default_rng(12345)\n        xs = rng.uniform(-5.0, 5.0, size=(samples, self.dim))\n        vals = np.empty(samples, dtype=float)\n        for i in range(samples):\n            vals[i] = self.f(xs[i])\n        A = float(np.mean(vals)) if vals.size > 0 else 1.0\n        local_min = min(self.offsets) if self.offsets else 0.0\n        self.global_local_score = float(local_min / max(A, 1e-9))\n        return self.global_local_score", "configspace": "", "generation": 4, "feedback": "The optimization landscape landscape_globallocal_enhanced_nh3 scored on:NOT Homogeneous 0.936, GlobalLocal 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["905d3156-c73d-4138-af26-81c2c6f0eeb2"], "operator": null, "metadata": {"ela_features_2D": [0.02464975202302775, 0.07311221849173899, 0.03840736341406957, 0.07000482263572713, 5.1090375726667885, 0.032248770534309634, 0.6749466771647767, 1.2391376184052705, 0.9396486884931192, 2.845691434544368, 9.94667238441076, 3.0, 0.6852703726010375, 0.712624373626994, 0.5200409528406758, 0.34278555382825104, -0.16662571456757042, 0.16393953695407665, 0.23665820978029678, 0.31702954203040445, 0.5004126891966215, 0.16735524263740637, 0.23948115709390833, 0.321506507318339, 0.5029080529717311, -0.4373383686949303, -0.3992997348210821, -0.35725897322216893, -0.26133192008300893, -0.42737253320713775, -0.39036093840974806, -0.34825487731236626, -0.255144320390288, 1.0, 1.0, 0.8666666666666666, 1.0, 0.508855051853058, 0.5088418214793645, 0.456310463455193, 0.38622426109176655, 0.6226578695607223, 0.6576576576576574, 0.03179257074903385, -0.7957957957957955, 0.3718875502008032], "score_NOT Homogeneous_2D": 0.9651447646319866, "score_GlobalLocal_2D": 0.4090580642223358, "ela_features": [0.025087949293812327, 0.1011388746256487, 0.00161327073278058, 0.06821034238742825, 70.59729459371167, 0.03789355608001301, 0.8050672438383147, 1.8763098382791608, 0.9518919198425954, 2.2273758293231185, 6.9083802074007306, 3.8, 0.89547864373538, 0.8716406139880615, 0.6406600748983271, 0.18408871185150683, -0.38385169417576165, 0.444728337579238, 0.5324008933526669, 0.6099511548257455, 0.7238823086282951, 0.44719257861413997, 0.5332420395931401, 0.6118896399124851, 0.7277234272937918, -0.48842544495907775, -0.41130513613297764, -0.34309091349905313, -0.24287542800134787, -0.48889706975650016, -0.4127907856667156, -0.3432358615411081, -0.24079247717540192, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21534762285885564, 0.2153543832674257, 0.20715131307462947, 0.19682216862000362, 0.7527323919853897, 0.24524524524524516, 0.11508771282023303, -0.6676676676676674, 0.5112179487179487], "score_NOT Homogeneous_5D": 0.9786203745752573, "score_GlobalLocal_5D": 0.0017578520346432924, "ela_features_10D": [0.03525481202672413, 0.12837141907603195, 0.0026502190048564946, 0.07133872986043488, 29.025138935122904, 0.05264663281888906, 0.8346092101854504, 3.6717145971090135, 0.9402679751430977, 1.8726193870284853, 5.617239865663899, 4.4, 1.0128940391625654, 0.9372047003790716, 0.711924789961295, 0.1056383189336548, -0.46668299231958355, 0.62351936451144, 0.6839817973502844, 0.7346889266107103, 0.8134320928406588, 0.6254576495469614, 0.6866216329240651, 0.7381689601967892, 0.8174588333743305, -0.47746011392236964, -0.40078055505280696, -0.3364727638090406, -0.236609137694373, -0.4762736933530629, -0.3984963893181401, -0.33294835801708816, -0.23212224846619628, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.1098752283372699, 0.109876189248109, 0.10822940323583338, 0.11036144930381046, 0.8286876934574444, -0.12312312312312308, 0.06884194237262066, -0.8638638638638636, 0.589831865492394], "score_NOT Homogeneous_10D": 0.9359105601906776, "score_GlobalLocal_10D": 0.0006134189898148179}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[46, [0.0003087244526932195, -0.0003096280144199988], 1.9118029500500843e-07], [18, [-0.00034333961140559755, -3.366888898680214], 8.937413114467766], [14, [-3.3669133376883433, 0.032281210131645206], 8.807518741024431], [10, [3.336008979383812, 0.07402525472595724], 9.662146147535095], [12, [-0.000415967607156322, 3.358888891960653], 7.378101275908484]], "nr_of_basins": 5, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.1032013609622154e-162, -1.5381159745410318e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.3851239990377469e-163, -7.333635065991387e-163, 1.0483566392565942e-162, -1.523217403935747e-162, 8.70816018966048e-164]}
{"id": "170b110b-db3d-4bbd-9119-2f43c08f2256", "fitness": 0.9258775139848391, "name": "landscape_sector_phase_transition_novel", "description": "A three-zone non-homogeneous phase-transition landscape with an anisotropic inner basin, a non-separable oscillatory middle layer, and an outer shell of Gaussian wells placed on a deterministic sphere. The zones are softly gated in radius to create phase transitions, while the outer wells introduce pronounced global-local minima contrast. The global minimum remains at the origin (f(0)=0).", "code": "import numpy as np\n\nclass landscape_sector_phase_transition_novel:\n    \"\"\"\n    A three-zone, non-homogeneous phase-transition landscape with a deterministic\n    outer-shell of Gaussian wells arranged on a sphere. \n    - Inner zone (r <= r1): anisotropic paraboloid (quadratic basin with cross-terms)\n    - Middle zone (r1 < r <= r2): non-separable oscillatory modulation\n    - Outer shell (r > r2): Gaussian wells on a sphere, providing local minima without lowering f(0)=0\n    Radial gating ensures smooth transitions between zones.\n    \"\"\"\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n\n        # Zone radii (domain [-5,5])\n        self.r1 = 1.6\n        self.r2 = 3.4\n\n        # Gating softness for smooth transitions\n        self.s_gate = 0.6\n\n        # Inner zone: anisotropic paraboloid with small cross-terms\n        # Non-separable quadratic form via cross-terms (PSD construction)\n        self.inner_q = 0.25  # base weight for cross-terms\n        # cross-term amplitude will be implemented via a specific construction in f()\n\n        # Middle zone: non-separable oscillatory term\n        self.mid_amp = 1.0\n        self.mid_freq = 0.9\n\n        # Outer wells: Gaussian wells on a sphere\n        self.center_radius = 3.0  # radius on the sphere\n        self.outer_s = 1.6        # width (scale) for Gaussians\n        self.outer_A = 0.9         # amplitude of negative Gaussian contribution\n        self.outer_B = 1.4         # per-well bias to ensure nonnegative wells\n        # Centers on a sphere (deterministic, dimension-aware)\n        self.centers = self._generate_centers()\n\n    def _generate_centers(self):\n        centers = []\n        R = float(self.center_radius)\n\n        # Axis-aligned centers\n        for d in range(self.dim):\n            c = np.zeros(self.dim, dtype=float)\n            c[d] = R\n            centers.append(c)\n\n        # 2D diagonals (first two axes)\n        if self.dim >= 2:\n            s = R / np.sqrt(2.0)\n            c = np.zeros(self.dim, dtype=float)\n            c[0], c[1] = s, s\n            centers.append(c)\n\n            c = np.zeros(self.dim, dtype=float)\n            c[0], c[1] = s, -s\n            centers.append(c)\n\n        # 3D diagonal (first three axes)\n        if self.dim >= 3:\n            c = np.zeros(self.dim, dtype=float)\n            c[0], c[1], c[2] = R / np.sqrt(3.0), R / np.sqrt(3.0), R / np.sqrt(3.0)\n            centers.append(c)\n\n        # Negative axis center to diversify on the sphere\n        c = np.zeros(self.dim, dtype=float)\n        c[0] = -R\n        centers.append(c)\n\n        return centers\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at x \u2208 R^dim.\n        f(0) = 0 due to gating; outer wells provide nonnegative local minima for r>r2.\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.size != self.dim:\n            raise ValueError(\"Input vector length must be equal to dim\")\n\n        # Radial coordinate\n        r = np.linalg.norm(x)\n\n        # Radial phase-transition gating (three zones)\n        w_inner = self._sigmoid((self.r1 - r) / self.s_gate)           # inner dominance near origin\n        w_mid   = self._sigmoid((r - self.r1) / self.s_gate) - self._sigmoid((r - self.r2) / self.s_gate)  # middle region\n        w_outer = self._sigmoid((r - self.r2) / self.s_gate)            # outer region\n\n        # Inner zone: anisotropic paraboloid with cross-terms (PSD by construction)\n        # Construct a PSD quadratic form: sum_i p_i x_i^2 + q * sum_{i<j} (x_i - x_j)^2\n        i = np.arange(self.dim)\n        p_i = 1.0 + 0.15 * i                   # per-dimension diagonal weights\n        sum_p = np.sum(p_i)\n        ss = float(np.dot(x, x))\n        s = float(np.sum(x))\n        f_inner = np.sum(p_i * x**2) + self.inner_q * (self.dim * ss - s**2)\n\n        # Middle zone: non-separable oscillatory modulation\n        # A squared-sum of sine terms to ensure non-negativity and non-separability\n        alpha = 1.0 + 0.2 * i\n        beta = (np.arange(self.dim) + 1) * 0.9  # base frequencies\n        term_sum = float(np.dot(alpha, np.sin(beta * x)))\n        f_mid = term_sum**2\n\n        # Outer shell: Gaussian wells on a sphere\n        # Each center contributes a negative Gaussian well; add a positive bias to keep wells above zero\n        outer = 0.0\n        s2 = self.outer_s**2\n        for c in self.centers:\n            delta = x - c\n            e1 = np.exp(-np.dot(delta, delta) / s2)\n            # Negative well with a positive bias to ensure local minima but keep f(0)=0 after gating\n            term = -self.outer_A * e1 + self.outer_B\n            if term > 0:\n                outer += term\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * outer\n        return float(val)\n\n    def _sigmoid(self, z):\n        # Stable sigmoid\n        z = np.asarray(z, dtype=float)\n        z = np.clip(z, -50, 50)\n        return 1.0 / (1.0 + np.exp(-z))", "configspace": "", "generation": 4, "feedback": "The optimization landscape landscape_sector_phase_transition_novel scored on:NOT Homogeneous 0.835, GlobalLocal 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e9df1ba8-f907-4e24-84d0-88c02397e8f0"], "operator": null, "metadata": {"ela_features_2D": [-0.0008742574142266646, 0.7529757639151269, 0.02780193867271351, 0.03954595288016639, 1.5522233792416542, -5.8646657928962397e-05, 0.7935439158456535, 1.0626722410435228, 0.8719307474594272, -0.7697147659124106, -0.49050387914941657, 2.0, 0.6697222829878966, 0.7154068563444264, 0.5133310588556367, 0.3371294661288036, -0.20964751759421912, 0.13893588171165622, 0.21848881654624677, 0.3349610005536251, 0.5221942024337437, 0.1419525878793011, 0.21755640531418258, 0.3317527968859494, 0.5216513691905307, -0.45078173996114695, -0.4091349642309365, -0.348159986428088, -0.25013940575166504, -0.44142043332787456, -0.40252834747406496, -0.34378042312295065, -0.24608633021294998, 1.0, 1.0, 1.0, 1.0, 0.519016994604649, 0.5190118229511146, 0.37667590448216054, 0.35787684117708063, 0.6514878820954282, 0.6736736736736735, 0.6358897836228738, -0.007007007007007032, 0.3710843373493976], "score_NOT Homogeneous_2D": 0.9327868521213531, "score_GlobalLocal_2D": 0.9945245981216431, "ela_features": [-0.0032919223362680937, 0.5214785414652916, 0.0007862184371061956, 0.0035081897427297498, 9.366152845008658, -0.010815963783250605, 0.1425150684153804, 1.1276976259615368, 0.2597715851498735, -2.6453991921883233, 29.87778120878205, 7.2, 0.8332909932664891, 0.852898075002215, 0.5812573005997572, 0.19911745035140388, -0.41683244089728405, 0.4713311741915468, 0.5540716022888591, 0.63012787022174, 0.7503742356322615, 0.472689607168864, 0.5551214111117435, 0.6340411537462078, 0.7541206504445896, -0.46505962586138433, -0.39227334718172546, -0.32536848819580727, -0.21959066894206095, -0.4662737792431499, -0.39337934791813584, -0.3235960333808444, -0.2174178143953654, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21740214489412502, 0.21741529326277723, 0.2154964461066581, 0.1812716936168701, 0.7155607647985238, 0.2892892892892892, 0.004126305207504251, -1.740740740740741, 0.6078525641025642], "score_NOT Homogeneous_5D": 0.7936510145664215, "score_GlobalLocal_5D": 0.9996832609176636, "ela_features_10D": [-0.002986930413868949, 0.5624481753285383, 7.565626291953511e-05, 0.0013994935036054153, 44.5133965334136, -0.020467250771245293, -0.005192114345616572, 89.73351802619234, -0.06376719501456089, -4.9027504919560005, 724.0739831751356, 4.2, 0.8245292459273517, 0.9043531806011507, 0.6261574400334563, 0.12676749950182184, -0.24427730784269192, 0.6554828537266664, 0.7248748320736695, 0.785734543585907, 0.8885856905303292, 0.6583321233028114, 0.7280467824281743, 0.7892646142828152, 0.8913052054118129, -0.4369698967322885, -0.34895605231831556, -0.27176438908099065, -0.14131265693727846, -0.43455389471973405, -0.34588639735752447, -0.26802572946861314, -0.13824436834611514, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11005052082098236, 0.11005307043653996, 0.11000161887740212, 0.1001108808781697, 0.7401541891889167, -0.8998998998998999, 0.00012212182002202207, -3.358358358358359, 0.6560448358686949], "score_NOT Homogeneous_10D": 0.8349914103746414, "score_GlobalLocal_10D": 0.999627947807312}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[24, [0.5674538135073658, 1.7820620427715133], 2.22945439888431], [19, [0.40893112920911373, -3.2033553937847716], 4.3343409377155275], [57, [0.000536590794108666, 0.00026702265017561214], 0.023694739631966697]], "nr_of_basins": 3, "f_opt_dim_2": 0.023670953995182768, "x_opt_dim_2": [8.920105633210077e-17, 1.014152229174441e-16], "f_opt_dim_5": 0.04260771719132899, "x_opt_dim_5": [-5.648446911103562e-17, 1.3768688399772985e-16, -1.1108305411519945e-16, -9.611930521604245e-17, 1.9513957576044796e-17]}
{"id": "596b7282-5efb-41c2-9f4d-350fca21b062", "fitness": 0.535457576586244, "name": "landscape_phase_transition_enhanced_glocal_v3", "description": "A three-zone, non-homogeneous phase-transition landscape with enhanced GlobalLocal contrast. The inner region remains a smooth paraboloid (global minimum at the origin), the middle region adds stronger non-separable oscillatory and cross-term components to boost outer local minima, and the outer region introduces rugged multi-modal wells. Radial blending preserves f(0)=0 while amplifying the separation between the global minimum and pronounced outer local minima for a clearer GlobalLocal contrast.", "code": "import numpy as np\n\nclass landscape_phase_transition_enhanced_glocal_v3:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Radial transition radii (domain [-5, 5])\n        self.r1 = 0.9\n        self.r2 = 2.8\n        self.r3 = 5.0\n\n        # Inner region: smooth paraboloid-like (keeps global minimum at origin)\n        # Middle region: enhanced non-separable, phase-transition boosted\n        self.a = 0.88       # weight for non-separable middle cross-term\n        self.b = 2.95       # base frequency for middle region cos modulation\n        self.c_mid = 0.75   # cross-term weight for sum(x)^2 in middle region\n        self.d_mid = 2.0    # nonnegative sin^2 modulation in middle\n        self.gl_local = 1.0  # additional non-separable boost in middle\n\n        # Outer region: rugged multi-modal wells (nonnegative contributions)\n        self.e_outer = 0.40  # weight for (sum x)^2 term in outer\n        self.g_outer = 1.0   # weight for outer radial oscillation term\n        self.freq_out = 6.0   # frequency for outer per-dimension cosine term\n        self.freq_out2 = 8.0  # frequency for outer cross-term (cos) term\n        self.outer_rug = 1.05  # weight for outer cross-term ruggedness\n\n    def _smoothstep(self, a, b, x):\n        # Smooth transition in r from 0 to 1 over [a, b]\n        if x <= a:\n            return 0.0\n        if x >= b:\n            return 1.0\n        t = (x - a) / (b - a)\n        return t * t * (3.0 - 2.0 * t)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D numpy array of length {}\".format(self.dim))\n\n        r = np.linalg.norm(x)\n\n        # Inner region: pure paraboloid (global minimum at origin)\n        f_inner = float(np.sum(x**2))\n\n        # Middle region: enhanced non-separable, phase-transition boosted\n        f_mid = 0.0\n        # Non-separable cross-term with diminishing separability\n        f_mid += (1.0 - self.a) * float(np.sum(x**2))\n        f_mid += float(self.a * np.sum((np.cos(self.b * x) * x)**2))\n        # Cross-term: radial (sum x)^2\n        f_mid += float(self.c_mid * (np.sum(x))**2 / max(self.dim, 1))\n        # Nonnegative sine-based modulation to break separability\n        f_mid += float(self.d_mid * np.sum(np.sin(0.4 * x))**2)\n        # Additional non-separable boost (cos-based cross-term)\n        f_mid += float(self.gl_local * (np.sum(np.cos(self.b * x) * x))**2)\n\n        # Outer region: rugged, multi-modal wells with radial phase transition\n        f_outer = 0.0\n        f_outer += float(np.sum(x**4))\n        f_outer += float(self.e_outer * (np.sum(x))**2)\n        # Nonnegative radial-well term using (1 - cos)\n        f_outer += float(self.g_outer * np.sum(1.0 - np.cos(self.freq_out * x)))\n        # Outer cross-term ruggedness (squared sum of cos terms)\n        f_outer += float(self.outer_rug * (np.sum(np.cos(self.freq_out2 * x)))**2)\n\n        # Phase-transition weights based on radius\n        s1 = self._smoothstep(self.r1, self.r2, r)  # inner -> middle\n        s2 = self._smoothstep(self.r2, self.r3, r)  # middle -> outer\n\n        w_inner = 1.0 - s1\n        w_mid   = s1 * (1.0 - s2)\n        w_outer = s2\n\n        val = w_inner * f_inner + w_mid * f_mid + w_outer * f_outer\n        return float(val)", "configspace": "", "generation": 4, "feedback": "The optimization landscape landscape_phase_transition_enhanced_glocal_v3 scored on:NOT Homogeneous 0.713, GlobalLocal 0.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2ca08b03-e72f-4d20-9b1e-dd2db67c4a0f"], "operator": null, "metadata": {"ela_features_2D": [-0.001552412327592223, 0.18978983440474445, 0.008197299575160077, 0.03521826469982612, 13.332660613040076, -0.002363862452487453, 0.8907034524534488, 1.008297819459663, 0.893336095598826, 1.0174565636651787, 0.1514678538381337, 2.0, 0.6515414351656784, 0.7050098908134329, 0.5131564508989171, 0.34811585408363116, -0.21394879939222827, 0.13485056320721744, 0.22591185388799984, 0.32600288437098224, 0.5017893490610297, 0.14012401022862184, 0.2238228010725925, 0.32147298155835524, 0.5002046114629786, -0.4527026922816752, -0.4050536463253729, -0.35268118394222, -0.26069919462235946, -0.4418314986582367, -0.3988159419753941, -0.3486368587211679, -0.25680299870277257, 1.0, 1.0, 1.0, 1.0, 0.5188093942263377, 0.5188027089263393, 0.4035769813972843, 0.3556021443302873, 0.5886310657219881, 0.6576576576576574, 0.280521022865816, -0.2592592592592592, 0.4265060240963855], "score_NOT Homogeneous_2D": 0.9437464289367199, "score_GlobalLocal_2D": 0.978923499584198, "ela_features": [-0.0016982224381312694, 0.3067379865250289, 0.0029512533935104916, 0.021508638420017566, 10.498386542675647, 0.005268445446768721, 0.9234884461692081, 1.0372152840923916, 0.9276157250383832, 0.5199642443874195, -0.01859048313762246, 1.4, 0.9134547939411387, 0.8761898475803103, 0.6309238575010243, 0.18332295009006455, -0.5103866682020328, 0.4316579087838031, 0.5137575499976512, 0.592783551456199, 0.7227728521952748, 0.431383515528144, 0.5146988511305675, 0.5939959637416512, 0.7259975821995441, -0.4999038509487782, -0.4276904628459376, -0.35818011001494876, -0.2438440083512517, -0.5026331364288811, -0.42898404688902136, -0.35888967013357, -0.24220660007746903, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21186661935779155, 0.21189152268479877, 0.1959678060438513, 0.17798326491884534, 0.8273502483077415, 0.26526526526526517, 0.3017118636996902, -0.2792792792792792, 0.545673076923077], "score_NOT Homogeneous_5D": 0.5756121873855591, "score_GlobalLocal_5D": 0.0009350752807222307, "ela_features_10D": [-0.001170336572922892, 0.37934027044622753, 0.000990471380598294, 0.018953652341302342, 50.34239045369743, 0.011574827483082162, 0.912154365896446, 1.0617553968355933, 0.9200212204880793, 0.4274402023497245, 0.09738236150487678, 1.4, 1.0094204418320738, 0.9368493064149959, 0.6967069331634154, 0.10777566391288636, -0.6073687422257623, 0.6287520847056836, 0.6877602601472388, 0.7408903625857036, 0.8187099538100169, 0.6314847195827464, 0.69079385831033, 0.7437675512494327, 0.8221041182190557, -0.47087719395766403, -0.39603328776340724, -0.3286450716718047, -0.2299418666393298, -0.4687551902873549, -0.3933128383742418, -0.3259295758580726, -0.22628468353226694, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10969133756569478, 0.10968496859778347, 0.10647947593786782, 0.09996958196268012, 0.8581697057971545, -0.05505505505505507, 0.1408573711742785, -0.6236236236236234, 0.6035228182546037], "score_NOT Homogeneous_10D": 0.7131644487380981, "score_GlobalLocal_10D": 0.000363819592166692}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not homogeneous. Which refers to a search space with phase transitions. Its overall appearance is different in different search space areas. (NOT Homogeneous)\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[4, [0.00044444444444512003, 0.00044444444444512003], 3.950617283962628e-07], [12, [0.5601516577179182, -2.6459141001156863], 3.427787679681848], [3, [1.5096185737273062, -0.642757663606471], 2.1220504129823277], [3, [-1.510087595545215, 0.6429659537006662], 2.1220046110664255], [1, [1.6299069205660102, -1.6298873101386415], 1.459788766257025], [1, [-1.6298873101386415, 1.6299069205660102], 1.459788766257025], [2, [-0.6626902366040113, 1.5028782795405569], 2.1243269114905496], [2, [0.6646470004509109, -1.5027867819460545], 2.1245919064195973], [9, [-2.586795981356523, 1.5737823303071599], 3.9975132106545623], [9, [1.5737819559109516, -2.586796951294632], 3.997511612870157], [21, [2.67419100236366, -0.701777062567815], 3.2666884492853776], [15, [-2.6459146517190826, 0.560149745003713], 3.427789880718645], [18, [-0.6975464206617389, 2.6734310544670152], 3.26626230764299]], "nr_of_basins": 13, "f_opt_dim_2": 0.0, "x_opt_dim_2": [1.865608655399275e-163, 1.529528007703602e-162], "f_opt_dim_5": 0.0, "x_opt_dim_5": [1.0457711605714239e-163, -6.802514291392801e-163, 1.0963434773178261e-163, 8.173639432186884e-163, 5.340409811415769e-163]}
