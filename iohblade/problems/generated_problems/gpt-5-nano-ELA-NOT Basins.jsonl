{"id": "7a70c5d5-a465-4f20-87da-b775b432bb78", "fitness": 0.9942524266274025, "name": "landscape", "description": "A non-homogeneous multi-well landscape created by a superposition of uneven negative Gaussian wells. The wells have varying depths (amplitudes) and widths (sigmas) and are placed at non-uniform centers in the domain [-5,5]^dim. This yields multiple local minima with basins of attraction of different sizes, breaking basin-size homogeneity and providing a challenging minimization landscape.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5):\n        self.dim = dim\n        # number of Gaussian wells (ensembles of local minima)\n        self.K = max(5, dim * 3)\n        \n        # Deterministic RNG for reproducibility with respect to dimension\n        rng = np.random.RandomState(12345)\n        \n        # Random centers for the wells inside [-5, 5]^dim\n        self.centers = rng.uniform(-5.0, 5.0, size=(self.K, dim))\n        \n        # Amplitudes (depths) of the wells (positive values to be negated in function)\n        self.amps = rng.uniform(0.5, 4.0, size=(self.K,))\n        \n        # Widths (standard deviations) of the wells\n        self.sigs = rng.uniform(0.4, 1.8, size=(self.K,))\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension.\")\n        \n        # Sum of negative Gaussians to create multiple local minima with varying basins\n        val = 0.0\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            dist2 = np.dot(diff, diff)\n            val += - self.amps[i] * np.exp(- dist2 / (2.0 * (self.sigs[i] ** 2)))\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.3512474169240278, 1.143603595637029, 0.23421084385683005, 0.4176377817104129, 1.7864881631208729, 0.5117436885305406, 0.41624256490688827, 9.888133883402073, 0.7027684594121153, -1.6219686144298735, 1.6734342202726018, 2.0, 0.4689422255960993, 0.6933715197577539, 0.3812015958692448, 0.3462670693590893, -0.1467522385046138, 0.16651287616315252, 0.28722629378468734, 0.38136754134288725, 0.508287027192756, 0.16019967013372502, 0.2617683313791984, 0.37097685138477904, 0.5074892116554877, -0.4360494079059819, -0.37290120024991535, -0.3236472123764871, -0.25724893500883245, -0.43115407785936044, -0.3790173038969983, -0.3229517679919066, -0.2528641739493171, 1.0, 1.0, 1.0, 1.0, 0.5172467993224661, 0.5172440530797892, 0.500068036565865, 0.5288940236223946, 0.6101139778043749, 0.6376376376376374, 0.21150493266557696, -0.4554554554554553, 0.3662650602409639], "score_NOT Basins_2D": 0.9846793217584491, "ela_features": [0.11744997135782001, 1.0313780807107762, 0.00806526465820718, 0.06738302943154928, 27.234199067755448, 0.21667637840374881, 0.13576708608657057, 299.1062681554614, 0.3092660528084107, -5.4745538504470375, 42.105246755545515, 6.8, 0.6947017951191404, 0.8502874108025956, 0.5281267728160307, 0.1990511173262476, -0.36974323329515835, 0.8072860475988269, 0.8449574247374144, 0.8882903882211715, 0.8987246162201833, 0.853703210549322, 0.8741436116805928, 0.9072647255617291, 0.8982715219321644, -0.1695144932325603, -0.1363754493609048, -0.09825905992037023, -0.089082676225233, -0.12934045482409282, -0.1112551893801039, -0.08197211702533916, -0.0899272142476083, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21775620612807364, 0.21775231301171924, 0.21445967641629174, 0.22618506485481618, 0.5948781726305087, 0.24924924924924916, 0.002098742530018638, -1.7447447447447448, 0.4985576923076923], "score_NOT Basins_5D": 0.9982084718067199, "ela_features_10D": [0.008977042636326505, 1.00449899581666, 0.00031729910255952776, 0.008304355972120116, 42.879177745680515, 0.02087777151397574, 0.017727131367441328, 16.472001812374167, 0.04772932249471677, -22.08030824135941, 623.9062838854504, 4.8, 0.8971853863637242, 0.9263849498511576, 0.6427994317311072, 0.11497004625266091, -0.28129871834097314, 0.8348057839989453, 0.83691242652868, 0.857700371438814, 0.8879086023739756, 0.8481182394095113, 0.8291375280044522, 0.8506822236906117, 0.8837648476327885, -0.209513558718178, -0.2068426419996375, -0.18047739132059598, -0.14216471676865478, -0.19312793983246274, -0.21727086798443834, -0.18987348631487366, -0.14780658848851086, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11026283759738845, 0.11026056445235306, 0.11013614220595144, 0.10305212612499222, 0.6010949008226397, -0.7437437437437435, 1.048067080404228e-05, -4.091091091091092, 0.5666933546837469], "score_NOT Basins_10D": 0.9998694863170385}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[22, [-3.159204091618346, -2.9528904052051685], -0.8728187900846941], [65, [2.6799908565573163, 1.4819751930404832], -4.82199455831397], [13, [2.493785738400488, 4.5394523189852665], -3.697317547725208]], "nr_of_basins": 3, "f_opt_dim_2": -4.821999526641622, "x_opt_dim_2": [2.6792409335889467, 1.4835224692512103], "f_opt_dim_5": -3.023211936200602, "x_opt_dim_5": [3.183048361154331, 0.002042678593512901, 3.1016334294467405, -4.0402057316493805, -2.8105933180029417]}
{"id": "3f42baf5-a6a2-44a0-a8c9-eb4ab7d404a2", "fitness": 0.5229652163883051, "name": "landscape", "description": "A multi-basin, non-homogeneous landscape formed as the pointwise minimum of several quadratic bowls with varying centers, depths and widths. Each bowl defines a local basin, and by varying depth and width the basin sizes differ, creating an irregular landscape. The global minimum lies at the deepest bowl's center. The function is defined in a way that all evaluations are within [-5, 5]^dim.", "code": "import numpy as np\n\nclass landscape:\n    \"\"\"\n    Novel multi-basin landscape for black-box optimization.\n    The function is: f(x) = min_j ( d_j + ||x - c_j||^2 / (2 * s_j^2) )\n    - c_j: center of j-th quadratic bowl (dimension dim)\n    - d_j: base depth (smaller -> deeper bowl)\n    - s_j: width of the bowl (larger -> wider basin)\n    The global minimum is at the center with the smallest d_j.\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = dim\n        self.seed = seed\n\n        rng = np.random.default_rng(seed)\n\n        # Number of bowls (basins) scales with dimension but stays modest\n        M = max(4, min(16, dim * 2))\n        self.M = M\n\n        # Centers c_j within [-4, 4]^dim\n        self.c = rng.uniform(-4.0, 4.0, size=(M, dim))\n\n        # Widths s_j (positive)\n        self.s = rng.uniform(0.4, 2.0, size=(M,))\n\n        # Depths d_j; ensure a unique deepest bowl (global minimum)\n        depths = rng.uniform(-1.5, 1.0, size=(M,))\n        deepest_idx = rng.integers(0, M)\n        depths[deepest_idx] = -5.0  # deepest bowl at its center\n        self.d = depths\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        # Compute distances to all centers\n        # delta shape: (M, dim)\n        delta = x - self.c  # broadcasting\n        # dist^2_j = ||x - c_j||^2\n        dist2 = np.sum(delta * delta, axis=1)\n        # Each bowl value: d_j + dist^2_j / (2 * s_j^2)\n        vals = self.d + dist2 / (2.0 * (self.s * self.s))\n        # The landscape value is the minimum over all bowls\n        return float(np.min(vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.038,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.6055986524748036, 0.2151992514558926, 0.2556740104690491, 0.47576392467393125, 1.8629851962653248, 0.6637370008539347, 0.8265099330227536, 1.2627889563563794, 0.9654185387128308, 0.6927225938191638, 0.3198691937080186, 1.4, 0.6485284457993373, 0.7052705001850933, 0.5083724324301814, 0.34911420476786686, -0.1333113597827352, 0.1485604586198454, 0.22877144973856947, 0.3225793381588489, 0.4941972474275131, 0.1569880636031203, 0.23077787543208492, 0.3238922381410477, 0.496364567749955, -0.4453558221824615, -0.4033999113907692, -0.3543337112496874, -0.26456815870104206, -0.43282706537232124, -0.3949437307431886, -0.34714005956828864, -0.25858401776177264, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.514718974454074, 0.5146944823342018, 0.5489033381350004, 0.5991718433819712, 0.651901049727959, 0.27327327327327317, 0.24815910617220585, -0.39139139139139123, 0.3493975903614458], "score_NOT Basins_2D": 0.9380187503993511, "ela_features": [0.31477539627695555, 0.41141441778944976, 0.05400022287699704, 0.2449764995932267, 4.83584354589591, 0.5472250389675655, 0.6172536083602927, 9.07781089497099, 0.8802231838232965, 0.4947913150907891, -0.016800537400945538, 1.6, 0.7354565232287487, 0.8590793052115353, 0.540853457792917, 0.19040390215136552, -0.38650002435792147, 0.7111463799869511, 0.7288343464775264, 0.7834729758937595, 0.844892998687152, 0.6893678049691625, 0.7079080571027091, 0.7730988257636238, 0.8358063130287052, -0.2540989677291792, -0.2385377522351691, -0.19047329397889504, -0.1364432503066771, -0.27472213468727363, -0.2583272347337135, -0.20066959888688757, -0.145207579064485, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21692880501718953, 0.21695168765288683, 0.213977655657713, 0.26023678267007755, 0.8158862503809878, 0.10110110110110107, 0.18688990488587703, -0.5115115115115113, 0.5017628205128204], "score_NOT Basins_5D": 0.5927059054374695, "ela_features_10D": [0.24583595103306957, 0.6007912184141677, 0.007022548273982877, 0.18323561587143095, 54.441132077223585, 0.5204741527690331, 0.5691646213507291, 2.008921326516693, 0.8559952207199804, 0.366693716554116, 0.029681523567507993, 1.4, 0.9042277232023442, 0.9288490817438685, 0.6473425009865209, 0.112229551953321, -0.49968287841575554, 0.8324880621211899, 0.8429801823594486, 0.8565668683280994, 0.8900788815790145, 0.8337233941530646, 0.8390644520386477, 0.8498750318442518, 0.8866226375679886, -0.21245393777159163, -0.19914666118603214, -0.18191474528328339, -0.13941167108636798, -0.2114470380328818, -0.2046543982573045, -0.19090648936789406, -0.14417620754639787, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10948316961976157, 0.10948425692169164, 0.1107606719653316, 0.13822002839373032, 0.8419078614478661, -0.1751751751751751, 0.10777396909784889, -0.7237237237237235, 0.5634907926341073], "score_NOT Basins_10D": 0.03817099332809448}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [2.5060000000002747, 3.302000000000187], 0.32413862092426876], [7, [0.8397679916431728, 1.8093074948909778], -1.058144545740363], [47, [1.0957777777778632, -1.841777777777863], -4.999999996212614], [27, [-3.671777777777679, -3.8677777777776576], -1.41603603553737]], "nr_of_basins": 4, "f_opt_dim_2": -5.0, "x_opt_dim_2": [1.0956934920758545, -1.8417062646818003], "f_opt_dim_5": 0.285504781200415, "x_opt_dim_5": [1.730949466287913, -0.5622975996385, -2.0453735183689634, 2.241114788416026, -1.2432214146457987]}
{"id": "cbef6f03-77eb-4ab4-ad01-c561c65f604e", "fitness": 0.9982448152489573, "name": "landscape", "description": "A multi-funnel, non-homogeneous basin landscape created as the pointwise minimum of several Gaussian wells with varying depths and widths. The wells are placed in [-5,5]^dim; the global minimum is at the deepest well. Different widths and spacings produce basins of different sizes, yielding a rugged, non-uniform optimization landscape suitable for benchmarking.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n        \n        # Number of wells grows with dimension to ensure richer basins\n        self.N = max(4, min(64, 4 * dim))\n        \n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n        \n        # Negative amplitudes (well depths) for each Gaussian\n        self.weights = -rng.uniform(low=0.5, high=3.0, size=self.N)\n        \n        # Widths (standard deviations) of Gaussians\n        self.sigmas = rng.uniform(low=0.3, high=2.0, size=self.N)\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n        \n        # Compute squared distances from x to each center\n        diffs = self.centers - x  # shape (N, dim)\n        d2 = np.sum(diffs**2, axis=1)\n        \n        # Value of each Gaussian well at x\n        vals = self.weights * np.exp(-0.5 * d2 / (self.sigmas**2))\n        \n        # Landscape value is the minimum across all wells (min of Gaussians)\n        return float(np.min(vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.12538714185128733, 0.8932889674564211, 0.04310676324998119, 0.2955339430346252, 10.531369187994649, 0.33841997043479866, 0.15250678936101444, 6.745606124639211, 0.4601231217556242, -0.8623000526159018, -0.15773440084013296, 1.6, 0.2866721213459991, 0.6533257681122165, 0.25642323880012674, 0.35427900238347887, -0.24138041843683972, 0.39333145642452944, 0.8898657123915615, 0.8608523200694693, 0.8373459231773801, 0.14741512546179458, 0.964735793796347, 0.829557750953966, 0.7690866643123975, -0.3174550761710192, -0.05763188809729497, -0.07281034535104257, -0.08511944861729817, -0.43791239292105344, -0.01809210669975153, -0.08752891365210189, -0.11861807309789647, 1.0, 1.0, 1.0, 1.0, 0.5081592283425277, 0.5080245695344378, 0.4379472771354832, 0.45190568605185605, 0.6633597597761518, 0.7537537537537535, 0.4773097026172765, -0.06706706706706703, 0.3678714859437751], "score_NOT Basins_2D": 0.9950283635407686, "ela_features": [0.04408190923182331, 0.9814335681019649, 0.005583888129793762, 0.07193159794015835, 36.42128297418567, 0.14758012019440792, 0.08860877405516177, 28.34135503470761, 0.3029096853554786, -4.032318853211255, 20.7581402361535, 5.8, 0.6466428435119491, 0.8479787721122797, 0.4911346174225735, 0.1966977535449866, -0.4266530979180657, 0.9365235057172347, 0.9333537420191543, 0.9321492650882082, 0.9262425212904677, 1.0185567996928637, 0.9690432468796347, 0.9522820450596982, 0.934362133621358, -0.05584307713442889, -0.058629921430783695, -0.059689776872911326, -0.0648860479218831, 0.01641417669597618, -0.02737847771533719, -0.04220560966950602, -0.05805653267252466, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2167235104279619, 0.2167304799085117, 0.21074145305761866, 0.2031630726448015, 0.6509369255972145, 0.3213213213213212, 0.009978357309422972, -1.1881881881881884, 0.5052884615384615], "score_NOT Basins_5D": 0.9997651964222314, "ela_features_10D": [0.0008294130763517815, 0.9942328394806704, 0.000234158627536469, 0.005625209347555743, 89.58291927781168, 0.022529940082945732, 0.004973646110804619, 13.477276893184722, 0.046650457932538456, -24.68507521816825, 837.6526307461902, 4.2, 0.8035115255728863, 0.915309990324659, 0.5802148504020449, 0.1242263929645288, -0.27356060923857095, 0.9296218514389041, 0.9293558196320759, 0.932437345735131, 0.9368380196087666, 0.9504648831934654, 0.9403598779286501, 0.9389723477949783, 0.9375431528576046, -0.08926268387203891, -0.08960084206181511, -0.08569240770796953, -0.08011146027744083, -0.06299655617023436, -0.0758537631618283, -0.07761833852148041, -0.07943932308863814, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11011006715437655, 0.11011588843825357, 0.10996641454034853, 0.10121035301773004, 0.6659114462359322, -0.7037037037037035, 1.4262333000100139e-05, -3.6346346346346343, 0.5838270616493194], "score_NOT Basins_10D": 0.9999408857838716}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [1.748666666666667, 1.598666666666667], -2.027544926281286], [4, [4.705699201827653, -1.2403908871586602], -2.2996056289963365], [22, [3.6359999705859294, 3.6377250394758396], -2.17809502415123], [18, [-2.5826666666666025, -1.8146666666666667], -2.676037331151971], [21, [4.232666666612168, -2.3829056213698236], -1.0568841356252854], [17, [-0.5895555555555554, 1.0986666666666665], -2.209221962325171], [10, [-1.8110143869219948, -3.8093418791538505], -0.9301234313258347]], "nr_of_basins": 7, "f_opt_dim_2": -2.1993900473232952, "x_opt_dim_2": [-0.65762114716757, 1.087043126355232], "f_opt_dim_5": -2.520266818104461, "x_opt_dim_5": [-3.634760232227362, 2.9770213829187955, -0.01706477894504904, -1.952922723707764, -2.6579394800122027]}
{"id": "e4099ea3-54d2-445f-be34-fb093e2da0db", "fitness": 0.9808201647489719, "name": "landscape", "description": "A multi-scale, non-homogeneous basin landscape built from a sum of negative Gaussians (valleys) with centers drawn in [-5,5]^dim and multiple widths. This creates many local minima with irregular basin sizes and boundaries, challenging optimization algorithms to locate the deepest valley. The function is evaluated in [-5,5]^dim and minimized (global minimum is the most negative sum of overlapping wells).", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5, seed=None):\n        self.dim = dim\n        self.seed = seed if seed is not None else 0\n        rng = np.random.default_rng(self.seed)\n\n        # Create a multi-scale set of wells (valleys)\n        # Each center i has:\n        # - a 3D (or D-D) center in [-5, 5]^dim\n        # - a depth weight w_i > 0\n        # - a width s_i (Gaussian std dev) to control basin size\n        scales = [0.35, 0.9, 2.0]  # different basin sizes (widths)\n        per_scale = 20             # wells per scale -> ~60 wells total\n        centers = []\n        weights = []\n        widths = []\n\n        for s in scales:\n            for _ in range(per_scale):\n                centers.append(rng.uniform(-5.0, 5.0, size=self.dim))\n                weights.append(rng.uniform(0.8, 3.0))  # valley depth\n                widths.append(s)\n\n        self.centers = np.asarray(centers)      # shape (N, dim)\n        self.weights = np.asarray(weights)      # shape (N,)\n        self.widths = np.asarray(widths)        # shape (N,)\n        self.N = self.centers.shape[0]\n\n    def f(self, x):\n        x = np.asarray(x)\n        if x.shape != (self.dim,):\n            raise ValueError(f\"x must be a 1-D array of length {self.dim}\")\n\n        # Compute squared distances from x to all centers\n        diff = self.centers - x  # shape (N, dim)\n        d2 = np.sum(diff * diff, axis=1)  # shape (N,)\n\n        # Sum of negative Gaussians: f(x) = - sum_i w_i * exp(-||x - c_i||^2 / (2 s_i^2))\n        vals = -self.weights * np.exp(-d2 / (2.0 * (self.widths ** 2)))\n        return float(np.sum(vals))", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.25835113421048056, 0.7365115863927307, 0.11809343426178216, 0.3326323359439757, 2.870051885255908, 0.2974475018492846, 0.7193789455414901, 2.2973228608047664, 0.8358134635618457, -0.053821716193318526, -0.24400906851672532, 1.0, 0.4553459523251391, 0.6674321751775649, 0.3791132968372602, 0.3620145966505258, -0.21576783182655893, 0.2734364062223934, 0.3206785813159679, 0.3960674635902593, 0.5607580662975836, 0.2763495869418431, 0.30695596463738795, 0.3722321034781083, 0.533262405116743, -0.38012568811963066, -0.35542390263347123, -0.3159715251837712, -0.2298063132981359, -0.3721045198356158, -0.35643878388796846, -0.3228321614785835, -0.24001285679374282, 1.0, 1.0, 1.0, 1.0, 0.5264207006552131, 0.5264170045604424, 0.48353509340515927, 0.5036675847834962, 0.7358444343365269, 0.49749749749749733, 0.5670069306482144, -0.10310310310310307, 0.4], "score_NOT Basins_2D": 0.9427874460816383, "ela_features": [0.1812136318171413, 1.0031298927467542, 0.004616155107623914, 0.1940775844069025, 42.90412581141628, 0.3072299832522625, 0.26803704197149625, 8.615258502829438, 0.5581394661733811, -1.7601223707477136, 3.7350630871657926, 2.4, 0.7017464042502537, 0.8490766314631744, 0.5260692466553991, 0.19987655013240183, -0.4354375546461234, 0.8078677165004462, 0.8654600072267622, 0.8698674961223315, 0.8846265213181377, 0.8604370302784863, 0.9046505860241332, 0.8857287339460573, 0.8848658826654818, -0.16901711578001172, -0.11835573525655574, -0.11447863870804591, -0.10149518647903692, -0.12343037985507717, -0.0843211590490583, -0.10105424612598894, -0.10181720121631518, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21948446435629557, 0.2194772033415882, 0.21280342912196729, 0.23856806723307028, 0.7453505045518931, 0.23723723723723716, 0.0955402224051923, -0.6276276276276274, 0.514102564102564], "score_NOT Basins_5D": 0.999803561848239, "ela_features_10D": [0.022892773290529876, 0.9894665856417666, 0.000594158150829314, 0.015050152335796749, 92.49508828272545, 0.05487655053905967, 0.067322514040142, 39.02320018000224, 0.15321897202864945, -10.882318596689792, 171.41866772186344, 7.2, 0.873621538918214, 0.9252171016414057, 0.6277177907984839, 0.11636899496827557, -0.4503844602075427, 0.815439355744803, 0.8349729507122736, 0.8549687468725338, 0.8878648912003027, 0.8154117404596087, 0.8323547883916188, 0.8518636338471438, 0.8850296300925422, -0.23406910530549138, -0.20929388977363184, -0.18393282664496233, -0.14221194176355884, -0.2347337115289035, -0.2131782581583676, -0.18836527252325413, -0.14618871239404943, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10939066255974031, 0.10939521253102802, 0.10910720996346071, 0.10759190561129901, 0.681035809494874, -0.3233233233233232, 0.0008981565531809247, -2.2132132132132134, 0.5670136108887109], "score_NOT Basins_10D": 0.9998694863170385}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[10, [1.0945208506593957, -1.162809810752488], -16.859509455311112], [4, [-4.242213842525311, 3.219971759753289], -8.536091624689767], [9, [3.487155146622495, 4.378393442902633], -9.951409518549523], [9, [3.6706391453215237, -4.382769868400406], -9.152534403545983], [11, [3.15706196697832, -0.2970922708510818], -14.981700952891773], [5, [-2.971717211358219, 3.707474244848923], -8.624145399865064], [21, [0.29177971887666676, -0.22779178857760324], -14.05462640026261], [6, [3.8639318860051395, -2.6895482281203895], -13.18891394923547], [2, [4.699141835464825, 1.7802765374059555], -9.096044370859868], [4, [-0.17884896801533315, 3.8749800983244973], -11.795231307019641], [7, [-3.7798815809030613, 1.6575179004215603], -10.581103506880048], [12, [-1.5362903147945943, -3.263217221130371], -8.086251730143637]], "nr_of_basins": 12, "f_opt_dim_2": -16.92913408995347, "x_opt_dim_2": [1.0909163128855717, -1.2411536501939655], "f_opt_dim_5": -2.9108754130531866, "x_opt_dim_5": [4.24292672865326, -2.877697525910762, 0.11984018621516661, -4.7165597393451995, -3.2307939646351156]}
{"id": "890f747f-8195-4fab-b9bd-7acce06bb2f2", "fitness": 0.7647566196198264, "name": "landscape", "description": "A multi-wountain irregular landscape built from Gaussian wells with varying depths and widths. Each well creates a local basin; by varying the widths (basin sizes) and depths, the basins are non-homogeneous. The global minimum lies at the deepest well, while other wells form diverse local minima. Centers are placed with a minimum separation to reduce excessive overlap and emphasize non-uniform basin sizes.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._bound = 5.0  # domain bounds per dimension\n        self._seed = 123456789  # fixed seed for determinism\n\n        # number of wells scales with dimension but stays modest\n        self.nwells = max(4, min(12, self.dim * 2))\n\n        # initialize wells deterministically with non-homogeneous basins\n        self.wells = []\n        self._init_wells()\n\n    def _rand(self):\n        # Simple LCG for deterministic pseudo-random numbers in [0,1)\n        self._seed = (1664525 * self._seed + 1013904223) % (2**32)\n        return self._seed / float(2**32)\n\n    def _init_wells(self):\n        self.wells = []\n        min_sep = 3.0  # minimum center separation to reduce excessive overlap\n\n        for i in range(self.nwells):\n            # deterministic placement with rejection for separation\n            tries = 0\n            while True:\n                cand = np.array([ -self._bound + 2.0 * self._bound * self._rand() for _ in range(self.dim) ])\n                ok = True\n                for w in self.wells:\n                    if np.linalg.norm(cand - w['c']) < min_sep:\n                        ok = False\n                        break\n                if ok:\n                    break\n                tries += 1\n                if tries > 200:\n                    # fallback: relax separation if needed\n                    break\n\n            depth = 1.0 + 4.0 * self._rand()  # in [1,5]\n            sigma = 0.3 + 1.2 * self._rand()  # in [0.3, 1.5]\n            self.wells.append({'c': cand, 'depth': depth, 'sigma': sigma})\n\n        # Slightly perturb the deepest well to ensure a clearly defined global minimum\n        idx_max = max(range(self.nwells), key=lambda j: self.wells[j]['depth'])\n        self.wells[idx_max]['depth'] += 1e-6\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to dim\")\n\n        val = 0.0\n        for w in self.wells:\n            diff = x - w['c']\n            dist2 = float(np.dot(diff, diff))\n            val += -w['depth'] * np.exp(-dist2 / (2.0 * (w['sigma'] ** 2)))\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.980,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.0978673684021264, 1.018914106754425, 0.057505869236804175, 0.2122246672707689, 4.536898123953803, 0.12523542375412927, 0.151922060450745, 15.053434465948545, 0.446227339466838, -2.277320829077229, 4.805661801573048, 2.2, 0.24988091169553445, 0.6499545891013685, 0.2225628611905746, 0.3513241315036001, -0.2314936227507407, 0.8048467905959831, 0.8789334510487098, 0.975977193975587, 0.9670314263514982, 1.1298475664977137, 1.2269960080464544, 1.1972202997192718, 1.077336839136773, -0.1020792554335939, -0.06332914791351332, -0.012560525593544236, -0.017245125951112716, 0.06670243152216858, 0.11655255942721301, 0.10127205905839151, 0.0397037509971697, 1.0, 1.0, 1.0, 1.0, 0.5141448598394189, 0.5141175475370389, 0.4435268298612126, 0.44172626687529293, 0.527880272364824, 0.7937937937937936, 0.10402662905401247, -0.5995995995995994, 0.3534136546184739], "score_NOT Basins_2D": 0.99827213678509, "ela_features": [0.04811448256366095, 0.9733408402918491, 0.002754465633855805, 0.040152703593239344, 66.04522529080158, 0.07833813598596633, 0.09925466912427372, 4.597211071915103, 0.2748981995685966, -7.239273210282778, 68.42083900508435, 6.4, 0.7527078964920589, 0.8587516061679041, 0.554710033981553, 0.1925667864012378, -0.35939310984876627, 0.6335802665464197, 0.680612076090366, 0.7098846684799576, 0.7908080227694008, 0.5541752697700495, 0.6240315615904164, 0.6714012808068305, 0.774792565834747, -0.3222837285205872, -0.2809195079755343, -0.2551795731881599, -0.18400301171403394, -0.39404325787279637, -0.3323213368761459, -0.2904660825400559, -0.19907653174139459, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21754765867129627, 0.2175298202705251, 0.21495972647639427, 0.20587971774888106, 0.5862002577023466, 0.25325325325325315, 9.369054060908127e-05, -2.541541541541542, 0.5068910256410255], "score_NOT Basins_5D": 0.3158937692642212, "ela_features_10D": [0.004814729657619777, 0.992538782308084, 0.00025709357144572317, 0.004621757167519775, 162.44776581016467, 0.008370011157856915, 0.0057656122995460414, 22.798683197373546, -0.002931338878685086, -33.704901693378766, 1280.0107822782568, 3.8, 0.9183268047380763, 0.9256100554578326, 0.6696806827658011, 0.11302974335924257, -0.1681164598950253, 0.7641983448568617, 0.79634535929928, 0.8362280712621258, 0.885326222550711, 0.7472415839291994, 0.7836252295457237, 0.829182042557593, 0.8826121552275931, -0.29905490794706446, -0.2582842079233848, -0.2077016455794814, -0.145433216336215, -0.32140550845254656, -0.2751344128454692, -0.21720143074904316, -0.14926225445581198, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10934625909980192, 0.10934260812474375, 0.10924802156151628, 0.10058392318911571, 0.4714915072681639, -1.6206206206206208, 0.0, -Infinity, 0.5564451561248999], "score_NOT Basins_10D": 0.9801039528101683}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[21, [-2.8568888888890025, 3.758000000000137], -3.097360004414292], [24, [4.780000000000024, 4.676000000000036], -3.160640228487997], [18, [-2.1195440665240404, -4.996883683171767], -1.9589852145405364], [37, [0.4493333333333353, -1.2726666666666662], -2.155554980414806]], "nr_of_basins": 4, "f_opt_dim_2": -2.1555550899778186, "x_opt_dim_2": [0.44930385910591114, -1.272965503973292], "f_opt_dim_5": -2.653100940139587, "x_opt_dim_5": [0.4292120661033537, -0.600936490041023, 1.119210925658192, 2.00584911581232, -1.130350144409913]}
{"id": "e50ab499-e344-486e-aa66-03ad79ad3ab1", "fitness": 0.6385741303068547, "name": "landscape", "description": "A multi-peak irregular landscape created by summing heavy-tailed Gaussian wells with varying depths and widths, placed at random centers inside [-5,5]^dim. The depths and widths follow heavy-tailed distributions to produce basins of widely varying sizes, yielding a non-homogeneous basin structure suitable for benchmarking optimization algorithms.", "code": "import numpy as np\n\nclass landscape:\n    \n    def __init__(self, dim):\n        \"\"\"\n        Initialize a novel irregular landscape in dim dimensions.\n        The landscape is constructed as a sum of negative Gaussians (wells)\n        with centers, depths, and widths drawn from heavy-tailed distributions\n        to create basins of highly varying sizes.\n        \n        Parameters:\n        - dim: int, dimensionality of the search space (domains are [-5, 5]^dim)\n        \"\"\"\n        self.dim = int(dim)\n        # Seed determined by dimension for reproducibility across runs with same dim\n        self._rng = np.random.default_rng(self.dim)\n        # Number of wells (scales with dimension to maintain complexity)\n        self.n_peaks = max(40, int(8 * self.dim + 12))\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Centers of wells, within [-5, 5]^dim\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Widths (sigma) of Gaussians: heavy-tailed distribution (log-normal)\n        raw_sigma = self._rng.lognormal(mean=-0.2, sigma=0.9, size=n)\n        self.sigmas = np.clip(raw_sigma, 0.05, 3.0)\n\n        # Depths (positive) of wells; larger depths create deeper basins\n        depths = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n        self.weights = depths  # positive values; wells will be negative contributions\n\n        # Pre-store for speed during evaluation\n        self._centers = self.centers\n        self._sigmas = self.sigmas\n        self._weights = self.weights\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i -w_i * exp(-||x - c_i||^2 / (2 * sigma_i^2))\n        This yields multiple negative wells with irregular basin sizes.\n\n        Parameters:\n        - x: numpy array of shape (dim,) or (k, dim)\n\n        Returns:\n        - scalar value if input is (dim,), or 1-D array of length k otherwise\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        total = np.zeros(x.shape[0], dtype=float)\n        for i in range(self.n_peaks):\n            c = self._centers[i]\n            s = self._sigmas[i]\n            w = self._weights[i]\n            d2 = np.sum((x - c) ** 2, axis=1)\n            total += -w * np.exp(-d2 / (2.0 * (s ** 2)))\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.24645633444597018, 0.8741224328433785, 0.03361347440004164, 0.27230748615526346, 8.283341758419857, 0.28970476331511363, 0.4954077238324179, 1.4413410618846154, 0.6895124601122059, -1.1804815726857785, 2.4164419733978435, 2.0, 0.3991138132236162, 0.6799846519277872, 0.3463495570134591, 0.3455190261085656, -0.22896895516183294, 0.4289385254895068, 0.4254949754499752, 0.43364406740901124, 0.5291692422010945, 0.5927321863663785, 0.4594406957452544, 0.42038594116156325, 0.510906161771294, -0.2989172524318583, -0.30071873280339967, -0.29645643277835887, -0.24644901552306883, -0.20936202926573907, -0.27789157718669266, -0.2979704736237352, -0.25143342577542527, 1.0, 1.0, 0.6666666666666666, 1.0, 0.512858943964248, 0.5127909424055851, 0.4780550126260903, 0.4992584422138334, 0.7266176809081399, 0.7577577577577576, 0.2863222309103869, -0.3353353353353353, 0.4100401606425702], "score_NOT Basins_2D": 0.8793074563145638, "ela_features": [0.334185243268957, 0.9585892114404879, 0.006846217304868929, 0.15914108558244539, 129.19109968948095, 0.4273950481181131, 0.4733304641248073, 5.526465417097376, 0.7193349222274461, -3.1091477022862732, 14.927786009285683, 4.4, 0.8570678294084828, 0.8694861026782122, 0.6179256198840829, 0.18297752793088454, -0.35396377092750086, 0.4935280279520976, 0.591865629093222, 0.66193019975804, 0.7673448300149045, 0.4856326080978903, 0.5760725174538688, 0.6484032760941524, 0.7624039044974109, -0.445518456055588, -0.3590172908609675, -0.29738387782649606, -0.20465652725214017, -0.4547871599471553, -0.37482434287799304, -0.31087228223811036, -0.2100770233004694, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21778214316841674, 0.2177906007181293, 0.215034762710182, 0.26270306893775514, 0.7311506754353554, 0.10110110110110107, 0.04658262838447799, -0.995995995995996, 0.5104166666666667], "score_NOT Basins_5D": 0.03652620315551758, "ela_features_10D": [0.05508198657023462, 0.9967671833233294, 0.0014148917507230071, 0.02994138402266605, 32.71495890668809, 0.1658860561305464, 0.13683261326690482, 5.27950961647543, 0.30084508671700877, -7.4083636562581985, 100.28804190241684, 5.2, 0.8911029845089619, 0.9280300802637236, 0.638466199134901, 0.11259305808585778, -0.4792304591942146, 0.861248149559431, 0.8583537094052275, 0.8636598855453872, 0.8882421279045779, 0.8810381008076741, 0.8601617780616146, 0.8590858936816133, 0.8851915467469027, -0.17595855736394778, -0.17962830634084254, -0.17289975762803622, -0.1417260220575538, -0.15124008514962406, -0.1777751006323698, -0.17914551135019047, -0.14595891426873636, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11043961227212647, 0.11044089934931658, 0.10996022380441757, 0.11326161770338528, 0.7509171175139207, -0.2952952952952952, 0.009576622302826937, -1.5925925925925926, 0.5698158526821457], "score_NOT Basins_10D": 0.9998887314504827}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[9, [-1.824501928739942, 4.17510428500226], -3.766522252043777], [31, [0.905504159865396, 2.5388040517499846], -11.16177631320166], [22, [1.4870964376715932, -0.9419170503651125], -12.477160095445397], [8, [0.618329658314276, -3.455732573697956], -5.068382691527612], [21, [-3.2804974384809107, -3.1704201014629576], -5.977534189994884], [2, [-4.7608145063832525, 3.3346944439079103], -1.6730238523045005], [7, [3.505648776154476, -0.48824916263875107], -5.7757003141858165]], "nr_of_basins": 7, "f_opt_dim_2": -12.47716085212219, "x_opt_dim_2": [1.4870905821905058, -0.9416702190201128], "f_opt_dim_5": -8.599736175264876, "x_opt_dim_5": [3.0168679984340843, 3.04133214750226, 0.09538931252139121, -2.042334346800628, -4.364701775928254]}
{"id": "03915f6a-fd12-4a0b-880e-c62a9eee9879", "fitness": 0.9951681761788981, "name": "landscape_nonhomogeneous_anisotropic", "description": "A non-homogeneous multi-well landscape using a collection of anisotropic Gaussian wells (rotated ellipsoids) with varying depths, per-axis widths, and non-uniform centers. This creates basins of attraction with highly non-uniform sizes and shapes, breaking basin-size homogeneity and providing a challenging minimization landscape in [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_anisotropic:\n    def __init__(self, dim=5):\n        self.dim = dim\n        # number of wells (enough to create rich, non-uniform basins)\n        self.K = max(6, dim * 3)\n        \n        # Deterministic RNG for reproducibility with respect to dimension\n        rng = np.random.RandomState(123456)\n        \n        # Random centers for the wells inside [-5, 5]^dim\n        self.centers = rng.uniform(-5.0, 5.0, size=(self.K, dim))\n        \n        # Amplitudes (depths) of the wells (positive values; function uses negation)\n        self.amps = rng.uniform(0.8, 6.0, size=(self.K,))\n        \n        # Widths per axis for each well (controls anisotropy of the ellipsoidal Gaussian)\n        self.widths = rng.uniform(0.25, 2.5, size=(self.K, dim))\n        \n        # Random rotation for each well to further break symmetry\n        self.orns = []\n        for i in range(self.K):\n            A = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(A)\n            # Ensure a proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            self.orns.append(Q)\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension.\")\n        \n        val = 0.0\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            # Rotate into the ellipsoid's frame\n            y = self.orns[i].T @ diff\n            # Anisotropic squared distance with per-axis widths\n            dist2 = np.sum((y / self.widths[i])**2)\n            val += - self.amps[i] * np.exp(-0.5 * dist2)\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonhomogeneous_anisotropic scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["7a70c5d5-a465-4f20-87da-b775b432bb78"], "operator": null, "metadata": {"ela_features_2D": [0.22349631809931997, 0.6771221644411118, 0.10423775273024372, 0.3855149007957085, 3.737052831856734, 0.2722478182026382, 0.36879784187671694, 1.4687179781201032, 0.6634426372351088, -1.3177423071341146, 0.7262802434603136, 1.8, 0.5236588570112022, 0.6961656441691266, 0.4263387823326152, 0.3502018321203132, -0.18152313958844055, 0.147698407254859, 0.4035823704046876, 0.5003659246931841, 0.6105534075492844, 0.14267628207480332, 0.30945748777184556, 0.439475762524269, 0.5684712427440397, -0.4457824440922077, -0.3119689344445844, -0.2613165162512153, -0.2036935327412725, -0.4403812413900928, -0.3547401878417574, -0.28792313688754645, -0.2216775968086922, 1.0, 1.0, 1.0, 1.0, 0.517855886501559, 0.5178387600031324, 0.4770145288860741, 0.4948627242030149, 0.49996172489484103, 0.7457457457457455, 0.5796804647382581, -0.4194194194194193, 0.35582329317269074], "score_NOT Basins_2D": 0.985748597420752, "ela_features": [0.021760568048623984, 0.9667425422031657, 0.0031386196767835737, 0.04553352538565668, 23.14630048316779, 0.08227428445015657, 0.08211397088195979, 14.24286124241863, 0.2698569760080881, -4.448983105653783, 25.726560526838, 6.0, 0.6556264041144868, 0.8413458518578192, 0.4861924144585589, 0.20350109396806873, -0.4380160818426949, 0.9315915027184385, 0.9160074977006604, 0.9034742408009379, 0.9059853839450002, 1.0147957347898366, 0.9736562610341583, 0.9372940443693689, 0.9123108540356192, -0.06018431845649212, -0.07389232831434123, -0.08492220862455266, -0.08270999040270903, 0.01309969227221408, -0.023291018066290303, -0.05548238107221108, -0.07757318337427468, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21920927919020797, 0.21922490338786563, 0.21426775908056958, 0.19533281535047575, 0.6514756622677649, 0.3213213213213212, 0.006020025637198903, -1.3603603603603607, 0.5248397435897436], "score_NOT Basins_5D": 0.9998150453320704, "ela_features_10D": [0.009059111460088332, 1.0053581376594756, 0.00022625802580731146, 0.00777985719947639, 93.35166223364139, 0.014131504512976224, 0.015011162458158766, 39.65393334307434, 0.030282551712437277, -22.658493477093565, 673.4794612699721, 4.6, 0.8357524644477333, 0.917489488009066, 0.6050476705289809, 0.12263470972555648, -0.27933354535744914, 0.8507453929922436, 0.8579784156881661, 0.8721017803414067, 0.9058850132097337, 0.8561596838375058, 0.856870466237794, 0.8699093053848073, 0.9043578810946096, -0.18927949427534854, -0.18010627214275474, -0.16219523446631473, -0.11935268620186049, -0.18288775284941888, -0.18198429795504198, -0.1654053568234366, -0.12160598164528835, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11053279362911102, 0.11053611833060306, 0.11036533588683435, 0.10247738902136391, 0.5601361978935591, -0.6116116116116114, 1.009435363897104e-05, -4.6276276276276285, 0.5939151321056846], "score_NOT Basins_10D": 0.9999408857838716}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [-2.714600720499872, 3.0427674512610787], -6.595391775530686], [15, [-0.5728393019741598, 3.503196090758899], -3.0309919934838176], [69, [-1.1717875148614516, -1.5471427959734034], -9.304706860530498]], "nr_of_basins": 3, "f_opt_dim_2": -9.304707708101288, "x_opt_dim_2": [-1.1715862983409626, -1.5476293637084575], "f_opt_dim_5": -5.922139890116166, "x_opt_dim_5": [0.6064704014622141, -0.28502582179053376, -3.612696473493436, -4.055166776249764, 4.422660018577334]}
{"id": "307a5731-5b5e-4154-aa22-0d3557641fd6", "fitness": 0.7320135304083427, "name": "landscape_min_bowls", "description": "A completely new landscape based on the pointwise minimum of anisotropic quadratic bowls. Each bowl has its own center, depth, and per-dimension curvature, producing non-homogeneous, non-separable basins with irregular sizes. The global minimum is located at the bowl with the smallest depth, and the domain is [-5,5]^dim. Centers are deterministically placed with a minimum separation to avoid excessive overlap, ensuring a diverse landscape for benchmarking optimizers.", "code": "import numpy as np\n\nclass landscape_min_bowls:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._bound = 5.0  # domain bounds per dimension\n        self._seed = 987654321  # fixed seed for determinism\n\n        # number of wells scales with dimension but stays modest\n        self.nwells = max(4, min(12, self.dim * 2))\n\n        # initialize wells deterministically with non-homogeneous basins\n        self.wells = []\n        self._init_wells()\n\n    def _rand(self):\n        # Simple LCG for deterministic pseudo-random numbers in [0,1)\n        self._seed = (1664525 * self._seed + 1013904223) % (2**32)\n        return self._seed / float(2**32)\n\n    def _init_wells(self):\n        self.wells = []\n        min_sep = 2.5  # minimum center separation to reduce excessive overlap\n\n        for i in range(self.nwells):\n            # deterministic placement with rejection for separation\n            tries = 0\n            while True:\n                cand = np.array([ -self._bound + 2.0 * self._bound * self._rand() for _ in range(self.dim) ])\n                ok = True\n                for w in self.wells:\n                    if np.linalg.norm(cand - w['c']) < min_sep:\n                        ok = False\n                        break\n                if ok:\n                    break\n                tries += 1\n                if tries > 500:\n                    # fallback: relax separation if needed\n                    break\n\n            depth = 0.5 + 4.5 * self._rand()  # in [0.5, 5.0]\n            # anisotropic curvature per dimension (controls basin width along each axis)\n            q = np.array([0.2 + 3.3 * self._rand() for _ in range(self.dim)])  # [0.2, ~3.5]\n            self.wells.append({'c': cand, 'depth': depth, 'q': q})\n\n        # Ensure a clearly defined global minimum by making the smallest depth bowl slightly unique\n        idx_min = int(min(range(self.nwells), key=lambda j: self.wells[j]['depth']))\n        self.wells[idx_min]['depth'] -= 1e-6\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to dim\")\n\n        vals = []\n        for w in self.wells:\n            diff = x - w['c']\n            quad = float(np.dot(w['q'], diff * diff))  # sum_i q_i * (x_i - c_i)^2\n            val = w['depth'] + 0.5 * quad\n            vals.append(val)\n\n        return float(min(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_min_bowls scored on:NOT Basins 0.797,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["890f747f-8195-4fab-b9bd-7acce06bb2f2"], "operator": null, "metadata": {"ela_features_2D": [0.5858826988274752, 0.5968365267954725, 0.3187066429226905, 0.49569150850152227, 1.5553279707639465, 0.839681720929683, 0.6810899204927156, 24.651482575803875, 0.9700512373442312, 1.7219864925962043, 2.229860498598863, 1.6, 0.31205505389973953, 0.6761004476600615, 0.2623035870627067, 0.34279683936211036, -0.10490043434530671, 0.20005867353408777, 0.5834011189700294, 0.7400380541566436, 0.795886979328784, 0.15676901172949553, 0.3177073832993128, 0.5447138254565465, 0.7327794823527525, -0.4183977411268023, -0.21789368006773935, -0.13597487374462655, -0.10676755250670307, -0.4326785804254311, -0.35004849786129566, -0.2336138269425662, -0.13712661260329634, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5139008558029129, 0.5138672349456087, 0.5463737235814593, 0.5877818993690038, 0.6877938941706727, 0.33733733733733723, 0.19834092218338353, -0.4354354354354353, 0.37389558232931724], "score_NOT Basins_2D": 0.4136626720428467, "ela_features": [0.2984195871103861, 0.32877954048136204, 0.026387668833050625, 0.23153106509245744, 8.93028538357348, 0.4040132856485025, 0.5440887774771479, 3.4410022050234637, 0.7765426065909427, 1.0933846066315431, 1.3935214721589335, 2.2, 0.7260266938208401, 0.8475159087229773, 0.5402360027360831, 0.20280113487099366, -0.37392976538913436, 0.7124079327000302, 0.7836043676570028, 0.8057363329980534, 0.8566209865834535, 0.7126874072286014, 0.787458915736132, 0.805329151826449, 0.8535196950667245, -0.2529586553974713, -0.19033462626340117, -0.17086904986840107, -0.12611295893782978, -0.253999854117211, -0.18788280230487273, -0.17209803816860053, -0.12950107680418704, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21636197400355525, 0.2163801228839227, 0.21001755630105215, 0.25269897750722475, 0.8193429009950381, 0.10910910910910906, 0.1762779264962117, -0.5075075075075073, 0.5275641025641026], "score_NOT Basins_5D": 0.9853570964187384, "ela_features_10D": [0.19355437384156848, 0.3978080346961216, 0.005395234851708763, 0.1739451225794632, 47.36160834578792, 0.48385343180100604, 0.3694717341652574, 14.637783713012805, 0.7129215178863475, 0.41050267286435577, 0.09248164269487695, 1.4, 0.8359583637006132, 0.9190433138818983, 0.6048740619269618, 0.12081066424381293, -0.4884846348931702, 0.9242734193009294, 0.9227800213984121, 0.9212966152665801, 0.9326693341456045, 0.932815614393386, 0.9286767429291786, 0.9250491050745415, 0.9326579959216478, -0.0960390730113728, -0.09793337705995375, -0.09981448191738389, -0.0853910148943526, -0.08542772053402045, -0.09069081073110982, -0.09530171856311412, -0.08562594073864957, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10979892191603413, 0.10979421547279125, 0.10795212342079748, 0.13112978268293504, 0.8491883684900658, -0.15115115115115113, 0.11604494704547266, -0.7117117117117114, 0.5661329063250601], "score_NOT Basins_10D": 0.797020822763443}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [-4.347070798000226, 3.729379411217009], 3.291613333801958], [16, [3.42688888888894, 0.899777777777863], 1.6314053557099482], [24, [4.336000000000073, -2.306666666666633], 1.0659330204203628], [55, [-1.4166666666666663, 2.8437777777777713], 0.6976066713490896]], "nr_of_basins": 4, "f_opt_dim_2": 0.6976065844140723, "x_opt_dim_2": [-1.4162776314772927, 2.8436058758499776], "f_opt_dim_5": 1.1458489112632126, "x_opt_dim_5": [-2.5447808474682896, 1.0303772446782322, 1.0483595736099383, 3.0826156889816216, 3.236385192482989]}
{"id": "f1e9d2f9-282b-4f0c-933f-fdc9fd887fa1", "fitness": 0.6606931970454752, "name": "landscape_paraboloid_min", "description": "A non-homogeneous landscape built from anisotropic paraboloid wells (ellipsoidal bowls) arranged in [-5,5]^dim. Each well is an ellipsoidal paraboloid with its own depth, curvature, and orientation, and the overall landscape is the pointwise minimum of these wells. This yields irregular basin sizes and shapes, with the global minimum located at the deepest well center. It is structurally different from Gaussian-based wells while preserving non-homogeneous basins.", "code": "import numpy as np\n\nclass landscape_paraboloid_min:\n    def __init__(self, dim=5, seed=4321):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n        \n        # Number of wells scales with dimension but is capped to keep evaluation reasonable\n        self.N = max(4, min(64, 4 * self.dim))\n        \n        # Centers of wells inside the domain [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, self.dim))\n        \n        # Depths (positive values, deeper wells have larger depth)\n        self.weights = rng.uniform(low=0.5, high=6.0, size=self.N)\n        \n        # Ellipsoidal curvature matrices for each well (anisotropic parabolas)\n        # Construct as Q_i = R_i^T * D_i * R_i where:\n        # - R_i is a random rotation (orthogonal)\n        # - D_i is a diagonal matrix with positive entries (curvatures along axes)\n        self.Q = []\n        for i in range(self.N):\n            # Random rotation via QR decomposition\n            A = rng.normal(size=(self.dim, self.dim))\n            Qr, Rr = np.linalg.qr(A)\n            # Ensure a proper rotation (det > 0)\n            if np.linalg.det(Qr) < 0:\n                Qr[:, -1] *= -1\n            \n            # Random axis curvatures (positive, controlling basin widths along axes)\n            D = rng.uniform(low=0.5, high=3.0, size=self.dim)\n            Diag = np.diag(D)\n            \n            # SPD paraboloid curvature matrix\n            Qi = Qr.T @ Diag @ Qr\n            self.Q.append(Qi)\n        self.Q = np.stack(self.Q, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n        \n        # Evaluate each paraboloid well: f_i(x) = (x - c_i)^T Q_i (x - c_i) - w_i\n        # Global landscape value is the minimum across all wells\n        vals = np.empty(self.N, dtype=float)\n        for i in range(self.N):\n            diff = x - self.centers[i]  # shape (dim,)\n            Qi = self.Q[i]               # shape (dim, dim)\n            vals[i] = float(diff @ Qi @ diff - self.weights[i])\n        \n        return float(np.min(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_paraboloid_min scored on:NOT Basins 0.979,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cbef6f03-77eb-4ab4-ad01-c561c65f604e"], "operator": null, "metadata": {"ela_features_2D": [0.449028332098196, -0.1001356334096204, 0.20750729260219422, 0.3596070388460517, 1.745120675263911, 0.8501570491696325, 0.4931040110805779, 1.3350263411029732, 0.9693504860036665, 1.8511478631328693, 3.7131684851385947, 2.6, 0.25535302294944867, 0.6603222424176405, 0.24712524315327727, 0.35177336304866935, -0.12117613593551384, 0.7000350258689773, 0.8036840930890976, 0.7805898560290873, 0.8574775442655254, 0.37766145201016793, 0.6459385957028541, 0.5596980780768679, 0.650476510770104, -0.15695301382492238, -0.10267804910506431, -0.1147739734697473, -0.07455070541940502, -0.3194933299470056, -0.18171240815613113, -0.22603398604907232, -0.17939317283189277, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5132310559985547, 0.51321056674493, 0.5039368923638732, 0.5544226150951918, 0.7032045671886565, 0.3093093093093092, 0.23541299582419964, -0.4674674674674673, 0.3759036144578313], "score_NOT Basins_2D": 0.004430592060089111, "ela_features": [0.19117166854267403, 0.20186423829693254, 0.04112459791158292, 0.1437186036802209, 3.691476891097124, 0.41577067479745045, 0.4040310653475448, 3.3860472847712964, 0.712534236044063, 1.128374120979036, 1.662969849654462, 2.2, 0.6732102480443188, 0.8457710391874261, 0.5052663019604786, 0.20092167855511364, -0.39528281454060066, 0.8514281513404747, 0.8425337920266742, 0.8605626094590324, 0.8840638914054535, 0.8646096033306179, 0.8506343054517072, 0.8644791493105671, 0.8850076615702875, -0.13066927352412952, -0.13849205248474278, -0.12263740757030754, -0.10196701907151642, -0.11961085752271121, -0.13197467447936082, -0.11975645395673087, -0.10161135713103878, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21496695091435547, 0.21497759168747047, 0.20881216105378594, 0.24106180242987355, 0.8241865683223857, 0.12512512512512508, 0.19499523763446647, -0.4634634634634633, 0.5272435897435898], "score_NOT Basins_5D": 0.998959633987397, "ela_features_10D": [0.14995978967821896, 0.44478659207161114, 0.005393753998680253, 0.0960267593635528, 34.72274066369248, 0.2947526973008733, 0.3786301411280917, 2.1082904607912494, 0.5782453044819587, 0.4060087847517841, 0.1338841022694294, 2.0, 0.8042576545594873, 0.9164593599740588, 0.5767513470940638, 0.12442317116358384, -0.5195807199734258, 0.8757291314908228, 0.8874617468202777, 0.8970570134515878, 0.9138155551584406, 0.878836976842487, 0.8874004281782668, 0.8968223080971358, 0.9128638008374322, -0.15761978596829462, -0.14274026036523885, -0.13057062862239724, -0.1093138766237447, -0.1541141924699895, -0.1432239798473734, -0.13124082925508165, -0.11083479551461614, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11013547378053996, 0.11013743700341368, 0.10880805777541538, 0.12803655037719186, 0.8545785662953367, -0.13513513513513503, 0.12428668765968957, -0.6836836836836835, 0.5947157726180945], "score_NOT Basins_10D": 0.9786893650889397}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [-4.803048592569847, 2.9851525830056853], -3.6476917852063426], [17, [-4.08008985212702, 3.745044040070038], -5.291333386013715], [22, [3.5577713114133744, -3.3496744911935177], -5.791954837767295], [29, [0.33020507908946717, -3.766955514897518], -5.080258990292059], [21, [-0.553122712177125, -0.864232393380419], -0.7542638092062783]], "nr_of_basins": 5, "f_opt_dim_2": -5.791955350354086, "x_opt_dim_2": [3.557269052064796, -3.349532416316169], "f_opt_dim_5": -5.1185790934285835, "x_opt_dim_5": [1.3394837081574826, 0.4393625010489067, -0.09568899321446458, 2.2252542221284806, -1.5672696475049204]}
{"id": "611d98d0-4517-49a6-86ae-5c4a051ded2c", "fitness": 0.9259686322960382, "name": "landscape_nh", "description": "A non-homogeneous multi-peak landscape with heavy-tailed Gaussian wells plus a non-separable background that creates cross-dimensional interactions, yielding highly irregular basin sizes to break basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_nh:\n    \"\"\"\n    A novel, non-homogeneous optimization landscape built as a sum of\n    heavy-tailed Gaussian wells with random centers, plus a non-separable\n    background term. The background is constructed from random directional\n    projections, creating cross-dimensional interactions that produce\n    irregular basin sizes and non-uniform basins across the domain.\n    \n    Evaluation domain: [-5, 5]^dim\n    Minimization problem: lower function values are better\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the irregular landscape in dim dimensions.\n        The landscape consists of:\n        - A set of heavy-tailed Gaussian wells (positive depths, contributing\n          negative values to f(x)).\n        - A non-separable background formed by a sum of Gaussians along random\n          directions (cross-coordinate interactions) with small amplitudes.\n        \n        Parameters:\n        - dim: int, dimensionality of the search space\n        \"\"\"\n        self.dim = int(dim)\n        # Seed deterministically by dimension for reproducibility\n        self._rng = np.random.default_rng(self.dim)\n        \n        # Number of heavy-tailed wells (scales with dimension to maintain complexity)\n        self.n_peaks = max(40, int(8 * self.dim + 12))\n        \n        # Number of background components to inject non-separability\n        self.n_bg = max(6, int(2 * self.dim))\n        \n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n        \n        # Centers of wells, within [-5, 5]^dim\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n        \n        # Widths (sigma) of Gaussians: heavy-tailed distribution (log-normal)\n        raw_sigma = self._rng.lognormal(mean=-0.2, sigma=0.9, size=n)\n        self.sigmas = np.clip(raw_sigma, 0.05, 3.0)\n        \n        # Depths (positive) of wells; deeper wells create deeper basins\n        depths = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n        self.weights = depths  # positive values; wells contribute negative amounts\n\n        # Background non-separable features\n        # Each background component is a Gaussian along a random direction:\n        # B_j(x) = beta_j * exp(- (a_j^T x)^2 / (2 * sigma_j^2))\n        self.n_bg = max(6, int(2 * d))\n        self.a = self._rng.normal(0.0, 1.0, size=(self.n_bg, d))  # direction-like vectors\n        self.betas = self._rng.uniform(-0.6, 0.6, size=self.n_bg)  # amplitude (can be +/-)\n        self.bg_sigmas = self._rng.uniform(0.7, 2.5, size=self.n_bg)\n\n        # Cache for speed in evaluation\n        self._centers = self.centers\n        self._sigmas = self.sigmas\n        self._weights = self.weights\n        self._a = self.a\n        self._betas = self.betas\n        self._bg_sigmas = self.bg_sigmas\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i -w_i * exp(-||x - c_i||^2 / (2 * sigma_i^2)) + sum_j beta_j * exp(- (a_j^T x)^2 / (2 * sigma_j^2))\n        This yields multiple negative wells with irregular, non-homogeneous basin sizes\n        due to heavy-tailed wells and the cross-dimensional background terms.\n\n        Parameters:\n        - x: numpy array of shape (dim,) or (k, dim)\n\n        Returns:\n        - scalar value if input is (dim,), or 1-D array of length k otherwise\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        total = np.zeros(x.shape[0], dtype=float)\n\n        # Primary wells (negative Gaussians)\n        for i in range(self.n_peaks):\n            c = self._centers[i]\n            s = self._sigmas[i]\n            w = self._weights[i]\n            d2 = np.sum((x - c) ** 2, axis=1)\n            total += -w * np.exp(-d2 / (2.0 * (s ** 2)))\n\n        # Background non-separable components\n        # B_j(x) = beta_j * exp(- (a_j^T x)^2 / (2 * sigma_j^2))\n        for j in range(self.n_bg):\n            a = self._a[j]\n            s = self._bg_sigmas[j]\n            coef = self._betas[j]\n            proj = np.dot(x, a)  # shape (n,)\n            total += coef * np.exp(- (proj ** 2) / (2.0 * (s ** 2)))\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh scored on:NOT Basins 0.996,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e50ab499-e344-486e-aa66-03ad79ad3ab1"], "operator": null, "metadata": {"ela_features_2D": [0.2219865075329827, 0.8562645127946082, 0.02940318130972967, 0.2644224409867396, 10.56991490332737, 0.28233820764775547, 0.44585344723635956, 1.1246049265925921, 0.6597838008501611, -1.31432094074709, 2.6478157723029696, 2.2, 0.3828355146389744, 0.6772158911992394, 0.347985769933002, 0.3468101522644361, -0.2258194293745949, 0.3457305154735468, 0.4060376088728669, 0.4454672825262909, 0.5376456027033532, 0.38979179117316043, 0.39489408020340777, 0.4355386980389782, 0.5217249551124675, -0.34224559535252763, -0.3106877115772051, -0.2900653043652889, -0.24184375660744362, -0.3132012110378235, -0.3105904964222413, -0.2897150268863107, -0.24547676506002744, 1.0, 1.0, 0.8666666666666666, 1.0, 0.5189741796174147, 0.5189547245751415, 0.47783392698572796, 0.4920259771182412, 0.7197762604229363, 0.7377377377377374, 0.2565733533893811, -0.34734734734734724, 0.37751004016064255], "score_NOT Basins_2D": 0.7826615422964096, "ela_features": [0.22087433280747018, 0.8787588641180598, 0.006681226837470106, 0.11249054183762086, 23.755351197233487, 0.39719401462377235, 0.3176347916191747, 5.264781527958222, 0.6048489425825886, -2.793356345933922, 15.05512764482251, 5.4, 0.737053529597303, 0.8417785552979484, 0.5625421716325282, 0.20435773728499446, -0.39465054845398007, 0.47319933959381444, 0.6030971233444221, 0.6926422670019795, 0.8441932654993147, 0.46625113850864414, 0.5921434217238432, 0.6781162778776231, 0.8310302528203255, -0.4632982632941741, -0.34905966771427216, -0.27030687800976577, -0.13702501560689678, -0.4716907779731011, -0.3604367156340594, -0.2844565845730635, -0.14932434176018627, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2179376789571122, 0.21792257695188186, 0.21478570542581835, 0.2475407679137569, 0.819496270169336, 0.025025025025025, 0.08863216387508643, -0.7997997997997995, 0.5424679487179487], "score_NOT Basins_5D": 0.9987674582516775, "ela_features_10D": [0.0005518974755886807, 0.524317860337062, 0.0014832161454396502, 0.01930603585639191, 45.09329522139321, 0.1510449291276448, 0.010556041437538567, 19.26073446506449, 0.16197140474149735, 0.18629714180001003, 0.3412512724553289, 1.6, 0.7144158504898532, 0.892857849475436, 0.5401020467118313, 0.14210158921784707, -0.5764770794758449, 0.9239852941121052, 0.9576929730658884, 0.9678222292584628, 0.9860118891463377, 0.9252850189340123, 0.9573005511860739, 0.9674895776653898, 0.9860892127338143, -0.09640352346374806, -0.05365524679942459, -0.0408093743034323, -0.01774013478126184, -0.09500530101702816, -0.05429579462277419, -0.04134049506498152, -0.017688382561055916, 0.9, 0.9, 0.8909090909090909, 0.909090909090909, 0.10967304458334418, 0.1096726378133905, 0.1075607841714312, 0.1006818748513089, 0.8615481222154523, -0.019019019019019052, 0.1377112345423646, -0.6316316316316314, 0.6413130504403523], "score_NOT Basins_10D": 0.9964768963400275}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[7, [-1.7956164201312372, 4.179558799670977], -3.290494307716564], [12, [1.4907396120119527, -0.9375999674926087], -12.12617025239514], [8, [0.6106697203973157, -3.4626102034160327], -4.64562545964192], [7, [2.482715971337017, 0.664793760610864], -5.5119246841375835], [31, [0.9121840949376999, 2.5368463913018355], -10.638107827582655], [10, [3.531156614582804, -0.5293908868412891], -5.753899673985544], [21, [-3.279498312527039, -3.1709341406783453], -5.8339358821994765], [4, [-4.746436061897256, 3.3285653604351633], -1.4121525107705923]], "nr_of_basins": 8, "f_opt_dim_2": -12.126170825372101, "x_opt_dim_2": [1.4908211295715528, -0.9374052490364282], "f_opt_dim_5": -9.273452812317466, "x_opt_dim_5": [3.1463889035918737, 2.9980163296440843, 0.2315143608701815, -1.9432731525219042, -4.355130024055951]}
{"id": "392b1c7a-2b50-42b4-84b0-a9340e5e872b", "fitness": 0.9992151276480096, "name": "landscape_anisotropic_nonhomogeneous", "description": "A non-homogeneous multi-well landscape using anisotropic (rotated) Gaussian wells with varying depths. Each well has its own positive-definite covariance, leading to irregular, non-uniform basin shapes and sizes. The centers are deterministically placed with separation to reduce overlap, and the global minimum lies at the deepest well.", "code": "import numpy as np\n\nclass landscape_anisotropic_nonhomogeneous:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._bound = 5.0  # domain bounds per dimension\n        self._seed = 987654321  # fixed seed for determinism\n\n        # number of wells scales with dimension but stays modest\n        self.nwells = max(4, min(16, self.dim * 2))\n\n        # initialize wells with anisotropic (rotated) Gaussian shapes\n        self.wells = []\n        self._init_wells()\n\n    def _rand(self):\n        # Simple LCG for deterministic pseudo-random numbers in [0,1)\n        self._seed = (1664525 * self._seed + 1013904223) % (2**32)\n        return self._seed / float(2**32)\n\n    def _init_wells(self):\n        self.wells = []\n        min_sep = 2.5  # minimum center separation to reduce excessive overlap\n\n        for i in range(self.nwells):\n            # deterministic placement with rejection for separation\n            tries = 0\n            while True:\n                cand = np.array([ -self._bound + 2.0 * self._bound * self._rand() for _ in range(self.dim) ])\n                ok = True\n                for w in self.wells:\n                    if np.linalg.norm(cand - w['c']) < min_sep:\n                        ok = False\n                        break\n                if ok:\n                    break\n                tries += 1\n                if tries > 200:\n                    # fallback: break out to ensure progress\n                    break\n\n            depth = 1.0 + 4.0 * self._rand()  # in [1,5]\n\n            # Create a random orthogonal matrix Q via QR decomposition\n            M = np.array([[self._rand() for _ in range(self.dim)] for __ in range(self.dim)], dtype=float)\n            try:\n                Q, R = np.linalg.qr(M)\n            except np.linalg.LinAlgError:\n                Q = np.eye(self.dim)\n\n            # Eigenvalues for anisotropic scales per axis (positive)\n            lambdas = np.array([0.2 + 1.8 * self._rand() for _ in range(self.dim)], dtype=float)\n            L = np.diag(lambdas)\n\n            # Anisotropic covariance Sigma = Q * L * Q^T\n            Sigma = Q @ L @ Q.T\n            Sigma_inv = np.linalg.inv(Sigma)\n\n            self.wells.append({'c': cand, 'depth': depth, 'Sigma': Sigma, 'Sigma_inv': Sigma_inv})\n\n        # Slightly perturb the deepest well to ensure a clearly defined global minimum\n        if self.wells:\n            idx_max = max(range(self.nwells), key=lambda j: self.wells[j]['depth'])\n            self.wells[idx_max]['depth'] += 1e-6\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to dim\")\n\n        val = 0.0\n        for w in self.wells:\n            diff = x - w['c']\n            dist2 = float(np.dot(diff, w['Sigma_inv'].dot(diff)))\n            val += -w['depth'] * np.exp(-dist2 / 2.0)\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_anisotropic_nonhomogeneous scored on:NOT Basins 0.999,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["890f747f-8195-4fab-b9bd-7acce06bb2f2"], "operator": null, "metadata": {"ela_features_2D": [0.0520116132178885, 0.8618686811072573, 0.09850083982918945, 0.12783219437780474, 1.2993643194769517, 0.05570401931913325, 0.05418630457259026, 3.0113197594377725, 0.23946867704100558, -2.1608821034117445, 4.48421235762425, 3.2, 0.27506429158000323, 0.6620109944683195, 0.21408841825748431, 0.345979552538633, -0.2392662684808357, 0.17241189978546884, 0.6164324180603963, 0.8601443226042464, 0.9228487584666519, 0.13697549731078426, 0.29283449829345665, 0.9608667272584818, 1.0419538141073519, -0.4330776936178161, -0.2007263737300647, -0.07318769202209906, -0.04037333715311263, -0.4431631509525674, -0.3631363873559016, -0.020092598097856795, 0.021542593935938225, 1.0, 1.0, 1.0, 1.0, 0.5185081232434097, 0.5185020122387666, 0.4269167613140842, 0.4118030129138668, 0.5497486581362986, 0.8138138138138136, 0.19870060566105038, -0.4834834834834833, 0.3875502008032129], "score_NOT Basins_2D": 0.9985177667113021, "ela_features": [0.013563340722189343, 0.9959987970499935, 0.0008082888548625111, 0.023170790857914465, 30.88873168848487, 0.03193891390637198, 0.016674485017055686, 6.521984561335385, 0.07386201831424528, -10.882327789464227, 151.07739275864964, 7.6, 0.7006349450189815, 0.8488840168315583, 0.5011974490484216, 0.19965072684808519, -0.3542828105278148, 0.8610491910575971, 0.8630239488036466, 0.8731240556051467, 0.8868051991005983, 0.8886824995063008, 0.8820879955613966, 0.8829015112184224, 0.8831796277756261, -0.12222015021595631, -0.12048015494360928, -0.11159465753173034, -0.09956161037616433, -0.09839926865027071, -0.1042282403195685, -0.10350298128733137, -0.10326181083685801, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21846661747139193, 0.21844561424353146, 0.2164790413198317, 0.19228149310218712, 0.5359243802193797, 0.21321321321321313, 1.6410689171837074e-05, -3.598598598598599, 0.5137820512820512], "score_NOT Basins_5D": 0.9996373430476524, "ela_features_10D": [0.00038856516181970944, 1.000340083976087, 0.00013494985741795707, 0.0026281781999799203, 19.552707554950047, -0.002606950830066368, 0.00042891713608703694, 9.803239728852613, -0.008052723397329875, -39.807490962872635, 1753.9502502486514, 3.0, 0.7898059363078657, 0.8973311080098367, 0.5469493517354321, 0.13394970762086886, -0.1493133963314917, 0.8859086096827674, 0.8948811595333819, 0.8990027352290042, 0.9181506044205046, 0.9000299977576821, 0.8974800211954657, 0.8978439169901378, 0.9160744120657791, -0.14468171618643674, -0.1333028362702255, -0.12807589147065887, -0.1037938270264771, -0.12708855617446618, -0.1303282731151382, -0.1298636773592899, -0.10668635598705109, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1109069605847145, 0.11090872670516454, 0.11083738943324087, 0.10182485446717018, 0.5920804238756442, -1.832832832832833, 0.0, -Infinity, 0.5123298638911129], "score_NOT Basins_10D": 0.9994902731850743}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [-0.29041298439272895, 4.336735828718915], -2.077423592622754], [10, [-4.346109174679696, 3.7301965966297628], -3.483889415642311], [19, [4.311732255646668, 2.48653157726581], -3.1347726511771805], [52, [-1.795986496079627, -1.7770937705313121], -4.703323523594596]], "nr_of_basins": 4, "f_opt_dim_2": -4.703323798013792, "x_opt_dim_2": [-1.7959262529349989, -1.7768120562134369], "f_opt_dim_5": -3.1271625612724456, "x_opt_dim_5": [-0.1659986704110675, 3.7263379150647076, 0.5261477585898399, 2.987847031744704, -0.4890671454500972]}
{"id": "59fe23b0-091a-4d35-aa4f-d1f3c74efad4", "fitness": 0.5653771768168857, "name": "landscape_projection_gaussians", "description": "A non-separable projection-based multi-well landscape. The function places Gaussian wells along random directions in the input space. Each well has its own width and strength, and the total landscape is the sum (with a negative sign) of these directional Gaussians. The global minimum occurs at the origin, while the basins of attraction are irregular due to the different directions and scales, breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_projection_gaussians:\n    \"\"\"\n    Non-separable multi-well landscape built from projection-based Gaussian wells.\n\n    Definition:\n      f(x) = - sum_{k=1..K} w_k * exp( - (u_k^T x)^2 / (2 * s_k^2) )\n\n    Where:\n    - u_k: random unit vector in R^dim (direction of the k-th well)\n    - w_k: positive weight (depth/strength) of the k-th well\n    - s_k: width of the k-th well\n\n    Properties:\n    - Domain for x is [-5, 5]^dim (per-dimension)\n    - Global minimum is at x = 0 with value -sum_k w_k\n    - Basins of attraction vary due to differing directions (u_k) and widths (s_k),\n      producing non-homogeneous basin sizes.\n    \"\"\"\n    def __init__(self, dim=5, seed=0, K=None):\n        self.dim = dim\n        self.seed = seed\n        rng = np.random.default_rng(seed)\n\n        # Number of wells/features\n        if K is None:\n            K = max(6, min(24, dim * 3))\n        self.K = K\n\n        # Random projection directions (unit vectors)\n        self.u = rng.normal(size=(K, dim))\n        # Normalize rows to unit vectors\n        norms = np.linalg.norm(self.u, axis=1, keepdims=True)\n        norms[norms == 0] = 1.0\n        self.u = self.u / norms\n\n        # Well strengths (weights) - positive\n        self.w = rng.uniform(0.6, 2.4, size=(K,))\n\n        # Widths for each well\n        self.s = rng.uniform(0.4, 3.0, size=(K,))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        # Compute projection of x on each u_k\n        # dp shape: (K,)\n        dp = self.u @ x  # shape (K,)\n\n        # Gaussian wells along projections\n        # exponent_k = - (dp_k)^2 / (2 * s_k^2)\n        exponent = - (dp * dp) / (2.0 * (self.s * self.s))\n        vals = - self.w * np.exp(exponent)\n\n        return float(np.sum(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_projection_gaussians scored on:NOT Basins 0.695,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3f42baf5-a6a2-44a0-a8c9-eb4ab7d404a2"], "operator": null, "metadata": {"ela_features_2D": [-0.00311847989912728, 0.6990543307462977, 0.00898819586070479, 0.016159305980326576, 2.460713181714902, 0.001006742228909796, 0.5493581748374001, 1.9080809436094974, 0.7746823897578435, -1.2429850042842807, 1.2979609526079616, 1.6, 0.6939603409108258, 0.7193964688648892, 0.553327893105033, 0.3367727240916666, -0.21686336410265544, 0.14696453210046134, 0.24572801636707395, 0.3491973114582413, 0.5554426004527224, 0.14398339428730803, 0.2346040575569905, 0.33034232840122824, 0.5354094559185211, -0.44637776155180076, -0.39469619473524364, -0.3405531225493769, -0.23263174186041913, -0.43992560497118494, -0.39335689543790997, -0.3441601193123814, -0.23876719442762182, 1.0, 1.0, 1.0, 1.0, 0.5175370843392102, 0.517467810730035, 0.4202052871252209, 0.34971207901676005, 0.7059165018265564, 0.5575575575575573, 0.47510223476561003, -0.1631631631631631, 0.36144578313253006], "score_NOT Basins_2D": 0.997904333518818, "ela_features": [-0.0023318072929885856, 0.5897180773754489, 0.002989618494775659, 0.01762480633650444, 8.14461137828544, 0.15128286803873067, 0.5592039080686516, 3.282993632182263, 0.7921359401334251, -0.3661119228886714, 0.048000017177551604, 1.2, 0.8368042359583686, 0.8607155934320112, 0.6112920049965742, 0.19143787690882702, -0.4842298419396731, 0.5036184893288359, 0.6001115640418891, 0.6813701549041431, 0.7868862504550915, 0.48199170581589257, 0.581049519253498, 0.6629477353614142, 0.7741033727230727, -0.43657467010174306, -0.351703163632101, -0.2802369619396978, -0.18743382339722386, -0.4578226675039703, -0.37026410573310664, -0.2978851538232323, -0.19964231499091248, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21745049569143574, 0.21743068607067678, 0.20463538647239363, 0.18186237725972082, 0.8306087284621769, 0.1651651651651651, 0.24875328607674158, -0.41941941941941935, 0.5237179487179487], "score_NOT Basins_5D": 0.0030465126037597656, "ela_features_10D": [-0.0011529224976852604, 0.5038123095515559, 0.0006522384558715553, 0.01650036468123346, 67.24660139652502, 0.33404671768379846, 0.4240462136559787, 6.140118719141967, 0.7950833954283544, -0.1387189517368624, -0.018382450516116044, 1.2, 0.9274973319679883, 0.9288458901027145, 0.6611220657927495, 0.11157940221679985, -0.5773399301057198, 0.7352364687358619, 0.7879811224922626, 0.8295044303920196, 0.8842802393448098, 0.7252115804106977, 0.7792312576571236, 0.8234446160821702, 0.8807802931264119, -0.33581795751134835, -0.2689167537792246, -0.21624999945448709, -0.1467744646617596, -0.34948754541709814, -0.28077914570520457, -0.224546459898662, -0.15162542900365428, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11031588988204595, 0.11031150806784892, 0.10752287943418648, 0.1006887303195764, 0.852214681289273, -0.12312312312312305, 0.1272524857863349, -0.6876876876876875, 0.5843074459567654], "score_NOT Basins_10D": 0.6951806843280792}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[100, [-0.00018074492153397493, -0.0003855480408151441], -9.361693696876287]], "nr_of_basins": 1, "f_opt_dim_2": -9.361693910744126, "x_opt_dim_2": [-5.362167337460266e-09, -5.208507203096655e-09], "f_opt_dim_5": -27.910754236516716, "x_opt_dim_5": [-4.966764855918815e-08, 3.716410134943406e-08, 4.6128186015544665e-09, -7.847415131385514e-08, -3.9634994560133745e-08]}
{"id": "bcd864e6-76a2-4e25-9a40-df3e5a31e7ba", "fitness": 0.9988762416372386, "name": "landscape_min_of_quadratics", "description": "A piecewise-quadratic basin landscape constructed as the minimum across many anisotropic, offset wells. Each well is defined by a center, a positive-definite curvature matrix, and a negative depth, producing non-uniform basins with varied sizes and shapes. The global landscape is non-homogeneous because wells vary in width, depth, and orientation, and the overall function is the pointwise minimum across these wells.", "code": "import numpy as np\n\nclass landscape_min_of_quadratics:\n    \"\"\"\n    A novel non-homogeneous landscape built as the pointwise minimum of many\n    anisotropic quadratic wells.\n\n    f(x) = min_i { d_i + (x - c_i)^T P_i (x - c_i) }\n\n    - c_i: center of well i, drawn uniformly in [-5, 5]^dim\n    - P_i: SPD curvature matrix (positive definite), controlling basin width/shape\n    - d_i: negative depth for well i (negative value), controlling basin depth\n\n    The wells have varied widths, depths, and orientations (due to random SPD P_i),\n    which yields basins of highly varying sizes and non-homogeneous structure.\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the landscape in 'dim' dimensions.\n        The RNG seed is tied to the dimension to keep reproducibility across runs\n        with the same dimension.\n        \"\"\"\n        self.dim = int(dim)\n        self._rng = np.random.default_rng(self.dim)\n        # Number of wells grows with dimension to maintain complexity\n        self.n_peaks = max(20, int(6 * self.dim + 6))\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Centers within [-5, 5]^dim\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Positive-definite curvature matrices P_i (SPD)\n        # Construct by P_i = A_i^T A_i and scale to vary basin widths\n        Ps = []\n        for i in range(n):\n            A = self._rng.normal(size=(d, d))\n            Pi = A.T @ A  # SPD\n            scale = self._rng.uniform(0.5, 3.0)  # vary widths\n            Pi *= scale\n            Ps.append(Pi)\n        self.Ps = np.asarray(Ps)  # shape (n, d, d)\n\n        # Depths (negative) to create wells\n        # Draw from lognormal to get highly varying depths, then convert to negative\n        depth_vals = self._rng.lognormal(mean=-0.2, sigma=0.9, size=n)\n        self.depths = -(depth_vals * 3.0 + 0.2)  # more negative for deeper wells\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape.\n\n        - Accepts x as a 1-D array of shape (dim,) or as a 2-D array of shape (k, dim)\n        - Returns a scalar for a single input, or a 1-D array of length k for multiple inputs\n\n        f(x) = min_i [ d_i + (x - c_i)^T P_i (x - c_i) ]\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        k = x.shape[0]\n        f_vals = np.full(k, np.inf, dtype=float)\n\n        for i in range(self.n_peaks):\n            c = self.centers[i]      # (dim,)\n            P = self.Ps[i]            # (dim, dim)\n            d_i = self.depths[i]      # scalar\n\n            delta = x - c  # (k, dim)\n            # Quadratic form: (x - c)^T P (x - c) = sum_jk delta_j P_jk delta_k\n            quad = np.sum((delta @ P) * delta, axis=1)  # (k,)\n            val = d_i + quad\n            f_vals = np.minimum(f_vals, val)\n\n        if single:\n            return float(f_vals[0])\n        else:\n            return f_vals", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_min_of_quadratics scored on:NOT Basins 0.999,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e50ab499-e344-486e-aa66-03ad79ad3ab1"], "operator": null, "metadata": {"ela_features_2D": [0.3824070815435981, 0.2724801736058672, 0.20597668799507388, 0.37179833453659095, 1.8211302466777037, 0.4149914085629228, 0.4427827435651759, 2.5749205634636367, 0.5903421192336039, 0.011862465031082405, -0.05585163668828068, 2.2, 0.3171920677680969, 0.6420408367036916, 0.2746786266497082, 0.36076101826702367, -0.21100162573609804, 0.6369997097793512, 0.6304052415481258, 0.6575270882145664, 0.7379075414748504, 0.613783091091195, 0.570126096954496, 0.5876813472244216, 0.6592250564395007, -0.19000021372334525, -0.1934585429003631, -0.17925868306925913, -0.13718005451270895, -0.19876291777779131, -0.22113890038661999, -0.21213355076542414, -0.17534343756780696, 1.0, 1.0, 0.7333333333333333, 1.0, 0.5172323799280145, 0.5172230007106158, 0.4984805595685954, 0.5368250339709065, 0.7025475932213403, 0.6616616616616614, 0.4343578041871954, -0.047047047047047055, 0.4032128514056225], "score_NOT Basins_2D": 0.998296337784268, "ela_features": [0.06744569088052157, 0.4194333025199337, 0.006103086377031693, 0.10057988686981312, 170.36274559075488, 0.1692013814405397, 0.2582370469452163, 2.074427518100226, 0.4599036802912743, 1.0130261443780346, 1.1674956139867232, 1.6, 0.6313035347859512, 0.8264097552220486, 0.4853316539758713, 0.21698137163833947, -0.4502680851769484, 0.7801750223506583, 0.824164892338511, 0.8522565125454621, 0.8950621026415124, 0.7767819957976336, 0.8166667743413397, 0.8437867776967861, 0.887579770638028, -0.19335736496161454, -0.15466474066670038, -0.12995322488629077, -0.09230409339410559, -0.19736962578672318, -0.16210412767923682, -0.13811331605668678, -0.0993955811941137, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21488106311933705, 0.21483733114204023, 0.20466242490663, 0.2121152355782598, 0.8394349916677569, 0.2812812812812812, 0.25178141529501674, -0.3433433433433432, 0.5708333333333334], "score_NOT Basins_5D": 0.9994593356386758, "ela_features_10D": [0.09136463868676128, 0.26703395183881884, 0.004602167184041162, 0.12591217388582013, 62.52880574846979, 0.30433045670895337, 0.2288373027500988, 3.5468761086042706, 0.4976626831609298, 0.6283263783650815, 0.50011739052498, 1.8, 0.7656742411967693, 0.9080471212446166, 0.5575774649329024, 0.13119481414065728, -0.5039555706955205, 0.9224196381533366, 0.9295526883160402, 0.9359881921469478, 0.9422375812608882, 0.9333688968872839, 0.9354185393190215, 0.9379448041279279, 0.9421016045292643, -0.0983961652950303, -0.0893501244709523, -0.0811888462394029, -0.07326196308502202, -0.0847333419013296, -0.08212992404101409, -0.07891885512340768, -0.07363090074896395, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11093770370750877, 0.11093970393911697, 0.10871392103882035, 0.1200390558047564, 0.8615377248078552, -0.09509509509509509, 0.12312232326486017, -0.6716716716716714, 0.6070456365092074], "score_NOT Basins_10D": 0.998873051488772}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [-1.9254966810826375, -4.933978855792795], -2.9304557635142503], [37, [-1.0838879056697053, -3.127348308913191], -11.774371983636616], [8, [-2.249392018894664, 1.5767054508123661], -1.9383962729048039], [12, [-0.7719432525586217, 1.3316750643420854], -4.656736389307241], [24, [3.912287745574481, 2.755677837064957], -6.793938492758734], [1, [0.16601809186930533, 0.9339113426700805], -3.315662878372278], [2, [-1.5315635213924967, 0.11716828710633517], -2.094415854175052], [9, [3.623079700581742, -0.6179591742677801], -5.0138728820345415], [5, [-2.9445253713695365, 3.812768095689076], -1.7824782398693897]], "nr_of_basins": 9, "f_opt_dim_2": -11.774372020335443, "x_opt_dim_2": [-1.0837514049728665, -3.1274743448691487], "f_opt_dim_5": -12.92295695187577, "x_opt_dim_5": [2.1289026279862413, 3.476243781705809, -0.9877425241893444, 0.532500390152644, -0.2051224763420374]}
{"id": "308a62d5-0b2f-434a-8bc6-1b681ded0dac", "fitness": 0.6354885113735994, "name": "landscape_aniso_min", "description": "A non-homogeneous multi-basin landscape built as the minimum over anisotropic, non-quadratic wells. Each bowl is defined by a center, an orientation via a random SPD matrix, a depth, and a width; the distance metric is anisotropic (elliptical) and the radial term uses a higher-order exponent, creating irregular basin shapes and sizes. The global minimum lies at the deepest bowl's center, ensuring a clear optimum while preserving non-uniform basins across the domain.", "code": "import numpy as np\n\nclass landscape_aniso_min:\n    \"\"\"\n    Anisotropic, non-quadratic multi-basin landscape.\n\n    The function is:\n        f(x) = min_j [ d_j + r_j(x)^p / (2 * s_j^p) ]\n    where\n        r_j(x) = sqrt( (x - c_j)^T A_j (x - c_j) )  (elliptical distance with A_j SPD)\n        p = 4 (non-quadratic bowl shape)\n        c_j  : center of bowl j\n        A_j  : positive definite (anisotropic) distance metric for bowl j\n        d_j  : base depth (smaller -> deeper bowl)\n        s_j  : width parameter for bowl j\n\n    The global minimum is at the deepest bowl's center.\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = dim\n        self.seed = seed\n\n        rng = np.random.default_rng(seed)\n\n        # Number of bowls scales with dimension but stays modest\n        M = max(4, min(16, dim * 2))\n        self.M = M\n\n        # Centers in [-4, 4]^dim\n        self.c = rng.uniform(-4.0, 4.0, size=(M, dim))\n\n        # Widths (positive)\n        self.s = rng.uniform(0.4, 2.0, size=(M,))\n\n        # Depths ensuring a unique deepest bowl\n        depths = rng.uniform(-2.0, 1.0, size=(M,))\n        deepest_idx = rng.integers(0, M)\n        depths[deepest_idx] = -6.0  # deepest bowl at its center\n        self.d = depths\n\n        # Anisotropic distance matrices A_j (SPD)\n        A = np.zeros((M, dim, dim))\n        for j in range(M):\n            # Random rotation matrix Q (via QR)\n            B = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(B)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            # Eigenvalues for A_j in [0.5, 4.0]\n            vals = rng.uniform(0.5, 4.0, size=(dim,))\n            A_j = Q @ np.diag(vals) @ Q.T\n            A[j] = A_j\n        self.A = A\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        min_val = float('inf')\n        for j in range(self.M):\n            delta = x - self.c[j]                      # shape (dim,)\n            r2 = delta @ self.A[j] @ delta              # scalar: (x - c_j)^T A_j (x - c_j)\n            r4 = r2 * r2                                 # non-quadratic\n            val = self.d[j] + r4 / (2.0 * (self.s[j] ** 4))\n            if val < min_val:\n                min_val = val\n        return float(min_val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_aniso_min scored on:NOT Basins 0.987,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3f42baf5-a6a2-44a0-a8c9-eb4ab7d404a2"], "operator": null, "metadata": {"ela_features_2D": [0.2431503657144069, 0.0737561013625285, 0.15878834383610513, 0.16526705783492113, 1.040210100652566, 0.5909911554386407, 0.39108609567034297, 2.480614196310368, 0.9192615861621937, 3.552522158843524, 15.409954832343294, 3.8, 0.4372873575935682, 0.6808983473656993, 0.3568373495961793, 0.35059156100000316, -0.1128639556934031, 0.13634669063771995, 0.2375699486449371, 0.44359459445758825, 0.8613776890408891, 0.13243247976616238, 0.2295735036089857, 0.3509327566397425, 0.8862764999426676, -0.4519345142165678, -0.3989704931254015, -0.291161810306184, -0.07253994403332344, -0.44627552703610834, -0.39632454105633613, -0.33390420891593137, -0.05851074947730078, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5150683402793653, 0.5150625353382772, 0.48742128367571136, 0.5019791765787373, 0.6017570857123851, 0.4814814814814813, 0.045813522144156106, -0.9079079079079078, 0.37751004016064255], "score_NOT Basins_2D": 0.037225961685180664, "ela_features": [0.3726889082658983, 0.1519783142412066, 0.007732718601146456, 0.21381241368917675, 62.60198089184695, 0.5805978779832847, 0.5621472788076376, 2.6577936128434057, 0.8685553406710713, 2.1558672715116174, 6.069014303768848, 3.6, 0.7617453519712843, 0.855012279302205, 0.5561634559662567, 0.19620047987084605, -0.29095394219211224, 0.7714881210947754, 0.8164332852219219, 0.8330351475955219, 0.8539585562284466, 0.8220695840809065, 0.8354206293489057, 0.8286576630496025, 0.8399018678279024, -0.20101288567789247, -0.16147769974659884, -0.14687411690266577, -0.12846723993211973, -0.15729436373978706, -0.14550556805404122, -0.15148887455157944, -0.14154671195893503, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21688766016735217, 0.21691019818448418, 0.21658927022417546, 0.27058573838545075, 0.7357898537746237, 0.1731731731731731, 0.06793523819312991, -0.7797797797797795, 0.5051282051282051], "score_NOT Basins_5D": 0.882495827972889, "ela_features_10D": [0.1883195139903089, 0.3118153041736117, 0.0033263974317953074, 0.09466987030783772, 77.10997207477484, 0.5181454953394244, 0.4562159624092315, 2.178770323714147, 0.8265398901260157, 1.4639202471192854, 3.3986639541598196, 4.2, 0.8980950166848602, 0.9258976871194562, 0.6399123426280978, 0.11529303608723022, -0.42764770726507306, 0.8636041153454019, 0.8672975304265851, 0.8785898103895422, 0.9060052661546972, 0.8729032336562199, 0.870173311320001, 0.8764479877225098, 0.9030068495394662, -0.17299084516319724, -0.1683050921828316, -0.15398478859696163, -0.11921437479583052, -0.1616395392188235, -0.1651072884267208, -0.15713203038288043, -0.12335624668635692, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10961403176803682, 0.10961759914338609, 0.10782801076343151, 0.13000586343684206, 0.8323486115472221, -0.1831831831831831, 0.07329477254331937, -0.8678678678678675, 0.5716573258606885], "score_NOT Basins_10D": 0.9867437444627285}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[10, [0.5555555555555554, 1.666666666666667], -0.2446505797260985], [26, [2.506022638615569, 3.301886826964833], 0.18896633928983306], [35, [1.095369507701201, -1.8414732851365967], -5.999999999999987], [29, [-3.6721461297599856, -3.867428062867636], -1.899243274083601]], "nr_of_basins": 4, "f_opt_dim_2": -6.0, "x_opt_dim_2": [1.095698678470224, -1.841643463828795], "f_opt_dim_5": -1.7277408631426343, "x_opt_dim_5": [2.526884562506487, -3.9780067044468197, 2.8592911887373758, -3.73148742232362, 1.8372469453032958]}
{"id": "fe68083c-6bd7-48db-bfe2-5023dc46d938", "fitness": 0.988968727683338, "name": "landscape_nh_elliptical_min", "description": "A non-homogeneous basin landscape built as the pointwise minimum of multiple anisotropic Gaussian wells. Each well has a random center in [-5,5]^dim, a random positive-definite, rotated covariance (elliptical well), and a negative depth. The wells exhibit diverse orientations and scales, producing basins of highly varying sizes (non-homogeneous), while the global minimum remains at the deepest well. This improves basin-size heterogeneity compared to isotropic wells.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_min:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple anisotropic Gaussian-like wells.\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a random SPD matrix A_i = Q_i * diag(lambda) * Q_i^T (elliptical, rotated)\n      - depth weight w_i < 0 (negative, making wells minima)\n    The landscape f(x) = min_i w_i * exp(-0.5 * (x - c_i)^T A_i (x - c_i))\n    This creates basins of widely varying sizes and shapes (non-homogeneous).\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure richer basins\n        self.N = max(4, min(64, 4 * dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Negative amplitudes (well depths) for each Gaussian\n        self.weights = -rng.uniform(low=0.5, high=4.0, size=self.N)\n\n        # Elliptical (anisotropic) Gaussian shapes per well\n        # Each A_i = Q_i * diag(lambda_i) * Q_i^T, with Q_i ~ random orthogonal\n        self.As = []\n        for _ in range(self.N):\n            # Random 2D/3D/.. rotation matrix\n            M = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(M)\n            # Ensure a proper rotation with determinant +1\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues (controls widths along principal axes)\n            # Wide variety to create basins of different sizes\n            lam = rng.uniform(low=0.5, high=12.0, size=dim)\n\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.As.append(A_i)\n\n        self.As = np.stack(self.As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        # Evaluate all wells and take the minimum\n        vals = []\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            # d2 = (x - c_i)^T A_i (x - c_i)\n            d2 = delta @ self.As[i] @ delta\n            v = self.weights[i] * np.exp(-0.5 * d2)\n            vals.append(v)\n\n        return float(np.min(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nh_elliptical_min scored on:NOT Basins 0.974,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["cbef6f03-77eb-4ab4-ad01-c561c65f604e"], "operator": null, "metadata": {"ela_features_2D": [0.12873036049943865, 1.0508191510750755, 0.05416943458992143, 0.2344649043624243, 7.259925719715301, 0.15276279788114108, 0.16176899569615427, 1.6978640206433067, 0.19868256328421344, -2.5998759193981775, 6.452050043279594, 2.2, 0.26744514288316473, 0.5733057711230897, 0.1801130015087756, 0.4051608575197444, -0.23753440849865304, 0.7358767903722157, 0.7345516376210405, 0.7504364278571678, 0.8387966393970545, 0.900136703862114, 0.8452115570572356, 0.7944557089540241, 0.8679726578813666, -0.13825436535395533, -0.1389462152322339, -0.1306327560650228, -0.08436841013721964, -0.05135564752365407, -0.07963207417159118, -0.10578385313527114, -0.06792070297223608, 1.0, 1.0, 1.0, 1.0, 0.5214578796458434, 0.5213625102400727, 0.4560049522164271, 0.45452595990784017, 0.49393905438703556, 1.0980980980980977, 0.016772538850653374, -0.6236236236236234, 0.3678714859437751], "score_NOT Basins_2D": 0.9986759905004874, "ela_features": [0.0017511753741541903, 1.0011006060201353, 0.0005892686889311112, 0.006273105858932748, 24.44983879561265, 0.002561012384029637, 0.00422807596656396, 28.816747644315296, 0.013086588377951024, -26.57970279785757, 763.5548230468336, 3.4, 0.501179734362174, 0.675813000660135, 0.2547324929115903, 0.30831794175682453, -0.1084033084506868, 0.940276105729183, 0.9418332613007461, 0.947689092110948, 0.9360204138656192, 0.9642853950166621, 0.9647782232036975, 0.9636368009446752, 0.9432892089541296, -0.052540454493963204, -0.051171913456679395, -0.04601984657893112, -0.056285581916147166, -0.03158008691187342, -0.031146351336773237, -0.03215489681581134, -0.050157713206094454, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21270189661492597, 0.21271161440251124, 0.21205560493956988, 0.18092107655901135, 0.4987296575746292, -1.3683683683683687, 0.0, -Infinity, 0.3092948717948718], "score_NOT Basins_5D": 0.9937747148796916, "ela_features_10D": [5.247721575507569e-07, 0.998223003050404, 0.00032257725002194645, 0.0021326009784160245, 29.558260004435898, -0.0006850241932992551, -0.0006807378119545904, 34.63200933210036, -0.012726392919094187, -49.76105090420431, 2480.2631559603637, 1.2, 0.5247892047948075, 0.6011615395977727, 0.2532061495681715, 0.2191475165759329, -0.08871849818914215, 0.990004347612555, 1.0, 1.0, 1.0, 0.990217554141856, 1.0, 1.0, 1.0, -0.012674505843231465, 0.0, 0.0, 0.0, -0.012433260690261072, 0.0, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11080583365047576, 0.11080487805223802, 0.11075271329693362, 0.10103741290674646, 0.10352286462090717, -5.000000000000001, 0.0, -Infinity, 0.02922337870296237], "score_NOT Basins_10D": 0.9744554776698351}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[8, [-0.5898331436733814, 1.0988116669637966], -2.8929108667323633], [3, [4.635412192860704, -2.337163799332899], -0.7091516694927971], [9, [-1.807328546856064, -3.8191663415135713], -1.1022229048534073], [25, [4.561170127545899, -1.2622627718539632], -3.026932714334677], [15, [-2.5825617006043493, -1.8147872523992998], -3.5464518257799806], [16, [1.7483750834179879, 1.5982737144394668], -2.6385623791925323], [24, [3.5483856102283284, 3.6705928696583645], -2.8388766430012127]], "nr_of_basins": 7, "f_opt_dim_2": -2.892911181801037, "x_opt_dim_2": [-0.5899387802936094, 1.0987080959173228], "f_opt_dim_5": -1.6047949177287697, "x_opt_dim_5": [-0.5112639972164964, -1.2949157006759298, -0.17330563019322626, -4.078184534997467, -2.7331689500608864]}
{"id": "ef5b7019-7e4f-4a40-b795-f98cd0125d67", "fitness": 0.9213807895139325, "name": "landscape_nonhomogeneous", "description": "A novel non-homogeneous multi-basin landscape using anisotropic ellipsoidal basins. Each basin j is a positive-definite quadratic form centered at c_j with its own orientation and scales (via A_j). The function is f(x) = min_j [ d_j + (x - c_j)^T A_j (x - c_j) ]. By using distinct rotations and axis scales for each basin, basin sizes and shapes vary in all directions, breaking basin-size homogeneity. The global minimum lies at the deepest bowl\u2019s center.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous:\n    \"\"\"\n    Novel multi-basin non-homogeneous landscape.\n    f(x) = min_j ( d_j + (x - c_j)^T A_j (x - c_j) )\n    - c_j: center of j-th elliptical basin (dimension dim)\n    - A_j: positive-definite matrix defining anisotropic basin shape\n    - d_j: base depth (smaller -> deeper basin)\n    The global minimum is at the deepest basin's center.\n    Domain: x in [-5, 5]^dim\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = dim\n        self.seed = seed\n\n        rng = np.random.default_rng(seed)\n\n        # Number of basins (balanced with dimension; ensure enough variety)\n        M = max(4, min(20, dim * 3))\n        self.M = M\n\n        # Centers c_j within [-4, 4]^dim\n        self.c = rng.uniform(-4.0, 4.0, size=(M, dim))\n\n        # Ellipsoidal basin shapes A_j (random rotations + axis scales)\n        self.A = np.empty((M, dim, dim), dtype=float)\n        for j in range(M):\n            # Random rotation matrix (via QR decomposition)\n            Q, _ = np.linalg.qr(rng.normal(size=(dim, dim)))\n            # Random axis scales (positive)\n            scales = rng.uniform(0.15, 2.5, size=(dim,))\n            # Build A_j = Q * diag(1/scale^2) * Q^T\n            D = np.diag(1.0 / (scales * scales))\n            A_j = Q @ D @ Q.T\n            self.A[j] = A_j\n\n        # Depths d_j; ensure a unique deepest basin\n        depths = rng.uniform(-4.0, 0.0, size=(M,))\n        deepest_idx = rng.integers(0, M)\n        depths[deepest_idx] = -10.0  # deepest basin\n        self.d = depths\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        # Compute min_j [ d_j + (x - c_j)^T A_j (x - c_j) ]\n        vals = np.empty(self.M, dtype=float)\n        for j in range(self.M):\n            delta = x - self.c[j]\n            vals[j] = self.d[j] + delta @ self.A[j] @ delta\n        return float(np.min(vals))", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_nonhomogeneous scored on:NOT Basins 0.999,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3f42baf5-a6a2-44a0-a8c9-eb4ab7d404a2"], "operator": null, "metadata": {"ela_features_2D": [0.1696495528055823, 0.5033569736166801, 0.06949994226028554, 0.24208916525113855, 3.8084013113048343, 0.20957511653604083, 0.6149244871349111, 6.189056505651367, 0.8684417296181721, 0.6254676991618494, 1.3039888975692575, 2.0, 0.4336501840753793, 0.68120128042963, 0.35499681262906646, 0.35306182104551204, -0.15959962692023907, 0.1507229243786667, 0.23349824216550713, 0.336675477924392, 0.6439325758664338, 0.1510539283409325, 0.22482285816753497, 0.32895986273337197, 0.5834083130702397, -0.44418190093422716, -0.4008982370411391, -0.3469304206663978, -0.1862322042792764, -0.43627147892743795, -0.39837920452363945, -0.34484201278844806, -0.21406811355895144, 1.0, 1.0, 1.0, 1.0, 0.5157729672194442, 0.5157538076702444, 0.4630403951323361, 0.47239212974243916, 0.6896552543103482, 0.4574574574574573, 0.26404975945161857, -0.41141141141141124, 0.3883534136546185], "score_NOT Basins_2D": 0.7654748558998108, "ela_features": [0.08762359572144254, 0.47626192841553056, 0.018366464579616576, 0.12400597404508537, 8.895195593101478, 0.2000399424331892, 0.3148335062019448, 3.2301023906808615, 0.5058670238337474, 0.932025039741777, 1.2808534152093125, 1.6, 0.7127231794367557, 0.8446173303276332, 0.5253884636899445, 0.2034293011555413, -0.43317396525393403, 0.5899538665967821, 0.7895901380887628, 0.8595222718524527, 0.8943190968539815, 0.5595209713207823, 0.7692761671088427, 0.8612183683359793, 0.8938913776015104, -0.3607055878469621, -0.1850927007413582, -0.12357541492484299, -0.09296550589216201, -0.3896788919046785, -0.20411233128839426, -0.12276922035139523, -0.09386677976543038, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21768276317027113, 0.21768964324781406, 0.20902297765968333, 0.21888056188812893, 0.8293123410151721, 0.21721721721721715, 0.20185234922648587, -0.4354354354354353, 0.5346153846153846], "score_NOT Basins_5D": 0.9996292495343369, "ela_features_10D": [0.274039509320439, 0.36803055436832344, 0.0065553153799010905, 0.1730940983970926, 38.2353856165319, 0.40632994519887944, 0.5002704490105342, 1.9736137543102852, 0.6653049311522061, 0.7269732891320251, 0.9074318078755766, 1.8, 0.8567753109615378, 0.9196844722905972, 0.6114815982812443, 0.12044342896736855, -0.4896930885581618, 0.7946801752213328, 0.8403208142165781, 0.865624357988521, 0.9014618426653633, 0.7927620850305088, 0.837417873948116, 0.8633230151025847, 0.9001132038970961, -0.260405321337805, -0.2025203968939457, -0.17042755755457045, -0.12497515107415955, -0.26352473876426397, -0.2067423211570325, -0.17380005263356407, -0.1270170622714783, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1098121276297016, 0.10980394681290953, 0.10925963603300101, 0.13870407386516692, 0.8533987217487043, -0.1311311311311311, 0.10720835323004799, -0.7357357357357355, 0.5882305844675741], "score_NOT Basins_10D": 0.99903826310765}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[14, [-3.6722563520419564, -3.8670002842543036], -0.6694231932190138], [30, [1.095863852347379, -1.8422576822390273], -3.6639384645110042], [47, [0.3477925358278096, 3.4824029144419395], -9.999997809966532], [9, [2.539919686879342, -3.9631119441345706], -3.7651415897830844]], "nr_of_basins": 4, "f_opt_dim_2": -10.0, "x_opt_dim_2": [0.3489999163097156, 3.4805793784492525], "f_opt_dim_5": -10.0, "x_opt_dim_5": [1.0328652005127938, 3.417236418946628, -0.47698274846924915, 3.6367239590374485, -0.0008334953579185324]}
{"id": "2d686a8f-c705-4ae7-a28d-e21edd003ebd", "fitness": 0.9954826044850051, "name": "landscape_ellipsoid_sum", "description": "A non-homogeneous landscape built from anisotropic ellipsoidal wells (compact-support bumps). Each well has a center, per-dimension axis scales (elliptical radii), and a heavy-tailed depth weight. The wells contribute only inside their ellipsoidal support, and the sum of many differently shaped wells yields basins of varying sizes and depths, providing a non-homogeneous search space for minimization.", "code": "import numpy as np\n\nclass landscape_ellipsoid_sum:\n    \"\"\"\n    A novel irregular landscape built from a sum of anisotropic ellipsoidal wells.\n    Each well i is defined by:\n      - center c_i in R^dim\n      - per-dimension scales s_i > 0 (defines the ellipsoidal shape)\n      - depth weight w_i > 0 (how deep the basin is)\n    Contribution of well i at point x is:\n      contrib_i(x) = -w_i * max(0, 1 - d2_i(x))\n    where d2_i(x) = sum_j ((x_j - c_i_j) / s_i_j)^2\n    The overall landscape is f(x) = sum_i contrib_i(x).\n    Domain is [-5, 5]^dim; f(x) <= 0 everywhere (global optimum <= 0).\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the irregular landscape in 'dim' dimensions.\n        The number of ellipsoidal wells scales with dimension to keep\n        the landscape challenging.\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed from dimension for reproducibility\n        seed = (self.dim * 131) ^ 0x9e3779b9\n        self._rng = np.random.default_rng(seed)\n\n        # Number of ellipsoidal wells; ensure sufficient complexity for larger dims\n        self.n_peaks = max(25, int(6 * self.dim + 12))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Centers within [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Per-well axis scales (ellipsoid radii) per dimension, positive values\n        # Range chosen to create diverse basin shapes (anisotropy)\n        self.scales = self._rng.uniform(0.3, 3.0, size=(n, d))\n\n        # Depth weights with heavy-tailed distribution to create wide-ranging basin depths\n        self.weights = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n\n        # Cache for speed during evaluation\n        self._centers = self.centers\n        self._scales = self.scales\n        self._weights = self.weights\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i -w_i * max(0, 1 - d2_i(x))\n        where d2_i(x) = sum_j ((x_j - c_i_j) / s_i_j)^2\n        Returns scalar for 1D input, or 1D array for batched inputs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        total = np.zeros(x.shape[0], dtype=float)\n\n        for i in range(self.n_peaks):\n            c = self._centers[i]\n            s = self._scales[i]\n            w = self._weights[i]\n            diff = x - c  # shape (k, d)\n            d2 = np.sum((diff / s) ** 2, axis=1)\n            contrib = -w * np.maximum(0.0, 1.0 - d2)\n            total += contrib\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape_ellipsoid_sum scored on:NOT Basins 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["e50ab499-e344-486e-aa66-03ad79ad3ab1"], "operator": null, "metadata": {"ela_features_2D": [0.10310949339532187, 0.9942671561574512, 0.12369943680470956, 0.15884180447756663, 1.2832211277832208, 0.12470854551957888, 0.2858968312226386, 1.1766448674287973, 0.35691241311835487, -1.9222677594319815, 3.8879073133723265, 2.6, 0.30526550270875885, 0.5518026653529089, 0.2232106348937533, 0.4362537706417296, -0.21349937217713794, 0.6125823110882671, 0.6350063094313028, 0.626360370400888, 0.6605736793299718, 0.7315623558990304, 0.7554030244974254, 0.6924426603104041, 0.6457496925433915, -0.20263234275159733, -0.19089749654285434, -0.1954217004358012, -0.17752576743493642, -0.13767810917175052, -0.1255031095798152, -0.15781420248518924, -0.18177336579164585, 1.0, 1.0, 1.0, 1.0, 0.5235653252517161, 0.523558543784549, 0.45502332944308826, 0.4446566564157715, 0.6842579762770111, 1.0060060060060056, 0.2638009319398403, -0.14314314314314308, 0.39076305220883534], "score_NOT Basins_2D": 0.9915951658040285, "ela_features": [0.0010991715855770412, 0.995156049647511, 0.001062406640790362, 0.007059408789046487, 9.740263470835131, -0.0016696183934101106, 0.003050396601718819, 8.165703210660856, 0.005674793492428454, -20.31151960135255, 472.9121766178194, 5.0, 0.3028715947430526, 0.3692490529768123, 0.1602849359286815, 0.41845951766561795, -0.4886263748921585, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21395252257156167, 0.2139567711783552, 0.21314255790493494, 0.18036645239154497, 0.09171366579030012, -0.5635635635635635, 0.01519419336011528, -0.7717717717717717, 0.02419871794871795], "score_NOT Basins_5D": 0.997436153003946, "ela_features_10D": [0.000248970597457876, 0.9863946853356895, 0.0008592698209883848, 0.008500711396155134, 9.892947696425665, -0.002301267587194289, 0.0017671575263561445, 2.347832311950446, 0.013004820710194931, -15.544020700413544, 255.60859523730028, 6.0, 0.31049075632483425, 0.39220549254111853, 0.20655282569752226, 0.40278283616392835, -0.48419870078231464, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2164334421485589, 0.21643150924216434, 0.2150470604987401, 0.18150351870188253, 0.10897897312163626, -0.0750750750750751, 0.021053290950295196, -0.6156156156156155, 0.030288461538461542], "score_NOT Basins_10D": 0.997416494647041}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-1.6666666666666665, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [1.666666666666667, -5.0], 0.0], [1, [2.7777777777777786, -5.0], 0.0], [1, [3.8888888888888893, -5.0], 0.0], [1, [5.0, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [1.666666666666667, -3.888888888888889], 0.0], [1, [2.7777777777777786, -3.888888888888889], 0.0], [1, [-5.0, -2.7777777777777777], 0.0], [1, [-3.888888888888889, -2.7777777777777777], 0.0], [1, [-5.0, -1.6666666666666665], 0.0], [1, [-5.0, -0.5555555555555554], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-2.7777777777777777, 3.8888888888888893], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [1, [-2.7777777777777777, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [5.0, 5.0], 0.0], [2, [-3.888888888888889, -1.016666666666666], -0.2720191488770072], [3, [-2.7777777777777777, -0.9975555555555558], -4.09953459215912], [8, [2.51666666666661, 4.656888888888805], -7.600039543233892], [3, [-2.8606220151665, -4.06945255191462], -0.21678559392535887], [6, [-1.9042025312149393, 0.7327157500477837], -10.669800248682604], [2, [-1.5544533068879667, 3.413095684626004], -0.919306455932361], [5, [-3.684898326485069, 1.7636435599468374], -0.31958777756827206], [1, [-0.9217574951347014, 0.03941647054918378], -2.385853151004457], [3, [0.3381864400765499, -1.89771113848157], -1.771405327777214], [7, [3.8341933550632157, 0.04550609790073732], -3.8484070639095767], [3, [0.5320181250425837, 2.9805724164274063], -1.4206343474191705], [2, [0.9047723773723382, 1.4654584679091738], -4.040779612787441], [2, [4.212342133015946, 3.3738960031532614], -0.9784579733410789], [3, [1.8658568384143386, 0.7493437433365783], -7.07220141452129], [1, [4.279396837279142, 1.678780643709515], -0.8377210851370589], [7, [2.0808323968315676, -0.17139820799567995], -8.735771447529944], [3, [-0.7941226418184252, -0.7175854902791337], -2.3285080079726486], [6, [4.357467334502734, -2.3931633409165607], -1.1479024212942035], [5, [-0.5348437985691868, -3.209955090002584], -1.6784817806000032]], "nr_of_basins": 47, "f_opt_dim_2": -8.9001793599399, "x_opt_dim_2": [2.1059866288933784, 0.0130632099857417], "f_opt_dim_5": -1.3533147624472848, "x_opt_dim_5": [-0.10120025971781166, -0.018088930542532203, 0.09443885719798573, 3.3752021016594203, -0.5529389333288078]}
{"id": "3d58d9cc-66ac-4242-b61d-80837608f749", "fitness": 0.8923323179284731, "name": "landscape", "description": "A separable, per-dimension multi-well landscape using irregular Gaussian wells of varying depth and width. Each dimension hosts its own set of wells, resulting in non-homogeneous basin sizes across dimensions. The global minimum arises from the combination of deep wells across all dimensions, typically located at the origin when a deep well is placed there. This creates a rugged, non-uniform landscape without reusing a min-of-quadratics structure.", "code": "import numpy as np\n\nclass landscape:\n    \"\"\"\n    Non-homogeneous, separable multi-well landscape using per-dimension irregular Gaussian wells.\n    Each dimension i has Ki wells with centers c_i_j, depths A_i_j and widths s_i_j.\n    f(x) = sum_i [ - sum_j A_i_j * exp(-0.5 * (x_i - c_i_j)^2 / s_i_j^2) ]\n    The wells vary in depth and width across dimensions, yielding irregular basin sizes.\n    A deep well is placed at the origin in every dimension to encourage a global minimum near x = 0.\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        self.wells = []  # per-dimension wells: dict with 'c','A','s'\n        self.Ks = []     # number of wells per dimension (for reference)\n\n        for i in range(self.dim):\n            Ki = rng.integers(3, 5)  # 3-4 wells per dimension\n            c = rng.uniform(-4.0, 4.0, size=(Ki,))\n            A = rng.uniform(0.6, 2.5, size=(Ki,))\n            s = rng.uniform(0.4, 1.8, size=(Ki,))\n\n            # Force a deep well at the origin for global minimum shaping\n            c[0] = 0.0\n            A[0] = rng.uniform(3.0, 6.0)\n            s[0] = rng.uniform(0.25, 0.9)\n\n            self.Ks.append(Ki)\n            self.wells.append({'c': c, 'A': A, 's': s})\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        val = 0.0\n        for i in range(self.dim):\n            ci = self.wells[i]['c']      # centers for dimension i\n            Ai = self.wells[i]['A']       # depths for dimension i\n            si = self.wells[i]['s']       # widths for dimension i\n\n            dx = x[i] - ci               # shape (Ki,)\n            dist2 = dx * dx               # (Ki,)\n            term = Ai * np.exp(-0.5 * dist2 / (si * si))\n            val -= np.sum(term)\n\n        return float(val)", "configspace": "", "generation": 1, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.810,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3f42baf5-a6a2-44a0-a8c9-eb4ab7d404a2"], "operator": null, "metadata": {"ela_features_2D": [0.022444893134826515, 0.6019001193672687, 0.06752800042859237, 0.1072852046966745, 1.6454602111646577, 0.021416389857228, 0.4870264090727857, 5.8706770713446454, 0.49995434781470827, -1.1157497519306083, 0.350489099969844, 2.0, 0.49691785348179973, 0.7048347973736934, 0.41535484679226614, 0.3319115798086111, -0.23478975365566926, 0.40846328647471386, 0.5435521574510533, 0.6104511157604114, 0.6765574659058937, 0.4083798491646258, 0.49430042713605404, 0.5511044788009578, 0.6171629225975472, -0.3094824255233788, -0.23880233465038136, -0.20380396098114012, -0.1692189376803498, -0.30382499670353047, -0.2596929887499807, -0.23053680480020516, -0.1966124593388096, 1.0, 1.0, 1.0, 1.0, 0.5155727804673326, 0.5155591973493429, 0.39956756113149516, 0.3835921518905035, 0.690603736298577, 0.7137137137137135, 0.4378881343003561, -0.07907907907907907, 0.38353413654618473], "score_NOT Basins_2D": 0.95945955067873, "ela_features": [0.04456842367919596, 0.5145009077404186, 0.009529479331545493, 0.1023376253602779, 141.4334028675661, 0.04122668143515344, 0.5170506704641065, 6.077246440919454, 0.54200078578999, -0.586296316105406, 0.0503998572937828, 1.4, 0.696650388321188, 0.8319297622976443, 0.5060632514375331, 0.21365523880061676, -0.5254872733004614, 0.6539685717272842, 0.7024673082451065, 0.7478322184843298, 0.8240302678488135, 0.6360027561633512, 0.6919421895239974, 0.7375247545639037, 0.8172535397109744, -0.3043655777519928, -0.2617075170145742, -0.22180514670207682, -0.1547825939278495, -0.3218279654688366, -0.27237230683899377, -0.23206801852421596, -0.1615771889580466, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2143863776935045, 0.21437716042153587, 0.2009083586388453, 0.20401490085570168, 0.8434384713979632, 0.3533533533533532, 0.29764301305445856, -0.28328328328328317, 0.5762820512820512], "score_NOT Basins_5D": 0.9080369025468826, "ela_features_10D": [0.076870300234042, 0.6592599837700759, 0.007266907685694357, 0.0834709942703081, 22.077969219000984, 0.07731784817746352, 0.5450128184065468, 11.429147002220024, 0.5701910605299565, -0.37729310794708065, 0.025548456886386274, 1.8, 0.8541193991594449, 0.9137069329142538, 0.6008709712290164, 0.1254317430193504, -0.6163024928614618, 0.759929164084322, 0.7986531588015648, 0.8308168905179603, 0.8769651808922128, 0.7580846440215352, 0.7971530669191329, 0.8293859753101405, 0.8767231304239255, -0.30448190199064257, -0.25536839040015846, -0.2145753897564012, -0.1560452052779664, -0.3076258047855401, -0.25794695647967925, -0.21695890995378844, -0.1567630550552052, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.10964189644640195, 0.10964286205326623, 0.10746938909277129, 0.11764082203370867, 0.8585576254581448, -0.031031031031031036, 0.14901252496321368, -0.6036036036036034, 0.62257806244996], "score_NOT Basins_10D": 0.8095005005598068}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[30, [2.4180000079147335, -0.018868835527005134], -9.678098655656932], [40, [0.057333333333334985, -0.018888888889095012], -11.726808909402658], [30, [-3.8568888888888924, -0.018888888889095012], -11.761198081607318]], "nr_of_basins": 3, "f_opt_dim_2": -11.761198777323676, "x_opt_dim_2": [-3.8565740040498797, -0.018795140318541532], "f_opt_dim_5": -29.026459743526456, "x_opt_dim_5": [-3.856574006972844, -0.018795145223351795, -0.015823823059966075, 0.08930681403618558, -0.04105548861936607]}
{"id": "842b4488-9c19-4cfb-acdb-8cb1a052cb8a", "fitness": 0.98748777488557, "name": "landscape_ellipsoid_sum_nonhomogeneous", "description": "A highly non-homogeneous landscape built from rotated, anisotropic ellipsoidal wells with heavy-tailed depths. Each well has its own center, a random rotation, per-dimension axis scales, and a depth weight. The well is defined by a positive-definite quadratic form, and contributions are compactly supported inside d2_i(x) <= 1. The sum of many differently shaped wells yields basins of highly varying sizes and shapes, breaking basin-size homogeneity and providing a challenging minimization landscape in [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_ellipsoid_sum_nonhomogeneous:\n    \"\"\"\n    A non-homogeneous landscape built from rotated, anisotropic ellipsoidal wells.\n    Each well i is defined by:\n      - center c_i in R^dim\n      - a random rotation R_i (orthogonal matrix)\n      - per-dimension axis scales s_i > 0 (defines the ellipsoidal radii)\n      - depth weight w_i > 0 (depth of the basin)\n    The quadratic form is A_i = R_i^T diag(1/s_i^2) R_i, and the\n    squared distance is d2_i(x) = (x - c_i)^T A_i (x - c_i).\n    Contribution of well i at point x is:\n      contrib_i(x) = -w_i * max(0, 1 - d2_i(x))\n    The overall landscape is f(x) = sum_i contrib_i(x).\n    Domain is [-5, 5]^dim; f(x) <= 0 everywhere (global optimum <= 0).\n    \"\"\"\n\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the irregular landscape in 'dim' dimensions.\n        The number of ellipsoidal wells scales with dimension to keep the\n        landscape challenging.\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed from dimension for reproducibility\n        seed = (self.dim * 131) ^ 0x9e3779b9\n        self._rng = np.random.default_rng(seed)\n\n        # Number of wells; ensure ample diversity across dimensions\n        self.n_peaks = max(25, int(6 * self.dim + 20))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Centers within [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Per-well axis scales (ellipsoid radii) per dimension, positive values\n        # Wide range to create strong anisotropy and varying basin shapes\n        self.scales = self._rng.uniform(0.25, 4.0, size=(n, d))\n\n        # Random rotations (orthogonal matrices) per well\n        self.rotations = np.empty((n, d, d))\n        for i in range(n):\n            M = self._rng.normal(size=(d, d))\n            Q, R = np.linalg.qr(M)\n            # Ensure a proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, -1] *= -1\n            self.rotations[i] = Q\n\n        # Depth weights with heavy-tailed distribution to create wide-ranging basin depths\n        self.weights = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n\n        # Precompute A_i matrices for each well:\n        # A_i = R_i^T diag(1 / s_i^2) R_i\n        self._As = np.empty((n, d, d))\n        for i in range(n):\n            s = self.scales[i]\n            diag_inv = np.diag(1.0 / (s * s))\n            self._As[i] = self.rotations[i].T @ diag_inv @ self.rotations[i]\n\n        # Cache for speed during evaluation\n        self._centers = self.centers\n        self._As = self._As\n        self._weights = self.weights\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i -w_i * max(0, 1 - d2_i(x))\n        where d2_i(x) = (x - c_i)^T A_i (x - c_i)\n        Returns scalar for 1D input, or 1D array for batched inputs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        total = np.zeros(x.shape[0], dtype=float)\n\n        for i in range(self.n_peaks):\n            c = self._centers[i]\n            A = self._As[i]\n            w = self._weights[i]\n\n            diff = x - c  # shape (k, d)\n            # d2 = (diff) @ A @ (diff)^T, computed efficiently:\n            # (diff @ A) has shape (k, d); then elementwise multiply with diff and sum over d\n            tmp = diff @ A  # shape (k, d)\n            d2 = np.sum(tmp * diff, axis=1)  # shape (k,)\n\n            contrib = -w * np.maximum(0.0, 1.0 - d2)\n            total += contrib\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_ellipsoid_sum_nonhomogeneous scored on:NOT Basins 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["2d686a8f-c705-4ae7-a28d-e21edd003ebd"], "operator": null, "metadata": {"ela_features_2D": [0.2218609507197912, 1.0042728687101743, 0.1885148125534, 0.2930796967254722, 1.5572707438586435, 0.25829323572955054, 0.48983975924308504, 1.1331482368363286, 0.6968635277374089, -1.3035278854593149, 1.3418484858340922, 1.4, 0.45944560415460883, 0.6489164239430315, 0.3735920636513418, 0.37609736696106844, -0.21465594904463597, 0.16499821359965544, 0.3138168169170666, 0.39529885403683523, 0.5441929779449192, 0.1524375159671954, 0.27891403863248443, 0.3825291676568341, 0.5309805884312703, -0.43667481757059556, -0.3588574538947383, -0.31624243249441525, -0.2383757807867133, -0.43485063006236296, -0.3700021212231199, -0.31681369713960095, -0.2406506822243585, 1.0, 1.0, 1.0, 1.0, 0.5115643028680643, 0.5115335338017275, 0.46177280567215445, 0.48722008966921493, 0.7135001077368941, 0.8818818818818815, 0.40180816160278077, -0.10310310310310311, 0.43052208835341366], "score_NOT Basins_2D": 0.9670617245137691, "ela_features": [0.005018145729100731, 0.979432373841598, 0.0024222962245850728, 0.013232990419401385, 8.27196832709163, 0.02703411657991097, 0.009868697291249062, 8.207852394472962, 0.04084577071461861, -10.4996006457521, 143.34422704598225, 7.4, 0.3940894624279936, 0.5049389803604384, 0.19189598592729223, 0.37687659676132357, -0.46235715873738137, 0.8621060106805348, 0.8906395431852834, 1.0, 1.0, 0.8750168925317932, 0.9093746961510092, 1.0, 1.0, -0.12128120056667932, -0.09618605632729024, 0.0, 0.0, -0.11045773251795847, -0.08010270859025011, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21523862036015734, 0.21522430420005198, 0.2135492209870952, 0.18675822214815602, 0.26529211607674874, 0.25325325325325315, 0.015634235854610618, -0.5515515515515513, 0.10208333333333333], "score_NOT Basins_5D": 0.9979851054958999, "ela_features_10D": [0.00662385026113943, 0.9769193379803877, 0.0005896322710495224, 0.012732906461860802, 21.594656681861604, 0.036196879152639805, 0.007745024976890891, 3.882424243686345, 0.033810132670790916, -12.595662934847072, 199.84145348980314, 7.0, 0.40132118520683563, 0.5089214855880435, 0.20869418064783113, 0.3678385854999415, -0.4090479938359987, 0.8017080056879111, 0.867826936213375, 1.0, 1.0, 0.7691883072061617, 0.8736900827554475, 1.0, 1.0, -0.17437866253295897, -0.11623344737619601, 0.0, 0.0, -0.2039137918584466, -0.11159024858272204, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21597988493861514, 0.21602122242600003, 0.21449046904917707, 0.186728948912088, 0.2666942829127682, 0.16516516516516513, 0.013399024376585727, -0.7077077077077074, 0.1046474358974359], "score_NOT Basins_10D": 0.997416494647041}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [5.0, -3.888888888888889], 0.0], [1, [-5.0, -2.7777777777777777], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [5, [1.389555555555556, 2.7777777777777786], -12.826523650230945], [1, [-3.68356115822981, -0.5580923764198714], -2.6271890923846213], [5, [-2.8589817735008096, -4.083715814826922], -1.0670215791991942], [1, [2.667738455915362, 1.6095318180176417], -6.598867570308558], [1, [3.7876457535425283, 0.6747776424496336], -4.656555093185164], [3, [3.795622456917807, -4.455684872330335], -0.5854123848423779], [6, [2.6180697196991245, -0.300022295140354], -5.538386806750847], [3, [-2.002091080854002, 0.8494571660436762], -8.930179969239898], [1, [-0.24813192483980698, 0.7935314282286248], -5.448737991321266], [4, [3.751251046527726, 1.224418271563999], -5.110375045994845], [3, [-4.01075465592877, 1.4347278217597776], -3.191555056101667], [2, [-1.177526960323044, -2.337953005764527], -2.881712981941485], [4, [3.004549183349666, 4.405322644263988], -3.475968882458898], [5, [4.224837233865222, 2.9580338810008975], -4.113773874309832], [10, [0.30619712648546416, 3.1432275182058236], -10.876072439659213], [10, [0.989277072771054, 1.2748927444163578], -8.119042791335643], [2, [4.364976892856412, -2.4350977819768214], -2.205135722919936], [1, [2.3772121996071474, -4.496213928851688], -2.1369776942162595], [3, [2.074457044873263, -4.743234612351817], -2.230807267419047], [2, [-4.299095458841391, -1.1308243418978106], -2.2367044820946917], [3, [-0.31667960920128224, -2.9067987620326896], -3.2310892321257927], [5, [-1.5625803617148553, 0.5108225315816919], -9.31921964613947], [7, [-2.2596218998773243, -4.315240334497041], -1.1490903504810872], [2, [3.747139598117265, -2.7873284732048074], -2.2309459218433085], [3, [-2.5444841221924817, -0.7199908145055918], -4.421642173588649]], "nr_of_basins": 33, "f_opt_dim_2": -13.05380464828892, "x_opt_dim_2": [1.3940530443550174, 2.6188529999403434], "f_opt_dim_5": -1.1445727691889387, "x_opt_dim_5": [2.537064063063161, 2.93638277550829, 3.2561518683094564, 1.2583672414870741, 0.14708262417017653]}
{"id": "148a1d29-a948-4ac5-8420-dcbab5ed810e", "fitness": 0.666645283480951, "name": "landscape_nonhomogeneous_anisotropic_ext", "description": "A non-homogeneous multi-well landscape built from a larger set of anisotropic Gaussian wells with diverse widths, rotations, and centers, augmented by a non-separable sinusoidal background. The combination yields highly irregular basin sizes and shapes, breaking basin-size homogeneity while preserving a bounded search space in [-5, 5]^dim for minimization.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_anisotropic_ext:\n    def __init__(self, dim=5):\n        self.dim = dim\n        # Increase the number of wells to induce rich, irregular basins\n        self.K = max(8, dim * 4)\n\n        # Number of background sinusoidal components (non-separable coupling)\n        self.M = max(4, int(dim))\n\n        # Deterministic RNG for reproducibility\n        rng = np.random.RandomState(987654)\n\n        # Random centers for the wells inside [-5, 5]^dim\n        self.centers = rng.uniform(-5.0, 5.0, size=(self.K, dim))\n\n        # Amplitudes (depths) of the wells (positive values; function uses negation)\n        self.amps = rng.uniform(0.6, 9.0, size=(self.K,))\n\n        # Widths per axis for each well (anisotropy)\n        self.widths = rng.uniform(0.15, 3.25, size=(self.K, dim))\n\n        # Random rotation for each well (to break symmetry)\n        self.orns = []\n        for i in range(self.K):\n            A = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(A)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            self.orns.append(Q)\n\n        # Background non-separable components (random directions with sine\n        # modulation to create complex interference patterns)\n        self.bg_vecs = rng.normal(size=(self.M, dim))\n        self.bg_as = rng.uniform(-0.9, 0.9, size=(self.M,))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension.\")\n\n        # Sum of anisotropic Gaussian wells\n        val = 0.0\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            y = self.orns[i].T @ diff\n            dist2 = np.sum((y / self.widths[i])**2)\n            val += - self.amps[i] * np.exp(-0.5 * dist2)\n\n        # Add a non-separable, bounded background to break basin-homogeneity\n        bg = 0.0\n        for j in range(self.M):\n            bg += self.bg_as[j] * np.sin(self.bg_vecs[j] @ x)\n\n        val += bg\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nonhomogeneous_anisotropic_ext scored on:NOT Basins 0.001,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["03915f6a-fd12-4a0b-880e-c62a9eee9879"], "operator": null, "metadata": {"ela_features_2D": [0.46083047895755264, 0.18817133184961826, 0.05892699410830811, 0.6701329508550931, 11.50634077154418, 0.4632623246163362, 0.7084654866545483, 1.3251591532973825, 0.8365013838587355, 0.004967200728282696, -1.215256576007166, 2.0, 0.4407319828028628, 0.6835025319316881, 0.3736893779691148, 0.3483495228321569, -0.17391764154477682, 0.22131146384269593, 0.25667754150931826, 0.4781661458642266, 0.6050235662970664, 0.20518230171778282, 0.24202930741799614, 0.3717869682189555, 0.579944271762433, -0.4074403578421989, -0.38894296930367867, -0.27305498917432736, -0.20666984940342328, -0.4087133577656889, -0.38984093031302425, -0.32311984547800077, -0.21605455996070128, 1.0, 1.0, 1.0, 1.0, 0.5114394132670239, 0.5114168065981628, 0.5576607577699468, 0.5597721988247424, 0.6724852846205641, 0.6096096096096094, 0.4638334418329251, -0.0910910910910911, 0.3815261044176707], "score_NOT Basins_2D": 0.9990358203649521, "ela_features": [0.0514823539536446, 0.8332438276763678, 0.006522141912374812, 0.07211341990394263, 17.896660514745044, 0.07290109866092502, 0.07682664613316106, 11.10863986454288, 0.14891335888747292, -1.1636437782652949, 3.025856655915491, 3.2, 0.556640294519757, 0.8069090101039758, 0.4326553083828159, 0.23056843957786408, -0.5936335058460985, 0.8513542641766696, 0.8495305518662024, 0.8792343553615771, 0.9490341131449277, 0.8669159187486463, 0.8501520562565228, 0.878365928393553, 0.947795337582661, -0.13075140538464664, -0.13235132710838035, -0.10622335752847664, -0.04482820366326969, -0.11766966301117962, -0.13246961286761483, -0.10751729300872497, -0.04614241387260187, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21788874548825002, 0.21790691506113316, 0.20946890222367803, 0.2083575976186766, 0.8529950165449591, 0.3453453453453452, 0.28687228908049345, -0.3113113113113112, 0.6048076923076924], "score_NOT Basins_5D": 0.9994740485562943, "ela_features_10D": [0.001009509781697271, 0.4914144096498121, 0.0019817235958243533, 0.02328523996102439, 45.04044409020152, 0.0008494755356271532, 0.0005123293372071514, 86.77190037906341, 0.0015805124762625412, 0.008414796143506542, -0.24366248685524958, 1.0, 0.6434371187106516, 0.8814903640091941, 0.4829612088569216, 0.15218287827259752, -0.6086924778193732, 1.0085434871047088, 1.0029877136619838, 0.9996274328417314, 0.996346026029969, 1.0082971322246614, 1.0032145207163203, 0.999700917805276, 0.9960398211104851, 0.010836082977469363, 0.0037892495576585363, -0.0004724696807580919, -0.00463460112320746, 0.010551647561777289, 0.00408859319741719, -0.00038084086300527176, -0.005036415610043532, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11038847730658397, 0.11038789211590021, 0.10706182259690437, 0.10100427814815602, 0.8687193408254702, 0.12912912912912908, 0.18747143967145052, -0.4714714714714713, 0.6694955964771817], "score_NOT Basins_10D": 0.0014259815216064453}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[5, [5.000024533005327, 3.626889039361666], -0.22987362449048152], [23, [2.6649230150593923, -2.08473504883147], -15.493717338615465], [19, [1.6235045933695929, -0.1541595477626805], -15.273250035531857], [35, [-2.8331620670291926, -1.1665747432231945], -13.500704777250679], [18, [-0.640473061200668, 2.501766361636466], -8.299091951037616]], "nr_of_basins": 5, "f_opt_dim_2": -14.676196336781237, "x_opt_dim_2": [2.5387081763056933, -2.7384928718995374], "f_opt_dim_5": -4.743729810066465, "x_opt_dim_5": [4.3100547690420274, -0.5617987396031296, 0.9605129076148566, -0.8720841778779669, 2.896598299616964]}
{"id": "1b08a637-d670-402d-a9b3-f035dc264e25", "fitness": 0.9982123050309989, "name": "landscape_softmin_aniso_wells", "description": "A non-homogeneous multi-peak landscape using a soft-min (log-sum-exp) of many anisotropic Gaussian-like wells with diverse covariances and depths. Each well has its own orientation and width, producing highly irregular basin shapes and sizes. The global minimum lies in the region where the wells collectively produce the deepest value. The function is evaluated in [-5,5]^dim and formulated for minimization.", "code": "import numpy as np\n\nclass landscape_softmin_aniso_wells:\n    \"\"\"\n    A novel, non-homogeneous optimization landscape built as a soft-min\n    (log-sum-exp) over many anisotropic Gaussian-like wells.\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a positive-definite covariance A_i (constructed as A_i = Q_i @ diag(lam_i) @ Q_i^T)\n      - depth weight w_i (positive)\n    The landscape is f(x) = -log( sum_i w_i * exp(- (x - c_i)^T A_i (x - c_i) ) ).\n    This yields irregular basin shapes/sizes due to varying A_i, w_i, and centers.\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the landscape in dim dimensions.\n        Deterministic seeding by dimension for reproducibility.\n        \"\"\"\n        self.dim = int(dim)\n        self._rng = np.random.default_rng(self.dim)\n\n        # Number of wells grows with dimension to maintain complexity\n        self.n_wells = max(20, int(5 * self.dim + 14))\n\n        # Centers of wells inside [-5, 5]^dim\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(self.n_wells, self.dim))\n\n        # Positive-definite, anisotropic covariances A_i\n        self.A = []\n        for i in range(self.n_wells):\n            # Random rotation\n            M = self._rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            # Random eigenvalues to control width along principal axes\n            lam = self._rng.uniform(0.4, 6.0, size=self.dim)\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.A.append(A_i)\n        self.A = np.asarray(self.A)  # shape (n_wells, dim, dim)\n\n        # Depth weights (positive) for each well\n        self.weights = self._rng.lognormal(mean=0.0, sigma=0.9, size=self.n_wells)\n\n        # Small-to-moderate random scaling to ensure variety in basin depths\n        self.weights *= self._rng.uniform(0.5, 1.8, size=self.n_wells)\n\n        # Optional numerical stabilization term (small constant)\n        self._eps = 1e-12\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape.\n        f(x) = -log( sum_i w_i * exp(- (x - c_i)^T A_i (x - c_i) ) )\n\n        - x: numpy array of shape (dim,) or (k, dim)\n        Returns:\n        - scalar if input is (dim,), or 1-D array of length k otherwise\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        m, d = x.shape\n        assert d == self.dim, \"Input dimension mismatch.\"\n\n        # Clip to domain to ensure domain constraints are respected\n        x = np.clip(x, -5.0, 5.0)\n\n        # Compute S_i(x) = w_i * exp(- (x - c_i)^T A_i (x - c_i) )\n        # Then f(x) = -log( sum_i S_i(x) )\n        # Vectorize over wells and samples as much as possible.\n\n        # Initialize sum for each sample\n        S = np.zeros(m, dtype=float)\n\n        for i in range(self.n_wells):\n            c = self.centers[i]            # shape (dim,)\n            A_i = self.A[i]                  # shape (dim, dim)\n            w_i = self.weights[i]\n\n            dx = x - c  # shape (m, dim)\n            # Compute quadratic form q = dx^T A_i dx for each sample\n            # q_j = (dx_j)^T A_i (dx_j)\n            temp = dx @ A_i                 # shape (m, dim)\n            q = np.sum(temp * dx, axis=1)   # shape (m,)\n\n            S += w_i * np.exp(-q)\n\n        # Numerical stability: ensure S is not zero\n        S = S + self._eps\n        fvals = -np.log(S)\n\n        if single:\n            return float(fvals[0])\n        else:\n            return fvals", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_softmin_aniso_wells scored on:NOT Basins 0.996,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["611d98d0-4517-49a6-86ae-5c4a051ded2c"], "operator": null, "metadata": {"ela_features_2D": [0.16319197186510567, 0.2970730189860723, 0.0813662541536833, 0.19300694244200794, 2.4070648981208747, 0.23462735483616387, 0.33307543143689505, 2.3903847828884097, 0.5367812565848589, 1.6106130656615973, 3.8073755760653443, 3.0, 0.27322781230670345, 0.6239225729454005, 0.20438420985051947, 0.3681299061487244, -0.2994303431245718, 0.8369639318829275, 0.787752407350178, 0.7444542325615637, 0.7946692082248065, 1.0070690183595912, 0.8535782040992921, 0.7328866214959311, 0.7786790619191896, -0.08525052677595893, -0.11097728494842274, -0.13363925823657227, -0.10739093548355849, 0.0036793889095057208, -0.07496448081075163, -0.13715790918119372, -0.11368287370043925, 1.0, 1.0, 0.8, 1.0, 0.5220215445428742, 0.5219960160361108, 0.48251789248840354, 0.4768596229008959, 0.7409826947978287, 0.7177177177177174, 0.5812190848817128, 0.025025025025025, 0.4100401606425702], "score_NOT Basins_2D": 0.9987473846413195, "ela_features": [0.045663192172410993, 0.954276180441058, 0.021508679691208614, 0.13828106750837701, 7.13246853341267, 0.07735962426304341, 0.07120072150542878, 8.292748813948075, 0.18780481538686336, -1.7809812473816304, 2.134450444921247, 2.0, 0.5892978834877651, 0.8143628086967917, 0.41408219044247147, 0.22482246727783065, -0.5003539411177113, 0.9192929835671986, 0.902134652776639, 0.9050802091269535, 0.9247228221309476, 0.930359276802006, 0.908099861079031, 0.9110522613995918, 0.9268474047840659, -0.07099404139631696, -0.08608640146812321, -0.08349443554599223, -0.06621597511324673, -0.061564672427940725, -0.08124497839021232, -0.07862530497779337, -0.06466444780102723, 1.0, 1.0, 0.9, 1.0, 0.21521210601165253, 0.21520511695419384, 0.19564715257554027, 0.20413912896014402, 0.584834772204349, 0.5895895895895894, 0.3008693342905068, -0.3513513513513513, 0.5274038461538462], "score_NOT Basins_5D": 0.9999418551378767, "ela_features_10D": [0.00010075311296100508, 0.9989191184465038, 8.374807773983402e-05, 0.0033908805145039926, 58.42326265359759, -0.004442012121921213, -0.0008073598074655353, 2266.3871358803663, -0.025110257279255553, -32.06117414161084, 1139.4879227191936, 3.6, 0.5835378818616441, 0.6779960683338978, 0.2896931863841753, 0.20464059414880958, -0.12812939610699126, 0.9125898933893989, 1.0, 1.0, 1.0, 0.9229287794376336, 1.0, 1.0, 1.0, -0.1108571505616061, 0.0, 0.0, 0.0, -0.09799890825078576, 0.0, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10940722852414815, 0.1094047691985868, 0.10931174737821517, 0.1002336745279819, 0.19616102927963705, -4.931931931931933, 0.0, -Infinity, 0.06829463570856685], "score_NOT Basins_10D": 0.9959476753138006}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [-3.1220435816566487, -4.44525933499223], -2.3304114966200355], [10, [0.24417761684457176, -2.839070286829893], -0.5587962134400253], [11, [3.1424161970788447, -4.080809312148577], 0.39480416315617406], [3, [-1.6775435247274912, 4.179199071601705], -0.5987083988198413], [13, [4.569712733653733, 1.878338238801655], -0.3380636817357933], [6, [-2.3844139163787412, -2.0162063311157477], 0.09979665138264046], [2, [-1.536384657561564, 0.11112949141599587], -0.51287970057658], [6, [1.4562111705066545, -0.9490208959176576], -0.9859076469249805], [9, [-2.2445502453621122, 1.5734056882957161], -0.7634257013650024], [7, [-0.588052209409904, 1.6706006576246075], -1.6422859942414907], [7, [3.397979062585176, -0.18740628610508597], -1.3637953831695173], [8, [1.000689611126204, 2.284015912850802], -1.0894074763737962], [7, [-2.9687789774014934, 3.8431921546790306], 1.5016476076954202]], "nr_of_basins": 13, "f_opt_dim_2": -1.6607958589226923, "x_opt_dim_2": [-0.6579770933852906, 1.709998904455713], "f_opt_dim_5": -0.12731159127022246, "x_opt_dim_5": [0.05105253313742071, 2.2534403156713623, 0.34993014908776343, -1.8387865048662109, -0.056981006746333475]}
{"id": "19e2b275-334e-40e1-b107-afbc6748db37", "fitness": 0.9947674135522296, "name": "landscape_nh_elliptical_inverted_tents", "description": "A non-homogeneous multi-well landscape built from truncated elliptical wells (anisotropic, non-Gaussian). Each well defines an ellipsoidal interior with a negative depth, with varying shapes, orientations, and radii. The landscape is the pointwise minimum across all wells, producing basins of highly varying sizes and non-separable interactions, thus breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_inverted_tents:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple truncated elliptical wells.\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite rotated covariance A_i (elliptical well)\n      - a radius r_i defining the interior tent region\n      - a negative depth depth_i < 0 (well depth)\n    The well value inside its ellipsoid is depth_i - (1 - d / r_i),\n    where d is the ellipsoidal distance sqrt((x - c_i)^T A_i (x - c_i)).\n    Outside the ellipsoid, the well contribution is depth_i (flat outside).\n    The landscape is f(x) = min_i [ depth_i - max(0, 1 - sqrt(d2_i)/r_i) ].\n    This creates non-homogeneous basins with varying shapes and sizes.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure richer basins\n        self.N = max(4, min(64, 4 * dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Elliptical (anisotropic) wells\n        self.As = []\n        self.radii = np.zeros(self.N, dtype=float)\n        self.depths = np.zeros(self.N, dtype=float)\n\n        for i in range(self.N):\n            # Random rotation (orthogonal matrix)\n            M = rng.normal(size=(dim, dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues controlling axis scales\n            lam = rng.uniform(low=0.5, high=12.0, size=dim)\n            A_i = Q @ np.diag(lam) @ Q.T  # SPD\n\n            self.As.append(A_i)\n\n            # Ellipsoid radius (defines interior region)\n            self.radii[i] = rng.uniform(low=0.8, high=3.5)\n\n            # Negative depth (well depth)\n            self.depths[i] = -rng.uniform(low=0.5, high=6.0)\n\n        self.As = np.stack(self.As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        # Compute all well contributions and take the minimum\n        vals = []\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            d2 = delta @ self.As[i] @ delta  # quadratic form\n            d = np.sqrt(max(d2, 0.0))\n\n            # Tent shape inside ellipsoid: 1 - d/r if inside, else 0\n            tent = 0.0\n            if d <= self.radii[i]:\n                tent = 1.0 - (d / self.radii[i])\n\n            f_i = self.depths[i] - tent  # inside: depth - (1 - d/r); outside: depth\n            vals.append(f_i)\n\n        return float(min(vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_elliptical_inverted_tents scored on:NOT Basins 0.988,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fe68083c-6bd7-48db-bfe2-5023dc46d938"], "operator": null, "metadata": {"ela_features_2D": [0.001567776380340935, 0.9879104993355243, 0.0121587199976715, 0.02255786213157663, 1.962119116538129, 0.0005268251311013605, 0.05092135274532954, 1.0669681931925443, 0.09621609864495177, -7.114040761615253, 56.70878696495843, 6.8, 0.08455980624729137, 0.09376513331747593, 0.0511782745948456, 1.2415909699691803, -0.19119403507890173, 0.16491239409734698, 0.48906353666945507, 1.0, 1.0, 0.16243525054059485, 0.4018000590482099, 1.0, 1.0, -0.437033412409336, -0.2673491036453339, 0.0, 0.0, -0.4302199466115404, -0.30714937810148457, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5231256540316369, 0.5231198655089712, 0.49430825017191954, 0.3590602700386337, 0.12137151849505134, 0.9019019019019016, 1.1508004838517327, 0.5415415415415413, 0.032530120481927716], "score_NOT Basins_2D": 0.9984954833053052, "ela_features": [0.0009416219561283245, 0.9924836238232995, 0.006059559138703599, 0.012720859033348932, 2.4587047148286785, 0.0005753596995770715, 0.02443303875523948, 4.509893906290186, 0.038717510897005744, -23.763659148931215, 763.5661944603589, 3.4, 0.14492476358223888, 0.1488510764218702, 0.06543932533704455, 0.7964707548262517, -0.6458450382516917, 0.6602396435660605, 0.6963728546061132, 1.0, 1.0, 0.6569981632768155, 0.694163073905479, 1.0, 1.0, -0.17781075162513985, -0.1589007366925684, 0.0, 0.0, -0.17611297817547478, -0.15703079728406008, 0.0, 0.0, 1.0, 1.0, 0.7666666666666667, 1.0, 0.33291987887689667, 0.33287472323952244, 0.3190699389480684, 0.2559088985433703, 0.05824285337503403, -Infinity, 1.1193218205441906, 0.6736736736736735, 0.013332174853259188], "score_NOT Basins_5D": 0.9978310957085341, "ela_features_10D": [0.00029225973305613273, 0.9966680564253967, 0.0014324323531488034, 0.003971388100309183, 2.772478638575283, 0.0009300793709595689, -0.000678002002554301, 6.764497505531905, -0.01060615559599487, -35.270531500418976, 1243.004798079999, 1.0, 0.18228466212095018, 0.1864612968972615, 0.11226237886401527, 0.46991009720076715, -0.9999999999999984, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.213477033898906, 0.21340177454842454, 0.2130759658825394, 0.1844719348034952, 0.009564751735344334, -Infinity, 0.006129403577943731, 0.5935935935935934, 0.0008012820512820513], "score_NOT Basins_10D": 0.9879756616428494}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -5.3789783579445505], [1, [-3.888888888888889, -5.0], -5.3789783579445505], [1, [-2.7777777777777777, -5.0], -5.3789783579445505], [1, [-1.6666666666666665, -5.0], -5.3789783579445505], [1, [-0.5555555555555554, -5.0], -5.3789783579445505], [1, [0.5555555555555554, -5.0], -5.3789783579445505], [1, [1.666666666666667, -5.0], -5.3789783579445505], [1, [2.7777777777777786, -5.0], -5.3789783579445505], [1, [3.8888888888888893, -5.0], -5.3789783579445505], [1, [5.0, -5.0], -5.3789783579445505], [1, [-5.0, -3.888888888888889], -5.3789783579445505], [1, [-3.888888888888889, -3.888888888888889], -5.3789783579445505], [1, [-2.7777777777777777, -3.888888888888889], -5.3789783579445505], [1, [-1.6666666666666665, -3.888888888888889], -5.3789783579445505], [1, [-0.5555555555555554, -3.888888888888889], -5.3789783579445505], [1, [0.5555555555555554, -3.888888888888889], -5.3789783579445505], [1, [1.666666666666667, -3.888888888888889], -5.3789783579445505], [1, [2.7777777777777786, -3.888888888888889], -5.3789783579445505], [1, [3.8888888888888893, -3.888888888888889], -5.3789783579445505], [1, [5.0, -3.888888888888889], -5.3789783579445505], [1, [-5.0, -2.7777777777777777], -5.3789783579445505], [1, [-3.888888888888889, -2.7777777777777777], -5.3789783579445505], [1, [-2.7777777777777777, -2.7777777777777777], -5.3789783579445505], [1, [-1.6666666666666665, -2.7777777777777777], -5.3789783579445505], [1, [-0.5555555555555554, -2.7777777777777777], -5.3789783579445505], [1, [0.5555555555555554, -2.7777777777777777], -5.3789783579445505], [1, [1.666666666666667, -2.7777777777777777], -5.3789783579445505], [1, [2.7777777777777786, -2.7777777777777777], -5.3789783579445505], [1, [3.8888888888888893, -2.7777777777777777], -5.3789783579445505], [1, [5.0, -2.7777777777777777], -5.3789783579445505], [1, [-5.0, -1.6666666666666665], -5.3789783579445505], [1, [-3.888888888888889, -1.6666666666666665], -5.3789783579445505], [1, [-2.7777777777777777, -1.6666666666666665], -5.3789783579445505], [1, [-1.6666666666666665, -1.6666666666666665], -5.3789783579445505], [1, [-0.5555555555555554, -1.6666666666666665], -5.3789783579445505], [1, [0.5555555555555554, -1.6666666666666665], -5.3789783579445505], [1, [1.666666666666667, -1.6666666666666665], -5.3789783579445505], [1, [2.7777777777777786, -1.6666666666666665], -5.3789783579445505], [1, [3.8888888888888893, -1.6666666666666665], -5.3789783579445505], [1, [5.0, -1.6666666666666665], -5.3789783579445505], [1, [-5.0, -0.5555555555555554], -5.3789783579445505], [1, [-3.888888888888889, -0.5555555555555554], -5.3789783579445505], [1, [-2.7777777777777777, -0.5555555555555554], -5.3789783579445505], [1, [-1.6666666666666665, -0.5555555555555554], -5.3789783579445505], [1, [-0.5555555555555554, -0.5555555555555554], -5.3789783579445505], [1, [0.5555555555555554, -0.5555555555555554], -5.3789783579445505], [1, [1.666666666666667, -0.5555555555555554], -5.3789783579445505], [1, [2.7777777777777786, -0.5555555555555554], -5.3789783579445505], [1, [3.8888888888888893, -0.5555555555555554], -5.3789783579445505], [1, [5.0, -0.5555555555555554], -5.3789783579445505], [1, [-5.0, 0.5555555555555554], -5.3789783579445505], [1, [-3.888888888888889, 0.5555555555555554], -5.3789783579445505], [1, [-2.7777777777777777, 0.5555555555555554], -5.3789783579445505], [1, [-1.6666666666666665, 0.5555555555555554], -5.3789783579445505], [1, [1.666666666666667, 0.5555555555555554], -5.3789783579445505], [1, [2.7777777777777786, 0.5555555555555554], -5.3789783579445505], [1, [3.8888888888888893, 0.5555555555555554], -5.3789783579445505], [1, [5.0, 0.5555555555555554], -5.3789783579445505], [1, [-5.0, 1.666666666666667], -5.3789783579445505], [1, [-3.888888888888889, 1.666666666666667], -5.3789783579445505], [1, [-2.7777777777777777, 1.666666666666667], -5.3789783579445505], [1, [0.5555555555555554, 1.666666666666667], -5.3789783579445505], [1, [1.666666666666667, 1.666666666666667], -5.3789783579445505], [1, [2.7777777777777786, 1.666666666666667], -5.3789783579445505], [1, [3.8888888888888893, 1.666666666666667], -5.3789783579445505], [1, [5.0, 1.666666666666667], -5.3789783579445505], [1, [-5.0, 2.7777777777777786], -5.3789783579445505], [1, [-3.888888888888889, 2.7777777777777786], -5.3789783579445505], [1, [-2.7777777777777777, 2.7777777777777786], -5.3789783579445505], [1, [-1.6666666666666665, 2.7777777777777786], -5.3789783579445505], [1, [-0.5555555555555554, 2.7777777777777786], -5.3789783579445505], [1, [0.5555555555555554, 2.7777777777777786], -5.3789783579445505], [1, [1.666666666666667, 2.7777777777777786], -5.3789783579445505], [1, [2.7777777777777786, 2.7777777777777786], -5.3789783579445505], [1, [3.8888888888888893, 2.7777777777777786], -5.3789783579445505], [1, [5.0, 2.7777777777777786], -5.3789783579445505], [1, [-5.0, 3.8888888888888893], -5.3789783579445505], [1, [-3.888888888888889, 3.8888888888888893], -5.3789783579445505], [1, [-2.7777777777777777, 3.8888888888888893], -5.3789783579445505], [1, [-1.6666666666666665, 3.8888888888888893], -5.3789783579445505], [1, [-0.5555555555555554, 3.8888888888888893], -5.3789783579445505], [1, [0.5555555555555554, 3.8888888888888893], -5.3789783579445505], [1, [1.666666666666667, 3.8888888888888893], -5.3789783579445505], [1, [2.7777777777777786, 3.8888888888888893], -5.3789783579445505], [1, [3.8888888888888893, 3.8888888888888893], -5.3789783579445505], [1, [5.0, 3.8888888888888893], -5.3789783579445505], [1, [-5.0, 5.0], -5.3789783579445505], [1, [-3.888888888888889, 5.0], -5.3789783579445505], [1, [-2.7777777777777777, 5.0], -5.3789783579445505], [1, [-1.6666666666666665, 5.0], -5.3789783579445505], [1, [-0.5555555555555554, 5.0], -5.3789783579445505], [1, [0.5555555555555554, 5.0], -5.3789783579445505], [1, [1.666666666666667, 5.0], -5.3789783579445505], [1, [2.7777777777777786, 5.0], -5.3789783579445505], [1, [3.8888888888888893, 5.0], -5.3789783579445505], [1, [5.0, 5.0], -5.3789783579445505], [4, [-0.5896909637332066, 1.098435368880265], -6.378728581057208]], "nr_of_basins": 97, "f_opt_dim_2": -6.3789783579445505, "x_opt_dim_2": [-0.5899387794648853, 1.098708094225075], "f_opt_dim_5": -5.953242907163173, "x_opt_dim_5": [-3.162976230831129, 2.9948801636232956, 3.3070372440367457, -2.9480716405810528, 4.465217945158466]}
{"id": "292132df-ba0f-46b6-9a4d-e6a36870f0c4", "fitness": 0.9979215761413798, "name": "landscape_compact_ellipsoidal_min", "description": "A non-homogeneous landscape built from compact ellipsoidal wells with smooth ellipsoidal bumps. Each well has its own orientation and axis scales, and contributes only inside an ellipsoidal support. The global minimum lies at the deepest well. This provides irregular basin shapes and sizes while avoiding Gaussian-style wells, ensuring a distinct benchmark from the selected solution.", "code": "import numpy as np\n\nclass landscape_compact_ellipsoidal_min:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._bound = 5.0  # domain bounds per dimension\n        self._seed = 42424242  # deterministic seed\n        # number of wells grows with dimension but stays modest\n        self.nwells = max(5, min(25, self.dim * 2 + 3))\n        self.wells = []\n        self._init_wells()\n\n    def _rand(self):\n        # Simple LCG for deterministic [0,1) values\n        self._seed = (1664525 * self._seed + 1013904223) % (2**32)\n        return self._seed / float(2**32)\n\n    def _init_wells(self):\n        self.wells = []\n        min_sep = 2.0  # separation between centers to reduce excessive overlap\n        for i in range(self.nwells):\n            tries = 0\n            while True:\n                cand = np.array([ -self._bound + 2.0 * self._bound * self._rand() for _ in range(self.dim) ])\n                ok = True\n                for w in self.wells:\n                    if np.linalg.norm(cand - w['c']) < min_sep:\n                        ok = False\n                        break\n                if ok:\n                    break\n                tries += 1\n                if tries > 300:\n                    # fallback: accept current candidate to keep progress\n                    break\n\n            # Depth: negative value (valleys). Deeper wells have more negative depth.\n            depth = - (0.5 + 4.5 * self._rand())  # in [-5.0, -0.5]\n\n            # Random orientation via QR decomposition to build a PD A_j\n            M = np.array([[self._rand() for _ in range(self.dim)] for __ in range(self.dim)], dtype=float)\n            try:\n                Q, _ = np.linalg.qr(M)\n            except np.linalg.LinAlgError:\n                Q = np.eye(self.dim)\n\n            # Axis scales (eigenvalues) for the ellipsoidal well\n            lambdas = np.array([0.2 + 2.0 * self._rand() for _ in range(self.dim)], dtype=float)\n            A = Q @ np.diag(lambdas) @ Q.T  # positive definite\n\n            # Support radius for the ellipsoid\n            R = 1.0 + 3.0 * self._rand()\n\n            # Exponent for the smooth ellipsoidal bump (controls edge sharpness)\n            p = 2 + int(self._rand() * 2)  # p in {2,3}\n            \n            self.wells.append({'c': cand, 'depth': depth, 'A': A, 'R': R, 'p': p})\n\n        # Ensure the deepest well is clearly defined (optional tiny perturbation)\n        if self.wells:\n            idx_deepest = min(range(len(self.wells)), key=lambda j: self.wells[j]['depth'])\n            self.wells[idx_deepest]['depth'] -= 1e-6\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to dim\")\n\n        val_min = float('inf')\n        for w in self.wells:\n            diff = x - w['c']\n            # dist2 = diff^T * A * diff\n            dist2 = float(diff @ (w['A'] @ diff))\n            dist = np.sqrt(max(dist2, 0.0))\n            if dist < w['R']:\n                # Smooth ellipsoidal bump inside the ellipsoid\n                bump = (1.0 - dist / w['R']) ** w['p']\n            else:\n                bump = 0.0\n            val = w['depth'] * bump\n            if val < val_min:\n                val_min = val\n\n        # If for some reason no well contributed (shouldn't happen), return 0\n        if not np.isfinite(val_min):\n            val_min = 0.0\n        return float(val_min)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_compact_ellipsoidal_min scored on:NOT Basins 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["392b1c7a-2b50-42b4-84b0-a9340e5e872b"], "operator": null, "metadata": {"ela_features_2D": [0.06510396073650884, 0.8213976980935673, 0.028963542406532584, 0.13167644072059254, 5.025173766969923, 0.06519514888722602, 0.1604968323936821, 17.74968890064712, 0.24202594590955898, -2.774204725123382, 10.02059276229895, 3.2, 0.31705952439559204, 0.5714792678460212, 0.24763977402298032, 0.4265753309531872, -0.22537722809431213, 0.30089089841142835, 0.5293011300886326, 0.6398271120246395, 0.8305158608599112, 0.21862160669966477, 0.46605469575969155, 0.591323153114171, 0.8079143628665447, -0.36557525570530613, -0.24614468219222382, -0.18835199300913313, -0.08861897528036197, -0.40078327882524106, -0.2738937441024866, -0.20963875218418665, -0.09851453550339392, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5161896375844489, 0.5161016108217892, 0.4630494307152663, 0.42143895242770013, 0.5786888437840516, 0.8458458458458455, 0.3160902247113581, -0.2672672672672672, 0.3441767068273092], "score_NOT Basins_2D": 0.9991492904955521, "ela_features": [0.00866384019095614, 0.9874090459524332, 0.002101375373840842, 0.014804317383557492, 14.664363144616155, 0.01745827918444265, 0.01447154833270059, 13.772960357962521, 0.0619059339895752, -12.829639359875477, 208.6716593308941, 6.0, 0.33495400531048236, 0.4559251064060583, 0.12455596692946336, 0.42332004778245197, -0.20858277532233452, 0.8653482621296543, 0.9058177709127839, 1.0, 1.0, 0.910511025182817, 0.9391153348640732, 1.0, 1.0, -0.11842163512004719, -0.08282665773338871, 0.0, 0.0, -0.07909031944501525, -0.05379587529176899, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21854367926201945, 0.2185304591510504, 0.21710322287492084, 0.1891943972310411, 0.22730820367735544, 0.1491491491491491, 0.00033161912162843737, -0.9359359359359359, 0.08477564102564103], "score_NOT Basins_5D": 0.9971707169897854, "ela_features_10D": [0.00037371459837296503, 0.997496386959402, 0.0006592363011188601, 0.0037949298187001943, 36.74927280985848, 0.0027543522073467442, 0.0010486388490261733, 7.943112594096763, 0.011127596266495865, -42.03176684972235, 2020.8230878468162, 2.0, 0.3167411931462044, 0.380356290750632, 0.14299642773577076, 0.2813832064914181, -0.8493594966796894, 0.9752701332514496, 0.9766459955173783, 1.0, 1.0, 0.9868813134996419, 0.9830065709080091, 1.0, 1.0, -0.021738596282450718, -0.020529155299877, 0.0, 0.0, -0.011573703405701208, -0.014992118925255603, 0.0, 0.0, 0.9199999999999999, 0.9199999999999999, 0.8212121212121213, 0.9272727272727274, 0.13274534640742963, 0.13274947427049805, 0.13236426542731436, 0.11857731141425824, 0.051695682812939125, -Infinity, 0.0035885312307664076, 0.07307307307307305, 0.017788204922912693], "score_NOT Basins_10D": 0.9974447209388018}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -0.5555555555555554], -0.0], [1, [2.7777777777777786, -0.5555555555555554], -0.0], [1, [-5.0, 0.5555555555555554], -0.0], [1, [-3.888888888888889, 0.5555555555555554], -0.0], [1, [3.8888888888888893, 0.5555555555555554], -0.0], [1, [5.0, 0.5555555555555554], -0.0], [1, [-5.0, 1.666666666666667], -0.0], [1, [-3.888888888888889, 1.666666666666667], -0.0], [1, [-2.7777777777777777, 1.666666666666667], -0.0], [1, [-1.6666666666666665, 1.666666666666667], -0.0], [1, [-5.0, 2.7777777777777786], -0.0], [1, [1.666666666666667, 2.7777777777777786], -0.0], [1, [-5.0, 3.8888888888888893], -0.0], [1, [1.666666666666667, 3.8888888888888893], -0.0], [1, [5.0, 3.8888888888888893], -0.0], [1, [-5.0, 5.0], -0.0], [1, [-3.888888888888889, 5.0], -0.0], [1, [1.666666666666667, 5.0], -0.0], [1, [2.7777777777777786, 5.0], -0.0], [1, [3.8888888888888893, 5.0], -0.0], [1, [5.0, 5.0], -0.0], [6, [1.1434902722888243, -3.652147598520029], -2.6404726725502776], [12, [-1.7645162019614355, 4.093537897780425], -2.05201049124668], [8, [3.5404249117487803, 2.6211108465295667], -1.6897222647826657], [14, [4.5180555702336616, -3.3412540037934484], -0.7155348814103364], [18, [-0.34505629035457, -1.2310499452133525], -4.17484443799888], [19, [-2.1581606651963003, -2.666616314076092], -1.3440436331957706], [2, [0.4884476622097726, 3.4718773051715055], -2.080415977673748]], "nr_of_basins": 28, "f_opt_dim_2": -4.175357703344733, "x_opt_dim_2": [-0.34519973676651716, -1.23116155853495], "f_opt_dim_5": -2.9101715374272317, "x_opt_dim_5": [-0.9946986311115323, 1.6217288048937917, 0.4996455670334399, 4.898146064952016, -1.0605560173280537]}
{"id": "18e6e488-8b98-42bc-b06a-d2c75b386847", "fitness": 0.9337758043160042, "name": "landscape_nh_min_of_anisotropic_quadratics", "description": "A non-homogeneous basin landscape defined as the minimum over anisotropic quadratic wells with random centers and PD matrices. Each well has its own orientation and axis scales, depths vary widely, and cross-dimensional interactions arise from off-diagonal terms in A_j. The global minimum lies at the deepest well, producing highly heterogeneous basin sizes and shapes to break basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_nh_min_of_anisotropic_quadratics:\n    def __init__(self, dim):\n        self.dim = int(dim)\n        self._bound = 5.0       # domain bound per dimension\n        self._seed = 123456789    # fixed seed for determinism\n\n        # number of wells scales with dimension, keeping the landscape rich but manageable\n        self.nwells = max(6, min(40, self.dim * 3))\n\n        # initialize wells as PD quadratic basins with random centers and anisotropic shapes\n        self._init_wells()\n\n    def _rand(self):\n        # Deterministic LCG in [0, 1)\n        self._seed = (1664525 * self._seed + 1013904223) % (2**32)\n        return self._seed / float(2**32)\n\n    def _init_wells(self):\n        self.wells = []\n        min_sep = 1.5  # minimum center separation to encourage diverse basins\n\n        for i in range(self.nwells):\n            tries = 0\n            while True:\n                cand = np.array([ -self._bound + 2.0 * self._bound * self._rand() for _ in range(self.dim) ])\n                ok = True\n                for w in self.wells:\n                    if np.linalg.norm(cand - w['c']) < min_sep:\n                        ok = False\n                        break\n                if ok:\n                    break\n                tries += 1\n                if tries > 300:\n                    break  # progress even if separation cannot be guaranteed\n\n            # Depth for the j-th well; negative means a basin\n            depth = - (0.5 + 9.5 * self._rand())  # approximately [-10, -0.5)\n\n            # Random rotation (orthogonal matrix) via QR decomposition\n            M = np.array([[self._rand() for _ in range(self.dim)] for __ in range(self.dim)], dtype=float)\n            try:\n                Q, _ = np.linalg.qr(M)\n            except np.linalg.LinAlgError:\n                Q = np.eye(self.dim)\n\n            # Anisotropic scales (positive) per axis\n            lambdas = np.array([0.25 + 4.75 * self._rand() for _ in range(self.dim)], dtype=float)\n            L = np.diag(lambdas)\n\n            # Positive-definite quadratic form A_j = Q * L * Q^T\n            A = Q @ L @ Q.T\n\n            self.wells.append({'c': cand, 'd': depth, 'A': A})\n\n        # Ensure the global minimum lies at the deepest well\n        if self.wells:\n            idx_min = min(range(len(self.wells)), key=lambda j: self.wells[j]['d'])\n            # Guarantee uniqueness of the global minimum by nudging the deepest slightly\n            self.wells[idx_min]['d'] -= 1e-6\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to dim\")\n\n        # Global landscape is the pointwise minimum across all quadratic wells\n        val = float('inf')\n        for w in self.wells:\n            diff = x - w['c']\n            val_j = float(diff.T @ w['A'] @ diff + w['d'])\n            if val_j < val:\n                val = val_j\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_min_of_anisotropic_quadratics scored on:NOT Basins 0.973,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["392b1c7a-2b50-42b4-84b0-a9340e5e872b"], "operator": null, "metadata": {"ela_features_2D": [0.37582223858131, 0.3748104233101281, 0.07696483597659565, 0.36177584866310253, 5.046076444822277, 0.5790307972700177, 0.4271297109023853, 6.446288542046325, 0.8189869225997318, 1.0400708596807882, 1.3523516255842527, 2.6, 0.36752458769321744, 0.6764259539842402, 0.2698448657367312, 0.3509276885260417, -0.18211391377873248, 0.17811637918595796, 0.37873676357046937, 0.43082509530517293, 0.6574442536007563, 0.15388595108074504, 0.3705648862886458, 0.44363128285116044, 0.5978082488022444, -0.42999242497587825, -0.32504845786103365, -0.2977962548778926, -0.1792244742761778, -0.43483542846383133, -0.32350071188242785, -0.2859380554800263, -0.2066943791609032, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5166666834913056, 0.5166196082140402, 0.49819761054409, 0.5382436890866877, 0.6943927336646724, 0.4614614614614613, 0.3393130417470008, -0.2192192192192192, 0.363855421686747], "score_NOT Basins_2D": 0.8504636287689209, "ela_features": [0.3903665972678495, -0.01238842741325077, 0.07053639828553453, 0.24041901538108448, 3.4538078279794697, 0.5902521897530455, 0.5442417540614499, 4.460093057789978, 0.8081211642404827, 1.0573836398681125, 1.3586870261167134, 1.8, 0.6724361630403421, 0.8469725539443915, 0.49574143444289, 0.20059036042086223, -0.3577190477807607, 0.8942757969178678, 0.8862153219247819, 0.8754138808320449, 0.8833324298258927, 0.9260488386513794, 0.9003117970947585, 0.8775276118751503, 0.8777229683313408, -0.09302197135495524, -0.1001126753055053, -0.10961505663312136, -0.10264701770999836, -0.06546052474770019, -0.08823042866862037, -0.10839181981134083, -0.10821589162756702, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.2182995372528997, 0.21832077564160865, 0.21781236857294078, 0.2715719844841877, 0.8208265129992072, 0.08108108108108106, 0.1594564627867518, -0.5435435435435434, 0.5201923076923077], "score_NOT Basins_5D": 0.9782923758029938, "ela_features_10D": [0.0585923206343941, 0.26099738328768046, 0.003904474166712217, 0.0739080891382351, 24.688854810064413, 0.24507982799613148, 0.33178315701699307, 1.730878696909413, 0.5722137732308937, 0.45943605879467875, 0.2538538369879049, 1.6, 0.8278331315718864, 0.918835667959582, 0.586858150299215, 0.12191462421198378, -0.534233760139707, 0.8687967839712971, 0.8806090151860195, 0.8914634774513198, 0.9129406970307873, 0.873075845330947, 0.8830706500207774, 0.892532277579835, 0.9121128434638488, -0.16639942228274268, -0.1514188771546882, -0.1376533815259588, -0.11041421555047722, -0.1614024421886572, -0.1486929666740699, -0.13666328364109953, -0.11176183194242642, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11093185519981456, 0.11093093282629748, 0.10844267410625515, 0.11448271918328205, 0.8564964156347978, -0.10310310310310308, 0.12987214700495925, -0.6556556556556554, 0.5940752602081666], "score_NOT Basins_10D": 0.9725714083760977}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-2.838771638257487, 3.7601560388502357], -5.48038188137403], [14, [-3.7170737845922917, -0.7155540067780404], -3.1944427657885632], [27, [-2.361909004903514, 1.9980557490315882], -7.849939349961055], [22, [4.498593685192208, -2.119335174314971], -0.502573766539837], [28, [0.40129718381149165, 3.5677398447101534], -5.701288907708883], [3, [-4.474049114347986, 4.124823381338912], -0.585293849588282]], "nr_of_basins": 6, "f_opt_dim_2": -7.849940485662617, "x_opt_dim_2": [-2.3616589432476056, 1.9986965565659438], "f_opt_dim_5": -4.503852496040054, "x_opt_dim_5": [-2.2359137860409444, -2.023286572765005, 1.2667003790817093, -3.1760971669734506, -0.7641357984633314]}
{"id": "367e5995-fbb6-4553-91c1-c61ca811b9ed", "fitness": 0.9329792315753972, "name": "landscape_nh_extreme", "description": "A highly non-homogeneous, multi-peak landscape with extreme anisotropic ellipsoidal wells and cross-dimensional background interactions to maximize basin-size heterogeneity. The wells are strongly anisotropic (random SPD matrices) with varying depths and scales, and the non-separable background adds cross-coordinate coupling, producing highly irregular basin shapes and sizes across [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_nh_extreme:\n    \"\"\"\n    An extreme non-homogeneous optimization landscape built as a\n    richly structured sum of anisotropic (ellipsoidal) Gaussian wells\n    plus a non-separable background. Each basin has its own random\n    orientation and axis scales, producing highly irregular basin\n    sizes and shapes to break basin-size homogeneous assumptions.\n\n    Evaluation domain: [-5, 5]^dim\n    Minimization problem: lower function values are better\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the landscape in 'dim' dimensions.\n\n        Landscape components:\n        - n_peaks: heavy-tailed wells with elliptical (SPD) shapes and varying depths.\n        - n_bg: non-separable background terms formed from PSD quadratic forms that couple coordinates.\n\n        Parameters:\n        - dim: int, dimensionality of the search space\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed for reproducibility (based on dimension)\n        self._rng = np.random.default_rng(self.dim)\n\n        # Number of heavy-tailed, anisotropic wells\n        self.n_peaks = max(60, int(12 * self.dim + 24))\n\n        # Number of non-separable background components\n        self.n_bg = max(6, int(2.5 * self.dim))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n        # Centers of wells in [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # For each well: random SPD matrix Q_i = U_i * diag(eig_i) * U_i^T\n        # to define the ellipsoidal basin shape (dx^2 with cross-terms)\n        self.Qs = []\n        self.s_peaks = []\n        self.weights = []\n        for i in range(n):\n            # random rotation (orthogonal matrix U)\n            A = self._rng.normal(size=(d, d))\n            # QR decomposition to get an orthogonal matrix\n            Q, R = np.linalg.qr(A)\n            # Ensure a proper rotation (det(Q) could be -1). If needed, flip a axis.\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] = -Q[:, 0]\n\n            # Random axis scales (eigenvalues > 0)\n            eig_vals = self._rng.uniform(0.5, 4.5, size=d)\n            U = Q  # rotation matrix\n            Q_i = U @ np.diag(eig_vals) @ U.T  # SPD matrix for ellipsoidal basin\n            self.Qs.append(Q_i)\n\n            # Scale for the well's effective width\n            s_i = self._rng.uniform(0.8, 3.2)\n            self.s_peaks.append(s_i)\n\n            # Depth/strength of the well (positive, will be used as negative contribution)\n            w_i = self._rng.lognormal(mean=0.0, sigma=0.9)\n            self.weights.append(w_i)\n\n        # Cache arrays for faster access\n        self._centers = self.centers\n        self._Qs = self.Qs\n        self._s_peaks = np.array(self.s_peaks, dtype=float)\n        self._weights = np.array(self.weights, dtype=float)\n\n        # Background components to induce non-separability\n        self.bg_Ms = []\n        self.bg_sigmas = []\n        self.bg_betas = []\n        for j in range(self.n_bg):\n            # Random rotation for cross interactions\n            A = self._rng.normal(size=(d, d))\n            R, _ = np.linalg.qr(A)\n            if np.linalg.det(R) < 0:\n                R[:, 0] = -R[:, 0]\n            # PSD quadratic form M_j = R * diag(L_j) * R^T\n            L_j = self._rng.uniform(0.6, 3.0, size=d)\n            M_j = R @ np.diag(L_j) @ R.T\n            self.bg_Ms.append(M_j)\n\n            # Background sigma controlling the width of background term\n            s_bg = self._rng.uniform(0.7, 2.5)\n            self.bg_sigmas.append(s_bg)\n\n            # Amplitude (can be positive or negative) to create constructive/destructive interference\n            beta_j = self._rng.uniform(-0.6, 0.6)\n            self.bg_betas.append(beta_j)\n\n        self._bg_Ms = self.bg_Ms\n        self._bg_sigmas = np.array(self.bg_sigmas, dtype=float)\n        self._bg_betas = np.array(self.bg_betas, dtype=float)\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i [-w_i * exp(- (x - c_i)^T Q_i (x - c_i) / (2 * s_i^2) )]\n             + sum_j [ beta_j * exp(- (x^T M_j x) / (2 * sigma_j^2) ) ]\n\n        This yields multiple deep, irregular basins with highly varied shapes\n        due to anisotropic ellipsoidal wells and cross-dimensional interactions.\n\n        Parameters:\n        - x: numpy array of shape (dim,) or (k, dim)\n\n        Returns:\n        - scalar value if input is (dim,), or 1-D array of length k otherwise\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        N, d = x.shape\n        total = np.zeros(N, dtype=float)\n\n        # Primary wells: negative, anisotropic Gaussian-like wells\n        for i in range(self.n_peaks):\n            c = self._centers[i]\n            Q = self._Qs[i]\n            s = self._s_peaks[i]\n            w = self._weights[i]\n\n            diff = x - c  # shape (N, d)\n            tmp = diff @ Q  # shape (N, d)\n            d2 = np.sum(tmp * diff, axis=1)  # x^T Q x for each sample\n\n            total += -w * np.exp(- d2 / (2.0 * (s ** 2)))\n\n        # Background cross-dimensional components\n        for j in range(self.n_bg):\n            M = self._bg_Ms[j]\n            s = self._bg_sigmas[j]\n            beta = self._bg_betas[j]\n\n            # proj = x^T M x for each sample\n            prod = x @ M  # shape (N, d)\n            proj = np.sum(prod * x, axis=1)\n\n            total += beta * np.exp(- proj / (2.0 * (s ** 2)))\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_extreme scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["611d98d0-4517-49a6-86ae-5c4a051ded2c"], "operator": null, "metadata": {"ela_features_2D": [0.15927744867829252, 0.609284645704953, 0.06122002165323008, 0.3131705049733019, 13.368749727149828, 0.339199961393066, 0.5955529350839939, 1.5137026142545729, 0.8914792371077326, 0.07599689299059323, -0.8194656941814269, 1.8, 0.5291728412068333, 0.703592409871906, 0.439355809288534, 0.3420779711635141, -0.19488068566095967, 0.1434980499038231, 0.22111303277808458, 0.3381191108932957, 0.5374839673283376, 0.14474962288876286, 0.21808946205586072, 0.3138864317611018, 0.5160525976729948, -0.4480441353345782, -0.4074407190219135, -0.3462397064800452, -0.24194342377766595, -0.43924417974492574, -0.40158800093486324, -0.3523886260453775, -0.24854676693373481, 1.0, 1.0, 1.0, 1.0, 0.5272759331024963, 0.5272615114833078, 0.4575422674048772, 0.4702798470074538, 0.7381889871608653, 0.4454454454454453, 0.6397994449806246, -0.03503503503503505, 0.3815261044176707], "score_NOT Basins_2D": 0.7993331551551819, "ela_features": [0.04195385810700738, 0.8884436067170662, 0.02583160373929791, 0.06901920597442376, 4.031811640559139, 0.07781168878171288, 0.3922669523327936, 2.3284164751920757, 0.593375652160297, -1.9601930599019568, 4.766312513960969, 3.2, 0.7756775013803152, 0.8611665403487743, 0.5657659208839448, 0.1908036333480893, -0.47553484285784126, 0.5755344024002218, 0.6395804188556445, 0.7116155543264504, 0.8023017481729298, 0.534592715972014, 0.6096758036465898, 0.6936385799410247, 0.7917316663250953, -0.3733563922794182, -0.31702004112907545, -0.2536591774829938, -0.17389355133957193, -0.41142536230327903, -0.3450417477575719, -0.27082056259360904, -0.18411131880365483, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21533875896480778, 0.21531074244570264, 0.2051745303247002, 0.20275055153652347, 0.7808241851950184, 0.2772772772772772, 0.1257280909940188, -0.5915915915915914, 0.5254807692307691], "score_NOT Basins_5D": 0.9996641702600755, "ela_features_10D": [0.048861486363637276, 0.9852895337813949, 0.00102707914386482, 0.020286370642482503, 21.53834710147886, 0.10616225673394095, 0.07253142694928912, 140.50855089333692, 0.17295344279091915, -12.909890399227834, 259.71959984261105, 6.2, 0.8361828413538444, 0.9167804841015949, 0.5871068131075949, 0.12362628355281768, -0.39473344914659503, 0.7928208157627967, 0.8418529845371767, 0.8770928023694357, 0.9139706781113391, 0.7807433377052506, 0.8423923147878117, 0.8778874552697381, 0.9142327180289692, -0.26280815326659906, -0.2006099742343983, -0.15590806360163137, -0.10912817908735706, -0.27894081194653497, -0.200507735441658, -0.15535197384922558, -0.10911243202828617, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1105606512176728, 0.11055294839643222, 0.11030228004234137, 0.11347689030710353, 0.7132233919101365, -0.3753753753753753, 0.0011677228219764055, -2.2972972972972974, 0.5968775020016013], "score_NOT Basins_10D": 0.9999403693109343}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[18, [-3.2745845037971355, -3.456948262846596], -9.598549870994432], [34, [0.31733853259902833, -2.6748500244383795], -11.233495218631711], [48, [2.2414073524156444, 0.8182442318233799], -13.223247315846255]], "nr_of_basins": 3, "f_opt_dim_2": -13.223533660426524, "x_opt_dim_2": [2.2386098869870357, 0.8040243252666892], "f_opt_dim_5": -5.416439373405049, "x_opt_dim_5": [-0.2990021846960363, 0.7255601032032747, 0.21837910109865968, 1.4486285941115147, -1.2249953711476775]}
{"id": "d7084ddb-9303-4948-889c-ba167172394f", "fitness": 0.9275236119622908, "name": "landscape_nonhomogeneous_anisotropic_min", "description": "A non-homogeneous multi-well landscape built as the pointwise minimum across anisotropic Gaussian wells with rotations, varying depths and axis widths. By taking the minimum rather than the sum of wells, basin boundaries become sharp and irregular, producing highly non-uniform basins and breaking basin-size homogeneity across the search space.", "code": "import numpy as np\n\nclass landscape_nonhomogeneous_anisotropic_min:\n    def __init__(self, dim=5):\n        self.dim = dim\n        # number of wells (rich, non-uniform basins)\n        self.K = max(6, dim * 3)\n        \n        # Deterministic RNG for reproducibility with respect to dimension\n        rng = np.random.RandomState(123456)\n        \n        # Random centers for the wells inside [-5, 5]^dim\n        self.centers = rng.uniform(-5.0, 5.0, size=(self.K, dim))\n        \n        # Amplitudes (depths) of the wells (positive values; function uses negation)\n        self.amps = rng.uniform(0.8, 6.0, size=(self.K,))\n        \n        # Widths per axis for each well (controls anisotropy of the ellipsoidal Gaussian)\n        self.widths = rng.uniform(0.25, 2.5, size=(self.K, dim))\n        \n        # Random rotation for each well to further break symmetry\n        self.orns = []\n        for i in range(self.K):\n            A = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(A)\n            # Ensure a proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            self.orns.append(Q)\n    \n    def f(self, x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input dimension does not match landscape dimension.\")\n        \n        min_val = float('inf')\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            # Rotate into the ellipsoid's frame\n            y = self.orns[i].T @ diff\n            # Anisotropic squared distance with per-axis widths\n            dist2 = np.sum((y / self.widths[i])**2)\n            val_i = - self.amps[i] * np.exp(-0.5 * dist2)\n            if val_i < min_val:\n                min_val = val_i\n        return float(min_val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nonhomogeneous_anisotropic_min scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["03915f6a-fd12-4a0b-880e-c62a9eee9879"], "operator": null, "metadata": {"ela_features_2D": [0.2147702910060149, 0.668430541159575, 0.14853374358266455, 0.3995142933052251, 2.7386302416333947, 0.2625828297897026, 0.38361383559416984, 2.923545264668622, 0.663740871519051, -1.2627514873946784, 0.4997207501001796, 1.6, 0.44916076720519893, 0.687357246215576, 0.39285673313866126, 0.35247104695515075, -0.19083401057961297, 0.5011078045686647, 0.5887345113615601, 0.558890258290482, 0.6300913300541489, 0.37280538054642537, 0.6181192395721793, 0.49299389080041234, 0.585011738878938, -0.2611132316488265, -0.2152601469372927, -0.2308759069116136, -0.19360897152246218, -0.32277589532238843, -0.1967084677484337, -0.26111340868061783, -0.21372361452804647, 1.0, 1.0, 1.0, 1.0, 0.5172450389142641, 0.5172231077958729, 0.48584820700480363, 0.49529087209092193, 0.5020071175908783, 0.8378378378378375, 0.8652578773117756, -0.3993993993993993, 0.3751004016064257], "score_NOT Basins_2D": 0.7827480733394623, "ela_features": [0.022868528935027423, 0.9883543570598177, 0.002108086643979788, 0.04280482092393946, 29.012027218258556, 0.08644869592866497, 0.07555945730465088, 13.895633045759912, 0.26057691499738783, -5.38916092104336, 39.34496436785493, 6.4, 0.6280776060929197, 0.8407923702991535, 0.46408869344099146, 0.20427467439496336, -0.4319542642031536, 0.9288789764623224, 0.9183665581712915, 0.9201149361497075, 0.9184741501228937, 1.014590647464632, 0.9702239698410624, 0.9519621789601607, 0.9264655364379639, -0.06256638533108135, -0.07181080562600044, -0.07027211955679886, -0.07171446091505736, 0.01288141292109839, -0.026343125274414424, -0.04249177228843419, -0.06503429436288082, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21350555185715323, 0.21351123685608564, 0.209989589884592, 0.19578877881670492, 0.6535894618984854, 0.2572572572572572, 0.00744843335199417, -1.4004004004004003, 0.5354166666666667], "score_NOT Basins_5D": 0.999886108947976, "ela_features_10D": [0.0017002610340268952, 1.0010524386036037, 0.00018954439394867163, 0.0051589041010033825, 67.11527916310803, -0.001074172214289759, 0.003973803032104683, 39.87508413693774, -0.0044571706016925065, -26.52612235911833, 809.8684819430098, 4.8, 0.8247346924691972, 0.9166513815024612, 0.5864996118834364, 0.12412713871319339, -0.2505706164637559, 0.8646452003550014, 0.8636330681455036, 0.8830016853960719, 0.9082021087755361, 0.8671665864845284, 0.8621603181655599, 0.8816491848131862, 0.9072944205714053, -0.17167311473519148, -0.17295588895818273, -0.14839069609935396, -0.11642958328175657, -0.16892562616010806, -0.1752874839346962, -0.15050508002939522, -0.1178955391590442, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11000428407827649, 0.11000154714669211, 0.10987466312939395, 0.10112236235867585, 0.5457750847897932, -0.93993993993994, 1.019315858253562e-05, -Infinity, 0.5838270616493195], "score_NOT Basins_10D": 0.9999366535994341}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[12, [-2.5285027641654825, 3.922489707044387], -5.2102989125160954], [10, [-3.7573620018957627, 0.4276879193446074], -1.990157431502125], [3, [-3.7301199464104755, 4.666574755895704], -1.4730914154883226], [20, [-0.48409388648093293, 3.388364109278001], -2.630560506577398], [11, [-1.3860982566947257, -0.4464183497799485], -4.820345370216206], [44, [-1.2335161709930536, -1.6364953558080861], -5.066014973824153]], "nr_of_basins": 6, "f_opt_dim_2": -4.970903605175965, "x_opt_dim_2": [-0.9724473170295305, -1.7537736872571459], "f_opt_dim_5": -5.011897665519454, "x_opt_dim_5": [-0.37645665069789946, 3.7137165498260716, -0.9886877766203069, 1.105882707997227, -3.8203286995172188]}
{"id": "898090aa-bc60-4355-b45f-5a69e6202990", "fitness": 0.9870441422487298, "name": "landscape_interacting_gaussians", "description": "A non-separable, multi-well landscape built from a sum of anisotropic Gaussian wells with varying centers, depths, and covariance structures. The wells create irregular basin shapes and sizes, breaking basin-size homogeneity. The global minimum is at or near the origin due to a deep central well, while other wells provide diverse local basins through rotated, stretched ellipsoids.", "code": "import numpy as np\n\nclass landscape_interacting_gaussians:\n    \"\"\"\n    Non-separable landscape composed as a sum of anisotropic Gaussian wells.\n    Each well k has:\n      - center c_k in R^dim\n      - depth A_k (positive scalar)\n      - positive-definite, rotated covariance P_k (dim x dim)\n    The objective is f(x) = - sum_k A_k * exp(-0.5 * (x - c_k)^T P_k (x - c_k)).\n    This yields multiple non-homogeneous basins with diverse shapes/sizes.\n    A deep well is placed at the origin (c_0 = 0) to encourage a global minimum near x = 0.\n    Evaluation is performed in [-5, 5]^dim, and the function is suitable for minimization.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        rng = np.random.default_rng(42)\n\n        self.wells = []\n        # Number of wells (4-6) to create a rich, non-homogeneous landscape\n        K = rng.integers(4, 7)\n        for k in range(K):\n            # Center\n            if k == 0:\n                c = np.zeros(self.dim)\n            else:\n                c = rng.uniform(-4.0, 4.0, size=(self.dim,))\n                # Ensure a reasonable distance from origin to avoid trivial overlaps\n                if np.linalg.norm(c) < 0.6:\n                    if np.linalg.norm(c) == 0:\n                        c += rng.uniform(0.6, 1.2)\n                    else:\n                        c = c / (np.linalg.norm(c) + 1e-12) * rng.uniform(0.6, 2.0)\n\n            # Depth (ensure the first well is the deepest)\n            if k == 0:\n                A = rng.uniform(5.0, 8.0)\n            else:\n                A = rng.uniform(1.0, 6.0)\n\n            # Generate a random rotation and a positive-definite covariance\n            R = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(R)  # orthogonal matrix\n            lam = rng.uniform(0.25, 4.0, size=(self.dim,))  # eigenvalues\n            P = Q @ np.diag(lam) @ Q.T  # SPD\n\n            self.wells.append({'c': c, 'A': A, 'P': P})\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        val = 0.0\n        for w in self.wells:\n            diff = x - w['c']\n            expo = -0.5 * float(diff.T @ w['P'] @ diff)\n            val -= w['A'] * np.exp(expo)\n\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_interacting_gaussians scored on:NOT Basins 0.994,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d58d9cc-66ac-4242-b61d-80837608f749"], "operator": null, "metadata": {"ela_features_2D": [0.10778914866092977, 0.8580910619250337, 0.028580806058831214, 0.16433844770948178, 6.320885078849753, 0.13198779469533847, 0.19452617856171645, 2.1771640074411023, 0.29854205434062886, -2.943467975199639, 10.131850558268741, 3.6, 0.41319905156239933, 0.6751965412966231, 0.3567758511455379, 0.35533628016013563, -0.26220343317919736, 0.4813708896441547, 0.5118767245996986, 0.5835744033214605, 0.6612513611533084, 0.5202191145957668, 0.5847940196467749, 0.6234076525540114, 0.653796802460499, -0.2712066392019515, -0.2552694281101488, -0.21775890089010036, -0.17714242542865494, -0.2461622389194121, -0.21319955805429594, -0.19334169046343802, -0.17774317822675584, 1.0, 1.0, 0.7999999999999999, 1.0, 0.5164979812754639, 0.5164797708957023, 0.4673001043426795, 0.44340483449520696, 0.46095315682924864, 0.8818818818818815, 0.2718082029322058, -0.8678678678678677, 0.38032128514056224], "score_NOT Basins_2D": 0.9928811597637832, "ela_features": [-0.00019307571121205403, 0.9879758543279676, 0.0011755657270623914, 0.0060496960785149986, 32.062038657342725, -0.003999235871392548, 0.018720063032788704, 2.0878464294842822, 0.0319550384642999, -19.441107615908578, 471.3023261804581, 5.6, 0.7470218179144783, 0.8101046522272382, 0.48602821641155325, 0.2295227525625238, -0.19588193591370093, 0.6155015404981634, 0.6794514789138099, 0.720169112091818, 0.7964301184466435, 0.6025860189628525, 0.671290836039566, 0.7128431199407721, 0.7897587508353276, -0.338282147200852, -0.28201782239186296, -0.24619322220239584, -0.17910149812673937, -0.35152985361359557, -0.29074686481076306, -0.253993185469984, -0.1859690083101911, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2145740164725522, 0.21457955079029922, 0.21359110439519866, 0.17989192426168973, 0.523604170878098, -0.20320320320320318, 0.0, -Infinity, 0.44919871794871796], "score_NOT Basins_5D": 0.9747302420437336, "ela_features_10D": [-0.002045190350143855, 0.9994871756450665, 0.00012284638062820907, 0.0018020757808890255, 29.9832021896328, -0.01575556196851533, -0.0021624771464232584, 11.42923712685499, -0.04773749583453575, -45.44530221331432, 2127.5164950980607, 2.0, 0.6799855957501136, 0.7848437526861868, 0.3987649947910933, 0.17930927617217843, -0.07112727214292483, 0.7163542683927087, 0.758926379722477, 0.7975609515239879, 1.0, 0.7098593384875825, 0.7538701172525892, 0.7934110307669114, 1.0, -0.3597425383137562, -0.30574882043180196, -0.256749415552061, 0.0, -0.368977117557972, -0.31300490130225345, -0.26272023851125675, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10932869809091408, 0.1093283131805342, 0.1092684234073749, 0.09966133385827039, 0.36797794076533774, -4.451451451451452, 0.0, -Infinity, 0.1745396317053643], "score_NOT Basins_10D": 0.9935210249386728}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[22, [-3.479511832446448, 2.6207261782966533], -4.159121530488362], [31, [-0.0004488942751416328, 0.000412021360788497], -6.317600165398945], [19, [-2.975177512645374, -0.39654540739405986], -2.8539955408910864], [28, [-0.26614731314053536, -3.649203142446563], -1.7714472307251687]], "nr_of_basins": 4, "f_opt_dim_2": -6.317601750641686, "x_opt_dim_2": [-0.0002646016376196701, 5.460120357679458e-05], "f_opt_dim_5": -6.316640618716139, "x_opt_dim_5": [-5.0843719988493464e-06, 1.6432269288424019e-06, -1.1488212784146226e-06, 2.8334886434316904e-06, -6.570841466302325e-06]}
{"id": "10bdf029-ebd3-49a4-bfe7-37cfbc5b2f09", "fitness": 0.9951366699145486, "name": "landscape_compact_bumps_min", "description": "Non-homogeneous landscape built as the pointwise minimum of multiple compact-support ellipsoidal bumps. Each bump has its own center, ellipsoidal footprint (defined by a random SPD matrix), and a negative depth. Outside a bump's footprint, its contribution is zero; inside, it forms a linear (in sqrt distance) bowl. The global minimum lies at the deepest bump center, while basins vary in size, orientation, and depth, breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_compact_bumps_min:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple compact-support ellipsoidal bumps.\n    Each bump i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite, rotated covariance B_i (ellipsoidal footprint defined by d^T B_i d <= 1)\n      - depth weight w_i < 0 (negative, creating a bowl at the center)\n    The local bump value inside footprint: f_i(x) = w_i * (1 - sqrt(d^T B_i d)),\n    where d = x - c_i. Outside the footprint, f_i(x) = 0.\n    The landscape is f(x) = min_i f_i(x).\n    This creates non-homogeneous basins with varied sizes, shapes, and depths.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to enrich basins\n        self.N = max(4, min(64, 3 * self.dim))\n\n        # Centers within the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, self.dim))\n\n        # Negative depths for each bump\n        self.weights = -rng.uniform(low=0.5, high=5.0, size=self.N)\n\n        # Ellipsoidal footprints: B_i = Q_i * diag(lam) * Q_i^T\n        self.Bs = []\n        for _ in range(self.N):\n            M = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            # Ensure proper rotation with determinant +1\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues controlling ellipse shape (larger = narrower along that axis)\n            lam = rng.uniform(low=0.5, high=8.0, size=self.dim)\n            B_i = Q @ np.diag(lam) @ Q.T\n            self.Bs.append(B_i)\n\n        self.Bs = np.stack(self.Bs, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        vals = []\n        for i in range(self.N):\n            delta = x - self.centers[i]\n            d2 = delta @ self.Bs[i] @ delta  # d^T B_i d\n\n            if d2 <= 1.0:\n                v = self.weights[i] * (1.0 - np.sqrt(d2))\n                vals.append(v)\n            else:\n                # Outside footprint: contribution is zero\n                vals.append(0.0)\n\n        return float(np.min(vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_compact_bumps_min scored on:NOT Basins 0.989,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fe68083c-6bd7-48db-bfe2-5023dc46d938"], "operator": null, "metadata": {"ela_features_2D": [0.045873131702607296, 0.9772215136046138, 0.053619753922054446, 0.06539417621395646, 1.228976674250721, 0.05801029077998236, 0.06704704303063318, 26.349424766814472, 0.16087144453342095, -5.919157775938141, 39.130405669362844, 6.6, 0.09687761853803378, 0.11383018443594409, 0.06790814724649383, 1.1508559733928407, -0.2915216065761484, 0.6275182594987221, 0.7713649655291807, 1.0, 1.0, 0.5847887927864448, 1.0336396756609605, 1.0, 1.0, -0.19494478346291738, -0.11965308501198957, 0.0, 0.0, -0.21412873401172838, 0.017303956667869613, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5161490477743851, 0.5161449132484682, 0.4821284013191584, 0.40642518237428094, 0.15423192314599468, 1.1741741741741738, 1.7070164767388682, 0.6776776776776774, 0.041365461847389554], "score_NOT Basins_2D": 0.9987799057271332, "ela_features": [0.008623296032589777, 0.9916676958930039, 0.013604531953344665, 0.017545423665526104, 2.497465555996958, 0.009490732095429033, 0.012739143945162845, 2.150325524808385, 0.03116580955555326, -29.289002027692316, 1000.5481503382773, 2.0, 0.16340638627608234, 0.17642641656280006, 0.08046140040639096, 0.5769318779522548, -0.8592739607328761, 0.9505277850891007, 0.9612681087685724, 1.0, 1.0, 1.0193683426101976, 1.0120075626571736, 1.0, 1.0, -0.025878176409164722, -0.020260073573674663, 0.0, 0.0, 0.009957382774144796, 0.006173161016836492, 0.0, 0.0, 1.0, 1.0, 0.8, 1.0, 0.2726198133393116, 0.27263463254293, 0.2635690495094618, 0.22358179811502948, 0.03974760847997677, -Infinity, 0.5502537364937112, 0.6416416416416414, 0.009877973432190297], "score_NOT Basins_5D": 0.997944310773164, "ela_features_10D": [5.912411839026355e-05, 0.9975594262818269, 0.001463564772745296, 0.004150394967370398, 2.835812288365792, -0.0007106496136555229, 3.484326279434846e-05, 2.084873015037776, -0.0032209890865133595, -35.27053150041898, 1243.0047980799995, 1.0, 0.1819452023228334, 0.19106248800176495, 0.08439062459684117, 0.4447320140887535, -0.9999999999999991, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21219372938540987, 0.21221624989659155, 0.21178865573793434, 0.17952647109912484, 0.009564751735344334, -Infinity, 0.00542240054695642, 0.4654654654654653, 0.0008012820512820513], "score_NOT Basins_10D": 0.9886857932433486}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-2.7777777777777777, -5.0], 0.0], [1, [-1.6666666666666665, -5.0], 0.0], [1, [-0.5555555555555554, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [1.666666666666667, -5.0], 0.0], [1, [2.7777777777777786, -5.0], 0.0], [1, [3.8888888888888893, -5.0], 0.0], [1, [5.0, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [-3.888888888888889, -3.888888888888889], 0.0], [1, [-2.7777777777777777, -3.888888888888889], 0.0], [1, [-0.5555555555555554, -3.888888888888889], 0.0], [1, [0.5555555555555554, -3.888888888888889], 0.0], [1, [1.666666666666667, -3.888888888888889], 0.0], [1, [2.7777777777777786, -3.888888888888889], 0.0], [1, [3.8888888888888893, -3.888888888888889], 0.0], [1, [5.0, -3.888888888888889], 0.0], [1, [-5.0, -2.7777777777777777], 0.0], [1, [-3.888888888888889, -2.7777777777777777], 0.0], [1, [-2.7777777777777777, -2.7777777777777777], 0.0], [1, [-1.6666666666666665, -2.7777777777777777], 0.0], [1, [-0.5555555555555554, -2.7777777777777777], 0.0], [1, [0.5555555555555554, -2.7777777777777777], 0.0], [1, [1.666666666666667, -2.7777777777777777], 0.0], [1, [2.7777777777777786, -2.7777777777777777], 0.0], [1, [5.0, -2.7777777777777777], 0.0], [1, [-5.0, -1.6666666666666665], 0.0], [1, [-3.888888888888889, -1.6666666666666665], 0.0], [1, [-1.6666666666666665, -1.6666666666666665], 0.0], [1, [-0.5555555555555554, -1.6666666666666665], 0.0], [1, [0.5555555555555554, -1.6666666666666665], 0.0], [1, [1.666666666666667, -1.6666666666666665], 0.0], [1, [2.7777777777777786, -1.6666666666666665], 0.0], [1, [3.8888888888888893, -1.6666666666666665], 0.0], [1, [-5.0, -0.5555555555555554], 0.0], [1, [-3.888888888888889, -0.5555555555555554], 0.0], [1, [-2.7777777777777777, -0.5555555555555554], 0.0], [1, [-1.6666666666666665, -0.5555555555555554], 0.0], [1, [-0.5555555555555554, -0.5555555555555554], 0.0], [1, [0.5555555555555554, -0.5555555555555554], 0.0], [1, [1.666666666666667, -0.5555555555555554], 0.0], [1, [2.7777777777777786, -0.5555555555555554], 0.0], [1, [3.8888888888888893, -0.5555555555555554], 0.0], [1, [5.0, -0.5555555555555554], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-3.888888888888889, 0.5555555555555554], 0.0], [1, [-2.7777777777777777, 0.5555555555555554], 0.0], [1, [-1.6666666666666665, 0.5555555555555554], 0.0], [1, [-0.5555555555555554, 0.5555555555555554], 0.0], [1, [0.5555555555555554, 0.5555555555555554], 0.0], [1, [1.666666666666667, 0.5555555555555554], 0.0], [1, [2.7777777777777786, 0.5555555555555554], 0.0], [1, [3.8888888888888893, 0.5555555555555554], 0.0], [1, [5.0, 0.5555555555555554], 0.0], [1, [-5.0, 1.666666666666667], 0.0], [1, [-3.888888888888889, 1.666666666666667], 0.0], [1, [-2.7777777777777777, 1.666666666666667], 0.0], [1, [-1.6666666666666665, 1.666666666666667], 0.0], [1, [-0.5555555555555554, 1.666666666666667], 0.0], [1, [0.5555555555555554, 1.666666666666667], 0.0], [1, [1.666666666666667, 1.666666666666667], 0.0], [1, [2.7777777777777786, 1.666666666666667], 0.0], [1, [3.8888888888888893, 1.666666666666667], 0.0], [1, [5.0, 1.666666666666667], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [-3.888888888888889, 2.7777777777777786], 0.0], [1, [-2.7777777777777777, 2.7777777777777786], 0.0], [1, [-1.6666666666666665, 2.7777777777777786], 0.0], [1, [-0.5555555555555554, 2.7777777777777786], 0.0], [1, [0.5555555555555554, 2.7777777777777786], 0.0], [1, [1.666666666666667, 2.7777777777777786], 0.0], [1, [2.7777777777777786, 2.7777777777777786], 0.0], [1, [3.8888888888888893, 2.7777777777777786], 0.0], [1, [5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-2.7777777777777777, 3.8888888888888893], 0.0], [1, [-1.6666666666666665, 3.8888888888888893], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [0.5555555555555554, 3.8888888888888893], 0.0], [1, [1.666666666666667, 3.8888888888888893], 0.0], [1, [2.7777777777777786, 3.8888888888888893], 0.0], [1, [3.8888888888888893, 3.8888888888888893], 0.0], [1, [5.0, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [1, [-2.7777777777777777, 5.0], 0.0], [1, [-1.6666666666666665, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [1.666666666666667, 5.0], 0.0], [1, [2.7777777777777786, 5.0], 0.0], [1, [3.8888888888888893, 5.0], 0.0], [1, [5.0, 5.0], 0.0], [2, [4.27638340497915, -2.390283261687536], -4.1659666761536185], [1, [-1.728600270182422, -3.7655699730252254], -2.5790759200465625], [1, [-2.5926206974096973, -1.7855737174241], -3.2542747956725644]], "nr_of_basins": 99, "f_opt_dim_2": -3.46943456581744, "x_opt_dim_2": [-2.582337067472149, -1.8146607121777358], "f_opt_dim_5": 0.0, "x_opt_dim_5": [2.9546207508320665, 1.6274978822760464, 2.3707745511041294, -2.06921759577103, 1.5027395199097988]}
{"id": "c92a86b1-02c3-4334-abea-6eff8abf0180", "fitness": 0.6114257226387659, "name": "landscape_radial_pnorm_nonhomogeneous", "description": "A completely different non-homogeneous multi-basin landscape using anisotropic, non-quadratic radial wells. Each basin is defined by a rotated, axis-scaled p-norm distance from its center, with a unique exponent p_j and per-axis widths. The landscape is the minimum over these basins, ensuring a global minimum at the deepest basin center. This structure breaks basin-size homogeneity differently from quadratic forms by using a family of Lp-like wells with varying anisotropy and nonlinearity.", "code": "import numpy as np\n\nclass landscape_radial_pnorm_nonhomogeneous:\n    \"\"\"\n    Radial, anisotropic, non-quadratic wells landscape.\n    f(x) = min_j [ d_j + sum_k ( | (Q_j^T (x - c_j))_k | / w_j[k] )^p_j ]\n    - c_j: center of j-th basin (dim)\n    - Q_j: rotation matrix (dim x dim)\n    - w_j: per-axis widths (dim,)\n    - p_j: Lp-like exponent (scalar > 1)\n    - d_j: basin depth (smaller -> deeper)\n    The global minimum is at the deepest basin's center.\n    Domain: x in [-5, 5]^dim\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = dim\n        self.seed = seed\n\n        rng = np.random.default_rng(seed)\n\n        # Number of basins\n        M = max(4, min(25, dim * 3))\n        self.M = M\n\n        # Centers c_j in [-4, 4]^dim\n        self.c = rng.uniform(-4.0, 4.0, size=(M, dim))\n\n        # Per-basin random rotations Q_j\n        self.Q = np.empty((M, dim, dim), dtype=float)\n        for j in range(M):\n            A = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(A)\n            # Ensure a proper rotation (determinant possibly -1); flip if needed\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] = -Q[:, 0]\n            self.Q[j] = Q\n\n        # Per-basin per-axis widths w_j (positive)\n        self.w = rng.uniform(0.5, 3.0, size=(M, dim))\n\n        # Per-basin exponent p_j (>1)\n        self.p = rng.uniform(1.2, 3.0, size=(M,))\n\n        # Depths d_j (smaller -> deeper)\n        depths = rng.uniform(-4.0, 0.0, size=(M,))\n        deepest_idx = rng.integers(0, M)\n        depths[deepest_idx] = -10.0  # deepest basin\n        self.d = depths\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        # Compute min_j [ d_j + sum_k ( |(Q_j^T (x - c_j))_k| / w_j[k] )^p_j ]\n        vals = np.empty(self.M, dtype=float)\n        for j in range(self.M):\n            delta = x - self.c[j]\n            y = self.Q[j].T @ delta\n            term = np.sum((np.abs(y) / self.w[j]) ** self.p[j])\n            vals[j] = self.d[j] + term\n        return float(np.min(vals))", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_radial_pnorm_nonhomogeneous scored on:NOT Basins 0.875,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["ef5b7019-7e4f-4a40-b795-f98cd0125d67"], "operator": null, "metadata": {"ela_features_2D": [0.4262382922573262, 0.8301153990214163, 0.2900502157331773, 0.47018685409049954, 1.6240528033084405, 0.42565156435277396, 0.6851709021642796, 1.6727720784369566, 0.9387960079240217, -0.03978266002951136, -1.1248726546127663, 2.0, 0.5430456592992876, 0.7022869539537544, 0.4519614327180995, 0.3413901331342365, -0.1700055930933953, 0.17567721507888495, 0.24847734431775165, 0.33311106268156737, 0.5154016714483349, 0.1756699968894871, 0.24670646406145652, 0.33249789468818014, 0.5096986660046262, -0.43152078461837, -0.3934103334316751, -0.3491053554469639, -0.25368025525468374, -0.42396130459728687, -0.3874256917476583, -0.3433024153849108, -0.25216886120478127, 1.0, 1.0, 0.9333333333333332, 1.0, 0.52419286435237, 0.5241802886027355, 0.5234462391328203, 0.5496863312924036, 0.7242487656119205, 0.4094094094094093, 0.5851885621564374, -0.09509509509509506, 0.3718875502008032], "score_NOT Basins_2D": 0.9589584022760391, "ela_features": [0.27448127335294037, 0.6278015679063655, 0.015580267056509367, 0.23025375496068037, 21.30007973848882, 0.42293257006004215, 0.6023046767578284, 2.3239241552382683, 0.8095124194342613, 0.09643270515064921, -0.03377329558877058, 1.4, 0.8270384333485914, 0.8599066000992206, 0.6048662645151681, 0.19255734350163517, -0.3922074388906677, 0.4555740225817589, 0.5482787586685116, 0.6288523669790399, 0.7617383105444129, 0.4560777795901564, 0.5456416065765429, 0.624812436460987, 0.7558386003620094, -0.47883209660472587, -0.3972981932234879, -0.3264317465386563, -0.209553706414209, -0.480707184560685, -0.4015581831054873, -0.33158612859720593, -0.21578091967033722, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.22117244329230065, 0.22114482946816016, 0.21516012264152318, 0.25409793946792264, 0.8143440289633087, 0.1371371371371371, 0.20221133919096174, -0.4754754754754753, 0.5286858974358974], "score_NOT Basins_5D": 0.0004717111587524414, "ela_features_10D": [0.1615886361200401, 0.5693691514859337, 0.0030443288200025695, 0.14531398141588897, 160.5061173384934, 0.3022506266368105, 0.45741541382634043, 2.77985478571525, 0.6363278314381923, 0.09100580920966699, 0.02404610557852358, 1.4, 0.8540859599453103, 0.9214921287292903, 0.6092540374638493, 0.11910410332025041, -0.5430266396733244, 0.8537898468194778, 0.8712200379992326, 0.875774790275373, 0.8977473149604134, 0.859704653911515, 0.875272184534059, 0.8769244592368428, 0.8969845459973884, -0.18543240980190548, -0.16332769436979028, -0.15755127417446158, -0.1296840526044573, -0.17840529899856167, -0.15861349401567323, -0.15651328283504345, -0.13100342101474838, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.11074295739401112, 0.11074234644857872, 0.10893953823378191, 0.1281755093818079, 0.8553171766755014, -0.0910910910910911, 0.11843388621246678, -0.6996996996996996, 0.5836669335468375], "score_NOT Basins_10D": 0.8748470544815063}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[11, [2.5296490988513822, -3.977147433121422], -3.791631080536983], [15, [-3.6716240159764775, -3.8684996364272046], -3.3988821319995934], [74, [0.853352577822217, 1.835830099986886], -9.999999346163317]], "nr_of_basins": 3, "f_opt_dim_2": -10.0, "x_opt_dim_2": [0.8530862055617371, 1.8359724875325167], "f_opt_dim_5": -10.0, "x_opt_dim_5": [1.0328648952087593, 3.4172360280903833, -0.4769830611772664, 3.6367251960814104, -0.0008339916840425955]}
{"id": "b5570d18-7424-4eee-86b1-948be71cb86d", "fitness": 0.9965797782254716, "name": "landscape_sum_anisotropic_negative_gaussians", "description": "A sum-of-anisotropic-negative-Gaussian-wells landscape. Instead of taking a minimum across wells, this benchmark uses a sum of shifted, rotated Gaussian wells with negative depths. Each well has its own center, SPD covariance (elliptical shape), and depth, producing highly non-homogeneous basin sizes and shapes. The global minimum is the deepest combination of wells, while numerous, differently-sized basins create a rich, non-uniform search landscape within [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_sum_anisotropic_negative_gaussians:\n    \"\"\"\n    Sum of negative anisotropic Gaussian wells: f(x) = sum_i w_i * exp(-0.5 * (x - c_i)^T A_i (x - c_i)).\n    - dim: dimensionality of the search space\n    - The landscape is evaluated within [-5, 5]^dim.\n    - N wells grow with dimension to create a richer, non-homogeneous landscape.\n    - Each well i has:\n        - center c_i in [-5, 5]^dim\n        - a random SPD (elliptical) matrix A_i = Q_i * diag(lam) * Q_i^T\n        - a negative depth weight w_i < 0\n    - The function tends to 0 as ||x|| -> infinity, with minima near the wells.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=2024):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells scales with dimension to ensure diverse basins\n        self.N = max(6, min(128, 6 * dim))\n\n        # Centers inside the search space\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Negative amplitudes (depths) for each Gaussian\n        self.weights = -rng.uniform(low=0.5, high=3.0, size=self.N)\n\n        # Elliptical (anisotropic) Gaussian shapes per well\n        self.As = []\n        for _ in range(self.N):\n            M = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(M)\n            # Ensure a proper rotation with determinant +1\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues control widths along principal axes\n            lam = rng.uniform(low=0.5, high=12.0, size=dim)\n\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.As.append(A_i)\n\n        self.As = np.stack(self.As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D numpy array with length dim\n\n        Returns:\n        - scalar float value of the landscape at x\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        # Evaluate all wells and sum their contributions\n        total = 0.0\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            d2 = delta @ self.As[i] @ delta  # quadratic form with A_i\n            contrib = self.weights[i] * np.exp(-0.5 * d2)\n            total += contrib\n\n        return float(total)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_sum_anisotropic_negative_gaussians scored on:NOT Basins 0.996,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fe68083c-6bd7-48db-bfe2-5023dc46d938"], "operator": null, "metadata": {"ela_features_2D": [-0.0014801158601264186, 0.8774538491146451, 0.006111850953233041, 0.025135118441962635, 8.985181396451804, 0.0028365346849215543, 0.01915428534974344, 2.1638024419345854, 0.10941240718317324, -2.3176568099267576, 6.144429287843993, 3.0, 0.2132733113432975, 0.6163335827258356, 0.21366435246865909, 0.35682261593275943, -0.37280136141557685, 1.0290437692473822, 1.0402489429578718, 1.032996962605706, 0.9328191145924031, 1.2148949389254073, 1.217245698135528, 1.1449159859512315, 0.9322970324422097, 0.015197612737642686, 0.021057740355944966, 0.01726776418433713, -0.035147281009277755, 0.11058387558931879, 0.11163504675000076, 0.07448421857119783, -0.03478827243592194, 1.0, 1.0, 1.0, 1.0, 0.5097725933479167, 0.5096865461705253, 0.43640045172350667, 0.3504938325946674, 0.6296307201630331, 0.9939939939939937, 0.28402400078297874, -0.1071071071071071, 0.40120481927710844], "score_NOT Basins_2D": 0.9989866176620126, "ela_features": [0.0019686854957825075, 0.9893333748654272, 0.0015896343573139498, 0.007471815751878537, 6.919583780205848, 0.0034297606011983285, 0.0028424200515357436, 70.587220179108, 0.013851755225044626, -20.058244592948277, 460.2824303231049, 5.4, 0.4946108319751312, 0.7069482450449794, 0.27716965702956287, 0.29843162036833476, -0.15449222954984437, 0.8749742244304738, 0.8731717000732161, 0.8595638923255876, 0.8904815450744206, 0.9070279560445949, 0.889207182396673, 0.8631157846271439, 0.8888348069004129, -0.1099974790060237, -0.11157754767537938, -0.12354769940902992, -0.09634720242713948, -0.08226086797489848, -0.09801547995663533, -0.12108328083614725, -0.09832949916550937, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21252009256068277, 0.21252062620341947, 0.21166956943630072, 0.1815316572001215, 0.5257037682044701, -0.41541541541541527, 0.0, -Infinity, 0.3900641025641026], "score_NOT Basins_5D": 0.9948403034359217, "ela_features_10D": [0.00030400688842049386, 1.0004184759928194, 0.0002178144512310114, 0.0023760277794185854, 28.375524208324475, 0.002695881603911832, -6.244901977452422e-05, 20.267800645138617, -0.013985104456841646, -45.205686401092294, 2119.416157668525, 2.4, 0.5795870056172212, 0.6647823259573113, 0.27407848646962657, 0.20912930946688416, -0.14911311816292339, 0.9077162690861795, 1.0, 1.0, 1.0, 0.9097148781134725, 1.0, 1.0, 1.0, -0.11702978076665183, 0.0, 0.0, 0.0, -0.11477844261661092, 0.0, 0.0, 0.0, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11103940806629434, 0.11103825550134375, 0.11097923546414945, 0.10150605849056078, 0.17227706469945234, -5.000000000000001, 0.0, -Infinity, 0.057325860688550834], "score_NOT Basins_10D": 0.9959124135784805}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[6, [-4.212283574761449, -3.191763859799634], -1.1709631208318694], [7, [4.951699408233559, -3.5774564494064403], -2.5177429999338714], [8, [-2.929307018861803, -0.5782579223178168], -2.436703160856155], [12, [-1.4034942664661378, -3.303511319617334], -1.1701575873760663], [18, [0.8876717754528789, 1.167592165276522], -0.6772047054574291], [2, [-4.937801172560655, -0.3466504327929337], -1.168949804654089], [1, [-3.852454995181246, 0.6129700693074768], -1.6541692105815045], [9, [1.688749860593692, -2.7887852396494424], -1.070551903093215], [14, [4.760136634164128, 2.9992751793889627], -2.7223731803646287], [19, [-2.155278320819685, 3.2707432752132406], -1.9911314356290553], [4, [1.0101546270142883, -1.8189886031125808], -1.3283650728886611]], "nr_of_basins": 11, "f_opt_dim_2": -2.0497670185687995, "x_opt_dim_2": [-2.2428202209548735, 3.3522979239830155], "f_opt_dim_5": -2.0669453705222587, "x_opt_dim_5": [1.9611898360504318, -1.6314723423193074, -1.5800740194944247, -2.241591323750212, -2.4865626427620593]}
{"id": "20639b01-7fea-4aea-a891-20aa09f872f7", "fitness": 0.8284151231249174, "name": "landscape", "description": "A non-homogeneous, separable multi-well landscape with cross-dimension coupling to break basin-size homogeneity. Each dimension has its own set of irregular Gaussian wells, and a weak cross-term coupling between dimension pairs creates highly varied basin shapes and sizes, ensuring non-homogeneous basins while preserving a global minimum near the origin.", "code": "import numpy as np\n\nclass landscape:\n    \"\"\"\n    Non-homogeneous, separable landscape with cross-dimension coupling to break basin-size homogeneity.\n    Each dimension i has Ki irregular Gaussian wells with centers c_i_j, depths A_i_j and widths s_i_j.\n    A global cross-coupling term adds weak, non-separable interactions between pairs of dimensions.\n    The function remains a minimization problem with the global minimum near x=0.\n    \"\"\"\n    def __init__(self, dim=5, seed=0):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        self.wells = []\n        self.Ks = []\n        for i in range(self.dim):\n            Ki = rng.integers(3, 5)  # 3-4 wells per dimension\n            c = rng.uniform(-4.0, 4.0, size=(Ki,))\n            A = rng.uniform(0.6, 2.5, size=(Ki,))\n            s = rng.uniform(0.4, 1.8, size=(Ki,))\n\n            # Force a deep well at the origin for global minimum shaping\n            c[0] = 0.0\n            A[0] = rng.uniform(3.0, 6.0)\n            s[0] = rng.uniform(0.25, 0.9)\n\n            self.Ks.append(Ki)\n            self.wells.append({'c': c, 'A': A, 's': s})\n\n        # Cross-dimension coupling parameters to break basin-size homogeneity\n        # Symmetric gamma_ij for i<j\n        self.gamma = np.zeros((self.dim, self.dim), dtype=float)\n        for i in range(self.dim):\n            for j in range(i+1, self.dim):\n                self.gamma[i, j] = rng.uniform(0.3, 2.0)\n                self.gamma[j, i] = self.gamma[i, j]\n        # Per-dimension cross-term widths (controls how quickly the cross-term decays away from origin)\n        self.s_cross = rng.uniform(0.5, 2.0, size=(self.dim,))\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n        - x: 1D array-like of length self.dim\n        Returns:\n        - scalar value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n        val = 0.0\n\n        # Per-dimension wells (separable part)\n        for i in range(self.dim):\n            ci = self.wells[i]['c']\n            Ai = self.wells[i]['A']\n            si = self.wells[i]['s']\n            dx = x[i] - ci\n            dist2 = dx * dx\n            term = Ai * np.exp(-0.5 * dist2 / (si * si))\n            val -= np.sum(term)\n\n        # Cross-dimension coupling term to break basin-size homogeneity\n        for i in range(self.dim):\n            xi = x[i]\n            for j in range(i+1, self.dim):\n                xj = x[j]\n                # product of two 1D Gaussians centered at 0 with independent widths\n                cross = np.exp(-0.5 * (xi * xi) / (self.s_cross[i] * self.s_cross[i]))\n                cross *= np.exp(-0.5 * (xj * xj) / (self.s_cross[j] * self.s_cross[j]))\n                val -= self.gamma[i, j] * cross\n\n        return float(val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape scored on:NOT Basins 0.627,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["3d58d9cc-66ac-4242-b61d-80837608f749"], "operator": null, "metadata": {"ela_features_2D": [0.01785966489471442, 0.632565808682954, 0.05191697119749287, 0.09741202755006426, 1.8890089029374812, 0.016908692430756878, 0.48762885563908276, 5.488315104494309, 0.4927678748297713, -1.1465994844809866, 0.4696724005085021, 2.0, 0.5080905183875546, 0.6933210217852287, 0.4302497835098239, 0.34848030893460985, -0.2314227837786456, 0.3611046996543074, 0.5084656404859997, 0.6083853408700419, 0.6790193011352217, 0.22782699721326663, 0.44520177960992663, 0.5454221719533441, 0.6147639595325137, -0.33431222650803394, -0.2571884672480005, -0.20490466081623676, -0.16794779813260133, -0.3970800790993846, -0.28528929089865257, -0.23373983841490947, -0.19808926032995347, 1.0, 1.0, 1.0, 1.0, 0.5223715453351765, 0.5223604878783679, 0.41366869741978507, 0.3849936418085321, 0.701418397345214, 0.6816816816816814, 0.37118867643930364, -0.1591591591591591, 0.3975903614457831], "score_NOT Basins_2D": 0.9758933186531067, "ela_features": [0.024173634219227535, 0.6069607790962269, 0.005498886980048392, 0.07962672895671959, 23.60729545360358, 0.022204204646721924, 0.6074596493389283, 2.69860431469926, 0.6234311540625013, -0.8396729594700147, 0.5344005438777459, 1.4, 0.774932735076004, 0.8479541124798947, 0.5712904599532393, 0.20026292548108704, -0.4944904968944792, 0.5360297817924422, 0.621204669170438, 0.6936417168401694, 0.7848207942668768, 0.5241413542757849, 0.6130121067186771, 0.6865229256476517, 0.7787979241920704, -0.408105505044305, -0.33318827933293893, -0.26947236238368294, -0.1892708231370929, -0.42064619191685615, -0.34209083712376, -0.27710834678846374, -0.19553876405790213, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2175534347378516, 0.21756808941806693, 0.20350688347942988, 0.1950120159901258, 0.8355947563345898, 0.2772772772772772, 0.24073359895799934, -0.3713713713713712, 0.55625], "score_NOT Basins_5D": 0.882330946624279, "ela_features_10D": [0.029212108067730558, 0.7154790686057065, 0.001256682592742042, 0.05500997922762611, 53.019546634323184, 0.02690502885105337, 0.6172894397798849, 3.0969726899145984, 0.6285609387726083, -0.6818740296190211, 0.5899642361956045, 1.6, 0.911663094936474, 0.9217540266815976, 0.643633388544524, 0.11829716734680149, -0.6399924833449356, 0.7062454754556194, 0.7539915504911344, 0.7955387141453849, 0.8531481848352656, 0.7047472673425869, 0.7531150258987219, 0.7955267059313246, 0.853720044760126, -0.3725342647657741, -0.31198327496523226, -0.25929325526384617, -0.1862345292439592, -0.37537388583290804, -0.3138796106903733, -0.2599575530321815, -0.18597380585003614, 0.9, 0.9, 0.909090909090909, 0.909090909090909, 0.1104074570663485, 0.11041125830581347, 0.10766113066329346, 0.10862969526405233, 0.8552047499957034, -0.05105105105105105, 0.1308641123984538, -0.6476476476476474, 0.6047237790232185], "score_NOT Basins_10D": 0.6270211040973663}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[30, [-3.848889569538719, -0.01867391625169887], -11.820861347250617], [70, [0.051333676133979766, -0.01710615568265147], -13.131517914548143]], "nr_of_basins": 2, "f_opt_dim_2": -13.13151801216058, "x_opt_dim_2": [0.051416266694332045, -0.017210407320697767], "f_opt_dim_5": -43.35161118855386, "x_opt_dim_5": [0.042073844949824094, -0.013217481060791627, -0.014216123144474176, 0.06303479086304255, -0.03852261234843146]}
{"id": "198cfda6-e39f-4905-b5e7-4b272bf2eb66", "fitness": 0.9994119455235099, "name": "landscape_nh_elliptical_min_heterogeneous", "description": "A non-homogeneous basin landscape built as the minimum of multiple anisotropic Gaussian wells with widely varying widths and depths. Each well has a random center in [-5,5]^dim, a random SPD covariance derived from a random rotation and per-axis scales drawn from a log-uniform distribution to create basins ranging from very wide to extremely narrow. The global minimum lies at the deepest well. This setup drastically increases basin-size heterogeneity (NOT Basins) across the search space.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_min_heterogeneous:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple anisotropic Gaussian-like wells with\n    dramatically varying shapes and depths to break basin-size homogeneity.\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite covariance A_i = Q_i * diag(lambda_i) * Q_i^T (elliptical, rotated)\n      - depth weight w_i < 0 (negative, making wells minima)\n    The landscape f(x) = min_i w_i * exp(-0.5 * (x - c_i)^T A_i (x - c_i))\n    This creates basins of widely varying sizes and depths (non-homogeneous),\n    while the global minimum is at the deepest well.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure a rich landscape\n        self.N = max(6, min(256, 8 * dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Negative amplitudes (well depths) for each Gaussian\n        # Allow a wide range to produce very deep and shallow wells\n        self.weights = -rng.uniform(low=0.5, high=8.0, size=self.N)\n\n        # Elliptical (anisotropic) Gaussian shapes per well\n        # Each A_i = Q_i * diag(lambda_i) * Q_i^T, with Q_i ~ random orthogonal\n        # lambda_i drawn log-uniformly to create extremely different axis scales\n        As = []\n        for _ in range(self.N):\n            # Random rotation\n            M = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues (controls widths along principal axes)\n            # Sampled logarithmically to create very wide to very narrow basins\n            lam = 10**rng.uniform(low=-2.0, high=1.6, size=dim)  # ~0.01 to ~40\n\n            A_i = Q @ np.diag(lam) @ Q.T\n            As.append(A_i)\n\n        self.As = np.stack(As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        # Evaluate all wells and take the minimum\n        min_val = float('inf')\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            d2 = delta @ self.As[i] @ delta\n            v = self.weights[i] * np.exp(-0.5 * d2)\n            if v < min_val:\n                min_val = v\n\n        return float(min_val)", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_nh_elliptical_min_heterogeneous scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["fe68083c-6bd7-48db-bfe2-5023dc46d938"], "operator": null, "metadata": {"ela_features_2D": [0.3654992249182662, 0.5726292772773421, 0.24721768209437264, 0.39772747330405483, 1.6171637795141987, 0.4946782192819807, 0.41721075623086695, 8.15315363885484, 0.5765798161167424, -0.018271415563214457, -0.9988896463959888, 2.4, 0.2924389807973788, 0.6155072846358671, 0.24595250318840964, 0.3727196177434628, -0.2704270876133067, 0.6256699156974095, 0.7588249834973102, 0.7961753130829872, 0.7988299409047988, 0.596418054638155, 0.7750881304317064, 0.7930484913163725, 0.7105942146769523, -0.19578914230020442, -0.1261550364279418, -0.10661079622040233, -0.10521680094269655, -0.2070268415600826, -0.11536777341339169, -0.1061618191898687, -0.1484261004038152, 1.0, 1.0, 1.0, 1.0, 0.5141624167238967, 0.5141268524757188, 0.5006710169566257, 0.5331016863859145, 0.742684845177118, 1.2222222222222219, 0.48234969100281166, -0.12312312312312308, 0.4032128514056225], "score_NOT Basins_2D": 0.9983435687609017, "ela_features": [0.10785648833023873, 1.0130913331784284, 0.024166449758703863, 0.10068537120863301, 4.582398144809451, 0.14716105379509042, 0.12981808289569283, 7.310174132758358, 0.22554318486422442, -2.922305383915309, 9.770359745536872, 4.6, 0.6011323344190429, 0.8169534248902203, 0.446652749745813, 0.22404913545623878, -0.5286630771715168, 0.8246884651906269, 0.8567906525379609, 0.8793046683493945, 0.9207391676641722, 0.8247812284968393, 0.8551958065078274, 0.875868607321806, 0.9166020804417773, -0.15426968355753562, -0.12601466637957842, -0.1062047654738629, -0.06974375312108347, -0.15516328383543126, -0.12819119658859596, -0.10989011585472294, -0.0738242002370854, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21282575864424708, 0.21280820929121447, 0.20500483089631388, 0.2227000614467441, 0.7023646018191496, 0.5295295295295294, 0.0545315137421023, -0.7477477477477474, 0.6054487179487179], "score_NOT Basins_5D": 0.9999556142101937, "ela_features_10D": [0.009795276640253769, 1.0066827158571172, 0.000217424416889009, 0.008311399168944515, 54.73065088678702, 0.03847252540539923, 0.013946410042121294, 180.31757598140757, 0.049219343996529205, -27.185624798688348, 969.9435480791674, 4.8, 0.7454857200416637, 0.9019161373422208, 0.5317660366002794, 0.13636716935558016, -0.25799480795146346, 0.9116237023217441, 0.9161410750285242, 0.9313405578962237, 0.952791207010535, 0.9142655797979714, 0.9165706762725367, 0.9319650021377919, 0.9529111212798812, -0.11208631385221861, -0.10635503809017122, -0.08707814604316759, -0.05987208902717307, -0.10903606797818059, -0.10609941778515246, -0.08652196451930574, -0.05988155570120033, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10958922537142876, 0.10958262808829515, 0.10946840466144221, 0.10250808963610321, 0.6212278529891788, -0.7037037037037035, 1.1576715586911507e-05, -3.722722722722723, 0.6088871096877502], "score_NOT Basins_10D": 0.9999366535994341}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[10, [4.718242323226497, -1.2289937568884546], -6.017272517287619], [10, [-0.6053118417022441, 1.0910294965863863], -7.548737532603195], [13, [-4.247182742973591, 1.6761838696274265], -7.009045118394702], [21, [-2.708997218898183, -1.9398112640221594], -7.8256350421294165], [27, [-4.3991500275772495, 4.778005552670722], -6.812852403018936], [11, [2.3569131514350032, -2.774278343179745], -6.717415136041273], [8, [1.5790108222935988, 1.170347179287208], -7.4578816006413104]], "nr_of_basins": 7, "f_opt_dim_2": -7.550846767120434, "x_opt_dim_2": [-0.5899387806759665, 1.0987080930163455], "f_opt_dim_5": -6.21943481629785, "x_opt_dim_5": [0.36566237242464394, 2.3323165161881643, -0.5108920925393075, -1.9449922986825086, 4.473596033618093]}
{"id": "06966410-1d26-4159-bd60-5e91452e9e08", "fitness": 0.9981856346130371, "name": "landscape_compact_ellipsoidal_tents", "description": "A completely different non-homogeneous basin landscape built as the minimum of multiple compact ellipsoidal tents. Each tent is a non-Gaussian, compact ellipsoidal region with a linear (tent-like) depth falloff, defined by a random SPD shape and rotation. The global landscape is the minimum over all tents, yielding basins of highly varying sizes and depths, breaking basin-size homogeneity without using Gaussian wells.", "code": "import numpy as np\n\nclass landscape_compact_ellipsoidal_tents:\n    \"\"\"\n    Non-homogeneous landscape built as the minimum of multiple compact ellipsoidal tents.\n    Each tent i has:\n      - center c_i in [-5, 5]^dim\n      - a random SPD shape A_i = Q_i * diag(lambda_i) * Q_i^T\n      - a negative depth w_i (<0)\n    The tent contribution is:\n        phi_i(x) = max(0, w_i * (1 - sqrt((x - c_i)^T A_i (x - c_i))))\n    The landscape f(x) = min_i phi_i(x). Outside all tents, f(x) = 0.\n    This construction yields highly non-homogeneous basins with varying sizes and depths.\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = dim\n        # Deterministic seed derived from dimension for reproducibility\n        rng = np.random.default_rng(seed=(dim * 131) % (2**32))\n\n        # Number of tents grows with dimension to ensure a rich landscape\n        self.N = max(6, min(128, 4 * dim + 6))\n\n        # Centers of tents inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Negative depths (-the deeper, the smaller the function value at center)\n        self.weights = -rng.uniform(low=0.2, high=6.0, size=self.N)\n\n        # Ellipsoidal shapes per tent: A_i = Q_i * diag(lambda_i) * Q_i^T\n        As = []\n        for _ in range(self.N):\n            # Random rotation\n            M = rng.normal(size=(dim, dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues (controls widths along principal axes)\n            lam = rng.uniform(low=0.2, high=15.0, size=dim)\n\n            A_i = Q @ np.diag(lam) @ Q.T\n            As.append(A_i)\n\n        self.As = np.stack(As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        min_val = 0.0  # outside all tents, f = 0\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            d = delta @ self.As[i] @ delta  # delta^T A_i delta\n            r = np.sqrt(d)\n\n            if r <= 1.0:\n                val = self.weights[i] * (1.0 - r)  # negative depth inside tent\n            else:\n                val = 0.0\n\n            if val < min_val:\n                min_val = val\n\n        return float(min_val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_compact_ellipsoidal_tents scored on:NOT Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["198cfda6-e39f-4905-b5e7-4b272bf2eb66"], "operator": null, "metadata": {"ela_features_2D": [0.0017149459374228738, 0.9894645124181931, 0.003591873924097963, 0.021766635986291073, 15.956561262315223, 0.0002574771513598639, 0.011070039833542756, 1.711083843045704, 0.02039060733423572, -6.455248440379288, 46.26455253511092, 6.8, 0.12909354548668542, 0.16594896400346842, 0.052015551028116724, 0.9403388855127697, -0.4771684171937853, 0.7951075568199759, 0.7751844196442562, 1.0, 1.0, 0.8727078387485172, 0.8163605829131348, 1.0, 1.0, -0.10719517628007065, -0.11761734579070818, 0.0, 0.0, -0.06535482158991653, -0.09432898698415107, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.518090725592596, 0.5180707466611529, 0.48859203450690225, 0.3601783359679423, 0.22047747885335495, 1.282282282282282, 0.13938114543418914, 0.4614614614614613, 0.0783132530120482], "score_NOT Basins_2D": 0.9989866176620126, "ela_features": [-0.002105282966226918, 0.989919813043158, 0.00444492314135524, 0.014682110760145329, 3.3031191526224704, -0.0038202802541895675, 0.029170789606776437, 1.055412290601333, 0.03621123677338245, -6.566793534634191, 46.96131153742514, 8.0, 0.13079490215681672, 0.16174410974422088, 0.0833532638703133, 0.9387065863413087, -0.390152415533166, 0.5773104941559444, 0.5826206282771703, 1.0, 1.0, 0.6662157116301978, 0.6537219108199759, 1.0, 1.0, -0.22122377674674346, -0.21844460217749653, 0.0, 0.0, -0.1713629577126523, -0.17777720408227282, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5106166248782079, 0.5105687348043325, 0.48073537235576047, 0.35106143283415164, 0.23184415154912483, 1.2662662662662658, 0.07617931797451333, 0.22522522522522515, 0.08433734939759037], "score_NOT Basins_5D": 0.9977851430885494, "ela_features_10D": [-0.002105282966226918, 0.989919813043158, 0.00444492314135524, 0.014682110760145329, 3.3031191526224704, -0.0038202802541895675, 0.029170789606776437, 1.055412290601333, 0.03621123677338245, -6.566793534634191, 46.96131153742514, 8.0, 0.13079490215681672, 0.16174410974422088, 0.0833532638703133, 0.9387065863413087, -0.390152415533166, 0.5773104941559444, 0.5826206282771703, 1.0, 1.0, 0.6662157116301978, 0.6537219108199759, 1.0, 1.0, -0.22122377674674346, -0.21844460217749653, 0.0, 0.0, -0.1713629577126523, -0.17777720408227282, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5106166248782079, 0.5105687348043325, 0.48073537235576047, 0.35106143283415164, 0.24057674011886238, 1.2662662662662658, 0.07481509358416528, 0.23723723723723716, 0.0855421686746988], "score_NOT Basins_10D": 0.9977851430885494}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-2.7777777777777777, -5.0], 0.0], [1, [-1.6666666666666665, -5.0], 0.0], [1, [-0.5555555555555554, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [1.666666666666667, -5.0], 0.0], [1, [2.7777777777777786, -5.0], 0.0], [1, [3.8888888888888893, -5.0], 0.0], [1, [5.0, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [-3.888888888888889, -3.888888888888889], 0.0], [1, [-2.7777777777777777, -3.888888888888889], 0.0], [1, [-1.6666666666666665, -3.888888888888889], 0.0], [1, [-0.5555555555555554, -3.888888888888889], 0.0], [1, [0.5555555555555554, -3.888888888888889], 0.0], [1, [1.666666666666667, -3.888888888888889], 0.0], [1, [2.7777777777777786, -3.888888888888889], 0.0], [1, [3.8888888888888893, -3.888888888888889], 0.0], [1, [5.0, -3.888888888888889], 0.0], [1, [-5.0, -2.7777777777777777], 0.0], [1, [-3.888888888888889, -2.7777777777777777], 0.0], [1, [-2.7777777777777777, -2.7777777777777777], 0.0], [1, [-1.6666666666666665, -2.7777777777777777], 0.0], [1, [-0.5555555555555554, -2.7777777777777777], 0.0], [1, [0.5555555555555554, -2.7777777777777777], 0.0], [1, [1.666666666666667, -2.7777777777777777], 0.0], [1, [2.7777777777777786, -2.7777777777777777], 0.0], [1, [3.8888888888888893, -2.7777777777777777], 0.0], [1, [5.0, -2.7777777777777777], 0.0], [1, [-5.0, -1.6666666666666665], 0.0], [1, [-3.888888888888889, -1.6666666666666665], 0.0], [1, [-2.7777777777777777, -1.6666666666666665], 0.0], [1, [-1.6666666666666665, -1.6666666666666665], -4.204832714395068], [1, [-0.5555555555555554, -1.6666666666666665], 0.0], [1, [0.5555555555555554, -1.6666666666666665], 0.0], [1, [1.666666666666667, -1.6666666666666665], 0.0], [1, [2.7777777777777786, -1.6666666666666665], 0.0], [1, [3.8888888888888893, -1.6666666666666665], 0.0], [1, [5.0, -1.6666666666666665], 0.0], [1, [-5.0, -0.5555555555555554], 0.0], [1, [-3.888888888888889, -0.5555555555555554], 0.0], [1, [-2.7777777777777777, -0.5555555555555554], -1.875778203290798], [1, [-1.6666666666666665, -0.5555555555555554], 0.0], [1, [-0.5555555555555554, -0.5555555555555554], 0.0], [1, [0.5555555555555554, -0.5555555555555554], 0.0], [1, [1.666666666666667, -0.5555555555555554], 0.0], [1, [2.7777777777777786, -0.5555555555555554], 0.0], [1, [3.8888888888888893, -0.5555555555555554], 0.0], [1, [5.0, -0.5555555555555554], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-3.888888888888889, 0.5555555555555554], 0.0], [1, [-2.7777777777777777, 0.5555555555555554], 0.0], [1, [-1.6666666666666665, 0.5555555555555554], 0.0], [1, [-0.5555555555555554, 0.5555555555555554], 0.0], [1, [0.5555555555555554, 0.5555555555555554], 0.0], [1, [1.666666666666667, 0.5555555555555554], 0.0], [1, [2.7777777777777786, 0.5555555555555554], 0.0], [1, [3.8888888888888893, 0.5555555555555554], 0.0], [1, [5.0, 0.5555555555555554], 0.0], [1, [-5.0, 1.666666666666667], 0.0], [1, [-3.888888888888889, 1.666666666666667], 0.0], [1, [-2.7777777777777777, 1.666666666666667], 0.0], [1, [-1.6666666666666665, 1.666666666666667], 0.0], [1, [-0.5555555555555554, 1.666666666666667], 0.0], [1, [0.5555555555555554, 1.666666666666667], 0.0], [1, [1.666666666666667, 1.666666666666667], 0.0], [1, [2.7777777777777786, 1.666666666666667], 0.0], [1, [3.8888888888888893, 1.666666666666667], 0.0], [1, [5.0, 1.666666666666667], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [-3.888888888888889, 2.7777777777777786], 0.0], [1, [-2.7777777777777777, 2.7777777777777786], 0.0], [1, [-1.6666666666666665, 2.7777777777777786], 0.0], [1, [-0.5555555555555554, 2.7777777777777786], 0.0], [1, [0.5555555555555554, 2.7777777777777786], 0.0], [1, [1.666666666666667, 2.7777777777777786], 0.0], [1, [2.7777777777777786, 2.7777777777777786], 0.0], [1, [3.8888888888888893, 2.7777777777777786], -1.4727260359726915], [1, [5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-2.7777777777777777, 3.8888888888888893], 0.0], [1, [-1.6666666666666665, 3.8888888888888893], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [0.5555555555555554, 3.8888888888888893], 0.0], [1, [1.666666666666667, 3.8888888888888893], 0.0], [1, [2.7777777777777786, 3.8888888888888893], 0.0], [1, [3.8888888888888893, 3.8888888888888893], 0.0], [1, [5.0, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [1, [-2.7777777777777777, 5.0], 0.0], [1, [-1.6666666666666665, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [1.666666666666667, 5.0], 0.0], [1, [2.7777777777777786, 5.0], 0.0], [1, [3.8888888888888893, 5.0], 0.0], [1, [5.0, 5.0], 0.0]], "nr_of_basins": 100, "f_opt_dim_2": -3.5390210311678776, "x_opt_dim_2": [3.794987953560165, -4.559227288662624], "f_opt_dim_5": 0.0, "x_opt_dim_5": [0.7612568149367919, -0.02724019154268444, -0.43688123436176274, 0.33183696181755956, -1.6450854438112186]}
{"id": "bd6e49db-a3ee-49a3-b948-bb4dc979bd1e", "fitness": 0.9977161723654717, "name": "landscape_rotated_l1_bumps_min", "description": "A completely different non-homogeneous landscape built as the pointwise minimum of rotated L1-based pyramidal bumps. Each bump defines a diamond-shaped footprint in a rotated coordinate frame, with per-axis widths and random orientation. Inside a bump, the value is a linear (in the rotated L1 distance) bowl with negative depth; outside, the bump contributes zero. The global minimum is at the deepest bump center, while basins vary widely in size, orientation, and depth, breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_rotated_l1_bumps_min:\n    \"\"\"\n    Non-homogeneous landscape built as the pointwise minimum of multiple rotated L1-bumps.\n    Each bump i has:\n      - center c_i in [-5, 5]^dim\n      - a random rotation R_i (orthogonal matrix)\n      - per-axis widths a_i (positive, controlling the L1 footprint in the rotated frame)\n      - depth w_i < 0 (negative, creating a bowl at the center)\n    The footprint is defined by y = R_i @ (x - c_i) and s = sum_j |y_j| / a_ij <= 1.\n    Inside the footprint: f_i(x) = w_i * (1 - s); outside: f_i(x) = 0.\n    The landscape is f(x) = min_i f_i(x).\n    This construction yields highly non-homogeneous basins in [-5,5]^dim.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Number of bumps grows with dimension, but capped for practicality\n        self.N = max(4, min(96, 3 * self.dim))\n\n        # Centers inside the search space\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, self.dim))\n\n        # Negative depths for each bump\n        self.weights = -rng.uniform(low=0.5, high=5.0, size=self.N)\n\n        # Rotations (orthogonal matrices) for each bump\n        self.Rs = []\n        for _ in range(self.N):\n            M = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            self.Rs.append(Q)\n        self.Rs = np.stack(self.Rs, axis=0)  # shape (N, dim, dim)\n\n        # Per-bump axis widths (positive real values)\n        self.as_ = []\n        for _ in range(self.N):\n            a = rng.uniform(low=0.4, high=4.0, size=self.dim)\n            # Avoid degenerate too-small widths\n            a[a < 0.1] = 0.1\n            self.as_.append(a)\n        self.as_ = np.stack(self.as_, axis=0)  # shape (N, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        vals = []\n        for i in range(self.N):\n            delta = x - self.centers[i]\n            y = self.Rs[i] @ delta  # rotate into bump's frame\n            a = self.as_[i]\n            s = np.sum(np.abs(y) / a)  # L1-distance-like footprint in rotated frame\n            if s <= 1.0:\n                v = self.weights[i] * (1.0 - s)\n                vals.append(v)\n            else:\n                vals.append(0.0)\n\n        return float(np.min(vals))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_rotated_l1_bumps_min scored on:NOT Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["10bdf029-ebd3-49a4-bfe7-37cfbc5b2f09"], "operator": null, "metadata": {"ela_features_2D": [0.23565345705372237, 0.921205440637611, 0.22876039737306603, 0.27829638649058824, 1.2147317487452831, 0.273214030335785, 0.3254623281140437, 1.8084505167333933, 0.5870339911159709, -2.3071174441694606, 4.686791705352602, 2.2, 0.11612738749706117, 0.20463218975461878, 0.08559201510970564, 0.8415767079736265, -0.08749384913666022, 0.3136139518503466, 0.42273006907174454, 0.6593501607860596, 0.791858300847433, 0.19469137566120037, 0.26213564300642406, 0.46392064131076083, 0.8494343072578069, -0.35891777462052665, -0.30182663676886556, -0.17810612773478982, -0.10882524165182503, -0.4125007216446388, -0.3779573326927693, -0.2745875484773955, -0.07713151583776068, 1.0, 1.0, 1.0, 1.0, 0.5060537381688409, 0.5060373764866356, 0.46909113348992265, 0.4944911006364793, 0.4066501524478623, 0.8738738738738736, 1.2904719845275756, 0.3813813813813812, 0.16224899598393575], "score_NOT Basins_2D": 0.997915129410103, "ela_features": [-0.00011749463107095792, 1.0016747952159908, 0.0009458948786169556, 0.004760098761717174, 16.288759328055225, -0.000930043196371777, -0.0005639410622304775, 16.731656415916227, -0.006064741582574418, -30.546918391661865, 979.5698718493189, 3.0, 0.2518013836647418, 0.25107564344817107, 0.11877234963839498, 0.41181445372670034, -0.7988861735318411, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21639168806984194, 0.21641901070485964, 0.2158719583142103, 0.18291941334142547, 0.02114861598079391, -Infinity, 0.0026180452815616428, -0.25125125125125136, 0.003365384615384615], "score_NOT Basins_5D": 0.9976166938431561, "ela_features_10D": [0.004164124694335136, 1.0063364257018055, 0.0010469168118023425, 0.008693975973402514, 8.30436179397598, 0.011441992567352455, 0.0062405518651235115, 6.485657222589483, 0.02714390933819677, -22.138449653011968, 521.0264445581859, 5.0, 0.27487693632760113, 0.27039509697063446, 0.1418068427418939, 0.4232926361176464, -0.5445243372709292, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2078957825038045, 0.20792112077202143, 0.2071826908778429, 0.1821168057634948, 0.02558192249009138, -Infinity, 0.004052700659496584, 0.30530530530530525, 0.004326923076923077], "score_NOT Basins_10D": 0.9976166938431561}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-2.7777777777777777, -5.0], 0.0], [1, [-0.5555555555555554, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [1.666666666666667, -5.0], 0.0], [1, [2.7777777777777786, -5.0], 0.0], [1, [3.8888888888888893, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [-3.888888888888889, -3.888888888888889], 0.0], [1, [0.5555555555555554, -3.888888888888889], 0.0], [1, [1.666666666666667, -3.888888888888889], 0.0], [1, [-5.0, -2.7777777777777777], 0.0], [1, [-3.888888888888889, -2.7777777777777777], 0.0], [1, [-2.7777777777777777, -2.7777777777777777], 0.0], [1, [-0.5555555555555554, -2.7777777777777777], 0.0], [1, [0.5555555555555554, -2.7777777777777777], 0.0], [1, [1.666666666666667, -2.7777777777777777], 0.0], [1, [-5.0, -1.6666666666666665], 0.0], [1, [-3.888888888888889, -1.6666666666666665], 0.0], [1, [-1.6666666666666665, -1.6666666666666665], 0.0], [1, [-0.5555555555555554, -1.6666666666666665], 0.0], [1, [0.5555555555555554, -1.6666666666666665], 0.0], [1, [1.666666666666667, -1.6666666666666665], 0.0], [1, [-5.0, -0.5555555555555554], 0.0], [1, [-3.888888888888889, -0.5555555555555554], 0.0], [1, [-2.7777777777777777, -0.5555555555555554], 0.0], [1, [-1.6666666666666665, -0.5555555555555554], 0.0], [1, [-0.5555555555555554, -0.5555555555555554], 0.0], [1, [0.5555555555555554, -0.5555555555555554], 0.0], [1, [1.666666666666667, -0.5555555555555554], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-3.888888888888889, 0.5555555555555554], 0.0], [1, [-2.7777777777777777, 0.5555555555555554], 0.0], [1, [0.5555555555555554, 0.5555555555555554], 0.0], [1, [1.666666666666667, 0.5555555555555554], 0.0], [1, [-5.0, 1.666666666666667], 0.0], [1, [-3.888888888888889, 1.666666666666667], 0.0], [1, [-2.7777777777777777, 1.666666666666667], 0.0], [1, [-1.6666666666666665, 1.666666666666667], 0.0], [1, [1.666666666666667, 1.666666666666667], 0.0], [1, [2.7777777777777786, 1.666666666666667], 0.0], [1, [3.8888888888888893, 1.666666666666667], 0.0], [1, [5.0, 1.666666666666667], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [-3.888888888888889, 2.7777777777777786], 0.0], [1, [-2.7777777777777777, 2.7777777777777786], 0.0], [1, [-1.6666666666666665, 2.7777777777777786], 0.0], [1, [-0.5555555555555554, 2.7777777777777786], 0.0], [1, [0.5555555555555554, 2.7777777777777786], 0.0], [1, [1.666666666666667, 2.7777777777777786], 0.0], [1, [2.7777777777777786, 2.7777777777777786], 0.0], [1, [3.8888888888888893, 2.7777777777777786], 0.0], [1, [5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-2.7777777777777777, 3.8888888888888893], 0.0], [1, [-1.6666666666666665, 3.8888888888888893], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [0.5555555555555554, 3.8888888888888893], 0.0], [1, [1.666666666666667, 3.8888888888888893], 0.0], [1, [2.7777777777777786, 3.8888888888888893], 0.0], [1, [3.8888888888888893, 3.8888888888888893], 0.0], [1, [5.0, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [1, [-2.7777777777777777, 5.0], 0.0], [1, [-1.6666666666666665, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [1.666666666666667, 5.0], 0.0], [1, [2.7777777777777786, 5.0], 0.0], [1, [3.8888888888888893, 5.0], 0.0], [1, [5.0, 5.0], 0.0], [1, [4.597080245532332, -2.285050688485385], -3.6634467815843914], [5, [-1.7970816686930164, -3.8194311485946324], -3.5111647223832914], [8, [3.952362556989534, -2.4463392574310543], -3.7618193460427665], [7, [4.29303769074854, -1.5927832875827281], -3.693912635178409], [4, [-0.5811641351143473, 1.087377018831626], -1.4871619775886507], [1, [-2.514312481450168, -1.849341123470712], -3.2514702790012375]], "nr_of_basins": 80, "f_opt_dim_2": -3.5369659100736275, "x_opt_dim_2": [-1.8090294158580242, -3.819087670333572], "f_opt_dim_5": -0.007190186114443145, "x_opt_dim_5": [3.764863081732069, -1.1237200695361722, 3.799714627359321, -2.002114084512227, -2.56206203760121]}
{"id": "d8e47fd4-7e83-47d1-87ef-287170b180b4", "fitness": 0.9910620968439616, "name": "landscape_nh_elliptical_inverted_tents_enhanced", "description": "A high-heterogeneity non-homogeneous multi-well landscape built from anisotropic, truncated elliptical wells with varied shapes, orientations, radii, and non-Gaussian interior profiles (tent-like). The landscape uses a per-well exponent to shape the interior bowl, and the global landscape is the pointwise minimum across all wells, producing highly irregular basin sizes and complex interactions that break basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_inverted_tents_enhanced:\n    \"\"\"\n    Enhanced non-homogeneous landscape: minimum over many truncated\n    elliptical wells with anisotropic, non-Gaussian interiors.\n\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite rotated covariance A_i (ellipsoid)\n      - a radius r_i defining the ellipsoidal interior\n      - a negative depth depth_i < 0 (well depth)\n      - an interior exponent s_i > 0 that controls the tent shape:\n        inside: tent_i = 1 - (d_i / r_i) ** s_i, where d_i is the ellipsoidal distance\n        d_i = sqrt( (x - c_i)^T A_i (x - c_i) )\n      - outside the ellipsoid, the well contribution equals depth_i\n    The landscape is f(x) = min_i f_i(x), where f_i = depth_i - tent_i inside,\n    and f_i = depth_i outside. This creates highly non-homogeneous basin sizes\n    and non-separable interactions across the search space.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure richly non-homogeneous basins\n        self.N = max(8, min(128, 6 * dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Ellipsoidal wells: SPD matrices A_i\n        self.As = []\n        self.radii = np.zeros(self.N, dtype=float)\n        self.depths = np.zeros(self.N, dtype=float)\n        self.exponents = np.zeros(self.N, dtype=float)\n\n        for i in range(self.N):\n            # Random rotation (orthogonal matrix)\n            M = rng.normal(size=(dim, dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues controlling axis scales (anisotropy)\n            lam = rng.uniform(low=0.4, high=14.0, size=dim)\n            A_i = Q @ np.diag(lam) @ Q.T  # SPD\n\n            self.As.append(A_i)\n\n            # Ellipsoid radius (defines interior region)\n            self.radii[i] = rng.uniform(low=0.4, high=4.0)\n\n            # Negative depth (well depth)\n            self.depths[i] = -rng.uniform(low=0.5, high=8.0)\n\n            # Interior exponent s_i to shape the tent (non-Gaussian)\n            self.exponents[i] = rng.uniform(low=0.5, high=3.0)\n\n        self.As = np.stack(self.As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        # Compute all well contributions and take the minimum\n        vals = []\n        for i in range(self.N):\n            delta = x - self.centers[i]  # (dim,)\n            d2 = delta @ self.As[i] @ delta  # quadratic form\n            d = np.sqrt(max(d2, 0.0))\n\n            # Tent shape inside ellipsoid: 1 - (d / r_i) ** s_i\n            tent = 0.0\n            if d <= self.radii[i]:\n                tent = 1.0 - (d / self.radii[i]) ** self.exponents[i]\n\n            f_i = self.depths[i] - tent  # inside: depth - tent; outside: depth\n            vals.append(f_i)\n\n        return float(min(vals))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_elliptical_inverted_tents_enhanced scored on:NOT Basins 0.987,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19e2b275-334e-40e1-b107-afbc6748db37"], "operator": null, "metadata": {"ela_features_2D": [0.012217237263700498, 1.0079839079318247, 0.008629515979798542, 0.03937274258535069, 9.4781738003781, 0.011175946547595083, 0.018354621465517317, 1.4059289655509644, 0.04917331703804377, -7.380492894601417, 62.904048340798816, 6.6, 0.06533883859097393, 0.086210802865984, 0.009327120380331148, 1.246221566163476, -0.23186362918244222, 0.48053255136418815, 1.0, 1.0, 1.0, 0.348460625211808, 1.0, 1.0, 1.0, -0.27164037777448397, 0.0, 0.0, 0.0, -0.33440986685144514, 0.0, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.516369502564874, 0.5163640803400129, 0.49124819215531124, 0.37764101441330233, 0.12739677301645363, 0.9939939939939937, 1.514102318545668, 0.6376376376376374, 0.032530120481927716], "score_NOT Basins_2D": 0.9992319892044179, "ela_features": [-0.0001605063562985176, 1.0012149298788349, 0.0010870884508262465, 0.004020090791130179, 4.200540530665755, -0.002105965876187765, -0.00040623744056429435, 93.52674791881023, -0.0072627974606515044, -34.961805614262175, 1226.866378802933, 1.2, 0.19364842558372547, 0.1997816986097983, 0.09662820070596381, 0.46146238213760327, -0.9852547984150428, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21926933623293796, 0.21932746530944652, 0.21884979615326108, 0.18528051541811955, 0.011105728229303067, -Infinity, 0.005343165343815587, 0.4574574574574573, 0.0011217948717948717], "score_NOT Basins_5D": 0.9869771506637335, "ela_features_10D": [0.00026723245192350475, 1.0017076544604924, 0.0012891714312108808, 0.003983780827644943, 3.0901870233837676, -5.7033396110961476e-05, -0.00029949035169862803, 151.13149303309964, -0.009341306002961458, -35.27053150041898, 1243.0047980799993, 1.0, 0.1924538556553942, 0.1870359485624951, 0.09983216289756901, 0.4735477356917605, -0.9999999999999993, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21928094578528054, 0.2193365950296084, 0.21886473354736027, 0.1858740610883334, 0.009564751735344334, -Infinity, 0.006462772491784145, 0.6406406406406405, 0.0008012820512820513], "score_NOT Basins_10D": 0.9869771506637335}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -7.616262616547005], [1, [-3.888888888888889, -5.0], -7.616262616547005], [1, [-2.7777777777777777, -5.0], -7.616262616547005], [1, [-1.6666666666666665, -5.0], -7.616262616547005], [1, [-0.5555555555555554, -5.0], -7.616262616547005], [1, [0.5555555555555554, -5.0], -7.616262616547005], [1, [1.666666666666667, -5.0], -7.616262616547005], [1, [2.7777777777777786, -5.0], -7.616262616547005], [1, [3.8888888888888893, -5.0], -7.616262616547005], [1, [5.0, -5.0], -7.616262616547005], [1, [-5.0, -3.888888888888889], -7.616262616547005], [1, [-3.888888888888889, -3.888888888888889], -7.616262616547005], [1, [-2.7777777777777777, -3.888888888888889], -7.616262616547005], [1, [-1.6666666666666665, -3.888888888888889], -7.616262616547005], [1, [-0.5555555555555554, -3.888888888888889], -7.616262616547005], [1, [0.5555555555555554, -3.888888888888889], -7.616262616547005], [1, [1.666666666666667, -3.888888888888889], -7.616262616547005], [1, [2.7777777777777786, -3.888888888888889], -7.616262616547005], [1, [3.8888888888888893, -3.888888888888889], -7.616262616547005], [1, [5.0, -3.888888888888889], -7.616262616547005], [1, [-5.0, -2.7777777777777777], -7.616262616547005], [1, [-3.888888888888889, -2.7777777777777777], -7.616262616547005], [1, [-2.7777777777777777, -2.7777777777777777], -7.616262616547005], [1, [-1.6666666666666665, -2.7777777777777777], -7.616262616547005], [1, [-0.5555555555555554, -2.7777777777777777], -7.616262616547005], [1, [0.5555555555555554, -2.7777777777777777], -7.616262616547005], [1, [1.666666666666667, -2.7777777777777777], -7.616262616547005], [1, [2.7777777777777786, -2.7777777777777777], -7.616262616547005], [1, [3.8888888888888893, -2.7777777777777777], -7.616262616547005], [1, [5.0, -2.7777777777777777], -7.616262616547005], [1, [-5.0, -1.6666666666666665], -7.616262616547005], [1, [-3.888888888888889, -1.6666666666666665], -7.616262616547005], [1, [-2.7777777777777777, -1.6666666666666665], -7.616262616547005], [1, [-1.6666666666666665, -1.6666666666666665], -7.616262616547005], [1, [-0.5555555555555554, -1.6666666666666665], -7.616262616547005], [1, [0.5555555555555554, -1.6666666666666665], -7.616262616547005], [1, [1.666666666666667, -1.6666666666666665], -7.616262616547005], [1, [2.7777777777777786, -1.6666666666666665], -7.616262616547005], [1, [3.8888888888888893, -1.6666666666666665], -7.616262616547005], [1, [5.0, -1.6666666666666665], -7.616262616547005], [1, [-5.0, -0.5555555555555554], -7.616262616547005], [1, [-3.888888888888889, -0.5555555555555554], -7.616262616547005], [1, [-2.7777777777777777, -0.5555555555555554], -7.616262616547005], [1, [-1.6666666666666665, -0.5555555555555554], -7.616262616547005], [1, [-0.5555555555555554, -0.5555555555555554], -7.616262616547005], [1, [0.5555555555555554, -0.5555555555555554], -7.616262616547005], [1, [1.666666666666667, -0.5555555555555554], -7.616262616547005], [1, [2.7777777777777786, -0.5555555555555554], -7.616262616547005], [1, [3.8888888888888893, -0.5555555555555554], -7.616262616547005], [1, [5.0, -0.5555555555555554], -7.616262616547005], [1, [-5.0, 0.5555555555555554], -7.616262616547005], [1, [-3.888888888888889, 0.5555555555555554], -7.616262616547005], [1, [-2.7777777777777777, 0.5555555555555554], -7.616262616547005], [1, [-1.6666666666666665, 0.5555555555555554], -7.616262616547005], [1, [-0.5555555555555554, 0.5555555555555554], -7.616262616547005], [1, [0.5555555555555554, 0.5555555555555554], -7.616262616547005], [1, [2.7777777777777786, 0.5555555555555554], -7.616262616547005], [1, [3.8888888888888893, 0.5555555555555554], -7.616262616547005], [1, [5.0, 0.5555555555555554], -7.616262616547005], [1, [-5.0, 1.666666666666667], -7.616262616547005], [1, [-3.888888888888889, 1.666666666666667], -7.616262616547005], [1, [-2.7777777777777777, 1.666666666666667], -7.616262616547005], [1, [-1.6666666666666665, 1.666666666666667], -7.616262616547005], [1, [-0.5555555555555554, 1.666666666666667], -7.616262616547005], [1, [0.5555555555555554, 1.666666666666667], -7.616262616547005], [1, [2.7777777777777786, 1.666666666666667], -7.616262616547005], [1, [3.8888888888888893, 1.666666666666667], -7.616262616547005], [1, [5.0, 1.666666666666667], -7.616262616547005], [1, [-5.0, 2.7777777777777786], -7.616262616547005], [1, [-3.888888888888889, 2.7777777777777786], -7.616262616547005], [1, [-2.7777777777777777, 2.7777777777777786], -7.616262616547005], [1, [-1.6666666666666665, 2.7777777777777786], -7.616262616547005], [1, [-0.5555555555555554, 2.7777777777777786], -7.616262616547005], [1, [0.5555555555555554, 2.7777777777777786], -7.616262616547005], [1, [2.7777777777777786, 2.7777777777777786], -7.616262616547005], [1, [3.8888888888888893, 2.7777777777777786], -7.616262616547005], [1, [5.0, 2.7777777777777786], -7.616262616547005], [1, [-5.0, 3.8888888888888893], -7.616262616547005], [1, [-3.888888888888889, 3.8888888888888893], -7.616262616547005], [1, [-2.7777777777777777, 3.8888888888888893], -7.653320600056925], [1, [-1.6666666666666665, 3.8888888888888893], -7.616262616547005], [1, [-0.5555555555555554, 3.8888888888888893], -7.616262616547005], [1, [0.5555555555555554, 3.8888888888888893], -7.616262616547005], [1, [1.666666666666667, 3.8888888888888893], -7.616262616547005], [1, [2.7777777777777786, 3.8888888888888893], -7.616262616547005], [1, [3.8888888888888893, 3.8888888888888893], -7.616262616547005], [1, [5.0, 3.8888888888888893], -7.616262616547005], [1, [-5.0, 5.0], -7.616262616547005], [1, [-3.888888888888889, 5.0], -7.616262616547005], [1, [-2.7777777777777777, 5.0], -7.616262616547005], [1, [-1.6666666666666665, 5.0], -7.616262616547005], [1, [-0.5555555555555554, 5.0], -7.616262616547005], [1, [0.5555555555555554, 5.0], -7.616262616547005], [1, [1.666666666666667, 5.0], -7.616262616547005], [1, [2.7777777777777786, 5.0], -7.616262616547005], [1, [3.8888888888888893, 5.0], -7.616262616547005], [1, [5.0, 5.0], -7.616262616547005], [3, [1.666666666666667, 1.6017777777778637], -8.038499561186827]], "nr_of_basins": 98, "f_opt_dim_2": -8.053679705523672, "x_opt_dim_2": [1.7488131334786265, 1.5987434796204434], "f_opt_dim_5": -7.793112387591439, "x_opt_dim_5": [-0.13793498540301036, -0.7034262168270343, 1.1633655600248909, 1.1190338724747348, -0.7844638780744282]}
{"id": "18cc12fc-c82a-4586-8a33-02e11c30e5d5", "fitness": 0.9979527104878798, "name": "landscape_ellipsoid_min_nonhomogeneous", "description": "A non-homogeneous landscape built from rotated, anisotropic ellipsoidal wells evaluated via the pointwise minimum across wells (not a sum). Each well has its own center, rotation, axis scales, and depth. The landscape outside all wells is flat (0). This creates irregular basin shapes and sizes, breaking basin-size homogeneity in [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_ellipsoid_min_nonhomogeneous:\n    \"\"\"\n    A non-homogeneous landscape built from rotated, anisotropic ellipsoidal wells.\n    The landscape is defined as the pointwise minimum across wells (not the sum).\n    Each well i is defined by:\n      - center c_i in R^dim\n      - rotation R_i (orthogonal matrix)\n      - per-dimension axis scales s_i > 0\n      - depth weight w_i > 0\n    The quadratic form is A_i = R_i^T diag(1/s_i^2) R_i, and the squared distance is\n    d2_i(x) = (x - c_i)^T A_i (x - c_i).\n    Contribution of well i at point x is:\n      contrib_i(x) = -w_i * max(0, 1 - d2_i(x))  if d2_i(x) <= 1, else 0\n    The overall landscape is f(x) = min_i contrib_i(x).\n    Outside all wells, f(x) = 0.\n    Domain is [-5, 5]^dim; f(x) <= 0 everywhere.\n    \"\"\"\n\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the irregular landscape in 'dim' dimensions.\n        The number of ellipsoidal wells scales with dimension to keep the landscape challenging.\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed from dimension for reproducibility\n        seed = (self.dim * 2021) ^ 0x9e3779b9\n        self._rng = np.random.default_rng(seed)\n\n        # Number of wells; ensure ample diversity across dimensions\n        self.n_peaks = max(25, int(5 * self.dim + 15))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Random centers in [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Per-well axis scales (ellipsoid radii) per dimension\n        self.scales = self._rng.uniform(0.2, 3.0, size=(n, d))\n\n        # Random rotations (orthogonal matrices) per well\n        self.rotations = np.empty((n, d, d))\n        for i in range(n):\n            M = self._rng.normal(size=(d, d))\n            Q, R = np.linalg.qr(M)\n            # Ensure a proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, -1] *= -1\n            self.rotations[i] = Q\n\n        # Depth weights with heavy-tailed distribution\n        self.weights = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n\n        # Precompute A_i matrices for each well:\n        # A_i = R_i^T diag(1 / s_i^2) R_i\n        self._As = np.empty((n, d, d))\n        for i in range(n):\n            s = self.scales[i]\n            diag_inv = np.diag(1.0 / (s * s))\n            self._As[i] = self.rotations[i].T @ diag_inv @ self.rotations[i]\n\n        # Cache references for speed\n        self._centers = self.centers\n        self._As = self._As\n        self._weights = self.weights\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = min_i contrib_i(x) where\n        contrib_i(x) = -w_i * max(0, 1 - d2_i(x)) if d2_i(x) <= 1 else 0\n        Returns scalar for 1D input, or 1D array for batched inputs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        n = self.n_peaks\n        # Initialize with zeros (outside all wells contribution is 0)\n        contributions = np.zeros((x.shape[0],), dtype=float)\n\n        for i in range(n):\n            c = self._centers[i]\n            A = self._As[i]\n            w = self._weights[i]\n\n            diff = x - c  # (k, d)\n            tmp = diff @ A  # (k, d)\n            d2 = np.sum(tmp * diff, axis=1)  # (k,)\n\n            inside = d2 <= 1.0\n            contrib = np.zeros_like(d2)\n            if np.any(inside):\n                contrib[inside] = -w * (1.0 - d2[inside])\n\n            if i == 0:\n                contributions = contrib\n            else:\n                contributions = np.minimum(contributions, contrib)\n\n        if single:\n            return float(contributions[0])\n        else:\n            return contributions", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_ellipsoid_min_nonhomogeneous scored on:NOT Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["842b4488-9c19-4cfb-acdb-8cb1a052cb8a"], "operator": null, "metadata": {"ela_features_2D": [0.003732465937605367, 0.9612322505070603, 0.011636097745592667, 0.025797125254873914, 5.349840216976524, 0.001983852939281561, 0.023480760406451574, 3.206427953579927, 0.05703486202250938, -7.206854635856516, 59.64609259132169, 6.6, 0.28954794649173904, 0.5382629433181549, 0.248929176689734, 0.44794759635669756, -0.18385110301687174, 0.49671361847953666, 0.7185329734180216, 0.78259441191138, 0.8452076964108729, 0.47280791595151284, 0.8191215643435651, 0.8410553189572155, 0.8848950650510374, -0.2634191577345572, -0.14732730249739223, -0.11379361200467412, -0.08102143794370184, -0.27109220117383376, -0.0931326879290946, -0.08181968801857228, -0.05924829760224204, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5194106428569998, 0.5193935084262904, 0.49275744388742454, 0.36524644610786, 0.674134208352465, 1.0980980980980977, 0.02646533891308229, -1.0560560560560561, 0.38273092369477907], "score_NOT Basins_2D": 0.9986247437773272, "ela_features": [0.00017745816563810023, 0.995921223987289, 0.0007872850381500573, 0.00651954810477286, 10.41323132881953, 0.0010638220498957241, 0.004033086157620769, 10.416195336854077, 0.002587509523814835, -15.680585716099955, 280.0682770600132, 6.0, 0.3128829687691863, 0.357709419171414, 0.12483957098710907, 0.41531270485314903, -0.6597017631496559, 0.973945576949925, 1.0, 1.0, 1.0, 0.9770772624209929, 1.0, 1.0, 1.0, -0.02291000484555874, 0.0, 0.0, 0.0, -0.020239011006105524, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21589054506077215, 0.21587602713023696, 0.21475577861855194, 0.18290987918447504, 0.08117205501697618, -0.0030030030030030186, 0.0371742094973932, -0.1591591591591591, 0.020673076923076922], "score_NOT Basins_5D": 0.9976166938431561, "ela_features_10D": [0.00036515484213461846, 0.997172164212655, 0.00047443771066945387, 0.0063181931313478655, 13.317223714009998, -0.0017241608809415165, 0.0025080241296994155, 15.674001975992956, -0.00708347687381794, -17.86206553416027, 368.93275215671264, 6.0, 0.31798322491025777, 0.3587153424084787, 0.0861639599392945, 0.4054708703070678, -0.5515075578917135, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2128718883623423, 0.21287381940125188, 0.212056974063182, 0.18235392949813284, 0.0785896377968053, -0.22322322322322313, 0.0004015115110500195, -0.27127127127127115, 0.019711538461538464], "score_NOT Basins_10D": 0.9976166938431561}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-0.5555555555555554, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [1.666666666666667, -5.0], 0.0], [1, [-0.5555555555555554, -3.888888888888889], 0.0], [1, [0.5555555555555554, -3.888888888888889], 0.0], [1, [1.666666666666667, -3.888888888888889], 0.0], [1, [-0.5555555555555554, -1.6666666666666665], 0.0], [1, [-0.5555555555555554, 0.5555555555555554], 0.0], [1, [5.0, 0.5555555555555554], 0.0], [1, [-5.0, 1.666666666666667], 0.0], [1, [-0.5555555555555554, 1.666666666666667], 0.0], [1, [0.5555555555555554, 1.666666666666667], 0.0], [1, [1.666666666666667, 1.666666666666667], 0.0], [1, [5.0, 1.666666666666667], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-3.888888888888889, 3.8888888888888893], 0.0], [1, [-2.7777777777777777, 3.8888888888888893], 0.0], [1, [-1.6666666666666665, 3.8888888888888893], 0.0], [1, [1.666666666666667, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-3.888888888888889, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [1.666666666666667, 5.0], 0.0], [9, [4.828209487619004, 3.831291326466062], -0.3297823008984084], [3, [-2.0257777777778605, 5.0], -12.009893886835947], [10, [-3.7787234495173996, -4.074093757298671], -2.0332994855616695], [13, [-3.7056642301803695, -1.9391177580495913], -3.694190956705937], [7, [4.364183249920248, -2.389489537663761], -0.6321325341461055], [7, [2.074660443187488, -0.5916086864211445], -1.0261082204993393], [3, [3.5373250397660088, -3.0409498748427017], -0.61371267160168], [2, [-0.22206712597389539, -2.7266207390994444], -0.5198063781444214], [6, [-2.756477875337565, 1.6278332137467657], -0.2883571533225814], [3, [3.605193135213816, -4.971243279093775], -0.8235873890347223], [2, [-0.11587141968364194, 2.6135327639271453], -0.6262154184944023], [4, [-0.7826205399279423, 3.080140249788518], -3.1433755925119287], [2, [3.4924647618048845, 1.894538568422401], -0.32994750083014074], [5, [0.605853902178215, -1.2383095288531811], -3.4533883840005952]], "nr_of_basins": 38, "f_opt_dim_2": -39.51355373727826, "x_opt_dim_2": [0.0720330209576324, 0.5526626832432144], "f_opt_dim_5": -1.0283097724487857, "x_opt_dim_5": [-1.1670514213642265, -0.19838593005417046, -0.9124356741641676, 1.171591956887576, 2.4927525826445223]}
{"id": "1d37e87d-9992-4e0c-bbc8-ef5b1d8edfa4", "fitness": 0.9982719344164556, "name": "landscape_compact_linear_ellipsoids", "description": "A non-homogeneous, compact ellipsoidal linear-well landscape. It uses a sum of negative, compact-support linear ramps inside randomly oriented ellipsoids. Each well contributes only within its ellipsoidal footprint, with depth linearly decreasing with distance from the center. Varying ellipsoid shapes, positions, radii, and depths creates highly non-uniform basin sizes and shapes, yielding a non-homogeneous search landscape within [-5,5]^dim. The global minimum arises where multiple wells overlap, producing deeper valleys without Gaussian-like basins.", "code": "import numpy as np\n\nclass landscape_compact_linear_ellipsoids:\n    \"\"\"\n    Sum of negative, compact-support linear wells inside ellipsoids.\n\n    Each well i defines an ellipsoidal footprint via a SPD matrix A_i and a center c_i.\n    Inside the footprint (delta^T A_i delta <= r_i^2), the contribution is:\n        w_i * (1 - sqrt(delta^T A_i delta) / r_i)\n    with w_i < 0 (depth) and r_i > 0 (footprint radius). Outside the footprint, the\n    contribution is zero. The total landscape is the sum of all wells, leading to\n    non-homogeneous basins due to varying centers, shapes, radii, and depths.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = dim\n\n        # Number of wells scales with dimension to promote diversity\n        self.N = max(6, min(160, 6 * dim))\n\n        rng = np.random.default_rng(1234)  # deterministic seed for reproducibility\n\n        # Random centers inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # Negative depths (bowl depths) for each well\n        self.weights = -rng.uniform(low=0.6, high=4.0, size=self.N)\n\n        # Ellipsoidal shapes per well: generate random SPD matrices\n        self.As = []\n        self.rs = rng.uniform(low=0.8, high=6.0, size=self.N)  # footprints radii\n        for _ in range(self.N):\n            M = rng.normal(size=(dim, dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1  # ensure proper rotation\n\n            lam = rng.uniform(low=0.4, high=10.0, size=dim)\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.As.append(A_i)\n\n        self.As = np.stack(self.As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D numpy array with length dim\n\n        Returns:\n        - scalar float value of the landscape at x\n        \"\"\"\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        total = 0.0\n        for i in range(self.N):\n            delta = x - self.centers[i]          # (dim,)\n            d2 = delta @ self.As[i] @ delta        # delta^T A_i delta\n            r = self.rs[i]\n            r2 = r * r\n\n            if d2 <= r2:\n                contrib = self.weights[i] * (1.0 - np.sqrt(d2) / r)\n                total += contrib\n\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_compact_linear_ellipsoids scored on:NOT Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b5570d18-7424-4eee-86b1-948be71cb86d"], "operator": null, "metadata": {"ela_features_2D": [0.21763616681581804, 0.9774514459859887, 0.01135376795757105, 0.3509214670905805, 131.83081396716048, 0.2244518126282789, 0.24939320369611861, 2.4301957239849195, 0.30332688490016774, -1.1895012919421863, 0.9029281486159043, 1.4, 0.27535083067255306, 0.5355079557898053, 0.1779720248392061, 0.45076460882250313, -0.2598796983164236, 0.3552073005079443, 0.554714573508748, 0.7290152110706039, 0.9011608969411562, 0.18147841022082215, 0.39397045452980695, 0.6545284667950317, 0.946923417147759, -0.3372888928576969, -0.23291363804288662, -0.1417363909883938, -0.051708275534338044, -0.42010502552672824, -0.3110781826623374, -0.1771766763310781, -0.027302233861335557, 1.0, 1.0, 1.0, 1.0, 0.5192034271319421, 0.519197156821966, 0.47134419225142266, 0.4910841214654237, 0.6769651539951193, 0.8818818818818815, 0.9963153557531041, 0.20120120120120114, 0.3606425702811245], "score_NOT Basins_2D": 0.9987953837262467, "ela_features": [0.011370824320393047, 1.0010930253895591, 0.003535163328820614, 0.024568158939939837, 10.355021650351654, 0.029979697107875868, 0.01838942202799554, 9.194950413819948, 0.06569680355755833, -7.67923755722714, 67.83788593014778, 7.2, 0.3892420489062737, 0.4656454198968377, 0.15940107442972848, 0.4042506781381975, -0.5136960675626148, 0.9643677638934165, 0.983197710129762, 1.0, 1.0, 0.9835195475116454, 1.0136208323310314, 1.0, 1.0, -0.03133140154954332, -0.014773908301540527, 0.0, 0.0, -0.014523632877188187, 0.012062008421008486, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21735274105626043, 0.2173313001743553, 0.21389266301314672, 0.18924781977055147, 0.22400619758624027, 0.4614614614614613, 0.06678162610342589, -0.19919919919919912, 0.08044871794871795], "score_NOT Basins_5D": 0.99801020976156, "ela_features_10D": [0.009693286712025406, 1.0050996373495442, 0.002460548675044396, 0.024657179842407687, 10.021008766251207, 0.02790320448095618, 0.01805034383138704, 13.063176175989488, 0.06636002695869148, -7.25714909692375, 60.8595336325983, 7.0, 0.3465332275527419, 0.46886622068795986, 0.13061747339383376, 0.3978106393711791, -0.48239384084702797, 1.0400726682210173, 1.002269755463237, 1.0, 1.0, 1.0631244225932248, 1.0621552173403246, 1.0, 1.0, 0.035256319733071306, 0.001996952733129942, 0.0, 0.0, 0.05586392987131039, 0.05500620140339496, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2159926276526641, 0.21596525561997731, 0.21257832307694885, 0.18542751307429575, 0.2462454066557295, 0.4614614614614613, 0.06415915771904454, -0.3113113113113112, 0.0875], "score_NOT Basins_10D": 0.99801020976156}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [-3.888888888888889, -5.0], 0.0], [1, [-2.7777777777777777, -5.0], 0.0], [1, [-1.6666666666666665, -5.0], 0.0], [1, [-0.5555555555555554, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [-3.888888888888889, -3.888888888888889], 0.0], [1, [-2.7777777777777777, -3.888888888888889], 0.0], [1, [-0.5555555555555554, -3.888888888888889], 0.0], [1, [-1.6666666666666665, -2.7777777777777777], 0.0], [1, [-0.5555555555555554, -2.7777777777777777], 0.0], [1, [-5.0, -1.6666666666666665], 0.0], [1, [-0.5555555555555554, -1.6666666666666665], 0.0], [1, [0.5555555555555554, -1.6666666666666665], 0.0], [1, [-5.0, -0.5555555555555554], 0.0], [1, [-3.888888888888889, -0.5555555555555554], 0.0], [1, [-2.7777777777777777, -0.5555555555555554], 0.0], [1, [0.5555555555555554, -0.5555555555555554], 0.0], [1, [1.666666666666667, -0.5555555555555554], 0.0], [1, [-5.0, 0.5555555555555554], 0.0], [1, [-2.7777777777777777, 0.5555555555555554], 0.0], [1, [-1.6666666666666665, 0.5555555555555554], 0.0], [1, [-2.7777777777777777, 1.666666666666667], 0.0], [1, [-1.6666666666666665, 2.7777777777777786], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [0.5555555555555554, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-2.7777777777777777, 5.0], 0.0], [1, [-1.6666666666666665, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [0.5555555555555554, 5.0], 0.0], [1, [5.0, 5.0], 0.0], [7, [-3.280023458995539, 3.704373915944487], -3.733513662346005], [9, [1.7131715845274718, 1.1136688985503347], -5.507384930338426], [1, [-1.6826177358451666, -3.8566160581263293], -1.8996438917261556], [12, [3.5870267576210377, 3.624929760655675], -3.43273688996893], [22, [4.045156004364611, -2.3348092906186095], -4.958877662844571], [4, [-4.398945760542991, 1.8372300743250518], -1.1215124500135898], [2, [0.21057765882767962, 0.6602266681933983], -1.6829909936001524], [2, [-0.587461714198634, 1.0979995687646615], -1.8624489309161347], [9, [-2.5136318676793694, -1.7603437969387064], -2.3655700814133067]], "nr_of_basins": 41, "f_opt_dim_2": -5.13019230077498, "x_opt_dim_2": [4.232462337639553, -2.3830757613645575], "f_opt_dim_5": -2.3057287316610315, "x_opt_dim_5": [1.5542258555576076, 4.106845690724835, -3.474153401550726, 0.8863231908490751, 0.03765599615019443]}
{"id": "2d127a1f-954e-4a3e-b0a1-bb3ceef6c1b8", "fitness": 0.8824491920337701, "name": "landscape_softmin_aniso_wells_heterogeneous", "description": "A heterogeneous soft-min landscape built from clustered, anisotropic Gaussian-like wells with per-well decay scales, creating highly non-uniform basin sizes and shapes to break basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_softmin_aniso_wells_heterogeneous:\n    \"\"\"\n    A novel, non-homogeneous optimization landscape built as a soft-min\n    (log-sum-exp) over many anisotropic Gaussian-like wells with\n    diverse covariances, centers, depths, and per-well decay scales.\n\n    Key ideas to promote non-homogeneous basin sizes:\n    - Wells are generated in clusters (centers grouped in a few clusters),\n      so some regions contain many overlapping wells (deep, broad basins),\n      while other regions have isolated wells (narrow, deep/local basins).\n    - Each well has its own decay scale s_i, drawn from a wide distribution,\n      producing a broad spectrum of basin widths and shapes.\n    - Each well has a random rotation and axis scales to yield varied anisotropic\n      ellipsoidal footprints.\n    The landscape is evaluated in [-5,5]^dim for minimization.\n    \"\"\"\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the landscape in dim dimensions.\n        Deterministic seeding by dimension for reproducibility.\n        \"\"\"\n        self.dim = int(dim)\n        self._rng = np.random.default_rng(self.dim)\n\n        # Number of wells grows with dimension to maintain complexity\n        self.n_wells = max(20, int(5 * self.dim + 14))\n\n        # Generate a small number of cluster centers in [-5, 5]^dim\n        n_clusters = max(3, int(self.dim // 3))\n        cluster_centers = self._rng.uniform(-5.0, 5.0, size=(n_clusters, self.dim))\n\n        # Centers of wells: sample around random cluster centers to create clustering\n        self.centers = np.zeros((self.n_wells, self.dim))\n        for i in range(self.n_wells):\n            cidx = self._rng.integers(0, n_clusters)\n            # Add some local perturbation around the cluster center\n            self.centers[i] = cluster_centers[cidx] + self._rng.normal(scale=0.8, size=self.dim)\n\n        # Positive-definite, anisotropic covariances A_i\n        self.A = []\n        for i in range(self.n_wells):\n            M = self._rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            # Random eigenvalues to control width along principal axes\n            lam = self._rng.uniform(0.2, 8.0, size=self.dim)\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.A.append(A_i)\n        self.A = np.asarray(self.A)  # shape (n_wells, dim, dim)\n\n        # Depth weights (positive) for each well\n        self.weights = self._rng.lognormal(mean=0.0, sigma=0.9, size=self.n_wells)\n        self.weights *= self._rng.uniform(0.4, 1.8, size=self.n_wells)\n\n        # Per-well decay scales s_i controlling sharpness/width of each well\n        # Drawn from a wide distribution to create a broad spectrum of basin sizes\n        self.scales = self._rng.lognormal(mean=0.0, sigma=1.0, size=self.n_wells)\n        self.scales = np.clip(self.scales, 0.05, 50.0)\n\n        self._eps = 1e-12\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape.\n        f(x) = -log( sum_i w_i * exp(- s_i * (x - c_i)^T A_i (x - c_i) ) )\n\n        - x: numpy array of shape (dim,) or (k, dim)\n        Returns:\n        - scalar if input is (dim,), or 1-D array of length k otherwise\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        m, d = x.shape\n        assert d == self.dim, \"Input dimension mismatch.\"\n\n        # Clip to domain to ensure domain constraints are respected\n        x = np.clip(x, -5.0, 5.0)\n\n        # Compute S_i(x) = w_i * exp(- s_i * (x - c_i)^T A_i (x - c_i) )\n        # Then f(x) = -log( sum_i S_i(x) )\n        S = np.zeros(m, dtype=float)\n\n        for i in range(self.n_wells):\n            c = self.centers[i]            # shape (dim,)\n            A_i = self.A[i]                  # shape (dim, dim)\n            w_i = self.weights[i]\n            s_i = self.scales[i]\n\n            dx = x - c  # shape (m, dim)\n            temp = dx @ A_i                 # shape (m, dim)\n            q = np.sum(temp * dx, axis=1)   # shape (m,)\n\n            S += w_i * np.exp(- s_i * q)\n\n        # Numerical stability\n        S = S + self._eps\n        fvals = -np.log(S)\n\n        if single:\n            return float(fvals[0])\n        else:\n            return fvals", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_softmin_aniso_wells_heterogeneous scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["1b08a637-d670-402d-a9b3-f035dc264e25"], "operator": null, "metadata": {"ela_features_2D": [0.2926839022616168, 0.2973094840586231, 0.21944019322296074, 0.2572728375905363, 1.1813014360496499, 0.3236606011999791, 0.43193861244347487, 4.8557309223444465, 0.7374888301029416, 1.3825420240720252, 2.132844660326363, 1.4, 0.3153458544387268, 0.662673464592868, 0.26915911736517917, 0.35379426644485534, -0.19512247307303293, 0.12316154904629324, 0.25879606351872125, 0.734526848916704, 0.9303614935444333, 0.1203585059223585, 0.20743334104689387, 0.6405284158442723, 1.091113354594132, -0.45894692734728687, -0.3879303951142671, -0.13893100912129835, -0.03644888397794453, -0.4520402736488672, -0.40726337641738597, -0.18443356967385616, 0.04679708245880578, 1.0, 1.0, 0.7333333333333332, 1.0, 0.5115215074359669, 0.5115105304791857, 0.4837979865703632, 0.5157770100296825, 0.7193752242690306, 0.5175175175175173, 0.4204154004461406, -0.21521521521521514, 0.3895582329317269], "score_NOT Basins_2D": 0.9978312195744365, "ela_features": [0.4983878599537321, 0.8124730120984573, 0.033795650765406235, 0.5286429584773982, 40.67497926923248, 0.6486538376537023, 0.5681426637074666, 2.741735888495473, 0.8119953845410816, -0.8798688740437427, -0.5432511109262104, 2.0, 0.7000042869463942, 0.8475087967892903, 0.540978559059136, 0.1975824203395036, -0.32127279989633867, 0.7302111854887177, 0.7693981459293929, 0.8033859198215516, 0.8567667584352373, 0.6739383825255224, 0.7339621065349771, 0.7731183821590091, 0.8431730835235827, -0.23720864826733762, -0.20275845713798585, -0.17287674584417093, -0.12593951388290583, -0.2878217198630642, -0.2349033137582655, -0.20033907813015794, -0.13847703768847433, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21490529377954154, 0.21489466033948124, 0.27613600129589305, 0.2837671269473141, 0.6512574557664641, 0.31331331331331325, 0.29029271125959205, -0.4874874874874873, 0.4939102564102564], "score_NOT Basins_5D": 0.6498743891716003, "ela_features_10D": [0.15495901086814984, 1.0190629597971401, 0.00517606635418424, 0.08532470821626578, 18.419958701805133, 0.3068322749282359, 0.19213648165993852, 79.00280524399601, 0.4416133537371655, -4.337869186000174, 20.837733304609696, 7.4, 0.8908640443023058, 0.9150367974402611, 0.6158022892187389, 0.12118227274142275, -0.380313105438712, 0.769256397461885, 0.7974399384432223, 0.8278718702753414, 0.8780084162807522, 0.7592305814251865, 0.7899745255400488, 0.8232079674589592, 0.8766998204727907, -0.292630883491674, -0.2568887960626454, -0.21829420635814203, -0.15471056580514025, -0.30617535956691766, -0.267082189506425, -0.2248187818691662, -0.15679569678372118, 0.9, 0.9, 0.8727272727272727, 0.909090909090909, 0.11069867876729236, 0.11070220423861488, 0.10928962128705084, 0.1273453222672865, 0.5360539985705755, 0.03703703703703701, 0.0, -Infinity, 0.5170536429143314], "score_NOT Basins_10D": 0.9996419673552737}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[3, [2.680862177955122, -3.349007560686836], -2.529540439876261], [15, [3.503868329045167, -3.8125529222935346], -2.5293663084977043], [16, [-2.094933734473023, -1.8384498814992094], -1.1750703191268677], [15, [1.4471037792804269, 2.340823985503452], -1.340904661377543], [41, [0.47706149029189326, 2.8495096114639096], -1.4946957693168719], [10, [-3.491954168089816, -3.475950647547819], -1.0756349890982764]], "nr_of_basins": 6, "f_opt_dim_2": -1.4946965597121182, "x_opt_dim_2": [0.47685299934614445, 2.8485808129258796], "f_opt_dim_5": -1.3191337326438917, "x_opt_dim_5": [1.6513937755542587, -2.504426387311709, -1.077111737705512, 7.986058249772769, 5.534468577357492]}
{"id": "ceaeb9f6-fce3-47ab-a157-fe29e9c9b3b8", "fitness": 0.9907518332668891, "name": "landscape_nh_elliptical_inverted_tents_v2", "description": "A non-homogeneous multi-well landscape built from truncated anisotropic elliptical wells with random perturbations to create highly varied basin sizes. The landscape is the pointwise minimum across wells, each with its own rotated ellipsoid interior, radius, depth, and shape (via an exponent) plus a small SPD perturbation to the quadratic form to break basin-size homogeneity. This produces highly irregular basins of attraction and non-uniform basin sizes across [-5, 5]^dim.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_inverted_tents_v2:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple truncated elliptical wells with\n    heterogeneous shapes and a small SPD perturbation to break basin-size homogeneity.\n\n    Each well i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite rotated covariance A_i (elliptical well)\n      - a radius r_i defining the interior ellipsoidal region\n      - a negative depth depth_i < 0 (well depth)\n      - an interior tent exponent p_i in [0.5, 2.0] controlling shape\n      - a small SPD perturbation to A_i via gamma_i * (t_i t_i^T) with t_i a random direction\n    The landscape is f(x) = min_i [ depth_i - (1 - d_i / r_i)^{p_i} for d_i <= r_i, else depth_i ],\n    where d_i is the ellipsoidal distance sqrt((x - c_i)^T A_eff_i (x - c_i)).\n    Outside the ellipsoid, the contribution is depth_i (flat outside).\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure richer basins\n        self.N = max(4, min(128, 4 * self.dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, self.dim))\n\n        # Elliptical (anisotropic) wells\n        self.A_eff = np.zeros((self.N, self.dim, self.dim))\n        self.radii = rng.uniform(low=0.5, high=5.0, size=self.N)\n        self.depths = -rng.uniform(low=0.5, high=7.0, size=self.N)\n        self.ps = rng.uniform(low=0.5, high=2.0, size=self.N)  # interior exponent\n        self.gamma = rng.uniform(low=0.0, high=2.0, size=self.N)  # perturbation strength\n\n        # Random directions for SPD perturbations\n        t_vectors = rng.normal(size=(self.N, self.dim))\n        norms = np.linalg.norm(t_vectors, axis=1, keepdims=True)\n        norms[norms == 0] = 1.0\n        self.t_vectors = t_vectors / norms  # unit vectors\n\n        for i in range(self.N):\n            # Random rotation (orthogonal matrix)\n            M = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues controlling axis scales\n            lam = rng.uniform(low=0.5, high=12.0, size=self.dim)\n            A_i = Q @ np.diag(lam) @ Q.T  # SPD\n\n            # Small SPD perturbation to break basin-size homogeneity\n            t = self.t_vectors[i]\n            gamma_i = float(self.gamma[i])\n            A_eff = A_i + gamma_i * np.outer(t, t)\n\n            self.A_eff[i] = A_eff\n\n        # Precompute well radii to speed up\n        # (already stored in self.radii)\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        x: 1D numpy array of length dim.\n        Returns the scalar landscape value (min over wells).\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"Input x must be a 1D array with length {self.dim}.\")\n\n        N = self.N\n        vals = np.empty(N, dtype=float)\n\n        for i in range(N):\n            delta = x - self.centers[i]  # (dim,)\n            # Ellipsoidal distance with per-well SPD matrix\n            d2 = delta @ self.A_eff[i] @ delta  # scalar\n            d = np.sqrt(max(d2, 0.0))\n\n            r = self.radii[i]\n            if d <= r:\n                tent = (1.0 - d / r) ** float(self.ps[i])\n            else:\n                tent = 0.0\n\n            f_i = self.depths[i] - tent  # inside: depth - (1 - d/r)^p; outside: depth\n            vals[i] = f_i\n\n        return float(np.min(vals))", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_elliptical_inverted_tents_v2 scored on:NOT Basins 0.988,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19e2b275-334e-40e1-b107-afbc6748db37"], "operator": null, "metadata": {"ela_features_2D": [0.03385373035183466, 1.0024010742486413, 0.021790070730165745, 0.04473551026813975, 2.060074155304613, 0.047484779395865526, 0.051971669070009205, 4.8003951254375306, 0.0918755168255289, -10.63548026779635, 127.10997830705583, 5.8, 0.045718191875421976, 0.05309805617195421, 0.00172889455253925, 1.5762179264519491, -0.13289811283683967, 0.21572836866779216, 1.0, 1.0, 1.0, 0.17114921488796003, 1.0, 1.0, 1.0, -0.4104762143896613, 0.0, 0.0, 0.0, -0.42653226408504014, 0.0, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5158803270796131, 0.5158582477172494, 0.49979556743130793, 0.40047080253772116, 0.08319706400569571, -Infinity, 1.399650909936535, 0.29729729729729726, 0.018072289156626502], "score_NOT Basins_2D": 0.9973026874940842, "ela_features": [0.001404906524741545, 1.0014101346403936, 0.0014111184727694658, 0.004256052657566986, 3.0296199710028415, 0.007150898206724721, 0.0007763100446795512, 9.099165324997488, 0.00361816623960145, -35.27053150041898, 1243.0047980799995, 1.0, 0.1661312192109843, 0.18105400642916347, 0.13527322644450152, 0.4630883379077154, -0.9999999999999989, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21759382234303834, 0.2175603586195948, 0.21718031681768904, 0.1839830365550465, 0.009564751735344334, -Infinity, 0.006481297167738339, 0.6376376376376374, 0.0008012820512820513], "score_NOT Basins_5D": 0.9869771506637335, "ela_features_10D": [0.0007062256516818799, 1.0014501033405616, 0.0015568309877424563, 0.003900326383736754, 2.5052985291567036, 0.0035048630946186154, -0.0007119967544086947, 7.786721567386619, -0.01206248377966146, -35.27053150041898, 1243.0047980799995, 1.0, 0.16882934660099466, 0.18244912967227914, 0.0716515538238451, 0.5043558017621191, -0.9999999999999991, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21645436681895774, 0.2164172916889048, 0.21604904536027436, 0.18698594672038696, 0.009564751735344334, -Infinity, 0.007475353728403666, 0.7657657657657655, 0.0008012820512820513], "score_NOT Basins_10D": 0.9879756616428494}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -6.8555002784496555], [1, [-3.888888888888889, -5.0], -6.8555002784496555], [1, [-2.7777777777777777, -5.0], -6.8555002784496555], [1, [-1.6666666666666665, -5.0], -6.8555002784496555], [1, [-0.5555555555555554, -5.0], -6.8555002784496555], [1, [0.5555555555555554, -5.0], -6.8555002784496555], [1, [1.666666666666667, -5.0], -6.8555002784496555], [1, [2.7777777777777786, -5.0], -6.8555002784496555], [1, [3.8888888888888893, -5.0], -6.8555002784496555], [1, [5.0, -5.0], -6.8555002784496555], [1, [-5.0, -3.888888888888889], -6.8555002784496555], [1, [-3.888888888888889, -3.888888888888889], -6.8555002784496555], [1, [-2.7777777777777777, -3.888888888888889], -6.8555002784496555], [1, [-1.6666666666666665, -3.888888888888889], -6.8555002784496555], [1, [-0.5555555555555554, -3.888888888888889], -6.8555002784496555], [1, [0.5555555555555554, -3.888888888888889], -6.8555002784496555], [1, [1.666666666666667, -3.888888888888889], -6.8555002784496555], [1, [2.7777777777777786, -3.888888888888889], -6.8555002784496555], [1, [3.8888888888888893, -3.888888888888889], -6.8555002784496555], [1, [5.0, -3.888888888888889], -6.8555002784496555], [1, [-5.0, -2.7777777777777777], -6.8555002784496555], [1, [-3.888888888888889, -2.7777777777777777], -6.8555002784496555], [1, [-2.7777777777777777, -2.7777777777777777], -6.8555002784496555], [1, [-1.6666666666666665, -2.7777777777777777], -6.8555002784496555], [1, [-0.5555555555555554, -2.7777777777777777], -6.8555002784496555], [1, [0.5555555555555554, -2.7777777777777777], -6.8555002784496555], [1, [1.666666666666667, -2.7777777777777777], -6.8555002784496555], [1, [2.7777777777777786, -2.7777777777777777], -6.8555002784496555], [1, [-5.0, -1.6666666666666665], -6.8555002784496555], [1, [-3.888888888888889, -1.6666666666666665], -6.8555002784496555], [1, [-2.7777777777777777, -1.6666666666666665], -6.8555002784496555], [1, [-1.6666666666666665, -1.6666666666666665], -6.8555002784496555], [1, [-0.5555555555555554, -1.6666666666666665], -6.8555002784496555], [1, [0.5555555555555554, -1.6666666666666665], -6.8555002784496555], [1, [1.666666666666667, -1.6666666666666665], -6.8555002784496555], [1, [2.7777777777777786, -1.6666666666666665], -6.8555002784496555], [1, [5.0, -1.6666666666666665], -6.8555002784496555], [1, [-5.0, -0.5555555555555554], -6.8555002784496555], [1, [-3.888888888888889, -0.5555555555555554], -6.8555002784496555], [1, [-2.7777777777777777, -0.5555555555555554], -6.8555002784496555], [1, [-1.6666666666666665, -0.5555555555555554], -6.8555002784496555], [1, [-0.5555555555555554, -0.5555555555555554], -6.8555002784496555], [1, [0.5555555555555554, -0.5555555555555554], -6.8555002784496555], [1, [1.666666666666667, -0.5555555555555554], -6.8555002784496555], [1, [2.7777777777777786, -0.5555555555555554], -6.8555002784496555], [1, [3.8888888888888893, -0.5555555555555554], -6.8555002784496555], [1, [5.0, -0.5555555555555554], -6.8555002784496555], [1, [-5.0, 0.5555555555555554], -6.8555002784496555], [1, [-3.888888888888889, 0.5555555555555554], -6.8555002784496555], [1, [-2.7777777777777777, 0.5555555555555554], -6.8555002784496555], [1, [-1.6666666666666665, 0.5555555555555554], -6.8555002784496555], [1, [-0.5555555555555554, 0.5555555555555554], -6.8555002784496555], [1, [0.5555555555555554, 0.5555555555555554], -6.8555002784496555], [1, [1.666666666666667, 0.5555555555555554], -6.8555002784496555], [1, [2.7777777777777786, 0.5555555555555554], -6.8555002784496555], [1, [3.8888888888888893, 0.5555555555555554], -6.8555002784496555], [1, [5.0, 0.5555555555555554], -6.8555002784496555], [1, [-5.0, 1.666666666666667], -6.8555002784496555], [1, [-3.888888888888889, 1.666666666666667], -6.8555002784496555], [1, [-2.7777777777777777, 1.666666666666667], -6.8555002784496555], [1, [-1.6666666666666665, 1.666666666666667], -6.8555002784496555], [1, [-0.5555555555555554, 1.666666666666667], -6.8555002784496555], [1, [0.5555555555555554, 1.666666666666667], -6.8555002784496555], [1, [1.666666666666667, 1.666666666666667], -6.8555002784496555], [1, [2.7777777777777786, 1.666666666666667], -6.8555002784496555], [1, [3.8888888888888893, 1.666666666666667], -6.8555002784496555], [1, [5.0, 1.666666666666667], -6.8555002784496555], [1, [-5.0, 2.7777777777777786], -6.8555002784496555], [1, [-3.888888888888889, 2.7777777777777786], -6.8555002784496555], [1, [-2.7777777777777777, 2.7777777777777786], -6.8555002784496555], [1, [-1.6666666666666665, 2.7777777777777786], -6.8555002784496555], [1, [-0.5555555555555554, 2.7777777777777786], -6.8555002784496555], [1, [0.5555555555555554, 2.7777777777777786], -6.8555002784496555], [1, [1.666666666666667, 2.7777777777777786], -6.8555002784496555], [1, [2.7777777777777786, 2.7777777777777786], -6.8555002784496555], [1, [3.8888888888888893, 2.7777777777777786], -6.8555002784496555], [1, [5.0, 2.7777777777777786], -6.8555002784496555], [1, [-5.0, 3.8888888888888893], -6.8555002784496555], [1, [-3.888888888888889, 3.8888888888888893], -6.8555002784496555], [1, [-2.7777777777777777, 3.8888888888888893], -6.8555002784496555], [1, [-1.6666666666666665, 3.8888888888888893], -6.8555002784496555], [1, [-0.5555555555555554, 3.8888888888888893], -6.8555002784496555], [1, [0.5555555555555554, 3.8888888888888893], -6.8555002784496555], [1, [1.666666666666667, 3.8888888888888893], -6.8555002784496555], [1, [2.7777777777777786, 3.8888888888888893], -6.8555002784496555], [1, [5.0, 3.8888888888888893], -6.8555002784496555], [1, [-5.0, 5.0], -6.8555002784496555], [1, [-3.888888888888889, 5.0], -6.8555002784496555], [1, [-2.7777777777777777, 5.0], -6.8555002784496555], [1, [-1.6666666666666665, 5.0], -6.8555002784496555], [1, [-0.5555555555555554, 5.0], -6.8555002784496555], [1, [0.5555555555555554, 5.0], -6.8555002784496555], [1, [1.666666666666667, 5.0], -6.8555002784496555], [1, [2.7777777777777786, 5.0], -6.8555002784496555], [1, [3.8888888888888893, 5.0], -6.8555002784496555], [1, [5.0, 5.0], -6.8555002784496555], [3, [4.276495400783949, -2.389273884964782], -7.771571130708812], [1, [3.9024281530254914, 3.6673036047488945], -6.926469831800465]], "nr_of_basins": 98, "f_opt_dim_2": -6.856962093901144, "x_opt_dim_2": [3.3642155990248006, -1.4100509241411143], "f_opt_dim_5": -6.754820580269257, "x_opt_dim_5": [-0.2814145444610451, 1.9638893476664374, 2.6004330298661626, 3.0605346508693123, -0.9907410583389018]}
{"id": "f953f421-eed9-409a-a755-3f91d0177eb6", "fitness": 0.9976023432488242, "name": "landscape_rotated_l1_pyramids", "description": "A non-homogeneous landscape built from rotated, anisotropic L1-diamond wells with compact support. Each well has its own center, rotation, per-axis scales, and depth; the distance is computed in a rotated L1 metric, yielding pyramid-shaped basins of varying sizes and orientations. The sum of many such wells creates a highly non-uniform landscape in [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_rotated_l1_pyramids:\n    \"\"\"\n    A non-homogeneous landscape built from rotated, anisotropic L1-diamond wells.\n    Each well i is defined by:\n      - center c_i in R^dim\n      - a random rotation R_i (orthogonal matrix)\n      - per-dimension scales s_i > 0 (defines the diamond anisotropy)\n      - depth weight w_i > 0 (depth of the basin)\n    The distance used inside a well is:\n        d_i(x) = sum_j | (R_i @ (x - c_i))_j | / s_i_j\n    Contribution of well i at point x is:\n        contrib_i(x) = -w_i * max(0, 1 - d_i(x))\n    The overall landscape is f(x) = sum_i contrib_i(x).\n    Domain is [-5, 5]^dim; f(x) <= 0 everywhere (global optimum <= 0).\n    \"\"\"\n\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the irregular landscape in 'dim' dimensions.\n        The number of wells scales with dimension to keep the landscape challenging.\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed from dimension for reproducibility\n        seed = (self.dim * 17) ^ 0x9e3779b9\n        self._rng = np.random.default_rng(seed)\n\n        # Number of wells; ensure ample diversity across dimensions\n        self.n_peaks = max(20, int(5 * self.dim + 30))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_peaks\n\n        # Centers within [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Random rotations (orthogonal matrices) per well\n        self.rotations = np.empty((n, d, d))\n        for i in range(n):\n            M = self._rng.normal(size=(d, d))\n            Q, R = np.linalg.qr(M)\n            # Ensure a proper rotation (determinant +1)\n            if np.linalg.det(Q) < 0:\n                Q[:, -1] *= -1\n            self.rotations[i] = Q\n\n        # Per-well axis scales (positive). Create anisotropy for each well\n        self.scales = self._rng.uniform(0.25, 3.0, size=(n, d))\n\n        # Depth weights with heavy-tailed distribution\n        self.weights = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n\n        # Cache for speed during evaluation (optional; kept for clarity)\n        self._centers = self.centers\n        self._rotations = self.rotations\n        self._scales = self.scales\n        self._weights = self.weights\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        f(x) = sum_i -w_i * max(0, 1 - d_i(x))\n        where d_i(x) = sum_j | (R_i (x - c_i))_j | / s_i_j\n        Returns scalar for 1D input, or 1D array for batched inputs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        total = np.zeros(x.shape[0], dtype=float)\n\n        n = self.n_peaks\n        centers = self._centers\n        rotations = self._rotations\n        scales = self._scales\n        weights = self._weights\n\n        for i in range(n):\n            c = centers[i]\n            R = rotations[i]\n            s = scales[i]\n            w = weights[i]\n\n            diff = x - c  # shape (k, d)\n            # Rotate differences into the well's local frame\n            # u = R_i @ (x - c_i)  -> we implement as (x - c_i) @ R_i^T\n            u = diff @ R.T  # shape (k, d)\n\n            # d_i(x) = sum_j | u_j | / s_j\n            d_i = np.sum(np.abs(u) / s, axis=1)\n\n            inside = 1.0 - d_i\n            inside = np.maximum(0.0, inside)\n\n            contrib = -w * inside\n            total += contrib\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_rotated_l1_pyramids scored on:NOT Basins 0.997,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["842b4488-9c19-4cfb-acdb-8cb1a052cb8a"], "operator": null, "metadata": {"ela_features_2D": [0.002595781757868054, 0.9196012493324822, 0.009412578017878873, 0.028889846912651257, 8.34729320075707, 0.044360597263832104, 0.03622969156154503, 1.2944893595742808, 0.17189138575378377, -4.476643204823814, 26.115378367996364, 5.0, 0.24086371202374424, 0.5270601240063695, 0.22928478289467616, 0.44253828261874756, -0.23122952860345397, 0.808403827679177, 0.8267914003975967, 1.0079384549714958, 0.9787768733225374, 1.1440478307798125, 1.0402989283597948, 1.1345599162916498, 0.9456294000845855, -0.10027551719910548, -0.09065120849564087, 0.00414765224086131, -0.011108476994319338, 0.07372711506516247, 0.020626890085604012, 0.0691797347967232, -0.027964905068521895, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5146836250471483, 0.5146514243247821, 0.4790995915289652, 0.36072002507823286, 0.6796235080036847, 0.7897897897897895, 0.11121410859890908, -0.3633633633633632, 0.41967871485943775], "score_NOT Basins_2D": 0.9986322775948793, "ela_features": [-0.0004913695313371269, 0.9970027877543224, 0.0008795690371166266, 0.004308517081781876, 38.433350157756855, -0.002789599495247841, -0.0013330822265913644, 72.83062207054364, -0.013006725520457563, -30.791082574743854, 982.0661162310353, 2.2, 0.2170855784084603, 0.2396579251208672, 0.08016053598208636, 0.45625110348580195, -0.8070196656931612, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2158015124462404, 0.21580665930001527, 0.2152721817295852, 0.18173058293431482, 0.019839214133523103, -Infinity, 0.003404264742830351, 0.12912912912912908, 0.003044871794871795], "score_NOT Basins_5D": 0.9972303239628673, "ela_features_10D": [0.001690008656357933, 0.9993223024652916, 2.4849187693644873e-05, 0.004266326447605682, 171.68876907379894, 0.008785915277165879, 0.0021961158522698643, 14.811478141626873, 0.01655376733928282, -35.127156607404025, 1236.0297580977092, 2.0, 0.19323936148468096, 0.21167157226962047, 0.03997093524389985, 0.47553585430551515, -0.3782494508855041, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21383851119434624, 0.2138909473015075, 0.2134366877555617, 0.18574477796162878, 0.016879966658188455, -Infinity, 0.07150724519380293, -0.4554554554554554, 0.002403846153846154], "score_NOT Basins_10D": 0.9969444281887263}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], 0.0], [1, [0.5555555555555554, -5.0], 0.0], [1, [-5.0, -3.888888888888889], 0.0], [1, [0.5555555555555554, -3.888888888888889], 0.0], [1, [-3.888888888888889, -2.7777777777777777], 0.0], [1, [-2.7777777777777777, -2.7777777777777777], 0.0], [1, [-1.6666666666666665, -1.6666666666666665], 0.0], [1, [5.0, -0.5555555555555554], 0.0], [1, [-3.888888888888889, 0.5555555555555554], 0.0], [1, [1.666666666666667, 0.5555555555555554], 0.0], [1, [-5.0, 1.666666666666667], 0.0], [1, [-3.888888888888889, 1.666666666666667], 0.0], [1, [-5.0, 2.7777777777777786], 0.0], [1, [-3.888888888888889, 2.7777777777777786], 0.0], [1, [-0.5555555555555554, 2.7777777777777786], 0.0], [1, [5.0, 2.7777777777777786], 0.0], [1, [-5.0, 3.8888888888888893], 0.0], [1, [-0.5555555555555554, 3.8888888888888893], 0.0], [1, [3.8888888888888893, 3.8888888888888893], 0.0], [1, [5.0, 3.8888888888888893], 0.0], [1, [-5.0, 5.0], 0.0], [1, [-0.5555555555555554, 5.0], 0.0], [1, [3.8888888888888893, 5.0], 0.0], [1, [5.0, 5.0], 0.0], [3, [4.300000000000077, 0.5555555555555554], -1.604754154393036], [3, [-0.5553615389939133, 1.3996074256416535], -1.2943350807246754], [7, [-2.757901604064052, 4.645475725938393], -8.41179349565293], [5, [-4.719713070638409, -1.0967562400085598], -1.0348150104145448], [2, [4.882035279727038, -4.830003620977235], -1.1508808913816395], [6, [3.8758532796277363, -1.6551853066828435], -2.203012237080965], [1, [-2.332592616222853, -0.44448227303530125], -0.755103374581507], [2, [3.495548271798153, -4.107162288242756], -1.6973738869312271], [5, [2.7777777777777786, -4.1780000000000905], -2.110018025506991], [8, [1.4043292327998618, 4.083769462325986], -0.42396152760758393], [2, [-0.5749607740581574, -3.9381050126204213], -1.6201470689057382], [1, [3.366874770574369, -1.420929603511888], -2.179655722109583], [1, [2.9803359237550664, 2.256821867851746], -0.3451346063543591], [2, [-1.5771036259790712, 1.95246656040222], -0.6890988227358791], [1, [3.683335279862945, -4.619822061095715], -1.998116864414813], [6, [1.2889705059407666, -1.8714881935243117], -15.064068121523233], [1, [-4.916829354158625, -2.849768358205541], -1.7267543174266324], [3, [-2.547759563130266, 0.6246904614272195], -1.0645601447858077], [4, [3.622660723077147, 1.2596240706258166], -0.9544904232065368], [1, [-0.8773738262953595, -1.1749826179317704], -1.2283582437563731], [6, [-2.483273374152345, -4.953600176413288], -3.206013340813357], [1, [1.9189736985092953, 1.596305341526653], -0.8168930726508379], [1, [-0.7328221514509664, -2.3577049004972346], -1.456414489491244], [2, [-2.698564124019369, -0.9222807446149655], -0.9015434053919724], [2, [-1.2865680052313793, -2.9591013237382406], -2.94720283971298]], "nr_of_basins": 49, "f_opt_dim_2": -15.659753121723346, "x_opt_dim_2": [1.2003752761837703, -1.8801464511947943], "f_opt_dim_5": 0.0, "x_opt_dim_5": [-1.4897097829737598, -2.672519334057664, 0.36459286480745207, -0.5134301732740484, -0.32509845380910135]}
{"id": "af2b47a1-3bb7-4752-8bae-7b0552602950", "fitness": 0.9188562009173135, "name": "landscape_interacting_gaussians_nonuniform", "description": "A non-separable, multi-well landscape built from a sum of anisotropic Gaussian wells with varying centers, depths, and covariance structures, augmented by pairwise interaction wells to create highly non-homogeneous basin sizes. This extended landscape preserves a deep central basin while introducing many additional interacting wells whose sizes and shapes vary dramatically, producing a rich, non-uniform basin-size distribution across [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_interacting_gaussians_nonuniform:\n    \"\"\"\n    Non-separable landscape composed as a sum of anisotropic Gaussian wells with\n    varying centers, depths, and covariance structures, augmented by pairwise\n    interaction wells to promote highly non-homogeneous basin sizes.\n\n    Each base well k has:\n      - center c_k in R^dim\n      - depth A_k (positive scalar)\n      - positive-definite, rotated covariance P_k (dim x dim)\n\n    Additionally, for every pair (i, j) of wells, there is an interaction well with:\n      - center m_ij (midpoint of c_i and c_j)\n      - covariance P_ij (dim x dim)\n      - depth B_ij (positive scalar)\n\n    The objective is:\n      f(x) = - sum_k A_k * exp(-0.5 * (x - c_k)^T P_k (x - c_k))\n             - sum_{i<j} B_ij * exp(-0.5 * (x - m_ij)^T P_ij (x - m_ij))\n\n    This setup yields basins of highly varying sizes and shapes, breaking basin-size\n    homogeneity and providing a challenging minimization landscape.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        rng = np.random.default_rng(1234)\n\n        self.wells = []\n        # Number of primary wells (4-8) to create a rich, non-homogeneous landscape\n        K = rng.integers(4, 9)\n        for k in range(K):\n            # Center\n            if k == 0:\n                c = np.zeros(self.dim)\n            else:\n                c = rng.uniform(-4.0, 4.0, size=(self.dim,))\n                # Enforce a reasonable distance from origin\n                if np.linalg.norm(c) < 0.6:\n                    if np.linalg.norm(c) == 0:\n                        c += rng.uniform(0.6, 1.2)\n                    else:\n                        c = c / (np.linalg.norm(c) + 1e-12) * rng.uniform(0.6, 2.0)\n\n            # Depth (origin well the deepest)\n            if k == 0:\n                A = rng.uniform(8.0, 12.0)\n            else:\n                A = rng.uniform(1.0, 6.0)\n\n            # Generate a random SPD covariance (via rotation + eigenvalues)\n            R = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(R)  # orthogonal\n            lam = rng.uniform(0.25, 4.0, size=(self.dim,))\n            P = Q @ np.diag(lam) @ Q.T  # SPD\n\n            self.wells.append({'c': c, 'A': A, 'P': P})\n\n        # Pairwise interaction wells to promote basin-size heterogeneity\n        self.intrs = []\n        for i in range(K):\n            for j in range(i + 1, K):\n                # Midpoint center for interaction well\n                m = (self.wells[i]['c'] + self.wells[j]['c']) / 2.0\n\n                # SPD covariance for the interaction well\n                R2 = rng.normal(size=(self.dim, self.dim))\n                Q2, _ = np.linalg.qr(R2)\n                lam2 = rng.uniform(0.25, 6.0, size=(self.dim,))\n                P_int = Q2 @ np.diag(lam2) @ Q2.T\n\n                # Interaction depth\n                B = rng.uniform(0.5, 2.5)\n\n                self.intrs.append({'m': m, 'P': P_int, 'B': B})\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        val = 0.0\n        # Sum of primary wells\n        for w in self.wells:\n            diff = x - w['c']\n            expo = -0.5 * float(diff.T @ w['P'] @ diff)\n            val -= w['A'] * np.exp(expo)\n\n        # Add pairwise interaction wells\n        for inter in self.intrs:\n            diff = x - inter['m']\n            expo = -0.5 * float(diff.T @ inter['P'] @ diff)\n            val -= inter['B'] * np.exp(expo)\n\n        return float(val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_interacting_gaussians_nonuniform scored on:NOT Basins 0.993,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["898090aa-bc60-4355-b45f-5a69e6202990"], "operator": null, "metadata": {"ela_features_2D": [0.11681326330901494, 0.64078769634745, 0.018611550510878417, 0.29300537694760376, 23.77984257428336, 0.14091587846622816, 0.43209680001681805, 2.9042980674840346, 0.6661347733864823, -1.0856874311898732, 0.10809386844485935, 1.6, 0.45057278063872735, 0.680338182131382, 0.4050933545628553, 0.3557650611228712, -0.20442082917962717, 0.32336352237239757, 0.4679707908928771, 0.47200293745409533, 0.6363875038239291, 0.18618088444705774, 0.33184243213993075, 0.4182082734085366, 0.5858823178537526, -0.3540076953165585, -0.27837857158392015, -0.2762557219649153, -0.19024481986613387, -0.41870357343730724, -0.34377431972068473, -0.299330953663996, -0.2130644863580402, 1.0, 1.0, 1.0, 1.0, 0.5179309288966476, 0.5179023379777279, 0.4406586616345548, 0.4512788237229833, 0.5642147287488568, 0.7617617617617616, 0.7114116511393821, -0.2952952952952952, 0.3811244979919679], "score_NOT Basins_2D": 0.770116999745369, "ela_features": [0.005725602484886782, 0.987036851018414, 0.0013972871616670947, 0.01164851404965771, 13.086278486975871, 0.0080584862065614, 0.02423504883618084, 17.942111745996588, 0.05142137808844207, -14.080364258236798, 244.47566824918312, 6.4, 0.7426978805316946, 0.835203882456144, 0.524566337414481, 0.2098211504561549, -0.3123320347058997, 0.6576832410357133, 0.697284961190135, 0.7401521617857256, 0.8100193552930304, 0.6298918506297536, 0.6735612202894388, 0.7234365745487003, 0.8003199821384162, -0.3011061710198143, -0.2662717275564573, -0.22856339217244237, -0.16710890596652128, -0.3272803204294412, -0.2886635716509859, -0.24455364883644287, -0.17657110311896942, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21471835654343105, 0.21474011653177913, 0.21359885800473788, 0.18767891513959095, 0.5074693824687572, 0.08108108108108103, 0.0, -Infinity, 0.49839743589743596], "score_NOT Basins_5D": 0.9930957299657166, "ela_features_10D": [-0.0011672139369644397, 1.000693868336458, 0.00015192403756979954, 0.002335197895893515, 116.90955324416385, -0.012931464409206405, -0.0001846696224135913, 47.961409845452934, -0.03673743434449413, -41.77512220813283, 1868.0260684382451, 2.4, 0.7465379306360905, 0.8460072639008764, 0.47516687742747, 0.1561081901194001, -0.1097773277335224, 0.7562541219272529, 0.7821030396838256, 0.8147632437279931, 0.8646568486998077, 0.7535836880677316, 0.778473218012054, 0.8117103444910935, 0.8633270135817266, -0.30914747735517334, -0.2763612376669746, -0.2349379165189715, -0.17165686033417252, -0.3133638245158442, -0.28170580645455445, -0.23944018507142867, -0.17380017198818948, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11124823366527406, 0.11124948576346594, 0.11118068758783702, 0.10196056515758778, 0.5224987101965323, -2.8578578578578577, 0.0, -Infinity, 0.3295436349079263], "score_NOT Basins_10D": 0.9933558730408549}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [3.325036196703932, -3.1517347275030327], -12.045778786818495], [22, [1.534128220532887, -1.5807607169079938], -9.572096452324423], [33, [-0.15566046622178395, -0.1590388945730869], -13.709987035761786], [29, [-3.5560603500561574, -1.2042973540435709], -8.16706351028522]], "nr_of_basins": 4, "f_opt_dim_2": -13.709990702005722, "x_opt_dim_2": [-0.15469591003431793, -0.1588313167295709], "f_opt_dim_5": -2.1693886617798106, "x_opt_dim_5": [1.963661550433429, -1.3158670158854955, -1.7684083081551645, -0.014555509075108023, -0.5285752079861479]}
{"id": "f046cb72-56a7-4df5-a5d0-ec9d6e5e628a", "fitness": 0.997938102732102, "name": "landscape_nh_rotated_sine_wells", "description": "A non-homogeneous multi-well landscape built from rotated, anisotropic ellipsoidal wells with interior sinusoidal ripples. Each well defines a clipped ellipsoidal region where the depth is modulated by a small, well-specific ripple pattern, and outside the ellipsoid the contribution is flat at the well's depth. The landscape uses a true minimum over wells, yielding highly irregular basin shapes and sizes, breaking basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_nh_rotated_sine_wells:\n    \"\"\"\n    Non-homogeneous landscape: minimum over multiple rotated, anisotropic ellipsoidal wells\n    with interior sinusoidal modulations.\n\n    For each well i:\n      - center c_i in [-5, 5]^dim\n      - a random SPD matrix A_i defining an anisotropic ellipsoid (via d_i = sqrt((x-c_i)^T A_i (x-c_i)))\n      - a radius r_i defining the interior ellipsoid\n      - a negative depth depth_i\n      - a small internal modulation h_i(x) composed of several sine terms along random directions\n    The well value inside the ellipsoid is:\n        f_i(x) = depth_i - (1 - d_i / r_i) * (1 + h_i(x))\n    Outside the ellipsoid, f_i(x) = depth_i.\n    The landscape is f(x) = min_i f_i(x).\n    \"\"\"\n\n    def __init__(self, dim):\n        self.dim = int(dim)\n        # Deterministic-ish seed derived from dimension for reproducibility\n        rng = np.random.default_rng(seed=(1000 + self.dim * 17))\n\n        # Number of wells grows with dimension to ensure richer basins\n        self.N = max(4, min(64, 4 * self.dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, self.dim))\n\n        # Elliptical (anisotropic) wells\n        As = []\n        self.radii = np.zeros(self.N, dtype=float)\n        self.depths = np.zeros(self.N, dtype=float)\n        self.mods = []  # modulation parameters per well\n\n        for i in range(self.N):\n            # Random rotation (orthogonal matrix)\n            M = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues controlling axis scales (avoid too flat wells)\n            lam = rng.uniform(low=0.5, high=6.0, size=self.dim)\n            A_i = Q @ np.diag(lam) @ Q.T  # SPD\n            As.append(A_i)\n\n            # Ellipsoid radius (defines interior region)\n            self.radii[i] = rng.uniform(low=0.8, high=3.5)\n\n            # Negative depth (well depth)\n            self.depths[i] = -rng.uniform(low=0.5, high=6.0)\n\n            # Interior modulation: a few sine components along random directions\n            T = rng.integers(2, 5)  # number of components\n            dirs = rng.normal(size=(T, self.dim))\n            dirs = np.asarray([d / np.linalg.norm(d) for d in dirs])\n            freqs = rng.uniform(low=0.5, high=2.5, size=T)\n            amps = rng.uniform(low=0.05, high=0.25, size=T)\n            self.mods.append((dirs, freqs, amps))\n\n        self.As = np.stack(As, axis=0)  # shape (N, dim, dim)\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        min_val = None\n        for i in range(self.N):\n            c = self.centers[i]\n            delta = x - c  # (dim,)\n\n            # Ellipsoidal distance via SPD matrix A_i\n            A_i = self.As[i]\n            d2 = delta @ A_i @ delta\n            d = np.sqrt(max(d2, 0.0))\n\n            if d <= self.radii[i]:\n                # Interior modulation h_i(x)\n                dirs, freqs, amps = self.mods[i]\n                # h_i(x) = sum_t amp_t * sin(freq_t * (dir_t dot delta))\n                projection = delta @ dirs.T  # (T,)\n                h_i = (amps * np.sin(freqs * projection)).sum()\n                f_i = self.depths[i] - (1.0 - d / self.radii[i]) * (1.0 + h_i)\n            else:\n                f_i = self.depths[i]\n\n            if min_val is None or f_i < min_val:\n                min_val = f_i\n\n        return float(min_val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_rotated_sine_wells scored on:NOT Basins 0.998,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["19e2b275-334e-40e1-b107-afbc6748db37"], "operator": null, "metadata": {"ela_features_2D": [0.04708274950536755, 0.9653162067151075, 0.029459700706900287, 0.06694512053578676, 3.2377299794774124, 0.06257387964904453, 0.06529177522950032, 1.2175868196761186, 0.10627641344375627, -7.251762751756601, 58.23914779745979, 6.8, 0.05037466162463948, 0.06180062479971664, -0.011077853198854872, 1.4679179089654197, -0.25342247877779983, 0.5926502390950491, 0.9529335571085393, 1.0, 1.0, 0.3943322372872341, 0.8548616230675166, 1.0, 1.0, -0.2130134732439986, -0.024594511884070337, 0.0, 0.0, -0.3111222562710183, -0.07425691550314575, 0.0, 0.0, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5249055052356499, 0.5248845113006928, 0.49961753491051536, 0.41687687565798504, 0.1123538222676252, 0.9939939939939937, 1.2395246916338225, 0.6656656656656654, 0.02971887550200803], "score_NOT Basins_2D": 0.9985397309064865, "ela_features": [0.003055028506365476, 0.9969657020851818, 0.000889919051324244, 0.005845471848454125, 51.05172883554786, 0.005435247521884979, 0.0035468476703191198, 114.38722869235657, 0.004834471421281461, -27.204322093296224, 795.147032241287, 3.6, 0.20273883414348365, 0.2307264741034945, 0.10102439304267988, 0.48697514539426556, -0.6407590063883511, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21564734796475724, 0.21563788800981332, 0.21511460197305593, 0.18540452097475968, 0.02287194335528405, -Infinity, 0.0038234600223966907, 0.33733733733733723, 0.0036858974358974354], "score_NOT Basins_5D": 0.9976372886449099, "ela_features_10D": [0.0011241253750364777, 0.9991385846457742, 7.719087761217194e-05, 0.004801666580935049, 62.20510414533611, 0.00039338306657599187, -3.671142309480402e-05, 525.7627603313504, -0.0101511228231832, -27.2768752068258, 790.2188339145731, 4.0, 0.23569926942789715, 0.265108061212187, 0.12911285795353905, 0.4616864282697974, -0.5466167161110844, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21483675278068143, 0.2148397242439486, 0.21430450331349932, 0.18225831327544356, 0.027028013741314742, -Infinity, 0.001821904953561479, 0.26526526526526517, 0.0049679487179487185], "score_NOT Basins_10D": 0.9976372886449099}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-5.0, -5.0], -5.474297059444123], [1, [-3.888888888888889, -5.0], -5.474297059444123], [1, [-2.7777777777777777, -5.0], -5.474297059444123], [1, [-1.6666666666666665, -5.0], -5.474297059444123], [1, [-0.5555555555555554, -5.0], -5.474297059444123], [1, [0.5555555555555554, -5.0], -5.474297059444123], [1, [1.666666666666667, -5.0], -5.474297059444123], [1, [2.7777777777777786, -5.0], -5.474297059444123], [1, [3.8888888888888893, -5.0], -5.474297059444123], [1, [5.0, -5.0], -5.474297059444123], [1, [-5.0, -3.888888888888889], -5.474297059444123], [1, [-2.7777777777777777, -3.888888888888889], -5.474297059444123], [1, [-1.6666666666666665, -3.888888888888889], -5.474297059444123], [1, [-0.5555555555555554, -3.888888888888889], -5.474297059444123], [1, [0.5555555555555554, -3.888888888888889], -5.474297059444123], [1, [1.666666666666667, -3.888888888888889], -5.474297059444123], [1, [5.0, -3.888888888888889], -5.474297059444123], [1, [-5.0, -2.7777777777777777], -5.474297059444123], [1, [-2.7777777777777777, -2.7777777777777777], -5.474297059444123], [1, [-1.6666666666666665, -2.7777777777777777], -5.474297059444123], [1, [-0.5555555555555554, -2.7777777777777777], -5.474297059444123], [1, [0.5555555555555554, -2.7777777777777777], -5.474297059444123], [1, [1.666666666666667, -2.7777777777777777], -5.474297059444123], [1, [2.7777777777777786, -2.7777777777777777], -5.474297059444123], [1, [3.8888888888888893, -2.7777777777777777], -5.474297059444123], [1, [5.0, -2.7777777777777777], -5.474297059444123], [1, [-5.0, -1.6666666666666665], -5.474297059444123], [1, [-3.888888888888889, -1.6666666666666665], -5.474297059444123], [1, [-2.7777777777777777, -1.6666666666666665], -5.474297059444123], [1, [-1.6666666666666665, -1.6666666666666665], -5.474297059444123], [1, [-0.5555555555555554, -1.6666666666666665], -5.474297059444123], [1, [0.5555555555555554, -1.6666666666666665], -5.474297059444123], [1, [1.666666666666667, -1.6666666666666665], -5.474297059444123], [1, [2.7777777777777786, -1.6666666666666665], -5.474297059444123], [1, [3.8888888888888893, -1.6666666666666665], -5.474297059444123], [1, [5.0, -1.6666666666666665], -5.474297059444123], [1, [-5.0, -0.5555555555555554], -5.474297059444123], [1, [-3.888888888888889, -0.5555555555555554], -5.474297059444123], [1, [-2.7777777777777777, -0.5555555555555554], -5.474297059444123], [1, [-1.6666666666666665, -0.5555555555555554], -5.474297059444123], [1, [-0.5555555555555554, -0.5555555555555554], -5.474297059444123], [1, [0.5555555555555554, -0.5555555555555554], -5.474297059444123], [1, [1.666666666666667, -0.5555555555555554], -5.474297059444123], [1, [2.7777777777777786, -0.5555555555555554], -5.474297059444123], [1, [3.8888888888888893, -0.5555555555555554], -5.474297059444123], [1, [5.0, -0.5555555555555554], -5.474297059444123], [1, [-5.0, 0.5555555555555554], -5.474297059444123], [1, [-3.888888888888889, 0.5555555555555554], -5.474297059444123], [1, [-2.7777777777777777, 0.5555555555555554], -5.474297059444123], [1, [-1.6666666666666665, 0.5555555555555554], -5.474297059444123], [1, [-0.5555555555555554, 0.5555555555555554], -5.474297059444123], [1, [0.5555555555555554, 0.5555555555555554], -5.474297059444123], [1, [1.666666666666667, 0.5555555555555554], -5.474297059444123], [1, [2.7777777777777786, 0.5555555555555554], -5.474297059444123], [1, [3.8888888888888893, 0.5555555555555554], -5.474297059444123], [1, [5.0, 0.5555555555555554], -5.474297059444123], [1, [-5.0, 1.666666666666667], -5.474297059444123], [1, [-3.888888888888889, 1.666666666666667], -5.474297059444123], [1, [-2.7777777777777777, 1.666666666666667], -5.474297059444123], [1, [-1.6666666666666665, 1.666666666666667], -5.474297059444123], [1, [-0.5555555555555554, 1.666666666666667], -5.474297059444123], [1, [0.5555555555555554, 1.666666666666667], -5.474297059444123], [1, [1.666666666666667, 1.666666666666667], -5.474297059444123], [1, [2.7777777777777786, 1.666666666666667], -5.474297059444123], [1, [3.8888888888888893, 1.666666666666667], -5.474297059444123], [1, [5.0, 1.666666666666667], -5.474297059444123], [1, [-5.0, 2.7777777777777786], -5.474297059444123], [1, [-3.888888888888889, 2.7777777777777786], -5.474297059444123], [1, [-2.7777777777777777, 2.7777777777777786], -5.474297059444123], [1, [-1.6666666666666665, 2.7777777777777786], -5.474297059444123], [1, [-0.5555555555555554, 2.7777777777777786], -5.474297059444123], [1, [0.5555555555555554, 2.7777777777777786], -5.474297059444123], [1, [1.666666666666667, 2.7777777777777786], -5.474297059444123], [1, [2.7777777777777786, 2.7777777777777786], -5.474297059444123], [1, [3.8888888888888893, 2.7777777777777786], -5.474297059444123], [1, [5.0, 2.7777777777777786], -5.474297059444123], [1, [-5.0, 3.8888888888888893], -5.474297059444123], [1, [-3.888888888888889, 3.8888888888888893], -5.474297059444123], [1, [-2.7777777777777777, 3.8888888888888893], -5.474297059444123], [1, [-1.6666666666666665, 3.8888888888888893], -5.474297059444123], [1, [-0.5555555555555554, 3.8888888888888893], -5.474297059444123], [1, [0.5555555555555554, 3.8888888888888893], -5.474297059444123], [1, [1.666666666666667, 3.8888888888888893], -5.474297059444123], [1, [2.7777777777777786, 3.8888888888888893], -5.474297059444123], [1, [3.8888888888888893, 3.8888888888888893], -5.474297059444123], [1, [5.0, 3.8888888888888893], -5.474297059444123], [1, [-5.0, 5.0], -5.474297059444123], [1, [-3.888888888888889, 5.0], -5.474297059444123], [1, [-2.7777777777777777, 5.0], -5.474297059444123], [1, [-1.6666666666666665, 5.0], -5.474297059444123], [1, [-0.5555555555555554, 5.0], -5.474297059444123], [1, [0.5555555555555554, 5.0], -5.474297059444123], [1, [1.666666666666667, 5.0], -5.474297059444123], [1, [2.7777777777777786, 5.0], -5.474297059444123], [1, [3.8888888888888893, 5.0], -5.474297059444123], [1, [5.0, 5.0], -5.474297059444123], [2, [3.4577777777777037, -3.888888888888889], -6.143293366782881], [2, [-3.888888888888889, -3.4817777777777], -5.908335758579632]], "nr_of_basins": 98, "f_opt_dim_2": -5.616552997718573, "x_opt_dim_2": [3.481006680321845, -2.849474762317216], "f_opt_dim_5": -5.902780296925264, "x_opt_dim_5": [1.5572653067122875, 1.5838159117513462, -2.1695974753899945, -1.84747833345703, -1.2157179581685948]}
{"id": "7fc30f8b-5a4a-45fc-beb2-96788222f796", "fitness": 0.9970392059428074, "name": "landscape_sine_interference_waves", "description": "A composite interference landscape built from many damped sine waves anchored at random centers with anisotropic Gaussian envelopes. The sum of irregular, directionally varying wells yields highly non-homogeneous basin sizes and shapes, distinct from the previously selected compact ellipsoidal bumps.", "code": "import numpy as np\n\nclass landscape_sine_interference_waves:\n    \"\"\"\n    Composite interference landscape: sum of damped sine waves anchored at random centers.\n    Each term i has:\n      - center c_i in [-5, 5]^dim\n      - a random SPD envelope (anisotropic Gaussian) defined by Sigma_i\n      - a direction vector (frequency) k_i\n      - an amplitude a_i\n    The local term: f_i(x) = a_i * sin(k_i^T (x - c_i)) * exp(-(x - c_i)^T Sigma_i (x - c_i))\n    The landscape is f(x) = sum_i f_i(x), evaluated on [-5,5]^dim.\n    This creates highly non-homogeneous basins with irregular shapes and varying depths.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=4242):\n        self.dim = int(dim)\n        rng = np.random.default_rng(seed)\n\n        # Number of waves grows with dimension to enrich basins\n        self.K = max(8, min(64, 4 * self.dim))\n\n        # Centers within the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.K, self.dim))\n\n        # Amplitudes (can be positive or negative)\n        self.A = rng.uniform(low=-2.0, high=2.0, size=self.K)\n\n        # SPD envelopes Sigma_i for anisotropic Gaussian shaping\n        self.Sigmas = []\n        for _ in range(self.K):\n            M = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(M)\n            # Ensure proper rotation with determinant +1\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n            # Eigenvalues controlling the shape of the ellipse (widths)\n            lam = rng.uniform(low=0.3, high=2.0, size=self.dim)\n            Sigma = Q @ np.diag(lam) @ Q.T\n            self.Sigmas.append(Sigma)\n        self.Sigmas = np.stack(self.Sigmas, axis=0)  # shape (K, dim, dim)\n\n        # Frequency vectors k_i (directions of oscillation)\n        self.Kvecs = rng.normal(size=(self.K, self.dim))\n        norms = np.linalg.norm(self.Kvecs, axis=1, keepdims=True)\n        norms[norms == 0] = 1.0\n        self.Kvecs = self.Kvecs / norms  # unit-ish direction vectors\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float).ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n        total = 0.0\n        for i in range(self.K):\n            delta = x - self.centers[i]\n            d2 = delta @ self.Sigmas[i] @ delta  # (x - c_i)^T Sigma_i (x - c_i)\n            env = np.exp(-d2)                   # anisotropic Gaussian envelope\n            phase = self.Kvecs[i] @ delta         # k_i^T (x - c_i)\n            total += self.A[i] * np.sin(phase) * env\n        return float(total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_sine_interference_waves scored on:NOT Basins 0.994,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["10bdf029-ebd3-49a4-bfe7-37cfbc5b2f09"], "operator": null, "metadata": {"ela_features_2D": [0.019948583734858017, 0.515054560933524, 0.02249053046438367, 0.05826115720759595, 14.505876054518405, 0.02651867789432514, 0.02525271529194282, 2.172252173032301, 0.13576889942037332, -0.2716537134588931, 4.389051969320951, 2.8, 0.30768281504367667, 0.6402831804290444, 0.31119155947307686, 0.36576541674744323, -0.27729369972289314, 0.6973177478683699, 0.6932686881488772, 0.7587397959322113, 0.7804639841507669, 0.6411865949985059, 0.4946965961626543, 0.5980946756290358, 0.6914293057708787, -0.15833783453201686, -0.16045369236067886, -0.12621042663770615, -0.11484521827102778, -0.1845450340525471, -0.2592760472388834, -0.20641937195603113, -0.15849595043310485, 1.0, 1.0, 0.6666666666666666, 1.0, 0.5249806624651467, 0.5249641964235825, 0.48245549530281207, 0.38883591507905424, 0.510595929627324, 0.8218218218218215, 0.2260417040535294, -0.6676676676676675, 0.37429718875502005], "score_NOT Basins_2D": 0.9969428519252688, "ela_features": [-3.748445787585819e-05, 0.4500967394029822, 0.0007483940011176327, 0.0051378445222005995, 12.00705347363447, -0.0018237520572284005, 0.00046665676259807223, 11.613504128592462, -0.0024230755609903286, -0.1501122006673114, 294.6642800267353, 6.6, 0.6133434950956496, 0.8143109145527827, 0.4613648550520776, 0.2244126765245722, -0.20050308432300853, 0.8296356802880318, 0.8433049074107043, 0.8559229154013867, 0.8944255482956057, 0.8353681217716165, 0.8432517162066475, 0.853237527857679, 0.8890215519607789, -0.14985401296110407, -0.13783280879116808, -0.1267310581417443, -0.09286391440353389, -0.1455767514299411, -0.138616597642854, -0.1297757637945448, -0.09813243553032507, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21670006242874512, 0.21671041983300848, 0.21618419994245458, 0.18327702000089047, 0.5836624602020188, -0.18718718718718713, 1.0499325923045863e-05, -Infinity, 0.5498397435897436], "score_NOT Basins_5D": 0.9998555905331159, "ela_features_10D": [-0.000820184360623033, 0.6848641242668936, 4.2043126497990086e-05, 0.002113667683422017, 181.45469389026385, -0.008018620707482249, -0.0022919412478545455, 20.862456263539674, -0.040643055223866756, -11.823238607618139, 1861.3055490381066, 2.2, 0.6223865791399354, 0.7905958381616218, 0.36791233788067595, 0.18758062775769058, -0.0752231175270289, 0.9207678714058645, 0.9233020830216017, 0.9268464445152327, 1.012333631750293, 0.9265667416744201, 0.923955746460058, 0.9266989452402496, 1.013017689193259, -0.10048805969611956, -0.09727379176422239, -0.09277922859387502, 0.015642563496849515, -0.09337979099286545, -0.0967004192184017, -0.09321323387586858, 0.016553917382254334, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11001111706480507, 0.11001672020012279, 0.10996083804768889, 0.10022547490570743, 0.6298930760911315, -3.19019019019019, 0.0, -Infinity, 0.28582866293034426], "score_NOT Basins_10D": 0.9943191753700376}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[2, [5.0, 1.666666666666667], 0.07292271574081241], [2, [-0.5555555555555554, 5.0], 0.05197823614689616], [4, [1.802666666666667, -5.0], -4.382041040069578e-06], [10, [0.15635790090899387, 0.06301801794123757], -0.4043499580956139], [16, [-2.3685824786417324, -2.7951399429469896], -1.0933769993720321], [3, [-2.0196161614853283, -1.1142607226483827], -0.009066583977798637], [11, [2.032955979406659, 3.9393186638403255], -0.6986158134510096], [21, [5.0, -1.0495555555555558], -0.004371183278185471], [23, [-1.0028389476207884, 2.2765345825897794], -0.23515449679280293], [1, [0.27239767096998474, 3.5357483918988217], -0.2500263481880424], [7, [2.0794113385411936, 2.406677873774964], -0.9673660866790275]], "nr_of_basins": 11, "f_opt_dim_2": -0.9698714147622044, "x_opt_dim_2": [2.113202334357021, 2.369904870458496], "f_opt_dim_5": -0.3447250412077861, "x_opt_dim_5": [-0.6029457514601024, 2.7690306367868587, 1.019909113926581, -0.37742314673250654, 1.1906456912100847]}
{"id": "be3de248-3f34-4f1e-810d-dc2b64f7eb72", "fitness": 0.9899986729336282, "name": "landscape_interacting_gaussians_heterogeneous", "description": "A non-separable multi-well landscape with per-well spatial modulation to induce strong heterogeneity of basin sizes across the search space. Each Gaussian well has its own center, covariance, depth, and a sinusoidal modulation that scales its depth depending on the location, creating irregular basin shapes and varied basin sizes that break basin-size homogeneity.", "code": "import numpy as np\n\nclass landscape_interacting_gaussians_heterogeneous:\n    \"\"\"\n    Non-separable landscape: sum of anisotropic Gaussian wells with per-well spatial modulation.\n    Each well k has:\n      - center c_k in R^dim\n      - depth A_k (positive scalar)\n      - positive-definite, rotated covariance P_k (dim x dim)\n      - per-well spatial modulation m_k(x) = 1 + m_amp_k * sin(omega_k * (v_k^T x) + phi_k)\n        where v_k is a random direction, omega_k and phi_k define the sinusoid, and m_amp_k controls the\n        modulation strength.\n    The objective is f(x) = - sum_k A_k * m_k(x) * exp(-0.5 * (x - c_k)^T P_k (x - c_k)).\n    The modulation introduces spatially varying basin depths, producing highly non-homogeneous basin sizes\n    across the search space [-5,5]^dim, thereby challenging optimization algorithms.\n    \"\"\"\n\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Deterministic seed for reproducibility\n        rng = np.random.default_rng(1234)\n\n        self.wells = []\n        # Number of wells to create a rich, non-homogeneous landscape\n        K = rng.integers(4, 7)\n\n        for k in range(K):\n            # Center\n            if k == 0:\n                c = np.zeros(self.dim)\n            else:\n                c = rng.uniform(-4.0, 4.0, size=(self.dim,))\n                # Ensure a reasonable distance from origin to avoid trivial overlaps\n                if np.linalg.norm(c) < 0.6:\n                    if np.linalg.norm(c) == 0:\n                        c += rng.uniform(0.6, 1.2)\n                    else:\n                        c = c / (np.linalg.norm(c) + 1e-12) * rng.uniform(0.6, 2.0)\n\n            # Depth (ensure the first well is the deepest)\n            if k == 0:\n                A = rng.uniform(6.0, 9.0)\n            else:\n                A = rng.uniform(0.8, 6.0)\n\n            # Generate a random rotation and a positive-definite covariance\n            R = rng.normal(size=(self.dim, self.dim))\n            Q, _ = np.linalg.qr(R)  # orthogonal matrix\n            lam = rng.uniform(0.3, 4.0, size=(self.dim,))  # eigenvalues\n            P = Q @ np.diag(lam) @ Q.T  # SPD\n\n            # Per-well modulation parameters\n            v = rng.normal(size=(self.dim,))\n            norm_v = np.linalg.norm(v)\n            if norm_v == 0:\n                v = rng.normal(size=(self.dim,))\n                norm_v = np.linalg.norm(v)\n            v /= (norm_v + 1e-12)  # direction for projection\n            omega = rng.uniform(0.5, 2.5)\n            phi = rng.uniform(0.0, 2 * np.pi)\n            m_amp = rng.uniform(0.0, 0.45)  # modulation depth\n\n            self.wells.append({\n                'c': c,\n                'A': A,\n                'P': P,\n                'v': v,\n                'omega': omega,\n                'phi': phi,\n                'm_amp': m_amp\n            })\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape at point x.\n\n        Parameters:\n        - x: 1D array-like of length self.dim\n\n        Returns:\n        - scalar function value f(x)\n        \"\"\"\n        x = np.asarray(x, dtype=float).reshape(-1)\n        if x.shape[0] != self.dim:\n            raise ValueError(f\"Input dimension mismatch: expected {self.dim}, got {x.shape[0]}\")\n\n        total = 0.0\n        for w in self.wells:\n            diff = x - w['c']\n            expo = -0.5 * float(diff.T @ w['P'] @ diff)\n            proj = w['v'] @ x  # projection of x along modulation direction\n            m = 1.0 + w['m_amp'] * np.sin(w['omega'] * proj + w['phi'])\n            total += w['A'] * m * np.exp(expo)\n\n        return float(-total)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_interacting_gaussians_heterogeneous scored on:NOT Basins 0.995,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["898090aa-bc60-4355-b45f-5a69e6202990"], "operator": null, "metadata": {"ela_features_2D": [0.12121571134595052, 0.982570258772229, 0.04101044996338487, 0.27519430037549053, 6.907955586923616, 0.12487016919643656, 0.4134970841226643, 1.433678637229368, 0.5638250218472942, -1.3108002384793993, 0.8174518547974307, 1.8, 0.4316515493226105, 0.6734575792697944, 0.3588134083677805, 0.35583241894098483, -0.2141733031895475, 0.28424786399725865, 0.5028196268666972, 0.57196730603664, 0.5928375441296685, 0.2056879093108249, 0.5264679810504543, 0.6126172989622102, 0.5869838231380161, -0.37440673846487654, -0.2600693390083454, -0.2239017505421783, -0.2129783513201927, -0.4075258776022535, -0.2429382307490245, -0.19876315831110702, -0.21188039431029307, 1.0, 1.0, 1.0, 1.0, 0.5212116755465525, 0.5212057061017376, 0.44244399739827556, 0.45250859554042877, 0.531205374442953, 0.8138138138138136, 0.6272172150510238, -0.35135135135135126, 0.3674698795180723], "score_NOT Basins_2D": 0.9844367047771811, "ela_features": [0.008857919038531569, 1.0051134173607088, 0.002657030576654674, 0.011173723021110887, 10.557162212896259, 0.01622301992943791, 0.014297178676506617, 5.595754205440766, 0.03960824892806632, -19.549177279632914, 474.7030955370087, 5.2, 0.6678224994538127, 0.7952991489321835, 0.454853449215205, 0.237395401321377, -0.21141611571126057, 0.6990492375085889, 0.7144741716658276, 0.7438258093505673, 0.8077030091886765, 0.7054465166488454, 0.712312220774242, 0.7331197358987821, 0.7976844970509658, -0.26475554605432505, -0.2511785382905738, -0.22536166614941638, -0.16916630765542412, -0.26045154673317517, -0.25435235389972005, -0.2359666442840272, -0.17887920146145764, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21359973956200268, 0.213603959770245, 0.2125512669711175, 0.18903245672209934, 0.5165416608736277, -0.1151151151151151, 0.0, -Infinity, 0.4320512820512821], "score_NOT Basins_5D": 0.9904921734705567, "ela_features_10D": [-0.0006929243743808878, 1.0010167199813758, 0.00013104120654468834, 0.0027249307190974443, 39.16953484941375, -0.01258800810040941, 0.0005039216293233784, 12.50694265150002, -0.03274520428053869, -38.17871725248241, 1622.2889561131694, 3.0, 0.7139404481066546, 0.815632074477772, 0.4114313192013454, 0.17231176462194983, -0.09212753595036227, 0.7393769327132207, 0.7830784910177557, 0.8173589380693812, 0.9738167905255795, 0.7336940544824946, 0.777975025104382, 0.8126400941865691, 0.9732388136177871, -0.33056715662828295, -0.2751366474117313, -0.23165637716079837, -0.033204963780334974, -0.33869546850711185, -0.2823754504708642, -0.23828870113818965, -0.03402332929259586, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11036668508093621, 0.11036662892233776, 0.11028779066407315, 0.10064995145580846, 0.4582937777891285, -3.454454454454455, 0.0, -Infinity, 0.2538030424339472], "score_NOT Basins_10D": 0.9950671405531466}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[19, [-1.9886259567305429, 1.935758847555463], -3.502531943788744], [26, [0.42198112581586855, -0.03922640186216894], -6.104516489518349], [17, [0.30224946726507923, -3.939549896231783], -1.4594096746555472], [15, [-1.4267623564814491, 3.8546466043065086], -4.584895662658631], [23, [2.891624445886262, 1.4101801308455189], -5.053230458343969]], "nr_of_basins": 5, "f_opt_dim_2": -6.104516567986912, "x_opt_dim_2": [0.4218834287587658, -0.039138512634020524], "f_opt_dim_5": -3.5471313166301623, "x_opt_dim_5": [2.443703551044885, -0.02153865026901691, -1.54605157555398, -2.135835301950159, 3.1744769382383415]}
{"id": "b02ef2a1-693b-4396-b0aa-89e9d8f24a0b", "fitness": 0.9948917296715081, "name": "landscape_line_slabs_nonhomogeneous", "description": "A completely different non-homogeneous landscape built from line-based troughs (slabs) oriented along random directions. Each trough is a thick slab around a random line in the space, producing non-uniform basin shapes and sizes. The sum of many such line-slabs creates a challenging, non-homogeneous minimization landscape within [-5,5]^dim.", "code": "import numpy as np\n\nclass landscape_line_slabs_nonhomogeneous:\n    \"\"\"\n    A non-homogeneous landscape built from line-based troughs (slabs).\n    Each trough i is defined by:\n      - center c_i in R^dim\n      - a random unit direction u_i (line orientation)\n      - width w_i > 0 (thickness of the slab around the line)\n      - depth h_i > 0 (depth of the trough)\n    The trough contribution is non-zero only for points whose perpendicular\n    distance to the line is <= w_i, with a linear (V-shaped) decay along the\n    line coordinate p_i = dot(u_i, x - c_i):\n        contrib_i(x) = -h_i * max(0, 1 - |p_i| / w_i)  for dist_perp(x, line_i) <= w_i\n    The overall landscape is f(x) = sum_i contrib_i(x).\n    Domain is [-5, 5]^dim; f(x) <= 0 everywhere (global optimum <= 0).\n    \"\"\"\n\n    def __init__(self, dim):\n        \"\"\"\n        Initialize the non-homogeneous line-slabs landscape in 'dim' dimensions.\n        The number of slabs scales with dimension to keep the landscape challenging.\n        \"\"\"\n        self.dim = int(dim)\n        # Deterministic seed from dimension for reproducibility\n        seed = (self.dim * 29) ^ 0x9e3779b9\n        self._rng = np.random.default_rng(seed)\n\n        # Number of slabs; ensures a rich, non-uniform landscape\n        self.n_slabs = max(20, int(4 * self.dim + 12))\n\n        self._init_landscape()\n\n    def _init_landscape(self):\n        d = self.dim\n        n = self.n_slabs\n\n        # Centers within [-5, 5]^d\n        self.centers = self._rng.uniform(-5.0, 5.0, size=(n, d))\n\n        # Random unit directions (slab normals / line directions)\n        self.directions = np.empty((n, d))\n        for i in range(n):\n            v = self._rng.normal(size=d)\n            norm = np.linalg.norm(v)\n            if norm == 0:\n                norm = 1.0\n            self.directions[i] = v / norm\n\n        # Widths (thickness of each slab) in a reasonable range\n        self.widths = self._rng.uniform(0.25, 4.0, size=n)\n\n        # Depths (how deep each trough is)\n        self.depths = self._rng.lognormal(mean=0.0, sigma=1.0, size=n)\n\n        # Cache references for speed\n        self._centers = self.centers\n        self._dirs = self.directions\n        self._widths = self.widths\n        self._depths = self.depths\n\n    def f(self, x):\n        \"\"\"\n        Landscape evaluation.\n        For each slab i:\n          - compute projection along its direction: p_i = dot(u_i, x - c_i)\n          - compute perpendicular distance to the line: dist_perp_i\n          - if dist_perp_i <= w_i, contribute: -h_i * (1 - |p_i|/w_i)\n          - else contribution is 0\n        Returns scalar for 1D input, or 1D array for batched inputs.\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim == 1:\n            x = x.reshape(1, -1)\n            single = True\n        else:\n            single = False\n\n        k = x.shape[0]\n        total = np.zeros(k, dtype=float)\n\n        for i in range(self.n_slabs):\n            c = self._centers[i]      # (d,)\n            u = self._dirs[i]          # (d,)\n            w = self._widths[i]        # scalar\n            h = self._depths[i]        # scalar\n\n            diff = x - c               # (k, d)\n            p = diff @ u                 # (k,)\n            # Perpendicular component: diff - p * u\n            perp = diff - p[:, None] * u  # (k, d)\n            dist_perp = np.sqrt((perp * perp).sum(axis=1))  # (k,)\n\n            mask = dist_perp <= w\n            if np.any(mask):\n                bump = 1.0 - np.abs(p[mask]) / w  # (m,)\n                total[mask] += -h * bump\n\n        if single:\n            return float(total[0])\n        else:\n            return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_line_slabs_nonhomogeneous scored on:NOT Basins 0.994,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["842b4488-9c19-4cfb-acdb-8cb1a052cb8a"], "operator": null, "metadata": {"ela_features_2D": [0.012631403987939405, 0.19814992399624148, 0.02550203142452756, 0.07842266496388635, 10.506000273620357, 0.35717845028468903, 0.024908263120965925, 5.22311618542391, 0.4745114902173098, 1.5897456591387817, 2.0577245795454937, 2.6, 0.2538752393902601, 0.5993948463746964, 0.238223979505325, 0.3837942889559961, -0.2142944333280128, 0.21721713504317383, 0.8427066439369846, 1.0266074357344641, 0.9584450616071601, 0.20620489910019613, 0.5909858921136796, 0.9564417546768045, 0.7566058963712501, -0.4094800105963869, -0.08229012733831098, 0.0139171577420921, -0.021740625915099076, -0.40766564251310095, -0.20986416109849637, -0.022323246820601116, -0.12498461281999665, 1.0, 1.0, 1.0, 1.0, 0.5128792461301606, 0.5128713643765161, 0.42246900096230444, 0.3787649209243351, 0.7470414385461563, 1.306306306306306, 0.15463865119856823, -0.3433433433433432, 0.46787148594377514], "score_NOT Basins_2D": 0.9997419286519289, "ela_features": [0.020609837224966697, 0.2502551498922085, 0.0018398100644136564, 0.0221703408435757, 27.310581663364054, 0.03565087785118819, 0.03153551806816142, 10.761449702449289, 0.09081067842606586, 4.852678020795158, 51.43721971273739, 7.4, 0.34284620803042454, 0.5631899143965294, 0.19282725117105995, 0.3967951973592382, -0.17683242899474377, 0.7457894371217235, 0.8243722346867808, 0.8790132318021115, 1.007693496768779, 0.7524206661104411, 0.8327543461680158, 0.8890579514960365, 1.008466495181289, -0.22354534311422175, -0.15444161984133148, -0.10639360492699945, 0.006765390514029845, -0.21878755276821008, -0.14778999590322084, -0.09804916001036885, 0.007481757473101513, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21479093727693402, 0.21477484203952427, 0.21313509601178215, 0.19354954965140778, 0.5803911258826275, 0.1531531531531531, 0.015537918946560581, -0.9359359359359359, 0.25817307692307695], "score_NOT Basins_5D": 0.9908900866284966, "ela_features_10D": [-0.001337666113496172, 0.4288625941574879, 0.00012932977004203347, 0.0018681916795983504, 19.352200107869873, -0.008548065379931514, -0.002149317534172623, 38.30502648859135, -0.03343059678489622, 12.879063722522043, 1375.0071285884183, 2.6, 0.37072002586928915, 0.4403297498621762, 0.21240331766668047, 0.23922441510622744, -0.3501258313143599, 1.0001239488838194, 1.0001239488838194, 1.0001239488838194, 1.0001239488838194, 1.0001298959164686, 1.0001298959164686, 1.0001298959164686, 1.0001298959164686, 0.000157187674533521, 0.000157187674533521, 0.000157187674533521, 0.000157187674533521, 0.00016514053073812818, 0.00016514053073812818, 0.00016514053073812818, 0.00016514053073812818, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11029120824134317, 0.1102847001611402, 0.11024294457054558, 0.10058059714145229, 0.024874999247739848, -Infinity, 0.0025128051206281905, -0.6076076076076075, 0.0032826261008807047], "score_NOT Basins_10D": 0.9940431737340987}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [-0.3260331523646304, 2.5731379808580415], 6.153199579793185], [1, [-4.995193773222347, 3.9124027185251222], -5.979953517075947], [4, [-3.888888888888889, 3.018888888888985], -8.908469549461117], [1, [-1.4933433609055413, -3.7107399347448564], 2.283085303861297], [2, [3.320132447795261, 2.610064726296901], 8.472092616010809], [1, [1.8741564319064719, 1.5047711465909877], 5.948740321575675], [1, [-4.819065461361644, 3.1977800336419944], -6.026837801359183], [2, [-3.481180060258024, -0.5401441618333132], 0.03108001077064615], [7, [-1.6666637243532512, 0.2903515664722242], -0.6131389917206254], [1, [4.650829057866897, 3.300185977192666], 24.67099823780993], [3, [-4.641677870539487, 4.705946146660589], -6.936447488446389], [1, [0.9454691471556858, -1.8412958545512697], 0.3545155757298786], [12, [0.5555555555555554, -4.036000000000106], -3.0950832220673026], [2, [-4.1827877936923965, 0.6062069858023021], 1.3320315092269408], [1, [-4.4625186394103356, 1.7466620648819922], 6.818755627561062], [1, [-3.638934441720124, 1.6614295701350716], 0.148416093118255], [1, [-3.4076619573538607, 0.6820506402935966], 6.148449542238398], [1, [-4.580206160055547, -2.230587886042522], 58.86021036174119], [2, [2.4853031889464807, 1.1303435945131937], 4.242113455502505], [1, [4.786249471922292, 1.8556492784978746], 31.00838508715174], [2, [1.9970594302154487, 3.183179580832337], 6.3517501183514105], [2, [-0.46824540672472736, 1.000582203993832], 13.641451148796502], [6, [-2.367512343067767, 4.027472557575736], -0.6777842688534914], [1, [2.9647398327539367, 3.436884916226262], 7.930294456721544], [1, [-1.3107284708787719, 1.667160019570569], 5.58404471219838], [2, [-3.6112297090387817, -4.853548558184414], 1.5826992261233155], [1, [2.1800090656104216, 2.40945637263493], 8.913169097336759], [1, [2.5321222381707362, 2.462976148981549], 1.0396464509677947], [2, [4.817067391891062, -0.615931160177184], 5.96523668529816], [5, [4.304477385742773, -3.6099350339993346], -2.2110662179853224], [3, [-3.1308382025133588, -3.674982496408417], 2.429313333142046], [2, [1.741869989164013, 1.9852824980220283], 6.700806309735055], [1, [-0.5389485358886131, 1.1042012420239187], 1.0119075808391638], [4, [-0.5979437155506643, -3.1796055283914693], 0.5284219504341423], [2, [0.8207249520957434, 4.770069463819687], 37.706575478972994], [1, [-1.4590177442982482, 0.3256830593727256], 24.56169512575698], [1, [-1.4591752097233288, 2.417408120075805], 0.9557439096584395], [1, [-1.557380611020169, 2.416588979094278], 1.1287811899756097], [2, [2.4424741178097213, -1.7634490017223043], -1.380504179889027], [1, [-1.9727310206424282, 2.4187721481238444], -1.8261126053269758], [8, [0.9507857580015189, -1.3191027766051693], 0.49803510542385254], [3, [-0.8765033013519286, -2.0458049453573603], 1.8850353951832266], [1, [3.4968600471006823, 4.801582934208914], 8.741444999961605], [1, [3.85572577229896, 4.805828160729154], 7.530432628332697]], "nr_of_basins": 44, "f_opt_dim_2": -3.2040443862198984, "x_opt_dim_2": [0.10929142484900814, -4.086852916486221], "f_opt_dim_5": -4.740202764884337, "x_opt_dim_5": [-0.7126158935641038, -3.662737544110398, -0.2190514441861572, 2.254117822466578, 1.6880638477471857]}
{"id": "21d99adf-b729-4272-b544-73bc23669204", "fitness": 0.887009065838356, "name": "landscape_nh_elliptical_min_heterogeneous_ext", "description": "A highly non-homogeneous basin landscape built as the minimum over many anisotropic Gaussian-like wells, augmented with secondary sub-wells in a subset of wells to create irregular, multi-modal local basins. This dramatically increases basin-size heterogeneity by combining extremely wide, shallow basins with very deep, narrow ones and introducing nested sub-basin structures within some wells.", "code": "import numpy as np\n\nclass landscape_nh_elliptical_min_heterogeneous_ext:\n    \"\"\"\n    Non-homogeneous landscape: minimum of multiple anisotropic Gaussian-like wells\n    with dramatically varying widths and depths. A subset of wells hosts an additional\n    secondary sub-well to create multi-modal local basins, dramatically increasing\n    basin-size heterogeneity across the search space [-5, 5]^dim.\n\n    Each primary well i has:\n      - center c_i in [-5, 5]^dim\n      - a random positive-definite covariance A_i = Q_i * diag(lambda_i) * Q_i^T (elliptical, rotated)\n      - depth weight w1_i < 0 (negative, forming wells)\n    With probability p_second, a secondary sub-well is attached to well i:\n      - center c_i2 near c_i\n      - covariance A_i2\n      - depth weight w2_i < 0\n\n    Landscape: f(x) = min_i [ w1_i * exp(-0.5 * (x - c_i)^T A_i (x - c_i))  +\n                               w2_i * exp(-0.5 * (x - c_i2)^T A_i2 (x - c_i2)) (if second exists) ]\n    This yields highly non-homogeneous basins and irregular basin shapes.\n    \"\"\"\n\n    def __init__(self, dim=5, seed=1234):\n        self.dim = dim\n        rng = np.random.default_rng(seed)\n\n        # Number of wells grows with dimension to ensure a rich landscape\n        self.N = max(8, min(512, 12 * dim))\n\n        # Centers of wells inside the search space [-5, 5]^dim\n        self.centers = rng.uniform(low=-5.0, high=5.0, size=(self.N, dim))\n\n        # First-layer depths (negative values for wells)\n        self.weights1 = -rng.uniform(low=0.5, high=8.0, size=self.N)\n\n        # Primary ellipsoidal Gaussian shapes per well\n        self.As = np.zeros((self.N, dim, dim))\n        self.has_second = rng.uniform(size=self.N) < 0.45  # some wells have a sub-well\n        self.centers2 = np.zeros((self.N, dim))\n        self.As2 = np.zeros((self.N, dim, dim))\n        self.weights2 = np.zeros(self.N)\n\n        for i in range(self.N):\n            # Random rotation\n            M = rng.normal(size=(dim, dim))\n            Q, R = np.linalg.qr(M)\n            if np.linalg.det(Q) < 0:\n                Q[:, 0] *= -1\n\n            # Eigenvalues (controls widths along principal axes)\n            # Wide to narrow, spanning many orders of magnitude\n            lam = 10**rng.uniform(low=-3.0, high=2.0, size=dim)  # ~0.001 to ~100\n            A_i = Q @ np.diag(lam) @ Q.T\n            self.As[i] = A_i\n\n            # Optional secondary sub-well for added non-stationarity\n            if self.has_second[i]:\n                # Second center near the first to create nested basins\n                c2 = self.centers[i] + rng.normal(scale=2.0, size=dim)\n                c2 = np.clip(c2, -5.0, 5.0)\n                self.centers2[i] = c2\n\n                # Random rotation for second well\n                M2 = rng.normal(size=(dim, dim))\n                Q2, R2 = np.linalg.qr(M2)\n                if np.linalg.det(Q2) < 0:\n                    Q2[:, 0] *= -1\n\n                lam2 = 10**rng.uniform(low=-3.0, high=2.0, size=dim)\n                A_i2 = Q2 @ np.diag(lam2) @ Q2.T\n                self.As2[i] = A_i2\n\n                # Depth for second sub-well\n                self.weights2[i] = -rng.uniform(low=0.2, high=6.0)\n            else:\n                self.centers2[i] = np.zeros(dim)\n                self.As2[i] = np.zeros((dim, dim))\n                self.weights2[i] = 0.0\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1:\n            x = x.ravel()\n        if x.shape[0] != self.dim:\n            raise ValueError(\"Input x must be a 1D array with length equal to landscape dimension.\")\n\n        min_val = float('inf')\n        for i in range(self.N):\n            delta1 = x - self.centers[i]  # (dim,)\n            d2_1 = delta1 @ self.As[i] @ delta1\n            v1 = self.weights1[i] * np.exp(-0.5 * d2_1)\n\n            if self.has_second[i]:\n                delta2 = x - self.centers2[i]\n                d2_2 = delta2 @ self.As2[i] @ delta2\n                v2 = self.weights2[i] * np.exp(-0.5 * d2_2)\n                fi = v1 + v2\n            else:\n                fi = v1\n\n            if fi < min_val:\n                min_val = fi\n\n        return float(min_val)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_nh_elliptical_min_heterogeneous_ext scored on:NOT Basins 1.000,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["198cfda6-e39f-4905-b5e7-4b272bf2eb66"], "operator": null, "metadata": {"ela_features_2D": [0.8964285618212159, 0.7454443669139683, 0.1370051431520845, 0.9332519374797783, 6.945998655166579, 0.9016614997206371, 0.9920958014357808, 3.753581677053103, 0.9988980064110418, 0.6247804334225098, -0.8905651198430178, 1.8, 0.6101534343114008, 0.7043672727066397, 0.4853681350684512, 0.34400625793346123, -0.10153493998935889, 0.13493826164637515, 0.23291940902700475, 0.3362807491825692, 0.5364937264448423, 0.13083645491571722, 0.2194035468826247, 0.32285485032222677, 0.5132422907802725, -0.45253534371535264, -0.4012787198294201, -0.3472082387387109, -0.24247227379084618, -0.4465785232624547, -0.4010767269524479, -0.34792017060541935, -0.2501071689606269, 1.0, 1.0, 0.6666666666666666, 0.6666666666666666, 0.5135621630029716, 0.51353518118131, 0.6503955390892362, 0.6506014456615449, 0.6579912086104448, 0.2932932932932932, 0.27545918395059077, -0.39139139139139123, 0.363855421686747], "score_NOT Basins_2D": 0.6611792147159576, "ela_features": [0.21474575719731873, 0.540066060578264, 0.027831508945580986, 0.1896570405407942, 7.212138119592106, 0.2658531169227712, 0.2410217925805786, 5.55856366926366, 0.4003990269617878, -1.5323062831037129, 3.140469800029223, 2.2, 0.5838063438507761, 0.8166980952015986, 0.4279938015862982, 0.2252191560148209, -0.5264265179813968, 0.8893231194206452, 0.8678398486546612, 0.8721315916006309, 0.914496347131538, 0.9025179114456285, 0.8507033790161538, 0.8601650973149824, 0.9067837233624779, -0.09735693750216227, -0.11625281278204638, -0.11247588730101332, -0.07520971521960877, -0.08621698180346471, -0.13200225248597025, -0.12362198636506769, -0.08240676570155218, 1.0, 1.0, 0.8333333333333334, 0.8333333333333334, 0.21574144980366006, 0.21573316498176315, 0.20941560417422508, 0.24490177595199536, 0.8070783531346754, 0.5255255255255253, 0.11039429340454639, -0.5195195195195194, 0.5536858974358976], "score_NOT Basins_5D": 0.9999358631030191, "ela_features_10D": [0.09311460934175061, 0.9861056172314699, 0.0029979049941452366, 0.04982619019384679, 21.734003637814318, 0.12343538538168974, 0.1430692849814368, 7.367279626136818, 0.2073625301526308, -3.8249482820552165, 23.650941836761522, 6.2, 0.7442214771084792, 0.9057342452590756, 0.5405752019831818, 0.13429093456255664, -0.5936930021384622, 0.9158752252205458, 0.9228476261993365, 0.9187129224289082, 0.9255033775130004, 0.9178739399452633, 0.9235897466369714, 0.9182063193491766, 0.9234835993817795, -0.10669220712992993, -0.09784836813854643, -0.10309307385625881, -0.09448103868806798, -0.10443863586649185, -0.09716784414472071, -0.1040162328215409, -0.09730564646358583, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10977254014170505, 0.10977284863717877, 0.10884375917703874, 0.11894150563272651, 0.8008298965784235, -0.007007007007007006, 0.027959226709666107, -1.1521521521521525, 0.6045636509207366], "score_NOT Basins_10D": 0.9999121196960914}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- The search space should be not have basin size homogeneity. Which refers to a search space where the size relation (largest to smallest) of all basins of attraction is not homogeneous. (NOT Basins)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[1, [5.0, 5.0], -9.376585885211995], [91, [3.680491978881422, -2.9988650939650072], -9.52039496232536], [8, [-1.6252143507256294, -3.2756315033837407], -8.441152900313165]], "nr_of_basins": 3, "f_opt_dim_2": -9.520394962925117, "x_opt_dim_2": [3.6804629185548525, -2.998619250694078], "f_opt_dim_5": -5.334900335190597, "x_opt_dim_5": [3.323965946550528, -0.0025123828465598965, -0.9665201383417436, -0.30527077041970396, -0.6216992459257819]}
