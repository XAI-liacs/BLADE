{"id": "470081bd-a04c-48af-8d67-3af2fd73485c", "fitness": 0.598335862159729, "name": "landscape", "description": "A multi-modal deceptive landscape built as a sum of negative Gaussians (local wells) with a deep global minimum anchored at the origin. A quadratic regularization term shapes the overall basin and bounds the search region. The GlobalLocal metric quantifies the contrast between the deepest global minimum and the next deepest local minimum, normalized by the global depth, providing a single scalar measure of landscape difficulty.", "code": "import numpy as np\n\nclass landscape:\n    def __init__(self, dim=5, num_wells=None, seed=42, gamma=0.0):\n        \"\"\"\n        A novel benchmark landscape for black-box optimization.\n        - dim: problem dimensionality\n        - num_wells: number of Gaussian wells (local minima). If None, a function of dim is used.\n        - seed: RNG seed for deterministic landscape construction\n        - gamma: weight of the quadratic regularization term (global convex term)\n        \"\"\"\n        self.dim = int(dim)\n        self.LB = -5.0\n        self.UB = 5.0\n        self.gamma = float(gamma)\n\n        rng = np.random.default_rng(seed)\n\n        # Determine number of wells\n        if num_wells is None:\n            # scalable but bounded number of wells with dimension\n            N = max(3, min(12, self.dim + 2))\n        else:\n            N = max(1, int(num_wells))\n        self.N = N\n\n        # Amplitudes for wells (positive values, wells will be -A_i)\n        A = rng.uniform(1.5, 6.0, size=N)\n        # Ensure a deep global minimum at origin by boosting the first well\n        A[0] = max(A[0], 6.0)\n\n        # Centers of wells in the domain; ensure one center at origin for global min\n        centers = rng.uniform(-4.0, 4.0, size=(N, self.dim))\n        centers[0] = np.zeros(self.dim)\n\n        # Widths (standard deviations) for the Gaussians\n        sigma = rng.uniform(0.4, 1.6, size=N)\n\n        self.centers = centers          # shape (N, dim)\n        self.A = A                        # shape (N,)\n        self.sigma = sigma                # shape (N,)\n\n        # Store for potential external introspection\n        self.GlobalLocal = self._compute_global_local_metric()\n\n    def _compute_global_local_metric(self):\n        \"\"\"\n        Compute a GlobalLocal metric to characterize the landscape:\n        - For each well i, compute the (approximate) depth at its center:\n            d_i = -A_i + sum_{j != i} (-A_j) * exp(-||c_i - c_j||^2 / (2 * sigma_j^2)) + gamma * ||c_i||^2\n        - Let d be the vector of d_i across wells.\n        - Let delta be the difference between the second smallest and smallest depths (local vs global).\n        - GlobalLocal = delta / (|min_depth| + epsilon)\n        This yields a dimensionless measure of how pronounced the global minimum is relative to local minima.\n        \"\"\"\n        N = self.N\n        d = np.zeros(N)\n        for i in range(N):\n            di = -self.A[i]\n            ci = self.centers[i]\n            # cross-well contributions (j != i)\n            for j in range(N):\n                if j == i:\n                    continue\n                dist2 = np.sum((ci - self.centers[j])**2)\n                di += -self.A[j] * np.exp(-dist2 / (2.0 * (self.sigma[j] ** 2)))\n            di += self.gamma * np.sum(ci ** 2)\n            d[i] = di\n\n        sorted_d = np.sort(d)\n        if N > 1:\n            delta = sorted_d[1] - sorted_d[0]\n        else:\n            delta = 0.0\n        global_min = sorted_d[0]\n        epsilon = 1e-12\n        gl = delta / (abs(global_min) + epsilon)\n        return gl\n\n    def f(self, x):\n        \"\"\"\n        Evaluate the landscape function at point x.\n\n        f(x) = sum_{i=1..N} (-A_i) * exp(-||x - c_i||^2 / (2 * sigma_i^2)) + gamma * ||x||^2\n\n        - The global minimum is encouraged at the origin (c_0 = 0) with depth ~ -A_0\n        - Additional wells provide local minima of varying depths\n        - The per-dimension bounds are [-5, 5] (as defined in __init__)\n        \"\"\"\n        x = np.asarray(x, dtype=float)\n        if x.ndim != 1 or x.shape[0] != self.dim:\n            raise ValueError(f\"x must be a 1D array of length {self.dim}\")\n\n        val = 0.0\n        for i in range(self.N):\n            diff = x - self.centers[i]\n            dist2 = np.dot(diff, diff)\n            val += -self.A[i] * np.exp(-dist2 / (2.0 * (self.sigma[i] ** 2)))\n        val += self.gamma * np.sum(x ** 2)\n        return float(val)", "configspace": "", "generation": 0, "feedback": "The optimization landscape landscape scored on:GlobalLocal 0.393,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": [], "operator": null, "metadata": {"ela_features_2D": [0.06864460081906483, 0.8799387075083717, 0.03675193451503078, 0.23538480341342516, 6.621186123727087, 0.088342162080233, 0.5388319840890199, 1.1574346626889032, 0.6670502418504574, -1.0868860824091167, 0.07879860399017788, 1.4, 0.5374844680063804, 0.6937626166873269, 0.42224807698585004, 0.35028855323310587, -0.2073070542488619, 0.27017908515426636, 0.37955342769974687, 0.4265729483109354, 0.5676395090570499, 0.1776533993000429, 0.332438266157127, 0.4067361334585076, 0.5552513888180053, -0.38187183250940304, -0.32464960564211576, -0.3000401008005353, -0.22622741187908207, -0.42238331323068545, -0.3429161689405007, -0.30471502467221645, -0.22843154828700402, 1.0, 1.0, 1.0, 1.0, 0.5152053714084659, 0.5151823950442287, 0.41828216268303964, 0.4250306112111618, 0.5569849680734426, 0.7457457457457456, 0.6703119454418819, -0.1431431431431431, 0.3618473895582329], "score_GlobalLocal_2D": 0.8445912003517151, "ela_features": [0.01337423082903626, 0.9998977050807563, 0.001701034396246946, 0.025893823023396136, 22.151001328682316, 0.03004065728971104, 0.10331637316153879, 3.801391016691569, 0.21795418957245802, -6.841815058578696, 58.3055278126635, 7.0, 0.8205701627783044, 0.866036003370162, 0.5850017614539622, 0.18781264138282133, -0.3784475206614139, 0.6597349167807948, 0.6988935731232994, 0.7299302978081539, 0.7916835641311118, 0.6718952701798211, 0.6926876181612291, 0.7132084615210365, 0.7767146110409253, -0.2992834656716104, -0.2648446686977593, -0.23754470022782576, -0.18322960819363607, -0.29005196034295155, -0.27168190641733914, -0.2535356086317022, -0.19739699560273719, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21495021057105346, 0.21493365980959975, 0.21177766401579445, 0.1916995381725075, 0.5846044387169138, 0.3133133133133132, 0.0001798549671827386, -2.4134134134134135, 0.4998397435897436], "score_GlobalLocal_5D": 0.5573504567146301, "ela_features_10D": [0.001039867738768896, 1.0004703529839847, 0.0002004172911951787, 0.003812114811994928, 33.048800731496044, -0.00746384955162398, 0.010478328652268009, 19.889652724224316, -0.002238184218508277, -31.317576273342315, 1137.7810102923806, 4.2, 0.9681712454669121, 0.933104272736589, 0.6900621678452532, 0.1089644365402603, -0.25590841787117374, 0.736261823529705, 0.773216200560458, 0.8065631263749689, 0.8573511448494413, 0.7301845566644606, 0.7644032534052236, 0.798583156693893, 0.8550448226221631, -0.3344636415887674, -0.2875992464632276, -0.24530984978135412, -0.18090251281512942, -0.34302285264143106, -0.299519620612651, -0.2560660600743746, -0.18428562605580537, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.11023351270214299, 0.11023558540580669, 0.11014582940223834, 0.10085305571747434, 0.5032970239901552, -1.1081081081081081, 1.0518431227388301e-05, -Infinity, 0.577181745396317], "score_GlobalLocal_10D": 0.3930658996105194}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[15, [-0.995959258284148, 3.3872489676269644], -4.906111001527558], [20, [-2.8797732036108425, -0.38383151027518675], -5.614871165912722], [65, [0.07513443556617495, 0.08829823562161312], -6.337353020773281]], "nr_of_basins": 3, "f_opt_dim_2": -6.337604103775176, "x_opt_dim_2": [0.06368367540765096, 0.08648714059931546], "f_opt_dim_5": -6.053778388375374, "x_opt_dim_5": [-0.00464893034632179, -0.015138974525264153, 0.012180091602916228, -0.002338943883069624, 0.020619886161516356]}
{"id": "273bb194-46cb-46a3-9e39-9a94e3834dcf", "fitness": 0.5282108187675476, "name": "landscape_enhanced", "description": "Novel multi-modal separable Gaussian-well benchmark with an enhanced GlobalLocal metric. The landscape features a global minimum at the origin and several axis-aligned local wells. The GlobalLocal score is robustly quantified using a trimmed-mean normalization of the local/minima levels, so the contrast between the deepest local minimum and the average landscape level is measured relative to a robust estimate of the landscape, improving peak recognizability benchmarking across dimensions.", "code": "import numpy as np\n\nclass landscape_enhanced:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Number of wells: ensure enough wells to create multiple local minima\n        self.K = max(6, min(20, self.dim + 2))\n\n        # Centers of Gaussian wells: first at origin, others along axes\n        self.centers = np.zeros((self.K, self.dim), dtype=float)\n        # Depths (amplitudes). Global well deeper than local wells\n        self.A = np.zeros(self.K, dtype=float)\n        self.sigma = np.ones(self.K, dtype=float)\n\n        # Global well at origin\n        self.A[0] = -1.0\n\n        # Local wells: depths gradually increasing in magnitude away from the origin\n        if self.K > 1:\n            for k in range(1, self.K):\n                # Linearly interpolate depths from -0.40 to -0.60 across local wells\n                self.A[k] = -0.4 - 0.2 * ((k - 1) / (self.K - 2))\n\n        # Distance to place local wells (kept within [-5,5] bounds)\n        L = 4.5\n\n        for k in range(1, self.K):\n            axis = (k - 1) % self.dim\n            sign = 1 if ((k - 1) // self.dim) % 2 == 0 else -1\n            self.centers[k, axis] = sign * L\n        # centers[0] remains at the origin\n\n        # Precompute an improved GlobalLocal contrast metric for diagnostics\n        self._compute_contrast()\n\n    def _compute_contrast(self):\n        # Global minimum approximation at origin by evaluating at centers\n        f_at_centers = [self.f(self.centers[i]) for i in range(self.K)]\n        self.global_min = f_at_centers[0]\n\n        # Local minima values (excluding the origin)\n        local_vals = f_at_centers[1:]  # may be empty if K==1\n        self.local_mins = np.array(local_vals) if len(local_vals) > 0 else np.array([])\n\n        if self.local_mins.size > 0:\n            deepest_local = float(np.min(self.local_mins))\n        else:\n            deepest_local = float('inf')\n\n        # Collect minima values for robust averaging (include global and locals)\n        minima_vals = np.array([self.global_min] + list(self.local_mins), dtype=float)\n\n        # Robust mean: trimmed mean (20% trimming)\n        sorted_vals = np.sort(minima_vals)\n        n = len(sorted_vals)\n        trim = max(0, int(n * 0.2))\n        if trim > 0:\n            trimmed_vals = sorted_vals[trim: n - trim]\n        else:\n            trimmed_vals = sorted_vals\n        mean_minima = float(np.mean(trimmed_vals)) if trimmed_vals.size > 0 else float(0.0)\n\n        # GlobalLocal contrast: normalized by robust average\n        denom = abs(mean_minima) + 1e-12\n        if self.local_mins.size > 0:\n            self.global_local_contrast = abs(deepest_local - self.global_min) / denom\n        else:\n            self.global_local_contrast = 0.0\n\n        self.average_minima = mean_minima\n        self.all_minima = minima_vals\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input x must be a 1-D array of length dim.\")\n        total = 0.0\n        # Sum of Gaussian wells. Each well adds a negative contribution (minima)\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            total += self.A[i] * np.exp(-dist2 / (2.0 * (self.sigma[i] ** 2)))\n        return total", "configspace": "", "generation": 2, "feedback": "The optimization landscape landscape_enhanced scored on:GlobalLocal 0.925,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["39bb9959-60ba-42e9-ac65-043d13e367f6"], "operator": null, "metadata": {"ela_features_2D": [0.012441950801630264, 0.8586535379085355, 0.02914329094296836, 0.08598509215767317, 4.089156568429022, 0.012011799779859954, 0.19503199602051563, 2.3246045178037504, 0.26616719849876896, -1.7464170558965535, 2.809842794713163, 1.8, 0.3261181281542142, 0.6640919752543267, 0.308698478895191, 0.3438410925883505, -0.25439059803691755, 0.4643411425187874, 0.4865339642391979, 0.6658716498525834, 0.8189757100687155, 0.5452554630021981, 0.48607865657402644, 0.7491540732068952, 0.8554436610928123, -0.28021867524949196, -0.26860771446160897, -0.17479000038529713, -0.09469664194855555, -0.2331491127594437, -0.2634974874658101, -0.12859275231677395, -0.07410768911760461, 1.0, 1.0, 1.0, 1.0, 0.5135031462377998, 0.5134841970995401, 0.4070999140362477, 0.375093633729714, 0.5789184346345302, 0.7497497497497496, 0.42995312700517874, -0.21921921921921914, 0.3630522088353414], "score_GlobalLocal_2D": 0.43385547399520874, "ela_features": [-0.0010352037129591097, 0.9976191481397481, 0.0011217294790616633, 0.007626842731365, 22.234442320794738, -0.008385062989026925, 0.07348889516598862, 2.723211270882013, 0.12972813244729306, -12.338524673870875, 215.18516024479527, 6.6, 0.8255718743874336, 0.8613589779895688, 0.5885876138234847, 0.19216304259620928, -0.3241000924921418, 0.5892804720814637, 0.6057574842039064, 0.653178614158182, 0.7449191913663535, 0.5954201199831746, 0.6042127799698299, 0.6512043839035402, 0.744621259961787, -0.36129217224634075, -0.34679442607335376, -0.3050789373486529, -0.2243805645052288, -0.357824713752494, -0.35004174718545106, -0.308477250998778, -0.22585901352655088, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21719203581235788, 0.21718045057925672, 0.2155828376174854, 0.18295114237070373, 0.5546197519538165, 0.07307307307307302, 1.157187843940354e-05, -3.666666666666667, 0.5080128205128205], "score_GlobalLocal_5D": 0.22546160221099854, "ela_features_10D": [-0.0028112281370632707, 1.0006717746266065, 3.773870367525993e-05, 0.001832322417782667, 172.92027742143688, -0.020491082414916484, 0.0038004947506682153, 2.4755414561210634, -0.025597600715362257, -40.06064667397222, 1737.0733153023036, 2.4, 0.9899010822109027, 0.9313574362256709, 0.6844237226549637, 0.1106077914970129, -0.20227290793098818, 0.6345454420892206, 0.6927265012192567, 0.7374655499652936, 0.8115840874831564, 0.6368168932949542, 0.6948844046095173, 0.7406419590968568, 0.8157382386043711, -0.46342520611851173, -0.3896467874563817, -0.3329144730910981, -0.23892580417832301, -0.4616711672874233, -0.3878557394411072, -0.32969079357556946, -0.2342283502792617, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10995312923054668, 0.10994927894309825, 0.10987536708816574, 0.10004360555793249, 0.5492901985331244, -1.880880880880881, 0.0, -Infinity, 0.5586869495596478], "score_GlobalLocal_10D": 0.9253153204917908}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[16, [0.00044444444444512003, -0.00044444444444512003], -1.0001000139715583], [19, [0.00044444444444512003, -4.499777777777588], -0.5500400398884105], [21, [4.500000000000055, -0.00044444444444512003], -1.000039968133561], [23, [-4.499777777777588, -0.00044444444444512003], -0.5000400452565456], [21, [0.00044444444444512003, 4.500000000000055], -0.4500400232584455]], "nr_of_basins": 5, "f_opt_dim_2": -1.0001001674739045, "x_opt_dim_2": [9.025044157788995e-05, -1.8046860423502032e-05], "f_opt_dim_5": -1.000120212930488, "x_opt_dim_5": [-3.6081528080742636e-05, 7.934733715611144e-05, 8.655999735088932e-05, 9.377983522424843e-05, 0.00010099656732194759]}
{"id": "2664c32d-2d9f-43e8-a28c-b64fc0d2dc8e", "fitness": 0.5058547258377075, "name": "landscape_enhanced_improved", "description": "A multi-modal Gaussian-well landscape with a global minimum at the origin and several axis-aligned local minima. It uses an improved, robust GlobalLocal metric based on trimmed statistics (mean, median, and trimmed mean) of local minima and all wells to quantify peak recognizability across dimensions. This yields a more stable and dimension-robust measure of how well local minima stand out against the global minimum.", "code": "import numpy as np\n\nclass landscape_enhanced_improved:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Number of wells (centers). Ensure enough wells to create multiple local minima\n        self.K = max(6, min(25, self.dim + 2))\n\n        # Centers of Gaussian wells: first at origin, others along axes\n        self.centers = np.zeros((self.K, self.dim), dtype=float)\n\n        # Depths (amplitudes). Global well deeper than local wells\n        self.A = np.zeros(self.K, dtype=float)\n        self.sigma = np.ones(self.K, dtype=float)\n\n        # Global well at origin with deepest depth\n        self.A[0] = -5.0\n        self.sigma[:] = 1.0\n\n        # Distance to place local wells (kept within [-5,5] bounds)\n        L = 4.5\n\n        for k in range(1, self.K):\n            axis = (k - 1) % self.dim\n            sign = 1 if ((k - 1) // self.dim) % 2 == 0 else -1\n            self.centers[k, axis] = sign * L\n        # centers[0] remains at the origin\n\n        # Depths for local wells: shallower than the global well, with slight variation\n        for i in range(1, self.K):\n            self.A[i] = -1.0 - 0.05 * ((i - 1) % 8)\n\n        # Precompute a robust GlobalLocal contrast metric\n        self._compute_contrast()\n\n    def _trimmed_mean(self, arr, trim_fraction):\n        arr = np.asarray(arr, dtype=float)\n        if arr.size == 0:\n            return 0.0\n        if trim_fraction <= 0.0:\n            return float(np.mean(arr))\n        if trim_fraction >= 0.5:\n            # Fallback to median if trimming beyond half the data\n            return float(np.median(arr))\n        n = arr.size\n        k = int(np.floor(trim_fraction * n))\n        s = np.sort(arr)\n        trimmed = s[k:-k] if k > 0 else s\n        return float(np.mean(trimmed))\n\n    def _compute_contrast(self):\n        # Global minimum at the origin\n        self.global_min = self.f(self.centers[0])\n\n        # Local minima at other centers\n        local_vals = [self.f(self.centers[k]) for k in range(1, self.K)]\n        self.local_mins = np.array(local_vals)\n\n        # Robust GlobalLocal contrast:\n        # Use trimmed mean and median of local minima, and a trimmed mean of all wells\n        if self.local_mins.size > 0:\n            trim = 0.15\n            self.mean_min = float(self._trimmed_mean(self.local_mins, trim))\n            self.median_min = float(np.median(self.local_mins))\n        else:\n            self.mean_min = float(self.global_min)\n            self.median_min = float(self.global_min)\n\n        # Robust mean of all wells (global + locals)\n        all_vals = np.concatenate(([self.global_min], self.local_mins))\n        self.trim_all = 0.15\n        self.trimmed_mean_all = float(self._trimmed_mean(all_vals, self.trim_all))\n\n        # Denominator for normalization (robust to scale)\n        denom = max(abs(self.trimmed_mean_all - self.global_min), 1e-12)\n\n        gld_mean = (self.mean_min - self.global_min) / denom\n        gld_median = (self.median_min - self.global_min) / denom\n        gld_all = (self.trimmed_mean_all - self.global_min) / denom\n\n        # Final robust GlobalLocal score is the maximum of the three robust contrasts\n        self.global_local_contrast = float(max(gld_mean, gld_median, gld_all))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input x must be a 1-D array of length dim.\")\n        total = 0.0\n        # Sum of Gaussian wells. Each well adds a negative contribution (minima)\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            total += self.A[i] * np.exp(-dist2 / (2.0 * (self.sigma[i] ** 2)))\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_enhanced_improved scored on:GlobalLocal 0.440,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b99f6d1e-216c-4e6d-a9b3-fb29906fe9d7"], "operator": null, "metadata": {"ela_features_2D": [-0.0011914371394465384, 0.8991579727173032, 0.004603121527494319, 0.029600198996330724, 25.999102578383184, -0.0023086899737736477, 0.2711321531684484, 1.286775028472407, 0.27419362331252917, -2.7790030999685955, 8.6512561897602, 2.6, 0.39254934336408565, 0.67127972285518, 0.3346171220970977, 0.3501172256820254, -0.20347674324152515, 0.13369986709540865, 0.22571357775365047, 0.42615447566384945, 0.7419928184553605, 0.13682982722466855, 0.21179955880790313, 0.34729227090290304, 0.7473346394027613, -0.4531300230592459, -0.404993777520695, -0.30014886257645684, -0.13495195701493462, -0.44303902025949393, -0.40455830141128757, -0.3350011313114229, -0.12966748948854934, 1.0, 1.0, 1.0, 1.0, 0.5176750764710762, 0.5176607257723892, 0.43805297522968056, 0.35565976266910426, 0.5737301900713334, 0.7337337337337335, 0.20853906117058213, -0.45145145145145127, 0.36064257028112445], "score_GlobalLocal_2D": 0.8922187089920044, "ela_features": [-0.0027559509294473815, 0.9982052902693639, 0.0008585047812716462, 0.004074431527594273, 6.629054702853892, -0.010583506779408225, 0.061177385853967835, 1.3828816881275958, 0.11625263195371047, -13.755825436674462, 242.25019324981275, 6.4, 0.8447691938302343, 0.8654616494304828, 0.6154700667171367, 0.18686990204348422, -0.27914585318689744, 0.5500730874035339, 0.5944087708507976, 0.649517700567683, 0.7422205537424205, 0.5477280133844118, 0.5938520706391452, 0.6471933007164242, 0.7423479899616185, -0.3957868644951291, -0.35678664593613557, -0.308310441566258, -0.22676225098517322, -0.4000069448536294, -0.3592117432576799, -0.31203929253991686, -0.22787987464835285, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21734540324650112, 0.21734669506348614, 0.2161075275908324, 0.18190321452979985, 0.5566322585470379, -0.031031031031031036, 1.1443186251684459e-05, -3.906906906906907, 0.5080128205128205], "score_GlobalLocal_5D": 0.18578417599201202, "ela_features_10D": [-0.002873158368171502, 0.9992739348548548, 5.4459720977165544e-05, 0.002083953125002664, 76.7336475833852, -0.0204807834850941, 0.003529610897026636, 10.574595132320422, -0.023209685923797775, -39.06260444916514, 1658.52452884242, 3.0, 0.9886667864597518, 0.9328033951977137, 0.6837887544858017, 0.10955489066767825, -0.17312769973793646, 0.6429831566982923, 0.6961703069388673, 0.7426586636891782, 0.8145785144583317, 0.6457544434707192, 0.6994744915987453, 0.745590554452545, 0.8186970017543637, -0.45279774258927086, -0.385341807854841, -0.32638149863780164, -0.2351668338418164, -0.45049126124835837, -0.38217590014222447, -0.32353023396778163, -0.23056112671299395, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10970003871464584, 0.10969344443235471, 0.10962772418848947, 0.0999526537252072, 0.5516868826262077, -2.0210210210210215, 0.0, -Infinity, 0.566212970376301], "score_GlobalLocal_10D": 0.43956124782562256}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[17, [0.00044444444444512003, -0.00044444444444512003], -5.000219468035387], [20, [0.00044444444444512003, -4.498888888888822], -1.1502005123543624], [20, [4.500000000000055, -0.00044444444444512003], -2.200200112715069], [20, [0.00044444444444512003, 4.498888888888822], -1.0502005839592752], [23, [-4.498888888888822, -0.00044444444444512003], -1.1002005463789883]], "nr_of_basins": 5, "f_opt_dim_2": -5.000220363103323, "x_opt_dim_2": [3.969063397159416e-05, -3.597412408125339e-06], "f_opt_dim_5": -5.000270457459492, "x_opt_dim_5": [-9.016526428853412e-06, 3.786886836408012e-05, 3.9663487567262087e-05, 4.147810313568439e-05, 4.327888373776698e-05]}
{"id": "6f14ab38-75bb-4655-a86c-8f0c79cf395f", "fitness": 0.6149536967277527, "name": "landscape_enhanced_v2", "description": "Novel multi-modal Gaussian-well benchmark with an enhanced, robust GlobalLocal metric. It retains a global minimum at the origin and several axis-aligned local wells, but computes a more robust GlobalLocal score using trimmed-mean and MAD-based statistics, combined into a max-operator to reflect peak recognizability across scales for benchmarking black-box optimizers.", "code": "import numpy as np\n\nclass landscape_enhanced_v2:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Number of wells: ensure enough wells to create multiple local minima\n        self.K = max(6, min(24, self.dim + 3))\n\n        # Centers of Gaussian wells: first at origin, others along axes\n        self.centers = np.zeros((self.K, self.dim), dtype=float)\n\n        # Depths (amplitudes). Global well deeper than local wells\n        self.A = np.zeros(self.K, dtype=float)\n        self.sigma = np.ones(self.K, dtype=float)\n\n        # Global well at origin with deepest depth\n        self.A[0] = -5.0\n        self.sigma[:] = 1.0\n\n        # Distance to place local wells along axes\n        L = 4.5\n\n        # Place axis-aligned wells\n        m = min(self.K - 1, self.dim * 2)\n        for k in range(1, m + 1):\n            axis = (k - 1) % self.dim\n            sign = 1 if ((k - 1) // self.dim) % 2 == 0 else -1\n            self.centers[k, axis] = sign * L\n\n        # Depths for local wells: shallower than the global well, with slight variation\n        for i in range(1, self.K):\n            self.A[i] = -1.0 - 0.05 * ((i - 1) % 8)\n\n        # Precompute a robust GlobalLocal contrast metric\n        self._compute_contrast()\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input x must be a 1-D array of length dim.\")\n        total = 0.0\n        # Sum of Gaussian wells. Each well adds a negative contribution (minima)\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            total += self.A[i] * np.exp(-dist2 / (2.0 * (self.sigma[i] ** 2)))\n        return total\n\n    def _compute_contrast(self):\n        # Global minimum at the origin\n        g = self.f(self.centers[0])\n\n        # Local minima at other centers\n        local_vals = np.array([self.f(self.centers[k]) for k in range(1, self.K)])\n        if local_vals.size > 0:\n            mean_min = float(np.mean(local_vals))\n            median_min = float(np.median(local_vals))\n        else:\n            mean_min = float(g)\n            median_min = float(g)\n\n        # Robust local minima statistic: trimmed mean\n        trim_frac = 0.2\n        L = local_vals\n        if L.size > 0:\n            sorted_L = np.sort(L)\n            n = sorted_L.size\n            t = int(np.floor(n * trim_frac))\n            low = t\n            high = n - t\n            if high > low:\n                trimmed_min = float(np.mean(sorted_L[low:high]))\n            else:\n                trimmed_min = mean_min\n        else:\n            trimmed_min = mean_min\n\n        # Average fitness across all wells (robust to scale)\n        all_vals = np.concatenate(([g], local_vals)) if local_vals.size > 0 else np.array([g])\n        average_fitness = float(np.mean(all_vals))\n        denom = max(abs(average_fitness), 1e-12)\n\n        # MAD-based scale component\n        if local_vals.size > 0:\n            med = float(np.median(local_vals))\n            mad = float(np.median(np.abs(local_vals - med)))\n        else:\n            mad = 0.0\n\n        # Normalize several robust estimates\n        gld_mean  = (mean_min   - g) / denom\n        gld_med   = (median_min - g) / denom\n        gld_trim  = (trimmed_min - g) / denom\n        # A scale-adjusted MAD variant (avoid division by zero)\n        gld_mad   = (median_min - g) / (denom * (1.0 + (mad if mad > 0 else 0.0)))\n\n        # Final robust GlobalLocal score: take the maximum across robust estimates\n        glc = max(gld_mean, gld_med, gld_trim, gld_mad)\n        if glc < 0:\n            glc = 0.0\n\n        # Store diagnostics (optional, useful for benchmarking)\n        self.global_min = float(g)\n        self.local_mins = local_vals\n        self.mean_min = mean_min\n        self.median_min = median_min\n        self.trimmed_min = trimmed_min\n        self.average_fitness = average_fitness\n        self.global_local_contrast = float(glc)", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_enhanced_v2 scored on:GlobalLocal 0.730,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b99f6d1e-216c-4e6d-a9b3-fb29906fe9d7"], "operator": null, "metadata": {"ela_features_2D": [-0.003333303489241768, 0.9067914762648931, 0.006105065943216909, 0.009965702333390749, 2.12776678300424, -0.004287238598959187, 0.2694261806894763, 1.0595475428836956, 0.28670580828167197, -3.2205231611911396, 11.67373953652456, 3.8, 0.43353632195625985, 0.675077502118936, 0.40574082826120234, 0.35379710371260326, -0.19229850411704527, 0.15682509520236623, 0.23582803544676487, 0.32402425871560453, 0.7430748904739797, 0.16146918440588526, 0.23360218505506083, 0.32689637209291694, 0.7358856312891475, -0.44133863947331164, -0.39998609862038137, -0.35382181422321135, -0.1344793256734956, -0.43156600722349836, -0.39444564543673855, -0.34642387257328533, -0.13590078917069773, 1.0, 1.0, 1.0, 1.0, 0.5205872440003192, 0.5204208678780161, 0.45343983446005687, 0.3507295877338746, 0.5844138815717187, 0.7417417417417416, 0.12784474809140475, -0.5915915915915914, 0.37228915662650597], "score_GlobalLocal_2D": 0.8628554344177246, "ela_features": [-0.002777558697874394, 0.996647011411169, 0.0005464639920637266, 0.003645353445914415, 93.13996166195598, -0.010596178410636582, 0.0631974682399001, 1.3556185920622703, 0.11994285153991269, -14.672146188586316, 289.35741775016487, 6.0, 0.8447143814150389, 0.8633461978555363, 0.6095286029762398, 0.18879874895813412, -0.306228827224183, 0.5431895691025559, 0.6023717472769825, 0.6529968392987248, 0.7434795475200084, 0.5387541646732932, 0.6031372008143107, 0.6521809329385174, 0.7429695834503571, -0.40186528418809253, -0.34980290909042194, -0.3052712454034503, -0.22567010269747798, -0.407972034904324, -0.35102098010161364, -0.30765614210020786, -0.22734858084615955, 1.0, 1.0, 0.8333333333333334, 1.0, 0.2184143311745368, 0.21842448947312415, 0.217232321436786, 0.18283264700849355, 0.5607510385032608, 0.017017017017016994, 1.26336120970612e-05, -3.758758758758759, 0.5094551282051282], "score_GlobalLocal_5D": 0.2521306276321411, "ela_features_10D": [-0.002963872572284165, 1.0003916769079377, 8.466902612810172e-05, 0.002092995910029479, 33.57760438126812, -0.020261290693115486, 0.006194527905628777, 2.970838448183256, -0.01870019801792877, -37.20248480971425, 1582.842312856431, 3.0, 0.9888484079040781, 0.9318287716575819, 0.6822965163003787, 0.10972172740452076, -0.20936540506746523, 0.6343174283149703, 0.6915725660866583, 0.737128059673761, 0.8131668456892086, 0.6376769574712957, 0.6940435045541098, 0.7403118509724687, 0.8172334163069594, -0.46381437959750704, -0.3911948486285774, -0.33341436209566855, -0.23697020108517325, -0.46080752364971794, -0.3891202274976543, -0.330275042953453, -0.23244403096183563, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.1092119232326759, 0.10921928156394192, 0.10912640545150576, 0.09948601413512981, 0.5445289339027622, -1.7767767767767768, 0.0, -Infinity, 0.5688550840672539], "score_GlobalLocal_10D": 0.7298750281333923}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[17, [-0.00044444444444512003, -0.00044444444444512003], -6.20017107242421], [19, [-4.498888888888822, -0.00044444444444512003], -1.1002488656950276], [20, [-0.00044444444444512003, 4.498888888888822], -1.0502489013361562], [20, [4.498888888888822, -0.00044444444444512003], -1.0002489372999401], [24, [-0.00044444444444512003, -4.498888888888822], -1.1502488297312434]], "nr_of_basins": 5, "f_opt_dim_2": -6.200172280831233, "x_opt_dim_2": [-2.9060103078119188e-06, -2.906828581320917e-06], "f_opt_dim_5": -5.000322538965004, "x_opt_dim_5": [-9.018681194003078e-06, -9.019218697018284e-06, 3.9665804478237926e-05, 4.147040200384291e-05, 4.327075832975985e-05]}
{"id": "4591cc5b-f520-468d-83de-0342db34253b", "fitness": 0.515434741973877, "name": "landscape_enhanced_robust", "description": "A multi-modal Gaussian-well landscape with a deep global minimum at the origin and several shallower local minima along axes, enhanced by a robust GlobalLocal metric that uses a MAD-based scale around the median across all wells to quantify peak recognizability in a dimension-agnostic way.", "code": "import numpy as np\n\nclass landscape_enhanced_robust:\n    def __init__(self, dim=5):\n        self.dim = int(dim)\n        # Number of wells (centers). Ensure enough wells to create multiple local minima\n        self.K = max(6, min(20, self.dim + 2))\n\n        # Centers of Gaussian wells: first at origin, others along axes\n        self.centers = np.zeros((self.K, self.dim), dtype=float)\n\n        # Depths (amplitudes). Global well deeper than local wells\n        self.A = np.zeros(self.K, dtype=float)\n        self.sigma = np.ones(self.K, dtype=float)\n\n        # Global well at origin with deepest depth\n        self.A[0] = -5.0\n        self.sigma[:] = 1.0\n\n        # Place local wells along axis directions within bounds\n        L = 4.5  # distance from origin for local wells\n        for k in range(1, self.K):\n            axis = (k - 1) % self.dim\n            sign = 1 if ((k - 1) // self.dim) % 2 == 0 else -1\n            self.centers[k, axis] = sign * L\n        # centers[0] remains at the origin\n\n        # Depths for local wells: shallower than the global well, with slight variation\n        for i in range(1, self.K):\n            self.A[i] = -1.0 - 0.05 * ((i - 1) % 8)\n\n        # Precompute a robust GlobalLocal contrast metric\n        self._compute_contrast()\n\n    def _compute_contrast(self):\n        # Global minimum at the origin\n        self.global_min = float(self.f(self.centers[0]))\n\n        # Local minima at other centers\n        local_vals = [self.f(self.centers[k]) for k in range(1, self.K)]\n        self.local_mins = np.array(local_vals)\n\n        # Robust GlobalLocal contrast:\n        # Use a robust center (median) over all wells and a robust dispersion (MAD)\n        all_vals = np.concatenate(([self.global_min], self.local_mins))\n        center = float(np.median(all_vals))\n        deviations = np.abs(all_vals - center)\n        scale = float(np.median(deviations)) + 1e-12  # MAD-based scale, small epsilon\n\n        # Compute statistics of local minima relative to the global minimum\n        if self.local_mins.size > 0:\n            mean_local = float(np.mean(self.local_mins))\n            med_local = float(np.median(self.local_mins))\n        else:\n            mean_local = self.global_min\n            med_local = self.global_min\n\n        # Normalize by robust dispersion to be scale-invariant\n        gld_mean = (mean_local - self.global_min) / scale\n        gld_median = (med_local - self.global_min) / scale\n\n        # Final robust GlobalLocal score is the maximum of the two normalized contrasts\n        self.global_local_contrast = float(max(gld_mean, gld_median))\n\n    def f(self, x):\n        x = np.asarray(x, dtype=float)\n        if x.shape != (self.dim,):\n            raise ValueError(\"Input x must be a 1-D array of length dim.\")\n        total = 0.0\n        # Sum of Gaussian wells. Each well adds a negative contribution (minima)\n        for i in range(self.K):\n            diff = x - self.centers[i]\n            dist2 = float(np.dot(diff, diff))\n            total += self.A[i] * np.exp(-dist2 / (2.0 * (self.sigma[i] ** 2)))\n        return total", "configspace": "", "generation": 3, "feedback": "The optimization landscape landscape_enhanced_robust scored on:GlobalLocal 0.525,  (higher is better, 1.0 is the best).", "error": "", "parent_ids": ["b99f6d1e-216c-4e6d-a9b3-fb29906fe9d7"], "operator": null, "metadata": {"ela_features_2D": [0.0027781114366215443, 0.9100709877489246, 0.0047496910474680385, 0.04805110656390089, 11.676758715037737, 0.0009855355531436683, 0.27408561502018475, 1.3727553651138398, 0.28612826533296803, -2.653655669331246, 7.773594263824485, 2.8, 0.3988807125000401, 0.6772001710851102, 0.35739439022769554, 0.34674950962577195, -0.20855303177694356, 0.13836308044858622, 0.2262777814053786, 0.4522548507422077, 0.7288640771620756, 0.13816738615415278, 0.2226909201453653, 0.3662123504228618, 0.7316352578224267, -0.4506850106179531, -0.4046883131608043, -0.2864946717688225, -0.14181395514713221, -0.4417389713747619, -0.3984086494562288, -0.32484054077331176, -0.13752926230116252, 1.0, 1.0, 1.0, 1.0, 0.5086013609725496, 0.508586165112519, 0.43390930743397427, 0.36111345825655355, 0.5725297014295113, 0.7417417417417415, 0.19741699236588833, -0.4274274274274273, 0.3618473895582329], "score_GlobalLocal_2D": 0.8913758397102356, "ela_features": [-0.002374426870590263, 0.9980861079512822, 0.0009455705961396064, 0.0037781916323525676, 6.558778158000232, -0.01024038196862671, 0.05253509682817838, 1.5091522702409015, 0.0972781445267316, -16.114493982453517, 329.08636073118123, 6.0, 0.8483714396743606, 0.8627147099125967, 0.6072310617264145, 0.19106452045658798, -0.2775777270283962, 0.5228343022021634, 0.5894585251046942, 0.6391621149661944, 0.737403560881672, 0.5186182030255794, 0.5878631075468211, 0.636814752225194, 0.7371223730265914, -0.4197308839815711, -0.3611268173710399, -0.3174068593666302, -0.23099100518074875, -0.42551747129937373, -0.36431151436367903, -0.3210438003173864, -0.23237751095934428, 1.0, 1.0, 0.8333333333333334, 1.0, 0.21533930325401346, 0.21532440139474546, 0.2144138291819863, 0.18045927078086058, 0.5580420181872731, -0.09909909909909909, 1.0950366808378266e-05, -3.9349349349349354, 0.5067307692307692], "score_GlobalLocal_5D": 0.12959176301956177, "ela_features_10D": [-0.002971258247644615, 0.999250988875995, 9.115263386732465e-05, 0.0016541426132765408, 19.19327494492385, -0.02056972706801603, 0.004859121188924109, 6.063881510321008, -0.023768608199760788, -37.38253954983456, 1557.154464441768, 2.8, 0.9770219506851252, 0.9323653525748078, 0.6791066791936247, 0.10909740741884293, -0.21198702353296497, 0.6434204013891728, 0.6945401434536949, 0.7400255816825139, 0.8118127171097178, 0.6463818555968075, 0.6973002360287872, 0.7434627192562953, 0.8161929029872352, -0.452210390061044, -0.3873803661844367, -0.32969634496237443, -0.23865677311665467, -0.4495592614442419, -0.38482394151646265, -0.3261364775171214, -0.23367370055156314, 0.9, 0.9, 0.8181818181818181, 0.909090909090909, 0.10988153736269198, 0.10988026488006626, 0.10979817236466197, 0.10006562297489092, 0.5422031826374396, -1.7087087087087092, 0.0, -Infinity, 0.5688550840672537], "score_GlobalLocal_10D": 0.5253366827964783}, "task_prompt": "\nYou are a highly skilled computer scientist in the field optimization and benchmarking. Your task is to design novel mathematical functions to be used as black-box optimization benchmark landscapes.\nThe code you need to write is a class with a function `f` with one parameter `x` which is a realvalued sample (numpy array). \nThe optimization function should have the following properties: \n- it will be used as minimization problem (so the global optimum should be the minimum value of the function).\n- It should have a global local minima contrast, GlobalLocal refers to the difference between global and local peaks in comparison to the average fitness level of a problem. It thus determines if very good peaks are easily recognized as such. (GlobalLocal)\nThe class should also have a __init__(dim) function, that received the number of dimensions for the function.\nThe function will be evaluated between per dimension lower bound of -5.0 and upper bound of 5.0.\n", "basin_info": [[17, [0.00044444444444512003, -0.00044444444444512003], -5.000219468035387], [20, [0.00044444444444512003, -4.498888888888822], -1.1502005123543624], [20, [4.500000000000055, -0.00044444444444512003], -2.200200112715069], [20, [0.00044444444444512003, 4.498888888888822], -1.0502005839592752], [23, [-4.498888888888822, -0.00044444444444512003], -1.1002005463789883]], "nr_of_basins": 5, "f_opt_dim_2": -5.000220363103323, "x_opt_dim_2": [3.9682675179593235e-05, -3.6129325186311215e-06], "f_opt_dim_5": -5.000270457459492, "x_opt_dim_5": [-9.01605430079177e-06, 3.786895282929844e-05, 3.9669694167908284e-05, 4.147302886725861e-05, 4.3271241239255554e-05]}
