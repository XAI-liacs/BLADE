from __future__ import annotations
from typing import Optional
from iohblade.solution import Solution


class MCTS_Node(Solution):
    def __init__(
        self,
        solution: Solution,
        approach: str,
        depth: int = 0,
        parent: Optional[MCTS_Node] = None,
        visit: int = 1,
        Q: float | None = None,
    ):
        """
            MCTS Node is a derivative of `iohblade.Solution`, with extra paramters in `children`, establishing heirarchy in
            the Tree, `rewards`, `depth` and `Q`, for calculating which subtree to explore.
        
            ## Args:
            `Solution: iohblade.Solution`: An instance of iohblade.Solution, generated by the `LLM.sample_solution`.\\
            `depth: int`: The Depth at which this instance of `MCTS_Node` exist in the Monte Carlo Tree.\\
            `parent:MCTS_Node?` An optional variable that points to the parent of current instance of `MCT_Node`; `None` if current instance is root node.\\
            `visits: int` Tracks the number of times current instance has been explored by MCTS Algorithm.\\
            `Q: int`: MCTS Quality value $Q_c$ evaluation of the node. 
        """
        super().__init__()

        # Copy Solution parameters to self.
        self.__dict__.update(solution.__dict__)
        self.parent_ids = (
            solution.parent_ids[-1] if solution.parent_ids else None
        )  # Only one parent exist here.

        # MCTS Specific Members:
        self.approach = approach
        self.depth = depth
        self.parent = parent
        self.visit = visit
        self.Q = Q
        self.children: list[MCTS_Node] = []

    def copy_attributes(self, other: MCTS_Node):
        """
        Copy attributes from another MCTS_Node instance to the current instance.

        ## Args:
        `other: MCTS_Node`: The MCTS_Node instance from which attributes are to be copied.
        """
        self.approach = other.approach
        self.depth = other.depth
        self.parent = other.parent
        self.visit = other.visit
        self.Q = other.Q
        self.children = other.children.copy()

    def add_child(self, childNode: MCTS_Node):
        """
        Add a child node to the current instance of MCTS_Node.

        ## Args:
        `childNode: MCTS_Node`: MCTS_Node instance to be added as a child.
        """
        childNode.parent = self
        childNode.parent_ids = self.id
        self.children.append(childNode)

    def __repr__(self):
        q_str = f"Q = {self.Q:.2f}," if self.Q is not None else ""
        return f"MCTS_Node(id=...{self.id[-4:]}, children={list(map(lambda x: '...' + x.id[-4:], self.children))}, {q_str} visits={self.visit}, ({self.approach}))"

    @property
    def is_root(self):
        """
        EZ check for is current node a root.
        """
        return self.parent is None

    @property
    def is_leaf(self):
        return len(self.children) == 0

    def is_less_fit_than(self, other: MCTS_Node):
        if self.Q is None or other.Q is None:
            return False
        return self.Q < other.Q

    def is_fully_expanded(self, max_children: int) -> bool:
        """
        Check for completion of progressive Widening (Page 3: https://arxiv.org/pdf/2501.08603).

        ## Args:
        `max_children: int`: User defined upper limit of sub-tree width.

        ## Returns:
        `bool`: Truth value of whether upper limit is reach or not.
        """
        return (
            len(self.children) >= max_children
            or any(self.is_less_fit_than(child) for child in self.children)
            or self.is_root
        )
